begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C compiler.    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It contains routines to build C expressions given their operands,    including computing the types of the result, C-specific error checks,    and some optimization.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_comment
comment|/* Possible cases of implicit bad conversions.  Used to select    diagnostic messages in convert_for_assignment.  */
end_comment

begin_enum
enum|enum
name|impl_conv
block|{
name|ic_argpass
block|,
name|ic_argpass_nonproto
block|,
name|ic_assign
block|,
name|ic_init
block|,
name|ic_return
block|}
enum|;
end_enum

begin_comment
comment|/* The level of nesting inside "__alignof__".  */
end_comment

begin_decl_stmt
name|int
name|in_alignof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The level of nesting inside "sizeof".  */
end_comment

begin_decl_stmt
name|int
name|in_sizeof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The level of nesting inside "typeof".  */
end_comment

begin_decl_stmt
name|int
name|in_typeof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|c_label_context_se
modifier|*
name|label_context_stack_se
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|c_label_context_vm
modifier|*
name|label_context_stack_vm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've already printed a "missing braces around initializer"    message within this initializer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|missing_braces_mentioned
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|require_constant_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|require_constant_elements
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|null_pointer_constant_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tagged_types_tu_compatible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_target_types
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|function_types_compatible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_lists_compatible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|decl_constant_value_for_broken_optimization
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_field
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_arguments
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|impl_conv
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|valid_compound_expr_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_member_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spelling_length
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|print_spelling
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warning_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|digest_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_init_element
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_pending_init_elements
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_designator
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_range_stack
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pending_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_nonincremental_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_nonincremental_init_from_string
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_init_member
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readonly_error
parameter_list|(
name|tree
parameter_list|,
name|enum
name|lvalue_use
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvalue_or_else
parameter_list|(
name|tree
parameter_list|,
name|enum
name|lvalue_use
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvalue_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_maybe_used_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comptypes_internal
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return true if EXP is a null pointer constant, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|null_pointer_constant_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
comment|/* This should really operate on c_expr structures, but they aren't      yet available everywhere required.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|expr
argument_list|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is a cache to hold if two types are compatible or not.  */
end_comment

begin_struct
struct|struct
name|tagged_tu_seen_cache
block|{
specifier|const
name|struct
name|tagged_tu_seen_cache
modifier|*
name|next
decl_stmt|;
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
comment|/* The return value of tagged_types_tu_compatible_p if we had seen      these two types already.  */
name|int
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tagged_tu_seen_base
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|free_all_tagged_tu_seen_up_to
parameter_list|(
specifier|const
name|struct
name|tagged_tu_seen_cache
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|tree
name|value
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|value
return|;
name|c_incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|c_incomplete_type_error
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|type_code_string
decl_stmt|;
comment|/* Avoid duplicate error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
name|error
argument_list|(
literal|"%qD has an incomplete type"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|retry
label|:
comment|/* We must print an error message.  Be clever about what it says.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|type_code_string
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|type_code_string
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|type_code_string
operator|=
literal|"enum"
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of flexible array member"
argument_list|)
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"invalid use of undefined type %<%s %E%>"
argument_list|,
name|type_code_string
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
name|error
argument_list|(
literal|"invalid use of incomplete typedef %qD"
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a type, apply default promotions wrt unnamed function    arguments and return the new type.  */
end_comment

begin_function
name|tree
name|c_type_promotes_to
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Preserve unsignedness if not really getting any wider.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
return|return
name|unsigned_type_node
return|;
return|return
name|integer_type_node
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|like
parameter_list|)
block|{
return|return
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|like
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true iff the given tree T is a variable length array.  */
end_comment

begin_function
name|bool
name|c_vla_type_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the composite type of two compatible types.     We assume that comptypes has already been done and returned    nonzero; if that isn't so, this may crash.  In particular, we    assume that qualifiers match.  */
end_comment

begin_function
name|tree
name|composite_type
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
name|targetm
operator|.
name|merge_type_attributes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* If one is an enumerated type and the other is the compatible      integer type, the composite type might be either of the two      (DR#013 question 3).  For consistency, use the enumerated type as      the composite type.  */
if|if
condition|(
name|code1
operator|==
name|ENUMERAL_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|code2
operator|==
name|ENUMERAL_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|t2
return|;
name|gcc_assert
argument_list|(
name|code1
operator|==
name|code2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type.  */
block|{
name|tree
name|pointed_to_1
init|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|pointed_to_2
init|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|target
init|=
name|composite_type
argument_list|(
name|pointed_to_1
argument_list|,
name|pointed_to_2
argument_list|)
decl_stmt|;
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
return|return
name|qualify_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|composite_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|quals
decl_stmt|;
name|tree
name|unqual_elt
decl_stmt|;
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|bool
name|d1_variable
decl_stmt|,
name|d2_variable
decl_stmt|;
name|bool
name|d1_zero
decl_stmt|,
name|d2_zero
decl_stmt|;
comment|/* We should not have any type quals on arrays at all.  */
name|gcc_assert
argument_list|(
operator|!
name|TYPE_QUALS
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_QUALS
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|d1_zero
operator|=
name|d1
operator|==
literal|0
operator|||
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d2_zero
operator|=
name|d2
operator|==
literal|0
operator|||
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|d1_variable
operator|=
operator|(
operator|!
name|d1_zero
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
expr_stmt|;
name|d2_variable
operator|=
operator|(
operator|!
name|d2_zero
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
expr_stmt|;
name|d1_variable
operator|=
name|d1_variable
operator|||
operator|(
name|d1_zero
operator|&&
name|c_vla_type_p
argument_list|(
name|t1
argument_list|)
operator|)
expr_stmt|;
name|d2_variable
operator|=
name|d2_variable
operator|||
operator|(
name|d2_zero
operator|&&
name|c_vla_type_p
argument_list|(
name|t2
argument_list|)
operator|)
expr_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
operator|&&
operator|(
name|d2_variable
operator|||
name|d2_zero
operator|||
operator|!
name|d1_variable
operator|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
operator|&&
operator|(
name|d1_variable
operator|||
name|d1_zero
operator|||
operator|!
name|d2_variable
operator|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Merge the element types, and have a size if either arg has 	   one.  We may have qualifiers on the element types.  To set 	   up TYPE_MAIN_VARIANT correctly, we need to form the 	   composite of the unqualified types and add the qualifiers 	   back at the end.  */
name|quals
operator|=
name|TYPE_QUALS
argument_list|(
name|strip_array_types
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|unqual_elt
operator|=
name|c_build_qualified_type
argument_list|(
name|elt
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_array_type
argument_list|(
name|unqual_elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
operator|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
operator|&&
operator|(
name|d2_variable
operator|||
name|d2_zero
operator|||
operator|!
name|d1_variable
operator|)
operator|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|c_build_qualified_type
argument_list|(
name|t1
argument_list|,
name|quals
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|attributes
operator|!=
name|NULL
condition|)
block|{
comment|/* Try harder not to create a new aggregate type.  */
if|if
condition|(
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|attributes
argument_list|)
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
argument_list|,
name|attributes
argument_list|)
condition|)
return|return
name|t2
return|;
block|}
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|composite_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
return|return
name|qualify_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
return|return
name|qualify_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
comment|/* If both args specify argument types, we must merge the two 	   lists, argument by argument.  */
comment|/* Tell global_bindings_p to return false so that variable_size 	   doesn't die on VLAs in parameter types.  */
name|c_override_global_bindings_to_false
operator|=
name|true
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
control|)
block|{
comment|/* A null type means arg type is not specified. 	       Take whatever the other function type has.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
comment|/* Given  wait (union {union wait *u; int *i} *) 	       and  wait (union wait *), 	       prefer  union wait *  as type of parm.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
name|tree
name|mv2
init|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|mv2
operator|&&
name|mv2
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv2
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv2
argument_list|)
expr_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
block|{
name|tree
name|mv3
init|=
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
decl_stmt|;
if|if
condition|(
name|mv3
operator|&&
name|mv3
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv3
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv3
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv3
argument_list|)
expr_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|mv3
argument_list|,
name|mv2
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|composite_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ISO C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
name|tree
name|mv1
init|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mv1
operator|&&
name|mv1
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv1
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv1
argument_list|)
expr_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
block|{
name|tree
name|mv3
init|=
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
decl_stmt|;
if|if
condition|(
name|mv3
operator|&&
name|mv3
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv3
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv3
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv3
argument_list|)
expr_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|mv3
argument_list|,
name|mv1
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|composite_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ISO C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
block|}
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|composite_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|parm_done
label|:
empty_stmt|;
block|}
name|c_override_global_bindings_to_false
operator|=
name|false
expr_stmt|;
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|t1
operator|=
name|qualify_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* ... falls through ...  */
block|}
default|default:
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the type of a conditional expression between pointers to    possibly differently qualified versions of compatible types.     We assume that comp_target_types has already been done and returned    nonzero; if that isn't so, this may crash.  */
end_comment

begin_function
specifier|static
name|tree
name|common_pointer_type
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|tree
name|attributes
decl_stmt|;
name|tree
name|pointed_to_1
decl_stmt|,
name|mv1
decl_stmt|;
name|tree
name|pointed_to_2
decl_stmt|,
name|mv2
decl_stmt|;
name|tree
name|target
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
name|targetm
operator|.
name|merge_type_attributes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* Find the composite type of the target types, and combine the      qualifiers of the two types' targets.  Do not lose qualifiers on      array element types by taking the TYPE_MAIN_VARIANT.  */
name|mv1
operator|=
name|pointed_to_1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|mv2
operator|=
name|pointed_to_2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mv1
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|pointed_to_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mv2
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|pointed_to_2
argument_list|)
expr_stmt|;
name|target
operator|=
name|composite_type
argument_list|(
name|mv1
argument_list|,
name|mv2
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|target
argument_list|,
name|TYPE_QUALS
argument_list|(
name|pointed_to_1
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|pointed_to_2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the common type for two arithmetic types under the usual    arithmetic conversions.  The default conversions have already been    applied, and enumerated types converted to their compatible integer    types.  The resulting type is unqualified and has no attributes.     This is the type for the result of most arithmetic operations    if the operands have the given two types.  */
end_comment

begin_function
specifier|static
name|tree
name|c_common_type
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|t1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|t2
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|t2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|t2
operator|=
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|code1
operator|==
name|VECTOR_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|INTEGER_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|code2
operator|==
name|VECTOR_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|||
name|code2
operator|==
name|INTEGER_TYPE
argument_list|)
expr_stmt|;
comment|/* When one operand is a decimal float type, the other operand cannot be      a generic float type or a complex type.  We also disallow vector types      here.  */
if|if
condition|(
operator|(
name|DECIMAL_FLOAT_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|||
name|DECIMAL_FLOAT_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|DECIMAL_FLOAT_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|DECIMAL_FLOAT_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|VECTOR_TYPE
operator|||
name|code2
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"can%'t mix operands of decimal float and vector types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"can%'t mix operands of decimal float and complex types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|==
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"can%'t mix operands of decimal float and other float types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* If one type is a vector type, return that type.  (How the usual      arithmetic conversions apply to the vector types extension is not      precisely specified.)  */
if|if
condition|(
name|code1
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|code2
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|t2
return|;
comment|/* If one type is complex, form the common type of the non-complex      components, then make that complex.  Use T1 or T2 if it is the      required type.  */
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|subtype1
init|=
name|code1
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
decl_stmt|;
name|tree
name|subtype2
init|=
name|code2
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
else|:
name|t2
decl_stmt|;
name|tree
name|subtype
init|=
name|c_common_type
argument_list|(
name|subtype1
argument_list|,
name|subtype2
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|t1
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|t2
return|;
else|else
return|return
name|build_complex_type
argument_list|(
name|subtype
argument_list|)
return|;
block|}
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t2
return|;
comment|/* If both are real and either are decimal floating point types, use      the decimal floating point type with the greater precision. */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|dfloat128_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|dfloat128_type_node
condition|)
return|return
name|dfloat128_type_node
return|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|dfloat64_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|dfloat64_type_node
condition|)
return|return
name|dfloat64_type_node
return|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|dfloat32_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|dfloat32_type_node
condition|)
return|return
name|dfloat32_type_node
return|;
block|}
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Same precision.  Prefer long longs to longs to ints when the      same precision, following the C99 rules on integer type rank      (which are equivalent to the C90 rules for C90 types).  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_long_unsigned_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_long_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_long_integer_type_node
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|long_long_unsigned_type_node
return|;
else|else
return|return
name|long_long_integer_type_node
return|;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_unsigned_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	 since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|long_unsigned_type_node
return|;
else|else
return|return
name|long_integer_type_node
return|;
block|}
comment|/* Likewise, prefer long double to double even if same size.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_double_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_double_type_node
condition|)
return|return
name|long_double_type_node
return|;
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
else|else
return|return
name|t2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrapper around c_common_type that is used by c-common.c and other    front end optimizations that remove promotions.  ENUMERAL_TYPEs    are allowed here and are converted to their compatible integer types.    BOOLEAN_TYPEs are allowed here and return either boolean_type_node or    preferably a non-Boolean type as the common type.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If both types are BOOLEAN_TYPE, then return boolean_type_node.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|boolean_type_node
return|;
comment|/* If either type is BOOLEAN_TYPE, then return the other.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|t1
return|;
return|return
name|c_common_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  Return 2 if they are compatible    but a warning may be needed if you use them together.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
specifier|const
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tagged_tu_seen_base1
init|=
name|tagged_tu_seen_base
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|comptypes_internal
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
name|free_all_tagged_tu_seen_up_to
argument_list|(
name|tagged_tu_seen_base1
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  Return 2 if they are compatible    but a warning may be needed if you use them together.  This    differs from comptypes, in that we don't free the seen types.  */
end_comment

begin_function
specifier|static
name|int
name|comptypes_internal
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
name|tree
name|t1
init|=
name|type1
decl_stmt|;
name|tree
name|t2
init|=
name|type2
decl_stmt|;
name|int
name|attrval
decl_stmt|,
name|val
decl_stmt|;
comment|/* Suppress errors caused by previously reported errors.  */
if|if
condition|(
name|t1
operator|==
name|t2
operator|||
operator|!
name|t1
operator|||
operator|!
name|t2
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* If either type is the internal version of sizetype, return the      language version.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Enumerated types are compatible with integer types, but this is      not transitive: two enumerated types in the same translation unit      are compatible with each other only if they are the same type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match. C99 6.7.3p9 */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow for two different type nodes which have essentially the same      definition.  Note that we already checked for equality of the type      qualifiers (just above).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
if|if
condition|(
operator|!
operator|(
name|attrval
operator|=
name|targetm
operator|.
name|comp_type_attributes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
comment|/* Do not remove mode or aliasing information.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|t2
argument_list|)
operator|||
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t2
argument_list|)
condition|)
break|break;
name|val
operator|=
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|?
literal|1
else|:
name|comptypes_internal
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|val
operator|=
name|function_types_compatible_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|bool
name|d1_variable
decl_stmt|,
name|d2_variable
decl_stmt|;
name|bool
name|d1_zero
decl_stmt|,
name|d2_zero
decl_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
comment|/* Target types must match incl. qualifiers.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
literal|0
operator|==
operator|(
name|val
operator|=
name|comptypes_internal
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Sizes must match unless one is missing or variable.  */
if|if
condition|(
name|d1
operator|==
literal|0
operator|||
name|d2
operator|==
literal|0
operator|||
name|d1
operator|==
name|d2
condition|)
break|break;
name|d1_zero
operator|=
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d2_zero
operator|=
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|d1_variable
operator|=
operator|(
operator|!
name|d1_zero
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
expr_stmt|;
name|d2_variable
operator|=
operator|(
operator|!
name|d2_zero
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
expr_stmt|;
name|d1_variable
operator|=
name|d1_variable
operator|||
operator|(
name|d1_zero
operator|&&
name|c_vla_type_p
argument_list|(
name|t1
argument_list|)
operator|)
expr_stmt|;
name|d2_variable
operator|=
name|d2_variable
operator|||
operator|(
name|d2_zero
operator|&&
name|c_vla_type_p
argument_list|(
name|t2
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|d1_variable
operator|||
name|d2_variable
condition|)
break|break;
if|if
condition|(
name|d1_zero
operator|&&
name|d2_zero
condition|)
break|break;
if|if
condition|(
name|d1_zero
operator|||
name|d2_zero
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|val
operator|!=
literal|1
operator|&&
operator|!
name|same_translation_unit_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
name|tree
name|a1
init|=
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|a2
init|=
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|attribute_list_contained
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
operator|&&
operator|!
name|attribute_list_contained
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|attrval
operator|!=
literal|2
condition|)
return|return
name|tagged_types_tu_compatible_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
name|val
operator|=
name|tagged_types_tu_compatible_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VECTOR_TYPE
case|:
name|val
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|t2
argument_list|)
operator|&&
name|comptypes_internal
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|attrval
operator|==
literal|2
operator|&&
name|val
operator|==
literal|1
condition|?
literal|2
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers.  */
end_comment

begin_function
specifier|static
name|int
name|comp_target_types
parameter_list|(
name|tree
name|ttl
parameter_list|,
name|tree
name|ttr
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|tree
name|mvl
decl_stmt|,
name|mvr
decl_stmt|;
comment|/* Do not lose qualifiers on element types of array types that are      pointer targets by taking their TYPE_MAIN_VARIANT.  */
name|mvl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|mvr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mvl
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mvl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mvr
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mvr
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mvr
argument_list|)
expr_stmt|;
name|val
operator|=
name|comptypes
argument_list|(
name|mvl
argument_list|,
name|mvr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"types are not quite compatible"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Determine whether two trees derive from the same translation unit.    If the CONTEXT chain ends in a null, that tree's context is still    being parsed, so if two trees have context chains ending in null,    they're in the same translation unit.  */
end_comment

begin_function
name|int
name|same_translation_unit_p
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
while|while
condition|(
name|t1
operator|&&
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TRANSLATION_UNIT_DECL
condition|)
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_declaration
case|:
name|t1
operator|=
name|DECL_CONTEXT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_type
case|:
name|t1
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_exceptional
case|:
name|t1
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
break|break;
comment|/* assume block */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|t2
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|TRANSLATION_UNIT_DECL
condition|)
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_declaration
case|:
name|t2
operator|=
name|DECL_CONTEXT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_type
case|:
name|t2
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_exceptional
case|:
name|t2
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
break|break;
comment|/* assume block */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|t1
operator|==
name|t2
return|;
block|}
end_function

begin_comment
comment|/* Allocate the seen two types, assuming that they are compatible. */
end_comment

begin_function
specifier|static
name|struct
name|tagged_tu_seen_cache
modifier|*
name|alloc_tagged_tu_seen_cache
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tu
init|=
name|XNEW
argument_list|(
expr|struct
name|tagged_tu_seen_cache
argument_list|)
decl_stmt|;
name|tu
operator|->
name|next
operator|=
name|tagged_tu_seen_base
expr_stmt|;
name|tu
operator|->
name|t1
operator|=
name|t1
expr_stmt|;
name|tu
operator|->
name|t2
operator|=
name|t2
expr_stmt|;
name|tagged_tu_seen_base
operator|=
name|tu
expr_stmt|;
comment|/* The C standard says that two structures in different translation      units are compatible with each other only if the types of their      fields are compatible (among other things).  We assume that they      are compatible until proven otherwise when building the cache.      An example where this can occur is:      struct a      {        struct a *next;      };      If we are comparing this against a similar struct in another TU,      and did not assume they were compatible, we end up with an infinite      loop.  */
name|tu
operator|->
name|val
operator|=
literal|1
expr_stmt|;
return|return
name|tu
return|;
block|}
end_function

begin_comment
comment|/* Free the seen types until we get to TU_TIL. */
end_comment

begin_function
specifier|static
name|void
name|free_all_tagged_tu_seen_up_to
parameter_list|(
specifier|const
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tu_til
parameter_list|)
block|{
specifier|const
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tu
init|=
name|tagged_tu_seen_base
decl_stmt|;
while|while
condition|(
name|tu
operator|!=
name|tu_til
condition|)
block|{
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tu1
init|=
operator|(
expr|struct
name|tagged_tu_seen_cache
operator|*
operator|)
name|tu
decl_stmt|;
name|tu
operator|=
name|tu1
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tu1
argument_list|)
expr_stmt|;
block|}
name|tagged_tu_seen_base
operator|=
name|tu_til
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if two 'struct', 'union', or 'enum' types T1 and T2 are    compatible.  If the two types are not the same (which has been    checked earlier), this can only happen when multiple translation    units are being compiled.  See C99 6.2.7 paragraph 1 for the exact    rules.  */
end_comment

begin_function
specifier|static
name|int
name|tagged_types_tu_compatible_p
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|tree
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|bool
name|needs_warning
init|=
name|false
decl_stmt|;
comment|/* We have to verify that the tags of the types are the same.  This      is harder than it looks because this may be a typedef, so we have      to go look at the original type.  It may even be a typedef of a      typedef...      In the case of compiler-created builtin structs the TYPE_DECL      may be a dummy, with no DECL_ORIGINAL_TYPE.  Don't fault.  */
while|while
condition|(
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
name|t1
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
name|t2
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C90 didn't have the requirement that the two tags be the same.  */
if|if
condition|(
name|flag_isoc99
operator|&&
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* C90 didn't say what happened if one or both of the types were      incomplete; we choose to follow C99 rules here, which is that they      are compatible.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t1
argument_list|)
operator|==
name|NULL
operator|||
name|TYPE_SIZE
argument_list|(
name|t2
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
block|{
specifier|const
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tts_i
decl_stmt|;
for|for
control|(
name|tts_i
operator|=
name|tagged_tu_seen_base
init|;
name|tts_i
operator|!=
name|NULL
condition|;
name|tts_i
operator|=
name|tts_i
operator|->
name|next
control|)
if|if
condition|(
name|tts_i
operator|->
name|t1
operator|==
name|t1
operator|&&
name|tts_i
operator|->
name|t2
operator|==
name|t2
condition|)
return|return
name|tts_i
operator|->
name|val
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|ENUMERAL_TYPE
case|:
block|{
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tu
init|=
name|alloc_tagged_tu_seen_cache
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
comment|/* Speed up the case where the type values are in the same order.  */
name|tree
name|tv1
init|=
name|TYPE_VALUES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|tv2
init|=
name|TYPE_VALUES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|tv1
operator|==
name|tv2
condition|)
block|{
return|return
literal|1
return|;
block|}
for|for
control|(
init|;
name|tv1
operator|&&
name|tv2
condition|;
name|tv1
operator|=
name|TREE_CHAIN
argument_list|(
name|tv1
argument_list|)
operator|,
name|tv2
operator|=
name|TREE_CHAIN
argument_list|(
name|tv2
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tv1
argument_list|)
operator|!=
name|TREE_PURPOSE
argument_list|(
name|tv2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|tv1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tv2
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|tv1
operator|==
name|NULL_TREE
operator|&&
name|tv2
operator|==
name|NULL_TREE
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|tv1
operator|==
name|NULL_TREE
operator|||
name|tv2
operator|==
name|NULL_TREE
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|list_length
argument_list|(
name|TYPE_VALUES
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|list_length
argument_list|(
name|TYPE_VALUES
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|s1
operator|=
name|TYPE_VALUES
argument_list|(
name|t1
argument_list|)
init|;
name|s1
condition|;
name|s1
operator|=
name|TREE_CHAIN
argument_list|(
name|s1
argument_list|)
control|)
block|{
name|s2
operator|=
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|TYPE_VALUES
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
operator|||
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|s2
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
case|case
name|UNION_TYPE
case|:
block|{
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tu
init|=
name|alloc_tagged_tu_seen_cache
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|list_length
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|list_length
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  Speed up the common case where the fields are in the same order. */
for|for
control|(
name|s1
operator|=
name|TYPE_FIELDS
argument_list|(
name|t1
argument_list|)
operator|,
name|s2
operator|=
name|TYPE_FIELDS
argument_list|(
name|t2
argument_list|)
init|;
name|s1
operator|&&
name|s2
condition|;
name|s1
operator|=
name|TREE_CHAIN
argument_list|(
name|s1
argument_list|)
operator|,
name|s2
operator|=
name|TREE_CHAIN
argument_list|(
name|s2
argument_list|)
control|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|s1
argument_list|)
operator|==
name|NULL
operator|||
name|DECL_NAME
argument_list|(
name|s1
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|s2
argument_list|)
condition|)
break|break;
name|result
operator|=
name|comptypes_internal
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|result
operator|==
literal|2
condition|)
name|needs_warning
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s1
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|simple_cst_equal
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|s1
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|s2
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|s1
operator|&&
operator|!
name|s2
condition|)
block|{
name|tu
operator|->
name|val
operator|=
name|needs_warning
condition|?
literal|2
else|:
literal|1
expr_stmt|;
return|return
name|tu
operator|->
name|val
return|;
block|}
for|for
control|(
name|s1
operator|=
name|TYPE_FIELDS
argument_list|(
name|t1
argument_list|)
init|;
name|s1
condition|;
name|s1
operator|=
name|TREE_CHAIN
argument_list|(
name|s1
argument_list|)
control|)
block|{
name|bool
name|ok
init|=
name|false
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|s1
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|s2
operator|=
name|TYPE_FIELDS
argument_list|(
name|t2
argument_list|)
init|;
name|s2
condition|;
name|s2
operator|=
name|TREE_CHAIN
argument_list|(
name|s2
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|s1
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|s2
argument_list|)
condition|)
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
name|comptypes_internal
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|result
operator|==
literal|2
condition|)
name|needs_warning
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s1
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|simple_cst_equal
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|s1
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|s2
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
break|break;
name|ok
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|tu
operator|->
name|val
operator|=
name|needs_warning
condition|?
literal|2
else|:
literal|10
expr_stmt|;
return|return
name|tu
operator|->
name|val
return|;
block|}
case|case
name|RECORD_TYPE
case|:
block|{
name|struct
name|tagged_tu_seen_cache
modifier|*
name|tu
init|=
name|alloc_tagged_tu_seen_cache
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
for|for
control|(
name|s1
operator|=
name|TYPE_FIELDS
argument_list|(
name|t1
argument_list|)
operator|,
name|s2
operator|=
name|TYPE_FIELDS
argument_list|(
name|t2
argument_list|)
init|;
name|s1
operator|&&
name|s2
condition|;
name|s1
operator|=
name|TREE_CHAIN
argument_list|(
name|s1
argument_list|)
operator|,
name|s2
operator|=
name|TREE_CHAIN
argument_list|(
name|s2
argument_list|)
control|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|||
name|DECL_NAME
argument_list|(
name|s1
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|s2
argument_list|)
condition|)
break|break;
name|result
operator|=
name|comptypes_internal
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|result
operator|==
literal|2
condition|)
name|needs_warning
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s1
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|simple_cst_equal
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|s1
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|s2
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|s1
operator|&&
name|s2
condition|)
name|tu
operator|->
name|val
operator|=
literal|0
expr_stmt|;
else|else
name|tu
operator|->
name|val
operator|=
name|needs_warning
condition|?
literal|2
else|:
literal|1
expr_stmt|;
return|return
name|tu
operator|->
name|val
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if two function types F1 and F2 are compatible.    If either type specifies no argument types,    the other must specify a fixed number of self-promoting arg types.    Otherwise, if one type specifies only the number of arguments,    the other must specify that number of self-promoting arg types.    Otherwise, the argument types must match.  */
end_comment

begin_function
specifier|static
name|int
name|function_types_compatible_p
parameter_list|(
name|tree
name|f1
parameter_list|,
name|tree
name|f2
parameter_list|)
block|{
name|tree
name|args1
decl_stmt|,
name|args2
decl_stmt|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|val1
decl_stmt|;
name|tree
name|ret1
decl_stmt|,
name|ret2
decl_stmt|;
name|ret1
operator|=
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|ret2
operator|=
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
expr_stmt|;
comment|/* 'volatile' qualifiers on a function's return type used to mean      the function is noreturn.  */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|ret1
argument_list|)
operator|!=
name|TYPE_VOLATILE
argument_list|(
name|ret2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"function return types not compatible due to %<volatile%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|ret1
argument_list|)
condition|)
name|ret1
operator|=
name|build_qualified_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ret1
argument_list|)
argument_list|,
name|TYPE_QUALS
argument_list|(
name|ret1
argument_list|)
operator|&
operator|~
name|TYPE_QUAL_VOLATILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|ret2
argument_list|)
condition|)
name|ret2
operator|=
name|build_qualified_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ret2
argument_list|)
argument_list|,
name|TYPE_QUALS
argument_list|(
name|ret2
argument_list|)
operator|&
operator|~
name|TYPE_QUAL_VOLATILE
argument_list|)
expr_stmt|;
name|val
operator|=
name|comptypes_internal
argument_list|(
name|ret1
argument_list|,
name|ret2
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|args1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
expr_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|args1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If one of these types comes from a non-prototype fn definition, 	 compare that with the other type's arglist. 	 If they don't match, ask for a warning (but no error).  */
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args2
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|args2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Both types have argument lists: compare them and propagate results.  */
name|val1
operator|=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|args2
argument_list|)
expr_stmt|;
return|return
name|val1
operator|!=
literal|1
condition|?
name|val1
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Check two lists of types for compatibility,    returning 0 for incompatible, 1 for compatible,    or 2 for compatible with warning.  */
end_comment

begin_function
specifier|static
name|int
name|type_lists_compatible_p
parameter_list|(
name|tree
name|args1
parameter_list|,
name|tree
name|args2
parameter_list|)
block|{
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|newval
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|a1
decl_stmt|,
name|mv1
decl_stmt|,
name|a2
decl_stmt|,
name|mv2
decl_stmt|;
if|if
condition|(
name|args1
operator|==
literal|0
operator|&&
name|args2
operator|==
literal|0
condition|)
return|return
name|val
return|;
comment|/* If one list is shorter than the other, 	 they fail to match.  */
if|if
condition|(
name|args1
operator|==
literal|0
operator|||
name|args2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|mv1
operator|=
name|a1
operator|=
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
expr_stmt|;
name|mv2
operator|=
name|a2
operator|=
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mv1
operator|&&
name|mv1
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv1
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mv2
operator|&&
name|mv2
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv2
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv2
argument_list|)
expr_stmt|;
comment|/* A null pointer instead of a type 	 means there is supposed to be an argument 	 but nothing is specified about what type it has. 	 So match anything that self-promotes.  */
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c_type_promotes_to
argument_list|(
name|a2
argument_list|)
operator|!=
name|a2
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|a2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c_type_promotes_to
argument_list|(
name|a1
argument_list|)
operator|!=
name|a1
condition|)
return|return
literal|0
return|;
block|}
comment|/* If one of the lists has an error marker, ignore this arg.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a1
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|a2
argument_list|)
operator|==
name|ERROR_MARK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|newval
operator|=
name|comptypes_internal
argument_list|(
name|mv1
argument_list|,
name|mv2
argument_list|)
operator|)
condition|)
block|{
comment|/* Allow  wait (union {union wait *u; int *i} *) 	     and  wait (union wait *)  to be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a1
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|a1
argument_list|)
operator|==
literal|0
operator|||
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|a1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|a1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|a1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|a2
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|a1
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
block|{
name|tree
name|mv3
init|=
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
decl_stmt|;
if|if
condition|(
name|mv3
operator|&&
name|mv3
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv3
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv3
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv3
argument_list|)
expr_stmt|;
if|if
condition|(
name|comptypes_internal
argument_list|(
name|mv3
argument_list|,
name|mv2
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a2
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|a2
argument_list|)
operator|==
literal|0
operator|||
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|a2
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|a2
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|a2
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|a1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|a2
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
block|{
name|tree
name|mv3
init|=
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
decl_stmt|;
if|if
condition|(
name|mv3
operator|&&
name|mv3
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|mv3
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mv3
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mv3
argument_list|)
expr_stmt|;
if|if
condition|(
name|comptypes_internal
argument_list|(
name|mv3
argument_list|,
name|mv1
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* comptypes said ok, but record if it said to warn.  */
if|if
condition|(
name|newval
operator|>
name|val
condition|)
name|val
operator|=
name|newval
expr_stmt|;
name|args1
operator|=
name|TREE_CHAIN
argument_list|(
name|args1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TREE_CHAIN
argument_list|(
name|args2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the size to increment a pointer by.  */
end_comment

begin_function
specifier|static
name|tree
name|c_size_in_bytes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_one_node
return|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
return|return
name|size_one_node
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
return|return
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
name|tree
name|decl_constant_value
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
comment|/* Don't change a variable array bound or initial value to a constant 	 in a place where a variable is invalid.  Note that DECL_INITIAL 	 isn't valid for a PARM_DECL.  */
name|current_function_decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return either DECL or its known constant value (if it has one), but    return DECL if pedantic or DECL has mode BLKmode.  This is for    bug-compatibility with the old behavior of decl_constant_value    (before GCC 3.0); every use of this function is a bug and it should    be removed before GCC 3.1.  It is not appropriate to use pedantic    in a way that affects optimization, and BLKmode is probably not the    right test for avoiding misoptimizations either.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_constant_value_for_broken_optimization
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|decl
return|;
name|ret
operator|=
name|decl_constant_value
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Avoid unwanted tree sharing between the initializer and current      function's body where the tree can be modified e.g. by the      gimplifier.  */
if|if
condition|(
name|ret
operator|!=
name|decl
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|ret
operator|=
name|unshare_expr
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Convert the array expression EXP to a pointer.  */
end_comment

begin_function
specifier|static
name|tree
name|array_to_pointer_conversion
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|orig_exp
init|=
name|exp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|adr
decl_stmt|;
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_NO_WARNING
argument_list|(
name|orig_exp
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* We are making an ADDR_EXPR of ptrtype.  This is a valid 	 ADDR_EXPR because it's the best way of representing what 	 happens in C when we take the address of an array and place 	 it in a pointer to the element type.  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can      simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert the function expression EXP to a pointer.  */
end_comment

begin_function
specifier|static
name|tree
name|function_to_pointer_conversion
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|orig_exp
init|=
name|exp
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_NO_WARNING
argument_list|(
name|orig_exp
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform the default conversion of arrays and functions to pointers.    Return the result of converting EXP.  For any other expression, just    return EXP after removing NOPs.  */
end_comment

begin_function
name|struct
name|c_expr
name|default_function_array_conversion
parameter_list|(
name|struct
name|c_expr
name|exp
parameter_list|)
block|{
name|tree
name|orig_exp
init|=
name|exp
operator|.
name|value
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
operator|.
name|value
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
block|{
name|bool
name|not_lvalue
init|=
name|false
decl_stmt|;
name|bool
name|lvalue_array_p
decl_stmt|;
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
operator|.
name|value
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
operator|.
name|value
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
operator|.
name|value
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
operator|.
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
operator|.
name|value
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|not_lvalue
operator|=
name|true
expr_stmt|;
name|exp
operator|.
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_NO_WARNING
argument_list|(
name|orig_exp
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|exp
operator|.
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|lvalue_array_p
operator|=
operator|!
name|not_lvalue
operator|&&
name|lvalue_p
argument_list|(
name|exp
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_isoc99
operator|&&
operator|!
name|lvalue_array_p
condition|)
block|{
comment|/* Before C99, non-lvalue arrays do not decay to pointers. 	       Normally, using such an array would be invalid; but it can 	       be used correctly inside sizeof or as a statement expression. 	       Thus, do not give an error here; an error will result later.  */
return|return
name|exp
return|;
block|}
name|exp
operator|.
name|value
operator|=
name|array_to_pointer_conversion
argument_list|(
name|exp
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|exp
operator|.
name|value
operator|=
name|function_to_pointer_conversion
argument_list|(
name|exp
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|STRIP_TYPE_NOPS
argument_list|(
name|exp
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_NO_WARNING
argument_list|(
name|orig_exp
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|exp
operator|.
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* EXP is an expression of integer type.  Apply the integer promotions    to it and return the promoted value.  */
end_comment

begin_function
name|tree
name|perform_integral_promotions
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Normally convert enums to int,      but convert wide enums to something wider.  */
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|type
operator|=
name|c_common_type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
comment|/* ??? This should no longer be needed now bit-fields have their      proper types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
comment|/* If it's thinner than an int, promote it like a 	 c_promoting_integer_type_p, otherwise leave it alone.  */
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Preserve unsignedness if not really getting any wider.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Perform default promotions for C data used in expressions.    Enumeral types or short or char are converted to int.    In addition, manifest constants symbols are replaced by their values.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|orig_exp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Functions and arrays have been converted during parsing.  */
name|gcc_assert
argument_list|(
name|code
operator|!=
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|exp
return|;
comment|/* Constants can be used directly unless they're not loadable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value unless      it is an array, in which case we must be sure that taking the      address of the array produces consistent results.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|code
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|exp
operator|=
name|decl_constant_value_for_broken_optimization
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* Strip no-op conversions.  */
name|orig_exp
operator|=
name|exp
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_NO_WARNING
argument_list|(
name|orig_exp
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|perform_integral_promotions
argument_list|(
name|exp
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up COMPONENT in a structure or union DECL.     If the component name is not found, returns NULL_TREE.  Otherwise,    the return value is a TREE_LIST, with each TREE_VALUE a FIELD_DECL    stepping down the chain to the component, which is in the last    TREE_VALUE of the list.  Normally the list is of length one, but if    the component is embedded within (nested) anonymous structures or    unions, the list steps down the chain to the component.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|component
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|;
comment|/* If TYPE_LANG_SPECIFIC is set, then it is a sorted array of pointers      to the field elements.  Use a binary search on this array to quickly      find the element.  Otherwise, do a linear search.  TYPE_LANG_SPECIFIC      will always be set for structures which have many elements.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|s
condition|)
block|{
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
name|tree
modifier|*
name|field_array
init|=
operator|&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|s
operator|->
name|elts
index|[
literal|0
index|]
decl_stmt|;
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|s
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|field
operator|=
name|field_array
index|[
name|bot
operator|+
name|half
index|]
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Step through all anon unions in linear fashion.  */
while|while
condition|(
name|DECL_NAME
argument_list|(
name|field_array
index|[
name|bot
index|]
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|field
operator|=
name|field_array
index|[
name|bot
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|anon
init|=
name|lookup_field
argument_list|(
name|field
argument_list|,
name|component
argument_list|)
decl_stmt|;
if|if
condition|(
name|anon
condition|)
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|anon
argument_list|)
return|;
block|}
block|}
comment|/* Entire record is only anon unions.  */
if|if
condition|(
name|bot
operator|>
name|top
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Restart the binary search, with new lower bound.  */
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|<
name|component
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_array
index|[
name|bot
index|]
argument_list|)
operator|==
name|component
condition|)
name|field
operator|=
name|field_array
index|[
name|bot
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|component
condition|)
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|tree
name|anon
init|=
name|lookup_field
argument_list|(
name|field
argument_list|,
name|component
argument_list|)
decl_stmt|;
if|if
condition|(
name|anon
condition|)
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|anon
argument_list|)
return|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
block|}
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an expression to refer to the COMPONENT field of    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|tree
name|datum
parameter_list|,
name|tree
name|component
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|NULL
decl_stmt|;
name|tree
name|ref
decl_stmt|;
if|if
condition|(
operator|!
name|objc_is_public
argument_list|(
name|datum
argument_list|,
name|component
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* See if there is a field or component with name COMPONENT.  */
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|c_incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|field
operator|=
name|lookup_field
argument_list|(
name|datum
argument_list|,
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
literal|"%qT has no member named %qE"
argument_list|,
name|type
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Chain the COMPONENT_REFs if necessary down to the FIELD. 	 This might be better solved in future the way the C++ front 	 end does it - by giving the anonymous entities each a 	 separate name and type, and then have build_component_ref 	 recursively call itself.  We can't do that here.  */
do|do
block|{
name|tree
name|subdatum
init|=
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|quals
decl_stmt|;
name|tree
name|subtype
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|subdatum
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|quals
operator|=
name|TYPE_QUALS
argument_list|(
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|subdatum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator||=
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|subdatum
argument_list|)
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|subtype
argument_list|,
name|datum
argument_list|,
name|subdatum
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|subdatum
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|subdatum
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|subdatum
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|subdatum
argument_list|)
expr_stmt|;
name|datum
operator|=
name|ref
expr_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field
condition|)
do|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member %qE in something not a structure or union"
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.  */
end_comment

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|tree
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|errorstring
parameter_list|)
block|{
name|tree
name|pointer
init|=
name|default_conversion
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ref
decl_stmt|;
name|ref
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|t
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"dereferencing pointer to incomplete type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"dereferencing %<void *%> pointer"
argument_list|)
expr_stmt|;
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	     so that we get the proper error message if the result is used 	     to assign to.  Also,&* is supposed to be a no-op. 	     And ANSI C seems to specify that the type of the result 	     should be the const type.  */
comment|/* A de-reference of a pointer to const is not a const.  It is valid 	     to change it via some other pointer.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"invalid type argument of %qs"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|tree
name|array
parameter_list|,
name|tree
name|index
parameter_list|)
block|{
name|bool
name|swapped
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|temp
operator|=
name|array
expr_stmt|;
name|array
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|temp
expr_stmt|;
name|swapped
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is pointer to function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* ??? Existing practice has been to warn only when the char      index is syntactically the index, not for char[array].  */
if|if
condition|(
operator|!
name|swapped
condition|)
name|warn_array_subscript_with_type_char
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|/* Apply default promotions *after* noticing character types.  */
name|index
operator|=
name|default_conversion
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|array
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a constant value which is not within 	 the array bounds cannot be stored in a register either; because we 	 would get a crash in store_bit_field/extract_bit_field when trying 	 to access a non-existent part of the register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|index
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|array
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|C_DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids subscripting %<register%> array"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_isoc99
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|foo
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|index
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are 	 or if the array is.  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
comment|/* This was added by rms on 16 Nov 91. 	       It fixes  vol struct foo *a;  a->elts[1] 	       in an inline function. 	       Hope it doesn't break something else.  */
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an external reference to identifier ID.  FUN indicates    whether this will be used for a function call.  LOC is the source    location of the identifier.  */
end_comment

begin_function
name|tree
name|build_external_ref
parameter_list|(
name|tree
name|id
parameter_list|,
name|int
name|fun
parameter_list|,
name|location_t
name|loc
parameter_list|)
block|{
name|tree
name|ref
decl_stmt|;
name|tree
name|decl
init|=
name|lookup_name
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|/* In Objective-C, an instance variable (ivar) may be preferred to      whatever lookup_name() found.  */
name|decl
operator|=
name|objc_lookup_ivar
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
name|ref
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|fun
condition|)
comment|/* Implicit function declaration.  */
name|ref
operator|=
name|implicitly_declare
argument_list|(
name|id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
comment|/* Don't complain about something that's already been        complained about.  */
return|return
name|error_mark_node
return|;
else|else
block|{
name|undeclared_variable
argument_list|(
name|id
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|ref
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_evaluation
condition|)
name|assemble_external
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|in_alignof
condition|)
block|{
if|if
condition|(
operator|!
name|in_sizeof
operator|&&
operator|!
name|in_typeof
condition|)
name|C_DECL_USED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|ref
argument_list|)
condition|)
name|record_maybe_used_decl
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|used_types_insert
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
operator|&&
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
condition|)
name|DECL_NONLOCAL
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Record details of decls possibly used inside sizeof or typeof.  */
end_comment

begin_struct
struct|struct
name|maybe_used_decl
block|{
comment|/* The decl.  */
name|tree
name|decl
decl_stmt|;
comment|/* The level seen at (in_sizeof + in_typeof).  */
name|int
name|level
decl_stmt|;
comment|/* The next one at this level or above, or NULL.  */
name|struct
name|maybe_used_decl
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|maybe_used_decl
modifier|*
name|maybe_used_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record that DECL, an undefined static function reference seen    inside sizeof or typeof, might be used if the operand of sizeof is    a VLA type or the operand of typeof is a variably modified    type.  */
end_comment

begin_function
specifier|static
name|void
name|record_maybe_used_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|maybe_used_decl
modifier|*
name|t
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|maybe_used_decl
argument_list|)
decl_stmt|;
name|t
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|in_sizeof
operator|+
name|in_typeof
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|maybe_used_decls
expr_stmt|;
name|maybe_used_decls
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the stack of decls possibly used inside sizeof or typeof.  If    USED is false, just discard them.  If it is true, mark them used    (if no longer inside sizeof or typeof) or move them to the next    level up (if still inside sizeof or typeof).  */
end_comment

begin_function
name|void
name|pop_maybe_used
parameter_list|(
name|bool
name|used
parameter_list|)
block|{
name|struct
name|maybe_used_decl
modifier|*
name|p
init|=
name|maybe_used_decls
decl_stmt|;
name|int
name|cur_level
init|=
name|in_sizeof
operator|+
name|in_typeof
decl_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|level
operator|>
name|cur_level
condition|)
block|{
if|if
condition|(
name|used
condition|)
block|{
if|if
condition|(
name|cur_level
operator|==
literal|0
condition|)
name|C_DECL_USED
argument_list|(
name|p
operator|->
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|p
operator|->
name|level
operator|=
name|cur_level
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|used
operator|||
name|cur_level
operator|==
literal|0
condition|)
name|maybe_used_decls
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the result of sizeof applied to EXPR.  */
end_comment

begin_function
name|struct
name|c_expr
name|c_expr_sizeof_expr
parameter_list|(
name|struct
name|c_expr
name|expr
parameter_list|)
block|{
name|struct
name|c_expr
name|ret
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|value
operator|==
name|error_mark_node
condition|)
block|{
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|pop_maybe_used
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|value
operator|=
name|c_sizeof
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
if|if
condition|(
name|c_vla_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
argument_list|)
condition|)
block|{
comment|/* sizeof is evaluated when given a vla (C99 6.5.3.4p2).  */
name|ret
operator|.
name|value
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ret
operator|.
name|value
argument_list|)
argument_list|,
name|expr
operator|.
name|value
argument_list|,
name|ret
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|pop_maybe_used
argument_list|(
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return the result of sizeof applied to T, a structure for the type    name passed to sizeof (rather than the type itself).  */
end_comment

begin_function
name|struct
name|c_expr
name|c_expr_sizeof_type
parameter_list|(
name|struct
name|c_type_name
modifier|*
name|t
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|struct
name|c_expr
name|ret
decl_stmt|;
name|type
operator|=
name|groktypename
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|c_sizeof
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|pop_maybe_used
argument_list|(
name|type
operator|!=
name|error_mark_node
condition|?
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
else|:
name|false
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.    FUNCTION's data type may be a function type or a pointer-to-function.  */
end_comment

begin_function
name|tree
name|build_function_call
parameter_list|(
name|tree
name|function
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|tree
name|fntype
decl_stmt|,
name|fundecl
init|=
literal|0
decl_stmt|;
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|result
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Implement type-directed function overloading for builtins. 	 resolve_overloaded_builtin and targetm.resolve_overloaded_builtin 	 handle all the type checking.  The result is a complete expression 	 that implements this function call.  */
name|tem
operator|=
name|resolve_overloaded_builtin
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fundecl
operator|=
name|function
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|function
operator|=
name|function_to_pointer_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF      expressions, like those used for ObjC messenger dispatches.  */
name|function
operator|=
name|objc_rewrite_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"called object %qE is not a function"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|fundecl
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|fundecl
argument_list|)
condition|)
name|current_function_returns_abnormally
operator|=
literal|1
expr_stmt|;
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Check that the function is called through a compatible prototype.      If it is not, replace the call by a trap, wrapped up in a compound      expression if necessary.  This has the nice side-effect to prevent      the tree-inliner from generating invalid assignment trees which may      blow up in the RTL expander later.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|comptypes
argument_list|(
name|fntype
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|tree
name|trap
init|=
name|build_function_call
argument_list|(
name|built_in_decls
index|[
name|BUILT_IN_TRAP
index|]
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* This situation leads to run-time undefined behavior.  We can't, 	 therefore, simply error unless we can prove that all possible 	 executions of the program must execute the code.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"function called through a non-compatible type"
argument_list|)
expr_stmt|;
comment|/* We can, however, treat "undefined" any way we please. 	 Call abort to encourage the user to fix the program.  */
name|inform
argument_list|(
literal|"if this code is reached, the program will abort"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|return_type
argument_list|)
condition|)
return|return
name|trap
return|;
else|else
block|{
name|tree
name|rhs
decl_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|return_type
argument_list|)
condition|)
name|rhs
operator|=
name|build_compound_literal
argument_list|(
name|return_type
argument_list|,
name|build_constructor
argument_list|(
name|return_type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|fold_convert
argument_list|(
name|return_type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|return_type
argument_list|,
name|trap
argument_list|,
name|rhs
argument_list|)
return|;
block|}
block|}
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|function
argument_list|,
name|fundecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|coerced_params
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check that the arguments to the function are valid.  */
name|check_function_arguments
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|coerced_params
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_constant_value
condition|)
block|{
name|result
operator|=
name|fold_build3_initializer
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|name
operator|==
name|NULL_TREE
operator|||
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"__builtin_"
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|pedwarn_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|fold_build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|require_complete_type
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the argument expressions in the list VALUES    to the types in the list TYPELIST.  The result is a list of converted    argument expressions, unless there are too few arguments in which    case it is error_mark_node.     If TYPELIST is exhausted, or when an element has NULL as its type,    perform the default conversions.     PARMLIST is the chain of parm decls for the function being called.    It may be 0, if that info is not available.    It is used only for generating error messages.     FUNCTION is a tree for the called function.  It is used only for    error messages, where it is formatted with %qE.     This is also where warnings about wrong number of args are generated.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_arguments
parameter_list|(
name|tree
name|typelist
parameter_list|,
name|tree
name|values
parameter_list|,
name|tree
name|function
parameter_list|,
name|tree
name|fundecl
parameter_list|)
block|{
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
name|tree
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
name|tree
name|selector
decl_stmt|;
comment|/* Change pointer to function to the function itself for      diagnostics.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle an ObjC selector specially for diagnostics.  */
name|selector
operator|=
name|objc_message_selector
argument_list|()
expr_stmt|;
comment|/* Scan the given expressions and types, producing individual      converted arguments and pushing them on RESULT in reverse order.  */
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
operator|,
name|parmnum
operator|=
literal|0
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|parmnum
operator|++
control|)
block|{
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
name|tree
name|rname
init|=
name|function
decl_stmt|;
name|int
name|argnum
init|=
name|parmnum
operator|+
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_func_diag
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments to function %qE"
argument_list|,
name|function
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|selector
operator|&&
name|argnum
operator|>
literal|2
condition|)
block|{
name|rname
operator|=
name|selector
expr_stmt|;
name|argnum
operator|-=
literal|2
expr_stmt|;
block|}
name|STRIP_TYPE_NOPS
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type of formal parameter %d is incomplete"
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|/* Optionally warn about conversions that 		 differ from the default conversions.  */
if|if
condition|(
name|warn_conversion
operator|||
name|warn_traditional
condition|)
block|{
name|unsigned
name|int
name|formal_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as integer "
literal|"rather than floating due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as integer "
literal|"rather than complex due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as complex "
literal|"rather than floating due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as floating "
literal|"rather than integer due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as complex "
literal|"rather than integer due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as floating "
literal|"rather than complex due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
comment|/* ??? At some point, messages should be written about 		     conversions between complex types, but that's too messy 		     to do now.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* Warn if any argument is passed as `float', 			 since without a prototype it would be `double'.  */
if|if
condition|(
name|formal_prec
operator|==
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|&&
name|type
operator|!=
name|dfloat32_type_node
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as %<float%> "
literal|"rather than %<double%> due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
comment|/* Warn if mismatch between argument and prototype 			 for decimal float types.  Warn of conversions with 			 binary float types and of precision narrowing due to 			 prototype. */
elseif|else
if|if
condition|(
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|&&
operator|(
name|type
operator|==
name|dfloat32_type_node
operator|||
name|type
operator|==
name|dfloat64_type_node
operator|||
name|type
operator|==
name|dfloat128_type_node
operator|||
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|dfloat32_type_node
operator|||
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|dfloat64_type_node
operator|||
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|dfloat128_type_node
operator|)
operator|&&
operator|(
name|formal_prec
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|||
operator|(
name|type
operator|==
name|dfloat128_type_node
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|!=
name|dfloat64_type_node
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|!=
name|dfloat32_type_node
operator|)
operator|)
operator|)
operator|||
operator|(
name|type
operator|==
name|dfloat64_type_node
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|!=
name|dfloat32_type_node
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE as %qT "
literal|"rather than %qT due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Detect integer changing in width or signedness. 		     These warnings are only activated with 		     -Wconversion, not with -Wtraditional.  */
elseif|else
if|if
condition|(
name|warn_conversion
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|would_have_been
init|=
name|default_conversion
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|tree
name|type1
init|=
name|TREE_TYPE
argument_list|(
name|would_have_been
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* No warning if function asks for enum 			   and the actual arg is that enum type.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|formal_prec
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wconversion
argument_list|,
literal|"passing argument %d of %qE "
literal|"with different width due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|type1
argument_list|)
condition|)
empty_stmt|;
comment|/* Don't complain if the formal parameter type 			 is an enum, because we can't tell now whether 			 the value was an enum--even the same enum.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|val
argument_list|,
name|type
argument_list|)
condition|)
comment|/* Change in signedness doesn't matter 			   if a constant value is unaffected.  */
empty_stmt|;
comment|/* If the value is extended from a narrower 			 unsigned type, it doesn't matter whether we 			 pass it as signed or unsigned; the value 			 certainly is the same either way.  */
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wconversion
argument_list|,
literal|"passing argument %d of %qE "
literal|"as unsigned due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wconversion
argument_list|,
literal|"passing argument %d of %qE "
literal|"as signed due to prototype"
argument_list|,
name|argnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
block|}
block|}
name|parmval
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|ic_argpass
argument_list|,
name|fundecl
argument_list|,
name|function
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|fundecl
condition|?
name|TREE_TYPE
argument_list|(
name|fundecl
argument_list|)
else|:
literal|0
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
operator|&&
operator|!
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* Convert `float' to `double'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|invalid_func_diag
operator|=
name|targetm
operator|.
name|calls
operator|.
name|invalid_arg_for_unprototyped_fn
argument_list|(
name|typelist
argument_list|,
name|fundecl
argument_list|,
name|val
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
name|invalid_func_diag
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function %qE"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the entry point used by the parser to build unary operators    in the input.  CODE, a tree_code, specifies the unary operator, and    ARG is the operand.  For unary plus, the C parser currently uses    CONVERT_EXPR for code.  */
end_comment

begin_function
name|struct
name|c_expr
name|parser_build_unary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|struct
name|c_expr
name|arg
parameter_list|)
block|{
name|struct
name|c_expr
name|result
decl_stmt|;
name|result
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|result
operator|.
name|value
operator|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|arg
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|overflow_warning
argument_list|(
name|result
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This is the entry point used by the parser to build binary operators    in the input.  CODE, a tree_code, specifies the binary operator, and    ARG1 and ARG2 are the operands.  In addition to constructing the    expression, we check for operands that were written with other binary    operators in a way that is likely to confuse the user.  */
end_comment

begin_function
name|struct
name|c_expr
name|parser_build_binary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|struct
name|c_expr
name|arg1
parameter_list|,
name|struct
name|c_expr
name|arg2
parameter_list|)
block|{
name|struct
name|c_expr
name|result
decl_stmt|;
name|enum
name|tree_code
name|code1
init|=
name|arg1
operator|.
name|original_code
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|arg2
operator|.
name|original_code
decl_stmt|;
name|result
operator|.
name|value
operator|=
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
operator|.
name|value
argument_list|,
name|arg2
operator|.
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|.
name|original_code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
operator|.
name|value
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|result
return|;
comment|/* Check for cases such as x+y<<z which users are likely      to misinterpret.  */
if|if
condition|(
name|warn_parentheses
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around + or - inside shift"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code2
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around&& within ||"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_IOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|BIT_XOR_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|BIT_XOR_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around arithmetic in operand of |"
argument_list|)
expr_stmt|;
comment|/* Check cases like x|y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around comparison in operand of |"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_XOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around arithmetic in operand of ^"
argument_list|)
expr_stmt|;
comment|/* Check cases like x^y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around comparison in operand of ^"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around + or - in operand of&"
argument_list|)
expr_stmt|;
comment|/* Check cases like x&y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around comparison in operand of&"
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly, check for cases like 1<=i<=10 that are probably errors.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
name|tcc_comparison
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"comparisons like X<=Y<=Z do not "
literal|"have their mathematical meaning"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about comparisons against string literals, with the exception      of testing for equality or inequality of a string literal with NULL.  */
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
operator|(
name|code1
operator|==
name|STRING_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg2
operator|.
name|value
argument_list|)
operator|)
operator|||
operator|(
name|code2
operator|==
name|STRING_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
operator|.
name|value
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"comparison with string literal results in unspecified behaviour"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|&&
operator|(
name|code1
operator|==
name|STRING_CST
operator|||
name|code2
operator|==
name|STRING_CST
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"comparison with string literal results in unspecified behaviour"
argument_list|)
expr_stmt|;
name|overflow_warning
argument_list|(
name|result
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|con0
decl_stmt|,
name|con1
decl_stmt|,
name|lit0
decl_stmt|,
name|lit1
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type %<void *%> used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* If the conversion to ptrdiff_type does anything like widening or      converting a partial to an integral mode, we get a convert_expression      that is in the way to do any simplifications.      (fold-const.c doesn't know that the extra bits won't be needed.      split_tree uses STRIP_SIGN_NOPS, which leaves conversions to a      different mode in place.)      So first try to find a common term here 'by hand'; we want to cover      at least the cases that occur in legal static initializers.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|con0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|con0
operator|=
name|op0
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|con1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|con1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|con0
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|lit0
operator|=
name|TREE_OPERAND
argument_list|(
name|con0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|con0
operator|=
name|TREE_OPERAND
argument_list|(
name|con0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|lit0
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|con1
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|lit1
operator|=
name|TREE_OPERAND
argument_list|(
name|con1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|con1
operator|=
name|TREE_OPERAND
argument_list|(
name|con1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|lit1
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|con0
argument_list|,
name|con1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|lit0
expr_stmt|;
name|op1
operator|=
name|lit1
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.      Do not do default conversions on the minus operator      in case restype is a short type.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This generates an error if op1 is pointer to incomplete type.  */
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
comment|/* This generates an error if op0 is pointer to incomplete type.  */
name|op1
operator|=
name|c_size_in_bytes
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
comment|/* Divide by the size, in easiest possible way.  */
return|return
name|fold_build2
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.    For any CODE other than ADDR_EXPR, FLAG nonzero suppresses    the default promotions (such as from short to int).    For ADDR_EXPR, the default promotions are not applied; FLAG nonzero    allows non-lvalues; this is only used to handle conversion of non-lvalue    arrays to pointers in C99.  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|xarg
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|typecode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|int
name|noconvert
init|=
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_op_diag
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|typecode
operator|==
name|ENUMERAL_TYPE
operator|||
name|typecode
operator|==
name|BOOLEAN_TYPE
condition|)
name|typecode
operator|=
name|INTEGER_TYPE
expr_stmt|;
if|if
condition|(
operator|(
name|invalid_op_diag
operator|=
name|targetm
operator|.
name|invalid_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
name|invalid_op_diag
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|||
name|typecode
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary plus"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|non_lvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|||
name|typecode
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary minus"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|VECTOR_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|code
operator|=
name|CONJ_EXPR
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support %<~%> for complex conjugation"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"wrong type argument to bit-complement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to abs"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
comment|/* Conjugating a real value is a no-op, but allow it anyway.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to conjugation"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
operator|&&
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|COMPLEX_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary exclamation mark"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arg
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
else|else
return|return
name|arg
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
else|else
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Increment or decrement the real part of the value, 	 and don't change the imaginary part.  */
if|if
condition|(
name|typecode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support %<++%> and %<--%>"
literal|" on complex types"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real
operator|=
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|real
argument_list|,
literal|1
argument_list|)
argument_list|,
name|imag
argument_list|)
return|;
block|}
comment|/* Report invalid types.  */
if|if
condition|(
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|error
argument_list|(
literal|"wrong type argument to increment"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"wrong type argument to decrement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|{
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|typecode
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* If pointer target is an undefined struct, 	       we just cannot know how to do the arithmetic.  */
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|error
argument_list|(
literal|"increment of pointer to unknown structure"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"decrement of pointer to unknown structure"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|pedwarn
argument_list|(
literal|"wrong type argument to increment"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"wrong type argument to decrement"
argument_list|)
expr_stmt|;
block|}
name|inc
operator|=
name|c_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|lv_increment
else|:
name|lv_decrement
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Report a read-only lvalue.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|readonly_error
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|lv_increment
else|:
name|lv_decrement
operator|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
name|val
operator|=
name|boolean_increment
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|code
condition|)
name|TREE_NO_WARNING
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion.  */
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Don't let this be an lvalue.  */
if|if
condition|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
name|array_to_pointer_conversion
argument_list|(
name|op0
argument_list|)
else|:
name|op0
operator|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Anything not already handled and not a true memory reference 	 or a non-lvalue array is an error.  */
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|flag
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
name|lv_addressof
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Ordinary case; arg is a COMPONENT_REF or a decl.  */
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If the lvalue is const or volatile, merge that into the type 	 to which the address will point.  Note that you can't get a 	 restricted pointer by taking the address of something, so we 	 only have to deal with `const' and `volatile' here.  */
if|if
condition|(
operator|(
name|DECL_P
argument_list|(
name|arg
argument_list|)
operator|||
name|REFERENCE_CLASS_P
argument_list|(
name|arg
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
name|argtype
operator|=
name|c_build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|COMPONENT_REF
operator|||
operator|!
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
comment|/* ??? Cope with user tricks that amount to offsetof.  Delete this 	 when we have proper support for integer constant expressions.  */
name|val
operator|=
name|get_base_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|op0
init|=
name|fold_convert
argument_list|(
name|argtype
argument_list|,
name|fold_offsetof
argument_list|(
name|arg
argument_list|,
name|val
argument_list|)
argument_list|)
decl_stmt|,
name|op1
decl_stmt|;
name|op1
operator|=
name|fold_convert
argument_list|(
name|argtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
name|val
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|val
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|require_constant_value
condition|?
name|fold_build1_initializer
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
else|:
name|fold_build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language.    Lvalues can be assigned, unless their type has TYPE_READONLY.    Lvalues can have their address taken, unless they have C_DECL_REGISTER.  */
end_comment

begin_function
specifier|static
name|int
name|lvalue_p
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
return|return
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
return|;
case|case
name|BIND_EXPR
case|:
return|return
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Give an error for storing in something that is 'const'.  */
end_comment

begin_function
specifier|static
name|void
name|readonly_error
parameter_list|(
name|tree
name|arg
parameter_list|,
name|enum
name|lvalue_use
name|use
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|use
operator|==
name|lv_assign
operator|||
name|use
operator|==
name|lv_increment
operator|||
name|use
operator|==
name|lv_decrement
operator|||
name|use
operator|==
name|lv_asm
argument_list|)
expr_stmt|;
comment|/* Using this macro rather than (for example) arrays of messages      ensures that all the format strings are checked at compile      time.  */
define|#
directive|define
name|READONLY_MSG
parameter_list|(
name|A
parameter_list|,
name|I
parameter_list|,
name|D
parameter_list|,
name|AS
parameter_list|)
value|(use == lv_assign ? (A)		\ 				   : (use == lv_increment ? (I)		\ 				   : (use == lv_decrement ? (D) : (AS))))
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|readonly_error
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|use
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|READONLY_MSG
argument_list|(
name|G_
argument_list|(
literal|"assignment of read-only member %qD"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"increment of read-only member %qD"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"decrement of read-only member %qD"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"read-only member %qD used as %<asm%> output"
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|error
argument_list|(
name|READONLY_MSG
argument_list|(
name|G_
argument_list|(
literal|"assignment of read-only variable %qD"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"increment of read-only variable %qD"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"decrement of read-only variable %qD"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"read-only variable %qD used as %<asm%> output"
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|READONLY_MSG
argument_list|(
name|G_
argument_list|(
literal|"assignment of read-only location"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"increment of read-only location"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"decrement of read-only location"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"read-only location used as %<asm%> output"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  USE says    how the lvalue is being used and so selects the error message.  */
end_comment

begin_function
specifier|static
name|int
name|lvalue_or_else
parameter_list|(
name|tree
name|ref
parameter_list|,
name|enum
name|lvalue_use
name|use
parameter_list|)
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|lvalue_error
argument_list|(
name|use
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Returns true if successful.  */
end_comment

begin_function
name|bool
name|c_mark_addressable
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|x
init|=
name|exp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot take address of bit-field %qD"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|ADDR_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|C_DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"global register variable %qD used in nested function"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|pedwarn
argument_list|(
literal|"register variable %qD used in nested function"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|C_DECL_REGISTER
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
name|error
argument_list|(
literal|"address of global register variable %qD requested"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"address of register variable %qD requested"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* drops in */
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* drops out */
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|tree
name|ifexp
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|)
block|{
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|,
name|orig_op2
init|=
name|op2
decl_stmt|;
comment|/* Promote both alternatives.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
comment|/* C90 does not permit non-lvalue arrays in conditional expressions.      In C99 they will be pointers by now.  */
if|if
condition|(
name|code1
operator|==
name|ARRAY_TYPE
operator|||
name|code2
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"non-lvalue array in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
else|else
name|result_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|c_common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
comment|/* If -Wsign-compare, warn here if type1 and type2 have 	 different signedness.  We'll promote the signed to unsigned 	 and later code won't know it used to be different. 	 Do this check on the original types, so that explicit casts 	 will be considered, but default promotions won't.  */
if|if
condition|(
name|warn_sign_compare
operator|&&
operator|!
name|skip_evaluation
condition|)
block|{
name|int
name|unsigned_op1
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsigned_op2
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|unsigned_op1
operator|^
name|unsigned_op2
condition|)
block|{
name|bool
name|ovf
decl_stmt|;
comment|/* Do not warn if the result type is signed, since the 		 signed type will only be chosen if it can represent 		 all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the signed quantity is an unsuffixed 		 integer literal (or some static constant expression 		 involving such literals) and it is non-negative.  */
elseif|else
if|if
condition|(
operator|(
name|unsigned_op2
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|op1
argument_list|,
operator|&
name|ovf
argument_list|)
operator|)
operator|||
operator|(
name|unsigned_op1
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|op2
argument_list|,
operator|&
name|ovf
argument_list|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"signed and unsigned type in conditional expression"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
name|result_type
operator|=
name|common_pointer_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|null_pointer_constant_p
argument_list|(
name|orig_op1
argument_list|)
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|null_pointer_constant_p
argument_list|(
name|orig_op2
argument_list|)
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conditional expr between "
literal|"%<void *%> and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|qualify_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conditional expr between "
literal|"%<void *%> and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|qualify_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|null_pointer_constant_p
argument_list|(
name|orig_op2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op2
operator|=
name|null_pointer_node
expr_stmt|;
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|null_pointer_constant_p
argument_list|(
name|orig_op1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
block|}
name|result_type
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Merge const and volatile flags of the incoming types.  */
name|result_type
operator|=
name|build_type_variant
argument_list|(
name|result_type
argument_list|,
name|TREE_READONLY
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|op2
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|)
expr_stmt|;
return|return
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a compound expression that performs two expressions and    returns the value of the second of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|tree
name|expr1
parameter_list|,
name|tree
name|expr2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr1
argument_list|)
condition|)
block|{
comment|/* The left-hand operand of a comma expression is like an expression 	 statement: with -Wextra or -Wunused, we should warn if it doesn't have 	 any side-effects, unless it was explicitly cast to (void).  */
if|if
condition|(
name|warn_unused_value
condition|)
block|{
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr1
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|expr1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
condition|)
empty_stmt|;
comment|/* (void) a, b */
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|expr1
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|)
condition|)
empty_stmt|;
comment|/* (void) a, (void) b, c */
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"left-hand operand of comma expression has no effect"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* With -Wunused, we should also warn if the left-hand operand does have      side-effects, but computes a value which is not used.  For example, in      `foo() + bar(), baz()' the result of the `+' operator is not used,      so we should issue a warning.  */
elseif|else
if|if
condition|(
name|warn_unused_value
condition|)
name|warn_if_unused_value
argument_list|(
name|expr1
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr2
argument_list|)
argument_list|,
name|expr1
argument_list|,
name|expr2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|value
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* The ObjC front-end uses TYPE_MAIN_VARIANT to tie together types differing      only in<protocol> qualifications.  But when constructing cast expressions,      the protocols do matter and must be kept around.  */
if|if
condition|(
name|objc_is_object_ptr
argument_list|(
name|type
argument_list|)
operator|&&
name|objc_is_object_ptr
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids casting nonscalar to the same type"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|field
condition|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids casts to union type"
argument_list|)
expr_stmt|;
name|t
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|build_constructor_single
argument_list|(
name|type
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_INVARIANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|error
argument_list|(
literal|"cast to union type from type not present in union"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|otype
decl_stmt|,
name|ovalue
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
return|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrisome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|in_type
init|=
name|type
decl_stmt|;
name|tree
name|in_otype
init|=
name|otype
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
name|int
name|discarded
init|=
literal|0
decl_stmt|;
comment|/* Check that the qualifiers on IN_TYPE are a superset of 	     the qualifiers of IN_OTYPE.  The outermost level of 	     POINTER_TYPE nodes is uninteresting and we stop as soon 	     as we hit a non-POINTER_TYPE node on either type.  */
do|do
block|{
name|in_otype
operator|=
name|TREE_TYPE
argument_list|(
name|in_otype
argument_list|)
expr_stmt|;
name|in_type
operator|=
name|TREE_TYPE
argument_list|(
name|in_type
argument_list|)
expr_stmt|;
comment|/* GNU C allows cv-qualified function types.  'const' 		 means the function is very pure, 'volatile' means it 		 can't return.  We need to warn when such qualifiers 		 are added, not when they're taken away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in_otype
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|in_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|added
operator||=
operator|(
name|TYPE_QUALS
argument_list|(
name|in_type
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|in_otype
argument_list|)
operator|)
expr_stmt|;
else|else
name|discarded
operator||=
operator|(
name|TYPE_QUALS
argument_list|(
name|in_otype
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|in_type
argument_list|)
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|in_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|in_otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
do|;
if|if
condition|(
name|added
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"cast adds new qualifiers to function type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|discarded
condition|)
comment|/* There are qualifiers present in IN_OTYPE that are not 	       present in IN_TYPE.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"cast discards qualifiers from pointer target type"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about possible alignment problems.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
comment|/* Don't warn about opaque types, where the actual alignment 	     restriction is unknown.  */
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wcast_align
argument_list|,
literal|"cast increases required alignment of target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
condition|)
comment|/* Unlike conversion of integers to pointers, where the          warning is disabled for converting constants because          of cases such as SIG_*, warn about converting constant          pointers to integers. In some cases it may cause unwanted          sign extension, and a warning is appropriate.  */
name|warning
argument_list|(
name|OPT_Wpointer_to_int_cast
argument_list|,
literal|"cast from pointer to integer of different size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wbad_function_cast
argument_list|,
literal|"cast from function call of type %qT "
literal|"to non-matching type %qT"
argument_list|,
name|otype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
comment|/* Don't warn about converting any constant.  */
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wint_to_pointer_cast
argument_list|,
literal|"cast to pointer from integer "
literal|"of different size"
argument_list|)
expr_stmt|;
name|strict_aliasing_warning
argument_list|(
name|otype
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* If pedantic, warn for conversions between function and object 	 pointer types, except for converting a null pointer constant 	 to function pointer type.  */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conversion of function pointer to object pointer type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|null_pointer_constant_p
argument_list|(
name|value
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conversion of object pointer to function pointer type"
argument_list|)
expr_stmt|;
name|ovalue
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|ovalue
argument_list|)
operator|&&
operator|(
name|TREE_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
operator|)
condition|)
block|{
comment|/* Avoid clobbering a shared constant.  */
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
comment|/* Reset VALUE's overflow flags, ensuring constant sharing.  */
name|value
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't let a cast be an lvalue.  */
if|if
condition|(
name|value
operator|==
name|expr
condition|)
name|value
operator|=
name|non_lvalue
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Interpret a cast of expression EXPR to type TYPE.  */
end_comment

begin_function
name|tree
name|c_cast_expr
parameter_list|(
name|struct
name|c_type_name
modifier|*
name|type_name
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|int
name|saved_wsp
init|=
name|warn_strict_prototypes
decl_stmt|;
comment|/* This avoids warnings about unprototyped casts on      integers.  E.g. "#define SIG_DFL (void(*)())0".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|warn_strict_prototypes
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|groktypename
argument_list|(
name|type_name
argument_list|)
expr_stmt|;
name|warn_strict_prototypes
operator|=
name|saved_wsp
expr_stmt|;
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|enum
name|tree_code
name|modifycode
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
name|lv_assign
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|STRIP_TYPE_NOPS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Give an error for storing in something that is 'const'.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
block|{
name|readonly_error
argument_list|(
name|lhs
argument_list|,
name|lv_assign
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower than one,      we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
comment|/* Convert new value to destination type.  */
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|ic_assign
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Emit ObjC write barrier, if necessary.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
name|flag_objc_gc
condition|)
block|{
name|result
operator|=
name|objc_generate_write_barrier
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
comment|/* Scan operands.  */
name|result
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
name|ic_assign
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE says whether it is argument passing, assignment,    initialization or return.     FUNCTION is a tree for the function being called.    PARMNUM is the number of the argument, for printing in error messages.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|enum
name|impl_conv
name|errtype
parameter_list|,
name|tree
name|fundecl
parameter_list|,
name|tree
name|function
parameter_list|,
name|int
name|parmnum
parameter_list|)
block|{
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|rhstype
decl_stmt|;
name|enum
name|tree_code
name|coder
decl_stmt|;
name|tree
name|rname
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|objc_ok
init|=
name|false
decl_stmt|;
if|if
condition|(
name|errtype
operator|==
name|ic_argpass
operator|||
name|errtype
operator|==
name|ic_argpass_nonproto
condition|)
block|{
name|tree
name|selector
decl_stmt|;
comment|/* Change pointer to function to the function itself for 	 diagnostics.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle an ObjC selector specially for diagnostics.  */
name|selector
operator|=
name|objc_message_selector
argument_list|()
expr_stmt|;
name|rname
operator|=
name|function
expr_stmt|;
if|if
condition|(
name|selector
operator|&&
name|parmnum
operator|>
literal|2
condition|)
block|{
name|rname
operator|=
name|selector
expr_stmt|;
name|parmnum
operator|-=
literal|2
expr_stmt|;
block|}
block|}
comment|/* This macro is used to emit diagnostics to ensure that all format      strings are complete sentences, visible to gettext and checked at      compile time.  */
define|#
directive|define
name|WARN_FOR_ASSIGNMENT
parameter_list|(
name|AR
parameter_list|,
name|AS
parameter_list|,
name|IN
parameter_list|,
name|RE
parameter_list|)
define|\
value|do {						\     switch (errtype)				\       {						\       case ic_argpass:				\ 	pedwarn (AR, parmnum, rname);		\ 	break;					\       case ic_argpass_nonproto:			\ 	warning (0, AR, parmnum, rname);		\ 	break;					\       case ic_assign:				\ 	pedwarn (AS);				\ 	break;					\       case ic_init:				\ 	pedwarn (IN);				\ 	break;					\       case ic_return:				\ 	pedwarn (RE);				\ 	break;					\       default:					\ 	gcc_unreachable ();			\       }						\   } while (0)
name|STRIP_TYPE_NOPS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|rhs
operator|=
name|decl_constant_value_for_broken_optimization
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
block|{
name|int
name|parmno
decl_stmt|;
switch|switch
condition|(
name|errtype
condition|)
block|{
case|case
name|ic_return
case|:
name|parmno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ic_assign
case|:
name|parmno
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ic_init
case|:
name|parmno
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
name|parmno
operator|=
name|parmnum
expr_stmt|;
break|break;
block|}
name|objc_ok
operator|=
name|objc_compare_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
name|parmno
argument_list|,
name|rname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
block|{
name|overflow_warning
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
comment|/* Except for passing an argument to an unprototyped function, 	 this is a constraint violation.  When passing an argument to 	 an unprototyped function, it is compile-time undefined; 	 making it a constraint in that case was rejected in 	 DR#252.  */
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* A type converts to a reference to it.      This code doesn't fully support references, it's just for the      special case of va_start and va_copy.  */
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot pass rvalue to reference parameter"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|rhs
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* We already know that these two types are compatible, but they 	 may not be exactly identical.  In fact, `TREE_TYPE (type)' is 	 likely to be __builtin_va_list and `TREE_TYPE (rhs)' is 	 likely to be va_list, a typedef to __builtin_va_list, which 	 is different enough that it will cause problems later.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|rhs
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
comment|/* Some types can interconvert without explicit casts.  */
elseif|else
if|if
condition|(
name|codel
operator|==
name|VECTOR_TYPE
operator|&&
name|coder
operator|==
name|VECTOR_TYPE
operator|&&
name|vector_types_convertible_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* Arithmetic types all interconvert, and enum is treated like int.  */
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|||
name|codel
operator|==
name|ENUMERAL_TYPE
operator|||
name|codel
operator|==
name|COMPLEX_TYPE
operator|||
name|codel
operator|==
name|BOOLEAN_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
operator|||
name|coder
operator|==
name|COMPLEX_TYPE
operator|||
name|coder
operator|==
name|BOOLEAN_TYPE
operator|)
condition|)
return|return
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* Aggregates in different TUs might need conversion.  */
if|if
condition|(
operator|(
name|codel
operator|==
name|RECORD_TYPE
operator|||
name|codel
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|codel
operator|==
name|coder
operator|&&
name|comptypes
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
condition|)
return|return
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* Conversion to a transparent union from its member types.      This applies only to function arguments.  */
if|if
condition|(
name|codel
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|errtype
operator|==
name|ic_argpass
operator|||
name|errtype
operator|==
name|ic_argpass_nonproto
operator|)
condition|)
block|{
name|tree
name|memb
decl_stmt|,
name|marginal_memb
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
block|{
name|tree
name|memb_type
init|=
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
decl_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|memb_type
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|memb_type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
continue|continue;
if|if
condition|(
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|memb_type
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Any non-function converts to a [const][volatile] void * 		 and vice versa; otherwise, targets must be the same. 		 Meanwhile, the lhs target must have all the qualifiers of 		 the rhs.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|||
name|comp_target_types
argument_list|(
name|memb_type
argument_list|,
name|rhstype
argument_list|)
condition|)
block|{
comment|/* If this type won't generate any warnings, use it.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|?
operator|(
operator|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
else|:
operator|(
operator|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* Keep looking for a better type, but remember this one.  */
if|if
condition|(
operator|!
name|marginal_memb
condition|)
name|marginal_memb
operator|=
name|memb
expr_stmt|;
block|}
block|}
comment|/* Can convert integer zero to any pointer type.  */
if|if
condition|(
name|null_pointer_constant_p
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|rhs
operator|=
name|null_pointer_node
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|memb
operator|||
name|marginal_memb
condition|)
block|{
if|if
condition|(
operator|!
name|memb
condition|)
block|{
comment|/* We have only a marginally acceptable member type; 		 it needs a warning.  */
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|marginal_memb
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Const and volatile mean something different for function 		 types, so the usual warnings are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Because const and volatile on functions are 		     restrictions that say the function will not do 		     certain things, it is okay to use a const or volatile 		     function where an ordinary one is wanted, but not 		     vice-versa.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"passing argument %d of %qE "
literal|"makes qualified function "
literal|"pointer from unqualified"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"assignment makes qualified "
literal|"function pointer from "
literal|"unqualified"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"initialization makes qualified "
literal|"function pointer from "
literal|"unqualified"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"return makes qualified function "
literal|"pointer from unqualified"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"passing argument %d of %qE discards "
literal|"qualifiers from pointer target type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"assignment discards qualifiers "
literal|"from pointer target type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"initialization discards qualifiers "
literal|"from pointer target type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"return discards qualifiers from "
literal|"pointer target type"
argument_list|)
argument_list|)
expr_stmt|;
name|memb
operator|=
name|marginal_memb
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|!
name|fundecl
operator|||
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|fundecl
argument_list|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C prohibits argument conversion to union type"
argument_list|)
expr_stmt|;
return|return
name|build_constructor_single
argument_list|(
name|type
argument_list|,
name|memb
argument_list|,
name|rhs
argument_list|)
return|;
block|}
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|POINTER_TYPE
operator|||
name|codel
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|codel
operator|)
condition|)
block|{
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
name|tree
name|mvl
init|=
name|ttl
decl_stmt|;
name|tree
name|mvr
init|=
name|ttr
decl_stmt|;
name|bool
name|is_opaque_pointer
decl_stmt|;
name|int
name|target_cmp
init|=
literal|0
decl_stmt|;
comment|/* Cache comp_target_types () result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mvl
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mvl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mvr
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|mvr
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|mvr
argument_list|)
expr_stmt|;
comment|/* Opaque pointers are treated like void pointers.  */
name|is_opaque_pointer
operator|=
operator|(
name|targetm
operator|.
name|vector_opaque_p
argument_list|(
name|type
argument_list|)
operator|||
name|targetm
operator|.
name|vector_opaque_p
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|VECTOR_TYPE
expr_stmt|;
comment|/* C++ does not allow the implicit conversion void* -> T*.  However, 	 for the purpose of reducing the number of false positives, we 	 tolerate the special case of  		int *p = NULL;  	 where NULL is typically defined in C to be '(void *) 0'.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|&&
name|rhs
operator|!=
name|null_pointer_node
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wc___compat
argument_list|,
literal|"request for implicit conversion from "
literal|"%qT to %qT not permitted in C++"
argument_list|,
name|rhstype
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Check if the right-hand side has a format attribute but the 	 left-hand side doesn't.  */
if|if
condition|(
name|warn_missing_format_attribute
operator|&&
name|check_missing_format_attribute
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|errtype
condition|)
block|{
case|case
name|ic_argpass
case|:
case|case
name|ic_argpass_nonproto
case|:
name|warning
argument_list|(
name|OPT_Wmissing_format_attribute
argument_list|,
literal|"argument %d of %qE might be "
literal|"a candidate for a format attribute"
argument_list|,
name|parmnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
break|break;
case|case
name|ic_assign
case|:
name|warning
argument_list|(
name|OPT_Wmissing_format_attribute
argument_list|,
literal|"assignment left-hand side might be "
literal|"a candidate for a format attribute"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ic_init
case|:
name|warning
argument_list|(
name|OPT_Wmissing_format_attribute
argument_list|,
literal|"initialization left-hand side might be "
literal|"a candidate for a format attribute"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ic_return
case|:
name|warning
argument_list|(
name|OPT_Wmissing_format_attribute
argument_list|,
literal|"return type might be "
literal|"a candidate for a format attribute"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|||
operator|(
name|target_cmp
operator|=
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
operator|)
operator|||
name|is_opaque_pointer
operator|||
operator|(
name|c_common_unsigned_type
argument_list|(
name|mvl
argument_list|)
operator|==
name|c_common_unsigned_type
argument_list|(
name|mvr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|&&
operator|!
name|null_pointer_constant_p
argument_list|(
name|rhs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"ISO C forbids passing argument %d of "
literal|"%qE between function pointer "
literal|"and %<void *%>"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"ISO C forbids assignment between "
literal|"function pointer and %<void *%>"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"ISO C forbids initialization between "
literal|"function pointer and %<void *%>"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"ISO C forbids return between function "
literal|"pointer and %<void *%>"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Const and volatile mean something different for function types, 	     so the usual warnings are not appropriate.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
condition|)
block|{
comment|/* Types differing only by the presence of the 'volatile' 		     qualifier are acceptable if the 'volatile' has been added 		     in by the Objective-C EH machinery.  */
if|if
condition|(
operator|!
name|objc_type_quals_match
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"passing argument %d of %qE discards "
literal|"qualifiers from pointer target type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"assignment discards qualifiers "
literal|"from pointer target type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"initialization discards qualifiers "
literal|"from pointer target type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"return discards qualifiers from "
literal|"pointer target type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is not a case of ignoring a mismatch in signedness, 		 no warning.  */
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|||
name|target_cmp
condition|)
empty_stmt|;
comment|/* If there is a mismatch, do warn.  */
elseif|else
if|if
condition|(
name|warn_pointer_sign
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"pointer targets in passing argument "
literal|"%d of %qE differ in signedness"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"pointer targets in assignment "
literal|"differ in signedness"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"pointer targets in initialization "
literal|"differ in signedness"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"pointer targets in return differ "
literal|"in signedness"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Because const and volatile on functions are restrictions 		 that say the function will not do certain things, 		 it is okay to use a const or volatile function 		 where an ordinary one is wanted, but not vice-versa.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"passing argument %d of %qE makes "
literal|"qualified function pointer "
literal|"from unqualified"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"assignment makes qualified function "
literal|"pointer from unqualified"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"initialization makes qualified "
literal|"function pointer from unqualified"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"return makes qualified function "
literal|"pointer from unqualified"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* Avoid warning about the volatile ObjC EH puts on decls.  */
if|if
condition|(
operator|!
name|objc_ok
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"passing argument %d of %qE from "
literal|"incompatible pointer type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"assignment from incompatible pointer type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"initialization from incompatible "
literal|"pointer type"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"return from incompatible pointer type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* ??? This should not be an error when inlining calls to 	 unprototyped functions.  */
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* An explicit constant 0 can convert to a pointer, 	 or one that results from arithmetic, even including 	 a cast to integer type.  */
if|if
condition|(
operator|!
name|null_pointer_constant_p
argument_list|(
name|rhs
argument_list|)
condition|)
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"passing argument %d of %qE makes "
literal|"pointer from integer without a cast"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"assignment makes pointer from integer "
literal|"without a cast"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"initialization makes pointer from "
literal|"integer without a cast"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"return makes pointer from integer "
literal|"without a cast"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|INTEGER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|WARN_FOR_ASSIGNMENT
argument_list|(
name|G_
argument_list|(
literal|"passing argument %d of %qE makes integer "
literal|"from pointer without a cast"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"assignment makes integer from pointer "
literal|"without a cast"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"initialization makes integer from pointer "
literal|"without a cast"
argument_list|)
argument_list|,
name|G_
argument_list|(
literal|"return makes integer from pointer "
literal|"without a cast"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|BOOLEAN_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
switch|switch
condition|(
name|errtype
condition|)
block|{
case|case
name|ic_argpass
case|:
case|case
name|ic_argpass_nonproto
case|:
comment|/* ??? This should not be an error when inlining calls to 	 unprototyped functions.  */
name|error
argument_list|(
literal|"incompatible type for argument %d of %qE"
argument_list|,
name|parmnum
argument_list|,
name|rname
argument_list|)
expr_stmt|;
break|break;
case|case
name|ic_assign
case|:
name|error
argument_list|(
literal|"incompatible types in assignment"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ic_init
case|:
name|error
argument_list|(
literal|"incompatible types in initialization"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ic_return
case|:
name|error
argument_list|(
literal|"incompatible types in return"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Convert VALUE for assignment into inlined parameter PARM.  ARGNUM    is used for error and warning reporting and indicates which argument    is being processed.  */
end_comment

begin_function
name|tree
name|c_convert_parm_for_inlining
parameter_list|(
name|tree
name|parm
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|fn
parameter_list|,
name|int
name|argnum
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|,
name|type
decl_stmt|;
comment|/* If FN was prototyped at the call site, the value has been converted      already in convert_arguments.      However, we might see a prototype now that was not in place when      the function call was seen, so check that the VALUE actually matches      PARM before taking an early exit.  */
if|if
condition|(
operator|!
name|value
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|value
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|ic_argpass_nonproto
argument_list|,
name|fn
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|ret
operator|=
name|default_conversion
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If VALUE is a compound expr all of whose expressions are constant, then    return its value.  Otherwise, return error_mark_node.     This is for handling COMPOUND_EXPRs as initializer elements    which is allowed with a warning when -pedantic is specified.  */
end_comment

begin_function
specifier|static
name|tree
name|valid_compound_expr_initializer
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|endtype
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
if|if
condition|(
name|valid_compound_expr_initializer
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|valid_compound_expr_initializer
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|endtype
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.  */
end_comment

begin_function
name|void
name|store_init_value
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|true
argument_list|,
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the expression if valid; else report error.  */
if|if
condition|(
operator|!
name|in_system_header
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"traditional C rejects automatic "
literal|"aggregate initialization"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
comment|/* ANSI wants warnings about out-of-range constant initializers.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Check if we need to set array size from compound literal size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|inside_init
init|=
name|init
decl_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|fold
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
condition|)
block|{
name|tree
name|cldecl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|inside_init
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|cldecl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For int foo[] = (int [3]){1}; we need to set array size 		 now since later on array initializer will be just the 		 brace enclosed list of the compound literal.  */
name|type
operator|=
name|build_distinct_type_copy
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|cldecl
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|cldecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Methods for storing and printing names for error messages.  */
end_comment

begin_comment
comment|/* Implement a spelling stack that allows components of a name to be pushed    and popped.  Each element on the stack is this structure.  */
end_comment

begin_struct
struct|struct
name|spelling
block|{
name|int
name|kind
decl_stmt|;
union|union
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SPELLING_STRING
value|1
end_define

begin_define
define|#
directive|define
name|SPELLING_MEMBER
value|2
end_define

begin_define
define|#
directive|define
name|SPELLING_BOUNDS
value|3
end_define

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next stack element (unused).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spelling stack base.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spelling_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the spelling stack.  */
end_comment

begin_comment
comment|/* Macros to save and restore the spelling stack around push_... functions.    Alternative to SAVE_SPELLING_STACK.  */
end_comment

begin_define
define|#
directive|define
name|SPELLING_DEPTH
parameter_list|()
value|(spelling - spelling_base)
end_define

begin_define
define|#
directive|define
name|RESTORE_SPELLING_DEPTH
parameter_list|(
name|DEPTH
parameter_list|)
value|(spelling = spelling_base + (DEPTH))
end_define

begin_comment
comment|/* Push an element on the spelling stack with type KIND and assign VALUE    to MEMBER.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_SPELLING
parameter_list|(
name|KIND
parameter_list|,
name|VALUE
parameter_list|,
name|MEMBER
parameter_list|)
define|\
value|{									\   int depth = SPELLING_DEPTH ();					\ 									\   if (depth>= spelling_size)						\     {									\       spelling_size += 10;						\       spelling_base = XRESIZEVEC (struct spelling, spelling_base,	\ 				  spelling_size);			\       RESTORE_SPELLING_DEPTH (depth);					\     }									\ 									\   spelling->kind = (KIND);						\   spelling->MEMBER = (VALUE);						\   spelling++;								\ }
end_define

begin_comment
comment|/* Push STRING on the stack.  Printed literally.  */
end_comment

begin_function
specifier|static
name|void
name|push_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_STRING
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a member name on the stack.  Printed as '.' STRING.  */
end_comment

begin_function
specifier|static
name|void
name|push_member_name
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|string
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
literal|"<anonymous>"
decl_stmt|;
name|PUSH_SPELLING
argument_list|(
name|SPELLING_MEMBER
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an array bounds on the stack.  Printed as [BOUNDS].  */
end_comment

begin_function
specifier|static
name|void
name|push_array_bounds
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|bounds
parameter_list|)
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_BOUNDS
argument_list|,
name|bounds
argument_list|,
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the maximum size in bytes of the printed spelling.  */
end_comment

begin_function
specifier|static
name|int
name|spelling_length
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
name|size
operator|+=
literal|25
expr_stmt|;
else|else
name|size
operator|+=
name|strlen
argument_list|(
name|p
operator|->
name|u
operator|.
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Print the spelling to BUFFER and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|print_spelling
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|d
init|=
name|buffer
decl_stmt|;
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"["
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"]"
argument_list|,
name|p
operator|->
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
name|d
operator|+=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_MEMBER
condition|)
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p
operator|->
name|u
operator|.
name|s
init|;
operator|(
operator|*
name|d
operator|=
operator|*
name|s
operator|++
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Issue an error message for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
name|void
name|error_init
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|)
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|error
argument_list|(
literal|"(near initialization for %qs)"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a pedantic warning for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
name|void
name|pedwarn_init
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|)
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|pedwarn
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|pedwarn
argument_list|(
literal|"(near initialization for %qs)"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a warning for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
specifier|static
name|void
name|warning_init
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|)
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"(near initialization for %qs)"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If TYPE is an array type and EXPR is a parenthesized string    constant, warn if pedantic that EXPR is being used to initialize an    object of type TYPE.  */
end_comment

begin_function
name|void
name|maybe_warn_string_init
parameter_list|(
name|tree
name|type
parameter_list|,
name|struct
name|c_expr
name|expr
parameter_list|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|expr
operator|.
name|original_code
operator|!=
name|STRING_CST
condition|)
name|pedwarn_init
argument_list|(
literal|"array initialized from parenthesized string constant"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Digest the parser output INIT as an initializer for type TYPE.    Return a C expression of type TYPE to represent the initial value.     If INIT is a string constant, STRICT_STRING is true if it is    unparenthesized or we should not warn here for it being parenthesized.    For other types of INIT, STRICT_STRING is not used.     REQUIRE_CONSTANT requests an error if non-constant initializers or    elements are seen.  */
end_comment

begin_function
specifier|static
name|tree
name|digest_init
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|strict_string
parameter_list|,
name|int
name|require_constant
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|inside_init
init|=
name|init
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|init
operator|||
name|init
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|STRIP_TYPE_NOPS
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|fold
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
comment|/* Initialization of an array of chars from a string constant      optionally enclosed in braces.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|inside_init
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|tree
name|typ1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Note that an array could be both an array of character type 	 and an array of wchar_t if wchar_t is signed char or unsigned 	 char.  */
name|bool
name|char_array
init|=
operator|(
name|typ1
operator|==
name|char_type_node
operator|||
name|typ1
operator|==
name|signed_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_char_type_node
operator|)
decl_stmt|;
name|bool
name|wchar_array
init|=
operator|!
operator|!
name|comptypes
argument_list|(
name|typ1
argument_list|,
name|wchar_type_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|char_array
operator|||
name|wchar_array
condition|)
block|{
name|struct
name|c_expr
name|expr
decl_stmt|;
name|bool
name|char_string
decl_stmt|;
name|expr
operator|.
name|value
operator|=
name|inside_init
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
operator|(
name|strict_string
condition|?
name|STRING_CST
else|:
name|ERROR_MARK
operator|)
expr_stmt|;
name|maybe_warn_string_init
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|char_string
operator|=
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
expr_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|inside_init
return|;
if|if
condition|(
operator|!
name|wchar_array
operator|&&
operator|!
name|char_string
condition|)
block|{
name|error_init
argument_list|(
literal|"char-array initialized from wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|char_string
operator|&&
operator|!
name|char_array
condition|)
block|{
name|error_init
argument_list|(
literal|"wchar_t-array initialized from non-wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* Subtract 1 (or sizeof (wchar_t)) 		 because it's ok to ignore the terminating null char 		 that is counted in the length of the constant.  */
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|inside_init
argument_list|)
operator|-
operator|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|)
condition|?
operator|(
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
else|:
literal|1
operator|)
argument_list|)
condition|)
name|pedwarn_init
argument_list|(
literal|"initializer-string for array of chars is too long"
argument_list|)
expr_stmt|;
return|return
name|inside_init
return|;
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|typ1
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"array of inappropriate type initialized "
literal|"from string constant"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Build a VECTOR_CST from a *constant* vector constructor.  If the      vector constructor is not constant (e.g. {1,2,3,foo()}) then punt      below and handle as a constructor.  */
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|vector_types_convertible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|inside_init
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|bool
name|constant_p
init|=
name|true
decl_stmt|;
comment|/* Iterate through elements and check if all constructor 	     elements are *_CSTs.  */
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (inside_init)
argument_list|,
argument|ix
argument_list|,
argument|value
argument_list|)
if|if
condition|(
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|constant_p
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|constant_p
condition|)
return|return
name|build_vector_from_ctor
argument_list|(
name|type
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|inside_init
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Any type can be initialized      from an expression of the same type, optionally with braces.  */
if|if
condition|(
name|inside_init
operator|&&
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|VECTOR_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
condition|)
name|inside_init
operator|=
name|array_to_pointer_conversion
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
else|else
block|{
name|error_init
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
condition|)
comment|/* Although the types are compatible, we may require a 	   conversion.  */
name|inside_init
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|inside_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_constant
operator|&&
operator|(
name|code
operator|==
name|VECTOR_TYPE
operator|||
operator|!
name|flag_isoc99
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
condition|)
block|{
comment|/* As an extension, allow initializing objects with static storage 	     duration with compound literals (which are then treated just as 	     the brace enclosed list they contain).  Also allow this for 	     vectors, as we can only assign them with compound literals.  */
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|inside_init
argument_list|)
decl_stmt|;
name|inside_init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|!=
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
block|{
name|error_init
argument_list|(
literal|"array initialized from non-constant array expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|inside_init
operator|=
name|decl_constant_value_for_broken_optimization
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
comment|/* Compound expressions can only occur here if -pedantic or 	 -pedantic-errors is specified.  In the later case, we always want 	 an error.  In the former case, we simply want a warning.  */
if|if
condition|(
name|require_constant
operator|&&
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|inside_init
operator|=
name|valid_compound_expr_initializer
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside_init
operator|==
name|error_mark_node
condition|)
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
else|else
name|pedwarn_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Added to enable additional -Wmissing-format-attribute warnings.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|inside_init
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|inside_init
argument_list|,
name|ic_init
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|inside_init
return|;
block|}
comment|/* Handle scalar types, including conversions.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|BOOLEAN_TYPE
operator|||
name|code
operator|==
name|COMPLEX_TYPE
operator|||
name|code
operator|==
name|VECTOR_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
operator|)
condition|)
name|init
operator|=
name|array_to_pointer_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|ic_init
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see if we have already given an error message.  */
if|if
condition|(
name|inside_init
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not computable at load time"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
comment|/* Come here only for records and arrays.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_init
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|error_init
argument_list|(
literal|"invalid initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle initializers that use braces.  */
end_comment

begin_comment
comment|/* Type of object we are accumulating a constructor for.    This type is always a RECORD_TYPE, UNION_TYPE or ARRAY_TYPE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For a RECORD_TYPE or UNION_TYPE, this is the chain of fields    left to fill.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_fields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the specified index    at which to store the next element we get.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the maximum index.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_max_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For a RECORD_TYPE, this is the first field not yet written out.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_unfilled_fields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the index of the first element    not yet written out.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_unfilled_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a RECORD_TYPE, the byte index of the next consecutive field.    This is so we can generate gaps between fields, when appropriate.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_bit_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are saving up the elements rather than allocating them,    this is the list of elements so far (in reverse order,    most recent first).  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|constructor_elements
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 1 if constructor should be incrementally stored into a constructor chain,    0 if all the elements should be kept in AVL tree.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_incremental
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if so far this constructor's elements are all compile-time constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if so far this constructor's elements are all valid address constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_simple
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if this constructor is erroneous so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_erroneous
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for managing pending initializer elements, organized as an    AVL tree.  */
end_comment

begin_struct
struct|struct
name|init_node
block|{
name|struct
name|init_node
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|struct
name|init_node
modifier|*
name|parent
decl_stmt|;
name|int
name|balance
decl_stmt|;
name|tree
name|purpose
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Tree of pending elements at this constructor level.    These are elements encountered out of order    which belong at places we haven't reached yet in actually    writing the output.    Will never hold tree nodes across GC runs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|init_node
modifier|*
name|constructor_pending_elts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The SPELLING_DEPTH of this constructor.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DECL node for which an initializer is being read.    0 means we are reading a constructor expression    such as (struct foo) {...}.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this is an initializer for a top-level decl.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_top_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there were any member designators in this initializer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_designated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nesting depth of designator list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|designator_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there were diagnosed errors in this designator list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|designator_erroneous
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This stack has a level for each implicit or explicit level of    structuring in the initializer, including the outermost one.  It    saves the values of most of the variables above.  */
end_comment

begin_struct_decl
struct_decl|struct
name|constructor_range_stack
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|constructor_stack
block|{
name|struct
name|constructor_stack
modifier|*
name|next
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|max_index
decl_stmt|;
name|tree
name|unfilled_index
decl_stmt|;
name|tree
name|unfilled_fields
decl_stmt|;
name|tree
name|bit_index
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|elements
expr_stmt|;
name|struct
name|init_node
modifier|*
name|pending_elts
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* If value nonzero, this value should replace the entire      constructor at this level.  */
name|struct
name|c_expr
name|replacement_value
decl_stmt|;
name|struct
name|constructor_range_stack
modifier|*
name|range_stack
decl_stmt|;
name|char
name|constant
decl_stmt|;
name|char
name|simple
decl_stmt|;
name|char
name|implicit
decl_stmt|;
name|char
name|erroneous
decl_stmt|;
name|char
name|outer
decl_stmt|;
name|char
name|incremental
decl_stmt|;
name|char
name|designated
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|constructor_stack
modifier|*
name|constructor_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This stack represents designators from some range designator up to    the last designator in the list.  */
end_comment

begin_struct
struct|struct
name|constructor_range_stack
block|{
name|struct
name|constructor_range_stack
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|constructor_stack
modifier|*
name|stack
decl_stmt|;
name|tree
name|range_start
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|range_end
decl_stmt|;
name|tree
name|fields
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|constructor_range_stack
modifier|*
name|constructor_range_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This stack records separate initializers that are nested.    Nested initializers can't happen in ANSI C, but GNU C allows them    in cases like { ... (struct foo) { ... } ... }.  */
end_comment

begin_struct
struct|struct
name|initializer_stack
block|{
name|struct
name|initializer_stack
modifier|*
name|next
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|struct
name|constructor_stack
modifier|*
name|constructor_stack
decl_stmt|;
name|struct
name|constructor_range_stack
modifier|*
name|constructor_range_stack
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|elements
expr_stmt|;
name|struct
name|spelling
modifier|*
name|spelling
decl_stmt|;
name|struct
name|spelling
modifier|*
name|spelling_base
decl_stmt|;
name|int
name|spelling_size
decl_stmt|;
name|char
name|top_level
decl_stmt|;
name|char
name|require_constant_value
decl_stmt|;
name|char
name|require_constant_elements
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|initializer_stack
modifier|*
name|initializer_stack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Prepare to parse and output the initializer for variable DECL.  */
end_comment

begin_function
name|void
name|start_init
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|asmspec_tree
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|top_level
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|locus
decl_stmt|;
name|struct
name|initializer_stack
modifier|*
name|p
init|=
name|XNEW
argument_list|(
expr|struct
name|initializer_stack
argument_list|)
decl_stmt|;
name|p
operator|->
name|decl
operator|=
name|constructor_decl
expr_stmt|;
name|p
operator|->
name|require_constant_value
operator|=
name|require_constant_value
expr_stmt|;
name|p
operator|->
name|require_constant_elements
operator|=
name|require_constant_elements
expr_stmt|;
name|p
operator|->
name|constructor_stack
operator|=
name|constructor_stack
expr_stmt|;
name|p
operator|->
name|constructor_range_stack
operator|=
name|constructor_range_stack
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|spelling
operator|=
name|spelling
expr_stmt|;
name|p
operator|->
name|spelling_base
operator|=
name|spelling_base
expr_stmt|;
name|p
operator|->
name|spelling_size
operator|=
name|spelling_size
expr_stmt|;
name|p
operator|->
name|top_level
operator|=
name|constructor_top_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|initializer_stack
expr_stmt|;
name|initializer_stack
operator|=
name|p
expr_stmt|;
name|constructor_decl
operator|=
name|decl
expr_stmt|;
name|constructor_designated
operator|=
literal|0
expr_stmt|;
name|constructor_top_level
operator|=
name|top_level
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
literal|0
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
block|{
name|require_constant_value
operator|=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|require_constant_elements
operator|=
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|)
operator|)
comment|/* For a scalar, you can always use any value to initialize, 	      even within braces.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|)
expr_stmt|;
name|locus
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|require_constant_value
operator|=
literal|0
expr_stmt|;
name|require_constant_elements
operator|=
literal|0
expr_stmt|;
name|locus
operator|=
literal|"(anonymous)"
expr_stmt|;
block|}
name|constructor_stack
operator|=
literal|0
expr_stmt|;
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
name|missing_braces_mentioned
operator|=
literal|0
expr_stmt|;
name|spelling_base
operator|=
literal|0
expr_stmt|;
name|spelling_size
operator|=
literal|0
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locus
condition|)
name|push_string
argument_list|(
name|locus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|initializer_stack
modifier|*
name|p
init|=
name|initializer_stack
decl_stmt|;
comment|/* Free the whole constructor stack of this initializer.  */
while|while
condition|(
name|constructor_stack
condition|)
block|{
name|struct
name|constructor_stack
modifier|*
name|q
init|=
name|constructor_stack
decl_stmt|;
name|constructor_stack
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|constructor_range_stack
argument_list|)
expr_stmt|;
comment|/* Pop back to the data of the outer initializer (if any).  */
name|free
argument_list|(
name|spelling_base
argument_list|)
expr_stmt|;
name|constructor_decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
name|require_constant_value
operator|=
name|p
operator|->
name|require_constant_value
expr_stmt|;
name|require_constant_elements
operator|=
name|p
operator|->
name|require_constant_elements
expr_stmt|;
name|constructor_stack
operator|=
name|p
operator|->
name|constructor_stack
expr_stmt|;
name|constructor_range_stack
operator|=
name|p
operator|->
name|constructor_range_stack
expr_stmt|;
name|constructor_elements
operator|=
name|p
operator|->
name|elements
expr_stmt|;
name|spelling
operator|=
name|p
operator|->
name|spelling
expr_stmt|;
name|spelling_base
operator|=
name|p
operator|->
name|spelling_base
expr_stmt|;
name|spelling_size
operator|=
name|p
operator|->
name|spelling_size
expr_stmt|;
name|constructor_top_level
operator|=
name|p
operator|->
name|top_level
expr_stmt|;
name|initializer_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call here when we see the initializer is surrounded by braces.    This is instead of a call to push_init_level;    it is matched by a call to pop_init_level.     TYPE is the type to initialize, for a constructor expression.    For an initializer for a decl, TYPE is zero.  */
end_comment

begin_function
name|void
name|really_start_incremental_init
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|struct
name|constructor_stack
modifier|*
name|p
init|=
name|XNEW
argument_list|(
expr|struct
name|constructor_stack
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|vector_opaque_p
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"opaque vector types cannot be initialized"
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|constructor_type
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|max_index
operator|=
name|constructor_max_index
expr_stmt|;
name|p
operator|->
name|unfilled_index
operator|=
name|constructor_unfilled_index
expr_stmt|;
name|p
operator|->
name|unfilled_fields
operator|=
name|constructor_unfilled_fields
expr_stmt|;
name|p
operator|->
name|bit_index
operator|=
name|constructor_bit_index
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constructor_constant
expr_stmt|;
name|p
operator|->
name|simple
operator|=
name|constructor_simple
expr_stmt|;
name|p
operator|->
name|erroneous
operator|=
name|constructor_erroneous
expr_stmt|;
name|p
operator|->
name|pending_elts
operator|=
name|constructor_pending_elts
expr_stmt|;
name|p
operator|->
name|depth
operator|=
name|constructor_depth
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|p
operator|->
name|implicit
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|range_stack
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|outer
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|incremental
operator|=
name|constructor_incremental
expr_stmt|;
name|p
operator|->
name|designated
operator|=
name|constructor_designated
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|constructor_stack
operator|=
name|p
expr_stmt|;
name|constructor_constant
operator|=
literal|1
expr_stmt|;
name|constructor_simple
operator|=
literal|1
expr_stmt|;
name|constructor_depth
operator|=
name|SPELLING_DEPTH
argument_list|()
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
name|constructor_pending_elts
operator|=
literal|0
expr_stmt|;
name|constructor_type
operator|=
name|type
expr_stmt|;
name|constructor_incremental
operator|=
literal|1
expr_stmt|;
name|constructor_designated
operator|=
literal|0
expr_stmt|;
name|designator_depth
operator|=
literal|0
expr_stmt|;
name|designator_erroneous
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|constructor_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
name|constructor_max_index
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect non-empty initializations of zero-length arrays.  */
if|if
condition|(
name|constructor_max_index
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|constructor_max_index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* constructor_max_index needs to be an INTEGER_CST.  Attempts 	     to initialize VLAs will cause a proper error; avoid tree 	     checking errors as well by setting a safe value.  */
if|if
condition|(
name|constructor_max_index
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_max_index
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|constructor_max_index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constructor_index
operator|=
name|bitsize_zero_node
expr_stmt|;
name|constructor_max_index
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* Vectors are like simple fixed-size arrays.  */
name|constructor_max_index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|constructor_type
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|bitsize_zero_node
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle the case of int x = {5}; */
name|constructor_fields
operator|=
name|constructor_type
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_type
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push down into a subobject, for initialization.    If this is for an explicit set of braces, IMPLICIT is 0.    If it is because the next element belongs at a lower level,    IMPLICIT is 1 (or 2 if the push is because of designator list).  */
end_comment

begin_function
name|void
name|push_init_level
parameter_list|(
name|int
name|implicit
parameter_list|)
block|{
name|struct
name|constructor_stack
modifier|*
name|p
decl_stmt|;
name|tree
name|value
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If we've exhausted any levels that didn't have braces,      pop them now.  If implicit == 1, this will have been done in      process_init_element; do not repeat it here because in the case      of excess initializers for an empty aggregate this leads to an      infinite cycle of popping a level and immediately recreating      it.  */
if|if
condition|(
name|implicit
operator|!=
literal|1
condition|)
block|{
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
operator|==
literal|0
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|constructor_max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* Unless this is an explicit brace, we need to preserve previous      content if any.  */
if|if
condition|(
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
condition|)
name|value
operator|=
name|find_init_member
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|value
operator|=
name|find_init_member
argument_list|(
name|constructor_index
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|XNEW
argument_list|(
expr|struct
name|constructor_stack
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|constructor_type
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|max_index
operator|=
name|constructor_max_index
expr_stmt|;
name|p
operator|->
name|unfilled_index
operator|=
name|constructor_unfilled_index
expr_stmt|;
name|p
operator|->
name|unfilled_fields
operator|=
name|constructor_unfilled_fields
expr_stmt|;
name|p
operator|->
name|bit_index
operator|=
name|constructor_bit_index
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constructor_constant
expr_stmt|;
name|p
operator|->
name|simple
operator|=
name|constructor_simple
expr_stmt|;
name|p
operator|->
name|erroneous
operator|=
name|constructor_erroneous
expr_stmt|;
name|p
operator|->
name|pending_elts
operator|=
name|constructor_pending_elts
expr_stmt|;
name|p
operator|->
name|depth
operator|=
name|constructor_depth
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|p
operator|->
name|implicit
operator|=
name|implicit
expr_stmt|;
name|p
operator|->
name|outer
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|incremental
operator|=
name|constructor_incremental
expr_stmt|;
name|p
operator|->
name|designated
operator|=
name|constructor_designated
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|constructor_stack
expr_stmt|;
name|p
operator|->
name|range_stack
operator|=
literal|0
expr_stmt|;
name|constructor_stack
operator|=
name|p
expr_stmt|;
name|constructor_constant
operator|=
literal|1
expr_stmt|;
name|constructor_simple
operator|=
literal|1
expr_stmt|;
name|constructor_depth
operator|=
name|SPELLING_DEPTH
argument_list|()
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
name|constructor_incremental
operator|=
literal|1
expr_stmt|;
name|constructor_designated
operator|=
literal|0
expr_stmt|;
name|constructor_pending_elts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|implicit
condition|)
block|{
name|p
operator|->
name|range_stack
operator|=
name|constructor_range_stack
expr_stmt|;
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
name|designator_depth
operator|=
literal|0
expr_stmt|;
name|designator_erroneous
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't die if an entire brace-pair level is superfluous      in the containing level.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* Don't die if there are extra init elts at the end.  */
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
name|constructor_type
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|constructor_type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_depth
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|constructor_type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|push_array_bounds
argument_list|(
name|tree_low_cst
argument_list|(
name|constructor_index
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_depth
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"extra brace group at end of initializer"
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
literal|0
expr_stmt|;
name|constructor_unfilled_fields
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|constructor_constant
operator|=
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constructor_simple
operator|=
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constructor_elements
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|implicit
operator|==
literal|1
operator|&&
name|warn_missing_braces
operator|&&
operator|!
name|missing_braces_mentioned
condition|)
block|{
name|missing_braces_mentioned
operator|=
literal|1
expr_stmt|;
name|warning_init
argument_list|(
literal|"missing braces around initializer"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|constructor_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* Vectors are like simple fixed-size arrays.  */
name|constructor_max_index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|constructor_type
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
name|constructor_max_index
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect non-empty initializations of zero-length arrays.  */
if|if
condition|(
name|constructor_max_index
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|constructor_max_index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* constructor_max_index needs to be an INTEGER_CST.  Attempts 	     to initialize VLAs will cause a proper error; avoid tree 	     checking errors as well by setting a safe value.  */
if|if
condition|(
name|constructor_max_index
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_max_index
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|constructor_max_index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|constructor_index
operator|=
name|bitsize_zero_node
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* We need to split the char/wchar array into individual 	     characters, so that we don't have to special case it 	     everywhere.  */
name|set_nonincremental_init_from_string
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|constructor_type
operator|!=
name|error_mark_node
condition|)
name|warning_init
argument_list|(
literal|"braces around scalar initializer"
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
name|constructor_type
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* At the end of an implicit or explicit brace level,    finish up that level of constructor.  If a single expression    with redundant braces initialized that level, return the    c_expr structure for that expression.  Otherwise, the original_code    element is set to ERROR_MARK.    If we were outputting the elements as they are read, return 0 as the value    from inner levels (process_init_element ignores that),    but return error_mark_node as the value from the outermost level    (that's what we want to put in DECL_INITIAL).    Otherwise, return a CONSTRUCTOR expression as the value.  */
end_comment

begin_function
name|struct
name|c_expr
name|pop_init_level
parameter_list|(
name|int
name|implicit
parameter_list|)
block|{
name|struct
name|constructor_stack
modifier|*
name|p
decl_stmt|;
name|struct
name|c_expr
name|ret
decl_stmt|;
name|ret
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
if|if
condition|(
name|implicit
operator|==
literal|0
condition|)
block|{
comment|/* When we come to an explicit close brace, 	 pop any inner levels that didn't have explicit braces.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|constructor_range_stack
argument_list|)
expr_stmt|;
block|}
comment|/* Now output all pending elements.  */
name|constructor_incremental
operator|=
literal|1
expr_stmt|;
name|output_pending_init_elements
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|constructor_stack
expr_stmt|;
comment|/* Error for initializing a flexible array member, or a zero-length      array member in an inappropriate context.  */
if|if
condition|(
name|constructor_type
operator|&&
name|constructor_fields
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
operator|&&
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Silently discard empty initializations.  The parser will 	 already have pedwarned for empty brackets.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|constructor_unfilled_index
argument_list|)
condition|)
name|constructor_type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|TYPE_SIZE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_depth
operator|>
literal|2
condition|)
name|error_init
argument_list|(
literal|"initialization of flexible array member in a nested context"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn_init
argument_list|(
literal|"initialization of a flexible array member"
argument_list|)
expr_stmt|;
comment|/* We have already issued an error message for the existence 	     of a flexible array member not at the end of the structure. 	     Discard the initializer so that we do not die later.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|constructor_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Warn when some struct elements are implicitly initialized to zero.  */
if|if
condition|(
name|warn_missing_field_initializers
operator|&&
name|constructor_type
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|constructor_unfilled_fields
condition|)
block|{
comment|/* Do not warn for flexible array members or zero-length arrays.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|&&
operator|(
operator|!
name|DECL_SIZE
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|constructor_unfilled_fields
argument_list|)
argument_list|)
operator|)
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
comment|/* Do not warn if this level of the initializer uses member 	   designators; it is likely to be deliberate.  */
if|if
condition|(
name|constructor_unfilled_fields
operator|&&
operator|!
name|constructor_designated
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
name|warning_init
argument_list|(
literal|"missing initializer"
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pad out the end of the structure.  */
if|if
condition|(
name|p
operator|->
name|replacement_value
operator|.
name|value
condition|)
comment|/* If this closes a superfluous brace pair,        just pass out the element between them.  */
name|ret
operator|=
name|p
operator|->
name|replacement_value
expr_stmt|;
elseif|else
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
block|{
comment|/* A nonincremental scalar initializer--just return 	 the element, after verifying there is just one.  */
if|if
condition|(
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|constructor_erroneous
condition|)
name|error_init
argument_list|(
literal|"empty scalar initializer"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error_init
argument_list|(
literal|"extra elements in scalar initializer"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|,
literal|0
argument_list|)
operator|->
name|value
expr_stmt|;
block|}
else|else
name|ret
operator|.
name|value
operator|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|,
literal|0
argument_list|)
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|constructor_erroneous
condition|)
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
name|ret
operator|.
name|value
operator|=
name|build_constructor
argument_list|(
name|constructor_type
argument_list|,
name|constructor_elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_constant
condition|)
name|TREE_CONSTANT
argument_list|(
name|ret
operator|.
name|value
argument_list|)
operator|=
name|TREE_INVARIANT
argument_list|(
name|ret
operator|.
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|constructor_constant
operator|&&
name|constructor_simple
condition|)
name|TREE_STATIC
argument_list|(
name|ret
operator|.
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|constructor_type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|constructor_fields
operator|=
name|p
operator|->
name|fields
expr_stmt|;
name|constructor_index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|constructor_max_index
operator|=
name|p
operator|->
name|max_index
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|p
operator|->
name|unfilled_index
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|p
operator|->
name|unfilled_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|p
operator|->
name|bit_index
expr_stmt|;
name|constructor_elements
operator|=
name|p
operator|->
name|elements
expr_stmt|;
name|constructor_constant
operator|=
name|p
operator|->
name|constant
expr_stmt|;
name|constructor_simple
operator|=
name|p
operator|->
name|simple
expr_stmt|;
name|constructor_erroneous
operator|=
name|p
operator|->
name|erroneous
expr_stmt|;
name|constructor_incremental
operator|=
name|p
operator|->
name|incremental
expr_stmt|;
name|constructor_designated
operator|=
name|p
operator|->
name|designated
expr_stmt|;
name|constructor_pending_elts
operator|=
name|p
operator|->
name|pending_elts
expr_stmt|;
name|constructor_depth
operator|=
name|p
operator|->
name|depth
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|implicit
condition|)
name|constructor_range_stack
operator|=
name|p
operator|->
name|range_stack
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
name|constructor_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|value
operator|==
literal|0
operator|&&
name|constructor_stack
operator|==
literal|0
condition|)
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Common handling for both array range and field name designators.    ARRAY argument is nonzero for array ranges.  Returns zero for success.  */
end_comment

begin_function
specifier|static
name|int
name|set_designator
parameter_list|(
name|int
name|array
parameter_list|)
block|{
name|tree
name|subtype
decl_stmt|;
name|enum
name|tree_code
name|subcode
decl_stmt|;
comment|/* Don't die if an entire brace-pair level is superfluous      in the containing level.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If there were errors in this designator list already, bail out      silently.  */
if|if
condition|(
name|designator_erroneous
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|designator_depth
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|constructor_range_stack
argument_list|)
expr_stmt|;
comment|/* Designator list starts at the level of closest explicit 	 braces.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_designated
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
operator|!=
name|error_mark_node
condition|)
name|subtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|subtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|subcode
operator|=
name|TREE_CODE
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
operator|&&
name|subcode
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"array index in non-array initializer"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|array
operator|&&
name|subcode
operator|!=
name|RECORD_TYPE
operator|&&
name|subcode
operator|!=
name|UNION_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"field name not in record or union initializer"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|constructor_designated
operator|=
literal|1
expr_stmt|;
name|push_init_level
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If there are range designators in designator list, push a new designator    to constructor_range_stack.  RANGE_END is end of such stack range or    NULL_TREE if there is no range designator at this level.  */
end_comment

begin_function
specifier|static
name|void
name|push_range_stack
parameter_list|(
name|tree
name|range_end
parameter_list|)
block|{
name|struct
name|constructor_range_stack
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|constructor_range_stack
argument_list|)
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|constructor_range_stack
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|range_start
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|stack
operator|=
name|constructor_stack
expr_stmt|;
name|p
operator|->
name|range_end
operator|=
name|range_end
expr_stmt|;
if|if
condition|(
name|constructor_range_stack
condition|)
name|constructor_range_stack
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|constructor_range_stack
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Within an array initializer, specify the next index to be initialized.    FIRST is that index.  If LAST is nonzero, then initialize a range    of indices, running from FIRST through LAST.  */
end_comment

begin_function
name|void
name|set_init_index
parameter_list|(
name|tree
name|first
parameter_list|,
name|tree
name|last
parameter_list|)
block|{
if|if
condition|(
name|set_designator
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|designator_erroneous
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|first
argument_list|)
argument_list|)
operator|||
operator|(
name|last
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error_init
argument_list|(
literal|"array index in initializer not of integer type"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error_init
argument_list|(
literal|"nonconstant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error_init
argument_list|(
literal|"nonconstant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error_init
argument_list|(
literal|"array index in non-array initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|first
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error_init
argument_list|(
literal|"array index in initializer exceeds array bounds"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constructor_max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|first
argument_list|)
condition|)
name|error_init
argument_list|(
literal|"array index in initializer exceeds array bounds"
argument_list|)
expr_stmt|;
else|else
block|{
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
condition|)
name|last
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|last
argument_list|,
name|first
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"empty index range in initializer"
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_max_index
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|last
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"array index range in initializer exceeds array bounds"
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|designator_depth
operator|++
expr_stmt|;
name|designator_erroneous
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constructor_range_stack
operator|||
name|last
condition|)
name|push_range_stack
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Within a struct initializer, specify the next field to be initialized.  */
end_comment

begin_function
name|void
name|set_init_label
parameter_list|(
name|tree
name|fieldname
parameter_list|)
block|{
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|set_designator
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|designator_erroneous
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"field name not in record or union initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tail
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|==
name|fieldname
condition|)
break|break;
block|}
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unknown field %qE specified in initializer"
argument_list|,
name|fieldname
argument_list|)
expr_stmt|;
else|else
block|{
name|constructor_fields
operator|=
name|tail
expr_stmt|;
name|designator_depth
operator|++
expr_stmt|;
name|designator_erroneous
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constructor_range_stack
condition|)
name|push_range_stack
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a new initializer to the tree of pending initializers.  PURPOSE    identifies the initializer, either array index or field in a structure.    VALUE is the value of that index or field.  */
end_comment

begin_function
specifier|static
name|void
name|add_pending_init
parameter_list|(
name|tree
name|purpose
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|struct
name|init_node
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|q
operator|=
operator|&
name|constructor_pending_elts
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
name|q
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|purpose
argument_list|,
name|p
operator|->
name|purpose
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|p
operator|->
name|purpose
argument_list|,
name|purpose
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|p
operator|->
name|value
argument_list|)
condition|)
name|warning_init
argument_list|(
literal|"initialized field with side-effects overwritten"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_override_init
condition|)
name|warning_init
argument_list|(
literal|"initialized field overwritten"
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|value
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|tree
name|bitpos
decl_stmt|;
name|bitpos
operator|=
name|bit_position
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|*
name|q
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|bit_position
argument_list|(
name|p
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|purpose
operator|!=
name|purpose
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|p
operator|->
name|value
argument_list|)
condition|)
name|warning_init
argument_list|(
literal|"initialized field with side-effects overwritten"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_override_init
condition|)
name|warning_init
argument_list|(
literal|"initialized field overwritten"
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|value
expr_stmt|;
return|return;
block|}
block|}
block|}
name|r
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|init_node
argument_list|)
expr_stmt|;
name|r
operator|->
name|purpose
operator|=
name|purpose
expr_stmt|;
name|r
operator|->
name|value
operator|=
name|value
expr_stmt|;
operator|*
name|q
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|struct
name|init_node
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|p
operator|->
name|left
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|balance
operator|==
literal|0
condition|)
name|p
operator|->
name|balance
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
comment|/* L rotation.  */
name|p
operator|->
name|left
operator|=
name|r
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
condition|)
name|p
operator|->
name|left
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
comment|/* LR rotation.  */
name|struct
name|init_node
modifier|*
name|t
init|=
name|r
operator|->
name|right
decl_stmt|;
name|r
operator|->
name|right
operator|=
name|t
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|right
condition|)
name|r
operator|->
name|right
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
condition|)
name|p
operator|->
name|left
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|<
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
operator|-
operator|(
name|t
operator|->
name|balance
operator|>
literal|0
operator|)
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == +1; growth of left side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* r == p->right */
block|{
if|if
condition|(
name|p
operator|->
name|balance
operator|==
literal|0
condition|)
comment|/* Growth propagation from right side.  */
name|p
operator|->
name|balance
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
comment|/* R rotation.  */
name|p
operator|->
name|right
operator|=
name|r
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|p
operator|->
name|right
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|r
expr_stmt|;
block|}
else|else
comment|/* r->balance == -1 */
block|{
comment|/* RL rotation */
name|struct
name|init_node
modifier|*
name|t
init|=
name|r
operator|->
name|left
decl_stmt|;
name|r
operator|->
name|left
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|left
condition|)
name|r
operator|->
name|left
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|t
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|p
operator|->
name|right
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|balance
operator|=
operator|(
name|t
operator|->
name|balance
operator|<
literal|0
operator|)
expr_stmt|;
name|p
operator|->
name|balance
operator|=
operator|-
operator|(
name|t
operator|->
name|balance
operator|>
literal|0
operator|)
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == -1; growth of right side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|r
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build AVL tree from a sorted chain.  */
end_comment

begin_function
specifier|static
name|void
name|set_nonincremental_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|tree
name|index
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|constructor_elements
argument_list|,
argument|ix
argument_list|,
argument|index
argument_list|,
argument|value
argument_list|)
name|add_pending_init
argument_list|(
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|constructor_unfilled_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|constructor_unfilled_index
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build AVL tree from a string constant.  */
end_comment

begin_function
specifier|static
name|void
name|set_nonincremental_init_from_string
parameter_list|(
name|tree
name|str
parameter_list|)
block|{
name|tree
name|value
decl_stmt|,
name|purpose
decl_stmt|,
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|val
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|wchar_bytes
decl_stmt|,
name|charwidth
decl_stmt|,
name|bitpos
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
name|wchar_bytes
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_bytes
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
name|charwidth
operator|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|TREE_STRING_LENGTH
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|purpose
operator|=
name|bitsize_zero_node
init|;
name|p
operator|<
name|end
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|purpose
argument_list|)
condition|;
name|purpose
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|purpose
argument_list|,
name|bitsize_one_node
argument_list|)
control|)
block|{
if|if
condition|(
name|wchar_bytes
operator|==
literal|1
condition|)
block|{
name|val
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|val
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|wchar_bytes
condition|;
name|byte
operator|++
control|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|bitpos
operator|=
operator|(
name|wchar_bytes
operator|-
name|byte
operator|-
literal|1
operator|)
operator|*
name|charwidth
expr_stmt|;
else|else
name|bitpos
operator|=
name|byte
operator|*
name|charwidth
expr_stmt|;
name|val
index|[
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
index|]
operator||=
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
argument_list|)
operator|)
operator|<<
operator|(
name|bitpos
operator|%
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|bitpos
operator|=
operator|(
operator|(
name|wchar_bytes
operator|-
literal|1
operator|)
operator|*
name|charwidth
operator|)
operator|+
name|HOST_BITS_PER_CHAR
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|bitpos
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|val
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bitpos
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitpos
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|<
literal|0
condition|)
name|val
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
index|[
literal|0
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|bitpos
operator|-
literal|1
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
condition|)
name|val
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
name|value
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|val
index|[
literal|1
index|]
argument_list|,
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|add_pending_init
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return value of FIELD in pending initializer or zero if the field was    not initialized yet.  */
end_comment

begin_function
specifier|static
name|tree
name|find_init_member
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
name|struct
name|init_node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|constructor_incremental
operator|&&
name|tree_int_cst_lt
argument_list|(
name|field
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
name|p
operator|=
name|constructor_pending_elts
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|field
argument_list|,
name|p
operator|->
name|purpose
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|p
operator|->
name|purpose
argument_list|,
name|field
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
else|else
return|return
name|p
operator|->
name|value
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|bitpos
init|=
name|bit_position
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|constructor_incremental
operator|&&
operator|(
operator|!
name|constructor_unfilled_fields
operator|||
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|bit_position
argument_list|(
name|constructor_unfilled_fields
argument_list|)
argument_list|)
operator|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
name|p
operator|=
name|constructor_pending_elts
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|field
operator|==
name|p
operator|->
name|purpose
condition|)
return|return
name|p
operator|->
name|value
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|bit_position
argument_list|(
name|p
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
else|else
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
operator|&&
operator|(
name|VEC_last
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
operator|->
name|index
operator|==
name|field
operator|)
condition|)
return|return
name|VEC_last
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
operator|->
name|value
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* "Output" the next constructor element.    At top level, really output it to assembler code now.    Otherwise, collect it in a list from which we will make a CONSTRUCTOR.    TYPE is the data type that the containing data type wants here.    FIELD is the field (a FIELD_DECL) or the index that this element fills.    If VALUE is a string constant, STRICT_STRING is true if it is    unparenthesized or we should not warn here for it being parenthesized.    For other types of VALUE, STRICT_STRING is not used.     PENDING if non-nil means output pending elements that belong    right after this element.  (PENDING is normally 1;    it is 0 while outputting pending elements, to avoid recursion.)  */
end_comment

begin_function
specifier|static
name|void
name|output_init_element
parameter_list|(
name|tree
name|value
parameter_list|,
name|bool
name|strict_string
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|field
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|constructor_elt
modifier|*
name|celt
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|value
operator|==
name|error_mark_node
condition|)
block|{
name|constructor_erroneous
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|array_to_pointer_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
operator|&&
name|require_constant_value
operator|&&
operator|!
name|flag_isoc99
operator|&&
name|pending
condition|)
block|{
comment|/* As an extension, allow initializing objects with static storage 	 duration with compound literals (which are then treated just as 	 the brace enclosed list they contain).  */
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|value
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
name|constructor_erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|constructor_constant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
name|constructor_simple
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|require_constant_value
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant_elements
condition|)
name|pedwarn
argument_list|(
literal|"initializer element is not computable at load time"
argument_list|)
expr_stmt|;
block|}
comment|/* If this field is empty (and not at the end of structure),      don't do anything other than checking the initializer.  */
if|if
condition|(
name|field
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return;
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|strict_string
argument_list|,
name|require_constant_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
block|{
name|constructor_erroneous
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If this element doesn't come next in sequence,      put it on constructor_pending_elts.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
operator|!
name|constructor_incremental
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|field
argument_list|,
name|constructor_unfilled_index
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|constructor_incremental
operator|&&
name|tree_int_cst_lt
argument_list|(
name|field
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
name|add_pending_init
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|(
operator|!
name|constructor_incremental
operator|||
name|field
operator|!=
name|constructor_unfilled_fields
operator|)
condition|)
block|{
comment|/* We do this for records but not for unions.  In a union, 	 no matter which field is specified, it can be initialized 	 right away since it starts at the beginning of the union.  */
if|if
condition|(
name|constructor_incremental
condition|)
block|{
if|if
condition|(
operator|!
name|constructor_unfilled_fields
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
else|else
block|{
name|tree
name|bitpos
decl_stmt|,
name|unfillpos
decl_stmt|;
name|bitpos
operator|=
name|bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|unfillpos
operator|=
name|bit_position
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|unfillpos
argument_list|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
block|}
block|}
name|add_pending_init
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|!
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|VEC_last
argument_list|(
name|constructor_elt
argument_list|,
name|constructor_elements
argument_list|)
operator|->
name|value
argument_list|)
condition|)
name|warning_init
argument_list|(
literal|"initialized field with side-effects overwritten"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_override_init
condition|)
name|warning_init
argument_list|(
literal|"initialized field overwritten"
argument_list|)
expr_stmt|;
comment|/* We can have just one union field set.  */
name|constructor_elements
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, output this element either to      constructor_elements or to the assembler file.  */
name|celt
operator|=
name|VEC_safe_push
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
name|constructor_elements
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|celt
operator|->
name|index
operator|=
name|field
expr_stmt|;
name|celt
operator|->
name|value
operator|=
name|value
expr_stmt|;
comment|/* Advance the variable that indicates sequential elements output.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|constructor_unfilled_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_unfilled_index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|constructor_unfilled_fields
operator|=
literal|0
expr_stmt|;
comment|/* Now output any pending elements which have become next.  */
if|if
condition|(
name|pending
condition|)
name|output_pending_init_elements
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output any pending elements which have become next.    As we output elements, constructor_unfilled_{fields,index}    advances, which may cause other elements to become next;    if so, they too are output.     If ALL is 0, we return when there are    no more pending elements to output now.     If ALL is 1, we output space as necessary so that    we can output all the pending elements.  */
end_comment

begin_function
specifier|static
name|void
name|output_pending_init_elements
parameter_list|(
name|int
name|all
parameter_list|)
block|{
name|struct
name|init_node
modifier|*
name|elt
init|=
name|constructor_pending_elts
decl_stmt|;
name|tree
name|next
decl_stmt|;
name|retry
label|:
comment|/* Look through the whole pending tree.      If we find an element that should be output now,      output it.  Otherwise, set NEXT to the element      that comes first among those still pending.  */
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|elt
operator|->
name|purpose
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|output_init_element
argument_list|(
name|elt
operator|->
name|value
argument_list|,
name|true
argument_list|,
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|,
name|constructor_unfilled_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|constructor_unfilled_index
argument_list|,
name|elt
operator|->
name|purpose
argument_list|)
condition|)
block|{
comment|/* Advance to the next smaller node.  */
if|if
condition|(
name|elt
operator|->
name|left
condition|)
name|elt
operator|=
name|elt
operator|->
name|left
expr_stmt|;
else|else
block|{
comment|/* We have reached the smallest node bigger than the 		     current unfilled index.  Fill the space first.  */
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Advance to the next bigger node.  */
if|if
condition|(
name|elt
operator|->
name|right
condition|)
name|elt
operator|=
name|elt
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have reached the biggest node in a subtree.  Find 		     the parent of it, which is the next bigger node.  */
while|while
condition|(
name|elt
operator|->
name|parent
operator|&&
name|elt
operator|->
name|parent
operator|->
name|right
operator|==
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_unfilled_index
argument_list|,
name|elt
operator|->
name|purpose
argument_list|)
condition|)
block|{
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|ctor_unfilled_bitpos
decl_stmt|,
name|elt_bitpos
decl_stmt|;
comment|/* If the current record is complete we are done.  */
if|if
condition|(
name|constructor_unfilled_fields
operator|==
literal|0
condition|)
break|break;
name|ctor_unfilled_bitpos
operator|=
name|bit_position
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
name|elt_bitpos
operator|=
name|bit_position
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
expr_stmt|;
comment|/* We can't compare fields here because there might be empty 	     fields in between.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|elt_bitpos
argument_list|,
name|ctor_unfilled_bitpos
argument_list|)
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
name|output_init_element
argument_list|(
name|elt
operator|->
name|value
argument_list|,
name|true
argument_list|,
name|TREE_TYPE
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
argument_list|,
name|elt
operator|->
name|purpose
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|ctor_unfilled_bitpos
argument_list|,
name|elt_bitpos
argument_list|)
condition|)
block|{
comment|/* Advance to the next smaller node.  */
if|if
condition|(
name|elt
operator|->
name|left
condition|)
name|elt
operator|=
name|elt
operator|->
name|left
expr_stmt|;
else|else
block|{
comment|/* We have reached the smallest node bigger than the 		     current unfilled field.  Fill the space first.  */
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Advance to the next bigger node.  */
if|if
condition|(
name|elt
operator|->
name|right
condition|)
name|elt
operator|=
name|elt
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have reached the biggest node in a subtree.  Find 		     the parent of it, which is the next bigger node.  */
while|while
condition|(
name|elt
operator|->
name|parent
operator|&&
name|elt
operator|->
name|parent
operator|->
name|right
operator|==
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
operator|(
name|tree_int_cst_lt
argument_list|(
name|ctor_unfilled_bitpos
argument_list|,
name|bit_position
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Ordinarily return, but not if we want to output all      and there are elements left.  */
if|if
condition|(
operator|!
operator|(
name|all
operator|&&
name|next
operator|!=
literal|0
operator|)
condition|)
return|return;
comment|/* If it's not incremental, just skip over the gap, so that after      jumping to retry we will output the next successive element.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|constructor_unfilled_fields
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|constructor_unfilled_index
operator|=
name|next
expr_stmt|;
comment|/* ELT now points to the node in the pending tree with the next      initializer to output.  */
goto|goto
name|retry
goto|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add one non-braced element to the current constructor level.    This adjusts the current position within the constructor's type.    This may also start or terminate implicit levels    to handle a partly-braced initializer.     Once this has found the correct level for the new element,    it calls output_init_element.  */
end_comment

begin_function
name|void
name|process_init_element
parameter_list|(
name|struct
name|c_expr
name|value
parameter_list|)
block|{
name|tree
name|orig_value
init|=
name|value
operator|.
name|value
decl_stmt|;
name|int
name|string_flag
init|=
name|orig_value
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|orig_value
argument_list|)
operator|==
name|STRING_CST
decl_stmt|;
name|bool
name|strict_string
init|=
name|value
operator|.
name|original_code
operator|==
name|STRING_CST
decl_stmt|;
name|designator_depth
operator|=
literal|0
expr_stmt|;
name|designator_erroneous
operator|=
literal|0
expr_stmt|;
comment|/* Handle superfluous braces around string cst as in      char x[] = {"foo"}; */
if|if
condition|(
name|string_flag
operator|&&
name|constructor_type
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|constructor_unfilled_index
argument_list|)
condition|)
block|{
if|if
condition|(
name|constructor_stack
operator|->
name|replacement_value
operator|.
name|value
condition|)
name|error_init
argument_list|(
literal|"excess elements in char array initializer"
argument_list|)
expr_stmt|;
name|constructor_stack
operator|->
name|replacement_value
operator|=
name|value
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|constructor_stack
operator|->
name|replacement_value
operator|.
name|value
operator|!=
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"excess elements in struct initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ignore elements of a brace group if it is entirely superfluous      and has already been diagnosed.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
return|return;
comment|/* If we've exhausted any levels that didn't have braces,      pop them now.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
operator|==
literal|0
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|constructor_max_index
operator|==
literal|0
operator|||
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
operator|)
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* In the case of [LO ... HI] = VALUE, only evaluate VALUE once.  */
if|if
condition|(
name|constructor_range_stack
condition|)
block|{
comment|/* If value is a compound literal and we'll be just using its 	 content, don't put it into a SAVE_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
operator|.
name|value
argument_list|)
operator|!=
name|COMPOUND_LITERAL_EXPR
operator|||
operator|!
name|require_constant_value
operator|||
name|flag_isoc99
condition|)
name|value
operator|.
name|value
operator|=
name|save_expr
argument_list|(
name|value
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|fieldtype
decl_stmt|;
name|enum
name|tree_code
name|fieldcode
decl_stmt|;
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in struct initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fieldtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|!=
name|error_mark_node
condition|)
name|fieldtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
name|fieldcode
operator|=
name|TREE_CODE
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
comment|/* Error for non-static initialization of a flexible array member.  */
if|if
condition|(
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|require_constant_value
operator|&&
name|TYPE_SIZE
argument_list|(
name|fieldtype
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error_init
argument_list|(
literal|"non-static initialization of a flexible array member"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|.
name|value
operator|!=
literal|0
operator|&&
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|&&
name|string_flag
condition|)
name|value
operator|.
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|.
name|value
operator|!=
literal|0
operator|&&
name|value
operator|.
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
operator|.
name|value
argument_list|)
argument_list|)
operator|!=
name|fieldtype
operator|&&
operator|(
name|fieldcode
operator|==
name|RECORD_TYPE
operator|||
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|||
name|fieldcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
operator|.
name|value
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
operator|.
name|value
argument_list|,
name|strict_string
argument_list|,
name|fieldtype
argument_list|,
name|constructor_fields
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Do the bookkeeping for an element that was 	       directly output as a constructor.  */
block|{
comment|/* For a record, keep track of end position of last field.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
condition|)
name|constructor_bit_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_position
argument_list|(
name|constructor_fields
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the current field was the first one not yet written out, 		 it isn't now, so update.  */
if|if
condition|(
name|constructor_unfilled_fields
operator|==
name|constructor_fields
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
block|}
block|}
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|fieldtype
decl_stmt|;
name|enum
name|tree_code
name|fieldcode
decl_stmt|;
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in union initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fieldtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|!=
name|error_mark_node
condition|)
name|fieldtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
name|fieldcode
operator|=
name|TREE_CODE
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
comment|/* Warn that traditional C rejects initialization of unions. 	     We skip the warning if the value is zero.  This is done 	     under the assumption that the zero initializer in user 	     code appears conditioned on e.g. __STDC__ to avoid 	     "missing initializer" warnings and relies on default 	     initialization to zero in the traditional C case. 	     We also skip the warning if the initializer is designated, 	     again on the assumption that this must be conditional on 	     __STDC__ anyway (and we've already complained about the 	     member-designator already).  */
if|if
condition|(
operator|!
name|in_system_header
operator|&&
operator|!
name|constructor_designated
operator|&&
operator|!
operator|(
name|value
operator|.
name|value
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|value
operator|.
name|value
argument_list|)
operator|||
name|real_zerop
argument_list|(
name|value
operator|.
name|value
argument_list|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"traditional C rejects initialization "
literal|"of unions"
argument_list|)
expr_stmt|;
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|.
name|value
operator|!=
literal|0
operator|&&
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|&&
name|string_flag
condition|)
name|value
operator|.
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|.
name|value
operator|!=
literal|0
operator|&&
name|value
operator|.
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
operator|.
name|value
argument_list|)
argument_list|)
operator|!=
name|fieldtype
operator|&&
operator|(
name|fieldcode
operator|==
name|RECORD_TYPE
operator|||
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|||
name|fieldcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
operator|.
name|value
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
operator|.
name|value
argument_list|,
name|strict_string
argument_list|,
name|fieldtype
argument_list|,
name|constructor_fields
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Do the bookkeeping for an element that was 	       directly output as a constructor.  */
block|{
name|constructor_bit_index
operator|=
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
block|}
name|constructor_fields
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|elttype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|eltcode
init|=
name|TREE_CODE
argument_list|(
name|elttype
argument_list|)
decl_stmt|;
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|.
name|value
operator|!=
literal|0
operator|&&
name|eltcode
operator|==
name|ARRAY_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|&&
name|string_flag
condition|)
name|value
operator|.
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|.
name|value
operator|!=
literal|0
operator|&&
name|value
operator|.
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
operator|.
name|value
argument_list|)
argument_list|)
operator|!=
name|elttype
operator|&&
operator|(
name|eltcode
operator|==
name|RECORD_TYPE
operator|||
name|eltcode
operator|==
name|ARRAY_TYPE
operator|||
name|eltcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|constructor_max_index
operator|!=
literal|0
operator|&&
operator|(
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|constructor_max_index
argument_list|)
operator|)
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in array initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now output the actual element.  */
if|if
condition|(
name|value
operator|.
name|value
condition|)
block|{
name|push_array_bounds
argument_list|(
name|tree_low_cst
argument_list|(
name|constructor_index
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
operator|.
name|value
argument_list|,
name|strict_string
argument_list|,
name|elttype
argument_list|,
name|constructor_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
name|constructor_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|value
condition|)
comment|/* If we are doing the bookkeeping for an element that was 	       directly output as a constructor, we must update 	       constructor_unfilled_index.  */
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|tree
name|elttype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Do a basic check of initializer size.  Note that vectors 	    always have a fixed size derived from their type.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in vector initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now output the actual element.  */
if|if
condition|(
name|value
operator|.
name|value
condition|)
name|output_init_element
argument_list|(
name|value
operator|.
name|value
argument_list|,
name|strict_string
argument_list|,
name|elttype
argument_list|,
name|constructor_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|value
condition|)
comment|/* If we are doing the bookkeeping for an element that was 	       directly output as a constructor, we must update 	       constructor_unfilled_index.  */
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
comment|/* Handle the sole element allowed in a braced initializer 	 for a scalar variable.  */
elseif|else
if|if
condition|(
name|constructor_type
operator|!=
name|error_mark_node
operator|&&
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in scalar initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|value
condition|)
name|output_init_element
argument_list|(
name|value
operator|.
name|value
argument_list|,
name|strict_string
argument_list|,
name|constructor_type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Handle range initializers either at this level or anywhere higher 	 in the designator stack.  */
if|if
condition|(
name|constructor_range_stack
condition|)
block|{
name|struct
name|constructor_range_stack
modifier|*
name|p
decl_stmt|,
modifier|*
name|range_stack
decl_stmt|;
name|int
name|finish
init|=
literal|0
decl_stmt|;
name|range_stack
operator|=
name|constructor_range_stack
expr_stmt|;
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|constructor_stack
operator|!=
name|range_stack
operator|->
name|stack
condition|)
block|{
name|gcc_assert
argument_list|(
name|constructor_stack
operator|->
name|implicit
argument_list|)
expr_stmt|;
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|range_stack
init|;
operator|!
name|p
operator|->
name|range_end
operator|||
name|tree_int_cst_equal
argument_list|(
name|p
operator|->
name|index
argument_list|,
name|p
operator|->
name|range_end
argument_list|)
condition|;
name|p
operator|=
name|p
operator|->
name|prev
control|)
block|{
name|gcc_assert
argument_list|(
name|constructor_stack
operator|->
name|implicit
argument_list|)
expr_stmt|;
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|p
operator|->
name|index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|p
operator|->
name|index
argument_list|,
name|p
operator|->
name|range_end
argument_list|)
operator|&&
operator|!
name|p
operator|->
name|prev
condition|)
name|finish
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|constructor_index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|constructor_fields
operator|=
name|p
operator|->
name|fields
expr_stmt|;
if|if
condition|(
name|finish
operator|&&
name|p
operator|->
name|range_end
operator|&&
name|p
operator|->
name|index
operator|==
name|p
operator|->
name|range_start
condition|)
block|{
name|finish
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break;
name|push_init_level
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|p
operator|->
name|stack
operator|=
name|constructor_stack
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|range_end
operator|&&
name|tree_int_cst_equal
argument_list|(
name|p
operator|->
name|index
argument_list|,
name|p
operator|->
name|range_end
argument_list|)
condition|)
name|p
operator|->
name|index
operator|=
name|p
operator|->
name|range_start
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|finish
condition|)
name|constructor_range_stack
operator|=
name|range_stack
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a complete asm-statement, whose components are a CV_QUALIFIER    (guaranteed to be 'volatile' or null) and ARGS (represented using    an ASM_EXPR node).  */
end_comment

begin_function
name|tree
name|build_asm_stmt
parameter_list|(
name|tree
name|cv_qualifier
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ASM_VOLATILE_P
argument_list|(
name|args
argument_list|)
operator|&&
name|cv_qualifier
condition|)
name|ASM_VOLATILE_P
argument_list|(
name|args
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an asm-expr, whose components are a STRING, some OUTPUTS,    some INPUTS, and some CLOBBERS.  The latter three may be NULL.    SIMPLE indicates whether there was anything at all after the    string in the asm expression -- asm("blah") and asm("blah" : )    are subtly different.  We use a ASM_EXPR node to represent this.  */
end_comment

begin_function
name|tree
name|build_asm_expr
parameter_list|(
name|tree
name|string
parameter_list|,
name|tree
name|outputs
parameter_list|,
name|tree
name|inputs
parameter_list|,
name|tree
name|clobbers
parameter_list|,
name|bool
name|simple
parameter_list|)
block|{
name|tree
name|tail
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
name|int
name|ninputs
decl_stmt|,
name|noutputs
decl_stmt|;
name|ninputs
operator|=
name|list_length
argument_list|(
name|inputs
argument_list|)
expr_stmt|;
name|noutputs
operator|=
name|list_length
argument_list|(
name|outputs
argument_list|)
expr_stmt|;
name|oconstraints
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|string
operator|=
name|resolve_asm_operand_names
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
comment|/* Remove output conversions that change the type but not the mode.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
operator|++
name|i
operator|,
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|tree
name|output
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
comment|/* ??? Really, this should not be here.  Users should be using a 	 proper lvalue, dammit.  But there's a long history of using casts 	 in the output operands.  In cases like longlong.h, this becomes a 	 primitive form of typechecking -- if the cast can be removed, then 	 the output operand had a type of the proper width; otherwise we'll 	 get an error.  Gross, but ...  */
name|STRIP_NOPS
argument_list|(
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|output
argument_list|,
name|lv_asm
argument_list|)
condition|)
name|output
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|output
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|output
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|output
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|output
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|output
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|output
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|output
argument_list|,
name|lv_asm
argument_list|)
expr_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
expr_stmt|;
if|if
condition|(
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
condition|)
block|{
comment|/* If the operand is going to end up in memory, 	     mark it addressable.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
operator|!
name|c_mark_addressable
argument_list|(
name|output
argument_list|)
condition|)
name|output
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|output
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|output
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
operator|++
name|i
operator|,
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|tree
name|input
decl_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|input
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
condition|)
block|{
comment|/* If the operand is going to end up in memory, 	     mark it addressable.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
block|{
comment|/* Strip the nops as we allow this case.  FIXME, this really 		 should be rejected or made deprecated.  */
name|STRIP_NOPS
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|input
argument_list|)
condition|)
name|input
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
name|input
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|input
expr_stmt|;
block|}
name|args
operator|=
name|build_stmt
argument_list|(
name|ASM_EXPR
argument_list|,
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
comment|/* asm statements without outputs, including simple ones, are treated      as volatile.  */
name|ASM_INPUT_P
argument_list|(
name|args
argument_list|)
operator|=
name|simple
expr_stmt|;
name|ASM_VOLATILE_P
argument_list|(
name|args
argument_list|)
operator|=
operator|(
name|noutputs
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a goto statement to LABEL.  */
end_comment

begin_function
name|tree
name|c_finish_goto_label
parameter_list|(
name|tree
name|label
parameter_list|)
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|C_DECL_UNJUMPABLE_STMT_EXPR
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"jump into statement expression"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|C_DECL_UNJUMPABLE_VM
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"jump into scope of identifier with variably modified type"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|C_DECL_UNDEFINABLE_STMT_EXPR
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* No jump from outside this statement expression context, so 	 record that there is a jump from within this context.  */
name|struct
name|c_label_list
modifier|*
name|nlist
decl_stmt|;
name|nlist
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_list
argument_list|)
expr_stmt|;
name|nlist
operator|->
name|next
operator|=
name|label_context_stack_se
operator|->
name|labels_used
expr_stmt|;
name|nlist
operator|->
name|label
operator|=
name|decl
expr_stmt|;
name|label_context_stack_se
operator|->
name|labels_used
operator|=
name|nlist
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|C_DECL_UNDEFINABLE_VM
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* No jump from outside this context context of identifiers with 	 variably modified type, so record that there is a jump from 	 within this context.  */
name|struct
name|c_label_list
modifier|*
name|nlist
decl_stmt|;
name|nlist
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_list
argument_list|)
expr_stmt|;
name|nlist
operator|->
name|next
operator|=
name|label_context_stack_vm
operator|->
name|labels_used
expr_stmt|;
name|nlist
operator|->
name|label
operator|=
name|decl
expr_stmt|;
name|label_context_stack_vm
operator|->
name|labels_used
operator|=
name|nlist
expr_stmt|;
block|}
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a computed goto statement to EXPR.  */
end_comment

begin_function
name|tree
name|c_finish_goto_ptr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids %<goto *expr;%>"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a C `return' statement.  RETVAL is the expression for what    to return, or a null pointer for `return;' with no value.  */
end_comment

begin_function
name|tree
name|c_finish_return
parameter_list|(
name|tree
name|retval
parameter_list|)
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|,
name|ret_stmt
decl_stmt|;
name|bool
name|no_warning
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"function declared %<noreturn%> has a %<return%> statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|warn_return_type
operator|||
name|flag_isoc99
operator|)
operator|&&
name|valtype
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
name|pedwarn_c99
argument_list|(
literal|"%<return%> with no value, in "
literal|"function returning non-void"
argument_list|)
expr_stmt|;
name|no_warning
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|valtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"%<return%> with a value, in function returning void"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|convert_for_assignment
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|,
name|ic_return
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|res
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|inner
decl_stmt|;
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|inner
operator|=
name|t
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Strip any conversions, additions, and subtractions, and see if 	 we are returning the address of a local variable.  Warn if so.  */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MINUS_EXPR
case|:
comment|/* If the second operand of the MINUS_EXPR has a pointer 		 type (or is converted from it), this may be valid, so 		 don't give a warning.  */
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
condition|)
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
break|break;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|ADDR_EXPR
case|:
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|inner
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|inner
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|inner
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|inner
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|inner
argument_list|)
operator|==
name|current_function_decl
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"function returns address of local variable"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
name|retval
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|ret_stmt
operator|=
name|build_stmt
argument_list|(
name|RETURN_EXPR
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|ret_stmt
argument_list|)
operator||=
name|no_warning
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|ret_stmt
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|c_switch
block|{
comment|/* The SWITCH_EXPR being built.  */
name|tree
name|switch_expr
decl_stmt|;
comment|/* The original type of the testing expression, i.e. before the      default conversion is applied.  */
name|tree
name|orig_type
decl_stmt|;
comment|/* A splay-tree mapping the low element of a case range to the high      element, or NULL_TREE if there is no high element.  Used to      determine whether or not a new case label duplicates an old case      label.  We need a tree, rather than simply a hash table, because      of the GNU case range extension.  */
name|splay_tree
name|cases
decl_stmt|;
comment|/* Number of nested statement expressions within this switch      statement; if nonzero, case and default labels may not      appear.  */
name|unsigned
name|int
name|blocked_stmt_expr
decl_stmt|;
comment|/* Scope of outermost declarations of identifiers with variably      modified type within this switch statement; if nonzero, case and      default labels may not appear.  */
name|unsigned
name|int
name|blocked_vm
decl_stmt|;
comment|/* The next node on the stack.  */
name|struct
name|c_switch
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A stack of the currently active switch statements.  The innermost    switch statement is on the top of the stack.  There is no need to    mark the stack for garbage collection because it is only active    during the processing of the body of a function, and we never    collect at that point.  */
end_comment

begin_decl_stmt
name|struct
name|c_switch
modifier|*
name|c_switch_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start a C switch statement, testing expression EXP.  Return the new    SWITCH_EXPR.  */
end_comment

begin_function
name|tree
name|c_start_case
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|orig_type
init|=
name|error_mark_node
decl_stmt|;
name|struct
name|c_switch
modifier|*
name|cs
decl_stmt|;
if|if
condition|(
name|exp
operator|!=
name|error_mark_node
condition|)
block|{
name|orig_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|orig_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|orig_type
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|orig_type
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|exp
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|orig_type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|in_system_header
operator|&&
operator|(
name|type
operator|==
name|long_integer_type_node
operator|||
name|type
operator|==
name|long_unsigned_type_node
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"%<long%> switch expression not "
literal|"converted to %<int%> in ISO C"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add this new SWITCH_EXPR to the stack.  */
name|cs
operator|=
name|XNEW
argument_list|(
expr|struct
name|c_switch
argument_list|)
expr_stmt|;
name|cs
operator|->
name|switch_expr
operator|=
name|build3
argument_list|(
name|SWITCH_EXPR
argument_list|,
name|orig_type
argument_list|,
name|exp
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|cs
operator|->
name|orig_type
operator|=
name|orig_type
expr_stmt|;
name|cs
operator|->
name|cases
operator|=
name|splay_tree_new
argument_list|(
name|case_compare
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cs
operator|->
name|blocked_stmt_expr
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|blocked_vm
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|next
operator|=
name|c_switch_stack
expr_stmt|;
name|c_switch_stack
operator|=
name|cs
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|cs
operator|->
name|switch_expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process a case label.  */
end_comment

begin_function
name|tree
name|do_case
parameter_list|(
name|tree
name|low_value
parameter_list|,
name|tree
name|high_value
parameter_list|)
block|{
name|tree
name|label
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|c_switch_stack
operator|&&
operator|!
name|c_switch_stack
operator|->
name|blocked_stmt_expr
operator|&&
operator|!
name|c_switch_stack
operator|->
name|blocked_vm
condition|)
block|{
name|label
operator|=
name|c_add_case_label
argument_list|(
name|c_switch_stack
operator|->
name|cases
argument_list|,
name|SWITCH_COND
argument_list|(
name|c_switch_stack
operator|->
name|switch_expr
argument_list|)
argument_list|,
name|c_switch_stack
operator|->
name|orig_type
argument_list|,
name|low_value
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|error_mark_node
condition|)
name|label
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_switch_stack
operator|&&
name|c_switch_stack
operator|->
name|blocked_stmt_expr
condition|)
block|{
if|if
condition|(
name|low_value
condition|)
name|error
argument_list|(
literal|"case label in statement expression not containing "
literal|"enclosing switch statement"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%<default%> label in statement expression not containing "
literal|"enclosing switch statement"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_switch_stack
operator|&&
name|c_switch_stack
operator|->
name|blocked_vm
condition|)
block|{
if|if
condition|(
name|low_value
condition|)
name|error
argument_list|(
literal|"case label in scope of identifier with variably modified "
literal|"type not containing enclosing switch statement"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%<default%> label in scope of identifier with variably "
literal|"modified type not containing enclosing switch statement"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low_value
condition|)
name|error
argument_list|(
literal|"case label not within a switch statement"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%<default%> label not within a switch statement"
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Finish the switch statement.  */
end_comment

begin_function
name|void
name|c_finish_case
parameter_list|(
name|tree
name|body
parameter_list|)
block|{
name|struct
name|c_switch
modifier|*
name|cs
init|=
name|c_switch_stack
decl_stmt|;
name|location_t
name|switch_location
decl_stmt|;
name|SWITCH_BODY
argument_list|(
name|cs
operator|->
name|switch_expr
argument_list|)
operator|=
name|body
expr_stmt|;
comment|/* We must not be within a statement expression nested in the switch      at this point; we might, however, be within the scope of an      identifier with variably modified type nested in the switch.  */
name|gcc_assert
argument_list|(
operator|!
name|cs
operator|->
name|blocked_stmt_expr
argument_list|)
expr_stmt|;
comment|/* Emit warnings as needed.  */
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|cs
operator|->
name|switch_expr
argument_list|)
condition|)
name|switch_location
operator|=
name|EXPR_LOCATION
argument_list|(
name|cs
operator|->
name|switch_expr
argument_list|)
expr_stmt|;
else|else
name|switch_location
operator|=
name|input_location
expr_stmt|;
name|c_do_switch_warnings
argument_list|(
name|cs
operator|->
name|cases
argument_list|,
name|switch_location
argument_list|,
name|TREE_TYPE
argument_list|(
name|cs
operator|->
name|switch_expr
argument_list|)
argument_list|,
name|SWITCH_COND
argument_list|(
name|cs
operator|->
name|switch_expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop the stack.  */
name|c_switch_stack
operator|=
name|cs
operator|->
name|next
expr_stmt|;
name|splay_tree_delete
argument_list|(
name|cs
operator|->
name|cases
argument_list|)
expr_stmt|;
name|XDELETE
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an if statement.  IF_LOCUS is the location of the 'if'.  COND,    THEN_BLOCK and ELSE_BLOCK are expressions to be used; ELSE_BLOCK    may be null.  NESTED_IF is true if THEN_BLOCK contains another IF    statement, and was not surrounded with parenthesis.  */
end_comment

begin_function
name|void
name|c_finish_if_stmt
parameter_list|(
name|location_t
name|if_locus
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|then_block
parameter_list|,
name|tree
name|else_block
parameter_list|,
name|bool
name|nested_if
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Diagnose an ambiguous else if if-then-else is nested inside if-then.  */
if|if
condition|(
name|warn_parentheses
operator|&&
name|nested_if
operator|&&
name|else_block
operator|==
name|NULL
condition|)
block|{
name|tree
name|inner_if
init|=
name|then_block
decl_stmt|;
comment|/* We know from the grammar productions that there is an IF nested 	 within THEN_BLOCK.  Due to labels and c99 conditional declarations, 	 it might not be exactly THEN_BLOCK, but should be the last 	 non-container statement within.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|inner_if
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
goto|goto
name|found
goto|;
case|case
name|BIND_EXPR
case|:
name|inner_if
operator|=
name|BIND_EXPR_BODY
argument_list|(
name|inner_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATEMENT_LIST
case|:
name|inner_if
operator|=
name|expr_last
argument_list|(
name|then_block
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
name|inner_if
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_if
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|found
label|:
if|if
condition|(
name|COND_EXPR_ELSE
argument_list|(
name|inner_if
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"%Hsuggest explicit braces to avoid ambiguous %<else%>"
argument_list|,
operator|&
name|if_locus
argument_list|)
expr_stmt|;
block|}
name|empty_body_warning
argument_list|(
name|then_block
argument_list|,
name|else_block
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|then_block
argument_list|,
name|else_block
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|if_locus
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a general-purpose loop construct.  START_LOCUS is the location of    the beginning of the loop.  COND is the loop condition.  COND_IS_FIRST    is false for DO loops.  INCR is the FOR increment expression.  BODY is    the statement controlled by the loop.  BLAB is the break label.  CLAB is    the continue label.  Everything is allowed to be NULL.  */
end_comment

begin_function
name|void
name|c_finish_loop
parameter_list|(
name|location_t
name|start_locus
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|incr
parameter_list|,
name|tree
name|body
parameter_list|,
name|tree
name|blab
parameter_list|,
name|tree
name|clab
parameter_list|,
name|bool
name|cond_is_first
parameter_list|)
block|{
name|tree
name|entry
init|=
name|NULL
decl_stmt|,
name|exit
init|=
name|NULL
decl_stmt|,
name|t
decl_stmt|;
comment|/* If the condition is zero don't generate a loop construct.  */
if|if
condition|(
name|cond
operator|&&
name|integer_zerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
if|if
condition|(
name|cond_is_first
condition|)
block|{
name|t
operator|=
name|build_and_jump
argument_list|(
operator|&
name|blab
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|start_locus
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|top
init|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* If we have an exit condition, then we build an IF with gotos either 	 out of the loop, or to the top of it.  If there's no exit condition, 	 then we just build a jump back to the top.  */
name|exit
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|top
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
operator|!
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
comment|/* Canonicalize the loop condition to the end.  This means 	     generating a branch to the loop condition.  Reuse the 	     continue label, if possible.  */
if|if
condition|(
name|cond_is_first
condition|)
block|{
if|if
condition|(
name|incr
operator|||
operator|!
name|clab
condition|)
block|{
name|entry
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|clab
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|start_locus
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_and_jump
argument_list|(
operator|&
name|blab
argument_list|)
expr_stmt|;
name|exit
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|exit
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_is_first
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|exit
argument_list|,
name|start_locus
argument_list|)
expr_stmt|;
else|else
name|SET_EXPR_LOCATION
argument_list|(
name|exit
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
block|}
name|add_stmt
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|body
condition|)
name|add_stmt
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|clab
condition|)
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|clab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr
condition|)
name|add_stmt
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|add_stmt
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
condition|)
name|add_stmt
argument_list|(
name|exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|blab
condition|)
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|blab
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|c_finish_bc_stmt
parameter_list|(
name|tree
modifier|*
name|label_p
parameter_list|,
name|bool
name|is_break
parameter_list|)
block|{
name|bool
name|skip
decl_stmt|;
name|tree
name|label
init|=
operator|*
name|label_p
decl_stmt|;
comment|/* In switch statements break is sometimes stylistically used after      a return statement.  This can lead to spurious warnings about      control reaching the end of a non-void function when it is      inlined.  Note that we are calling block_may_fallthru with      language specific tree nodes; this works because      block_may_fallthru returns true when given something it does not      understand.  */
name|skip
operator|=
operator|!
name|block_may_fallthru
argument_list|(
name|cur_stmt_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|label
condition|)
block|{
if|if
condition|(
operator|!
name|skip
condition|)
operator|*
name|label_p
operator|=
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|LABEL_DECL
condition|)
empty_stmt|;
else|else
switch|switch
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|label
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|is_break
condition|)
name|error
argument_list|(
literal|"break statement not within loop or switch"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"continue statement not within a loop"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
case|case
literal|1
case|:
name|gcc_assert
argument_list|(
name|is_break
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"break statement used with OpenMP for loop"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A helper routine for c_process_expr_stmt and c_finish_stmt_expr.  */
end_comment

begin_function
specifier|static
name|void
name|emit_side_effect_warnings
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|expr
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hstatement with no effect"
argument_list|,
name|EXPR_HAS_LOCATION
argument_list|(
name|expr
argument_list|)
condition|?
name|EXPR_LOCUS
argument_list|(
name|expr
argument_list|)
else|:
operator|&
name|input_location
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused_value
condition|)
name|warn_if_unused_value
argument_list|(
name|expr
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process an expression as if it were a complete statement.  Emit    diagnostics, but do not call ADD_STMT.  */
end_comment

begin_function
name|tree
name|c_process_expr_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|warn_sequence_point
condition|)
name|verify_sequence_points
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"expression statement has incomplete type"
argument_list|)
expr_stmt|;
comment|/* If we're not processing a statement expression, warn about unused values.      Warnings for statement expressions will be emitted later, once we figure      out which is the result.  */
if|if
condition|(
operator|!
name|STATEMENT_LIST_STMT_EXPR
argument_list|(
name|cur_stmt_list
argument_list|)
operator|&&
operator|(
name|extra_warnings
operator|||
name|warn_unused_value
operator|)
condition|)
name|emit_side_effect_warnings
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* If the expression is not of a type to which we cannot assign a line      number, wrap the thing in a no-op NOP_EXPR.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
operator|||
name|CONSTANT_CLASS_P
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|expr
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|expr
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Emit an expression as a statement.  */
end_comment

begin_function
name|tree
name|c_finish_expr_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
condition|)
return|return
name|add_stmt
argument_list|(
name|c_process_expr_stmt
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Do the opposite and emit a statement as an expression.  To begin,    create a new binding level and return it.  */
end_comment

begin_function
name|tree
name|c_begin_stmt_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
name|struct
name|c_label_context_se
modifier|*
name|nstack
decl_stmt|;
name|struct
name|c_label_list
modifier|*
name|glist
decl_stmt|;
comment|/* We must force a BLOCK for this level so that, if it is not expanded      later, there is a way to turn off the entire subtree of blocks that      are contained in it.  */
name|keep_next_level
argument_list|()
expr_stmt|;
name|ret
operator|=
name|c_begin_compound_stmt
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_switch_stack
condition|)
block|{
name|c_switch_stack
operator|->
name|blocked_stmt_expr
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|c_switch_stack
operator|->
name|blocked_stmt_expr
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|glist
operator|=
name|label_context_stack_se
operator|->
name|labels_used
init|;
name|glist
operator|!=
name|NULL
condition|;
name|glist
operator|=
name|glist
operator|->
name|next
control|)
block|{
name|C_DECL_UNDEFINABLE_STMT_EXPR
argument_list|(
name|glist
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|nstack
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_context_se
argument_list|)
expr_stmt|;
name|nstack
operator|->
name|labels_def
operator|=
name|NULL
expr_stmt|;
name|nstack
operator|->
name|labels_used
operator|=
name|NULL
expr_stmt|;
name|nstack
operator|->
name|next
operator|=
name|label_context_stack_se
expr_stmt|;
name|label_context_stack_se
operator|=
name|nstack
expr_stmt|;
comment|/* Mark the current statement list as belonging to a statement list.  */
name|STATEMENT_LIST_STMT_EXPR
argument_list|(
name|ret
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|tree
name|c_finish_stmt_expr
parameter_list|(
name|tree
name|body
parameter_list|)
block|{
name|tree
name|last
decl_stmt|,
name|type
decl_stmt|,
name|tmp
decl_stmt|,
name|val
decl_stmt|;
name|tree
modifier|*
name|last_p
decl_stmt|;
name|struct
name|c_label_list
modifier|*
name|dlist
decl_stmt|,
modifier|*
name|glist
decl_stmt|,
modifier|*
name|glist_prev
init|=
name|NULL
decl_stmt|;
name|body
operator|=
name|c_end_compound_stmt
argument_list|(
name|body
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_switch_stack
condition|)
block|{
name|gcc_assert
argument_list|(
name|c_switch_stack
operator|->
name|blocked_stmt_expr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|c_switch_stack
operator|->
name|blocked_stmt_expr
operator|--
expr_stmt|;
block|}
comment|/* It is no longer possible to jump to labels defined within this      statement expression.  */
for|for
control|(
name|dlist
operator|=
name|label_context_stack_se
operator|->
name|labels_def
init|;
name|dlist
operator|!=
name|NULL
condition|;
name|dlist
operator|=
name|dlist
operator|->
name|next
control|)
block|{
name|C_DECL_UNJUMPABLE_STMT_EXPR
argument_list|(
name|dlist
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* It is again possible to define labels with a goto just outside      this statement expression.  */
for|for
control|(
name|glist
operator|=
name|label_context_stack_se
operator|->
name|next
operator|->
name|labels_used
init|;
name|glist
operator|!=
name|NULL
condition|;
name|glist
operator|=
name|glist
operator|->
name|next
control|)
block|{
name|C_DECL_UNDEFINABLE_STMT_EXPR
argument_list|(
name|glist
operator|->
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
name|glist_prev
operator|=
name|glist
expr_stmt|;
block|}
if|if
condition|(
name|glist_prev
operator|!=
name|NULL
condition|)
name|glist_prev
operator|->
name|next
operator|=
name|label_context_stack_se
operator|->
name|labels_used
expr_stmt|;
else|else
name|label_context_stack_se
operator|->
name|next
operator|->
name|labels_used
operator|=
name|label_context_stack_se
operator|->
name|labels_used
expr_stmt|;
name|label_context_stack_se
operator|=
name|label_context_stack_se
operator|->
name|next
expr_stmt|;
comment|/* Locate the last statement in BODY.  See c_end_compound_stmt      about always returning a BIND_EXPR.  */
name|last_p
operator|=
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|last
operator|=
name|BIND_EXPR_BODY
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|continue_searching
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
comment|/* This can happen with degenerate cases like ({ }).  No value.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|last
argument_list|)
condition|)
return|return
name|body
return|;
comment|/* If we're supposed to generate side effects warnings, process 	 all of the statements except the last.  */
if|if
condition|(
name|extra_warnings
operator|||
name|warn_unused_value
condition|)
block|{
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|last
argument_list|)
init|;
operator|!
name|tsi_one_before_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|emit_side_effect_warnings
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
name|tsi_last
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|last_p
operator|=
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|last
operator|=
operator|*
name|last_p
expr_stmt|;
block|}
comment|/* If the end of the list is exception related, then the list was split      by a call to push_cleanup.  Continue searching.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|TRY_FINALLY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|TRY_CATCH_EXPR
condition|)
block|{
name|last_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
operator|*
name|last_p
expr_stmt|;
goto|goto
name|continue_searching
goto|;
block|}
comment|/* In the case that the BIND_EXPR is not necessary, return the      expression out from inside it.  */
if|if
condition|(
name|last
operator|==
name|error_mark_node
operator|||
operator|(
name|last
operator|==
name|BIND_EXPR_BODY
argument_list|(
name|body
argument_list|)
operator|&&
name|BIND_EXPR_VARS
argument_list|(
name|body
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Do not warn if the return value of a statement expression is 	 unused.  */
if|if
condition|(
name|EXPR_P
argument_list|(
name|last
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|last
return|;
block|}
comment|/* Extract the type of said expression.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If we're not returning a value at all, then the BIND_EXPR that      we already have is a fine expression to return.  */
if|if
condition|(
operator|!
name|type
operator|||
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|body
return|;
comment|/* Now that we've located the expression containing the value, it seems      silly to make voidify_wrapper_expr repeat the process.  Create a      temporary of the appropriate type and stick it in a TARGET_EXPR.  */
name|tmp
operator|=
name|create_tmp_var_raw
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Unwrap a no-op NOP_EXPR as added by c_finish_expr_stmt.  This avoids      tree_expr_nonnegative_p giving up immediately.  */
name|val
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|last_p
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tmp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
operator|*
name|last_p
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build4
argument_list|(
name|TARGET_EXPR
argument_list|,
name|type
argument_list|,
name|tmp
argument_list|,
name|body
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Begin the scope of an identifier of variably modified type, scope    number SCOPE.  Jumping from outside this scope to inside it is not    permitted.  */
end_comment

begin_function
name|void
name|c_begin_vm_scope
parameter_list|(
name|unsigned
name|int
name|scope
parameter_list|)
block|{
name|struct
name|c_label_context_vm
modifier|*
name|nstack
decl_stmt|;
name|struct
name|c_label_list
modifier|*
name|glist
decl_stmt|;
name|gcc_assert
argument_list|(
name|scope
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* At file_scope, we don't have to do any processing.  */
if|if
condition|(
name|label_context_stack_vm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|c_switch_stack
operator|&&
operator|!
name|c_switch_stack
operator|->
name|blocked_vm
condition|)
name|c_switch_stack
operator|->
name|blocked_vm
operator|=
name|scope
expr_stmt|;
for|for
control|(
name|glist
operator|=
name|label_context_stack_vm
operator|->
name|labels_used
init|;
name|glist
operator|!=
name|NULL
condition|;
name|glist
operator|=
name|glist
operator|->
name|next
control|)
block|{
name|C_DECL_UNDEFINABLE_VM
argument_list|(
name|glist
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|nstack
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_context_vm
argument_list|)
expr_stmt|;
name|nstack
operator|->
name|labels_def
operator|=
name|NULL
expr_stmt|;
name|nstack
operator|->
name|labels_used
operator|=
name|NULL
expr_stmt|;
name|nstack
operator|->
name|scope
operator|=
name|scope
expr_stmt|;
name|nstack
operator|->
name|next
operator|=
name|label_context_stack_vm
expr_stmt|;
name|label_context_stack_vm
operator|=
name|nstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a scope which may contain identifiers of variably modified    type, scope number SCOPE.  */
end_comment

begin_function
name|void
name|c_end_vm_scope
parameter_list|(
name|unsigned
name|int
name|scope
parameter_list|)
block|{
if|if
condition|(
name|label_context_stack_vm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|c_switch_stack
operator|&&
name|c_switch_stack
operator|->
name|blocked_vm
operator|==
name|scope
condition|)
name|c_switch_stack
operator|->
name|blocked_vm
operator|=
literal|0
expr_stmt|;
comment|/* We may have a number of nested scopes of identifiers with      variably modified type, all at this depth.  Pop each in turn.  */
while|while
condition|(
name|label_context_stack_vm
operator|->
name|scope
operator|==
name|scope
condition|)
block|{
name|struct
name|c_label_list
modifier|*
name|dlist
decl_stmt|,
modifier|*
name|glist
decl_stmt|,
modifier|*
name|glist_prev
init|=
name|NULL
decl_stmt|;
comment|/* It is no longer possible to jump to labels defined within this 	 scope.  */
for|for
control|(
name|dlist
operator|=
name|label_context_stack_vm
operator|->
name|labels_def
init|;
name|dlist
operator|!=
name|NULL
condition|;
name|dlist
operator|=
name|dlist
operator|->
name|next
control|)
block|{
name|C_DECL_UNJUMPABLE_VM
argument_list|(
name|dlist
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* It is again possible to define labels with a goto just outside 	 this scope.  */
for|for
control|(
name|glist
operator|=
name|label_context_stack_vm
operator|->
name|next
operator|->
name|labels_used
init|;
name|glist
operator|!=
name|NULL
condition|;
name|glist
operator|=
name|glist
operator|->
name|next
control|)
block|{
name|C_DECL_UNDEFINABLE_VM
argument_list|(
name|glist
operator|->
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
name|glist_prev
operator|=
name|glist
expr_stmt|;
block|}
if|if
condition|(
name|glist_prev
operator|!=
name|NULL
condition|)
name|glist_prev
operator|->
name|next
operator|=
name|label_context_stack_vm
operator|->
name|labels_used
expr_stmt|;
else|else
name|label_context_stack_vm
operator|->
name|next
operator|->
name|labels_used
operator|=
name|label_context_stack_vm
operator|->
name|labels_used
expr_stmt|;
name|label_context_stack_vm
operator|=
name|label_context_stack_vm
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin and end compound statements.  This is as simple as pushing    and popping new statement lists from the tree.  */
end_comment

begin_function
name|tree
name|c_begin_compound_stmt
parameter_list|(
name|bool
name|do_scope
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|push_stmt_list
argument_list|()
decl_stmt|;
if|if
condition|(
name|do_scope
condition|)
name|push_scope
argument_list|()
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_function
name|tree
name|c_end_compound_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
name|do_scope
parameter_list|)
block|{
name|tree
name|block
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|do_scope
condition|)
block|{
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
name|objc_clear_super_receiver
argument_list|()
expr_stmt|;
name|block
operator|=
name|pop_scope
argument_list|()
expr_stmt|;
block|}
name|stmt
operator|=
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_build_bind_expr
argument_list|(
name|block
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|/* If this compound statement is nested immediately inside a statement      expression, then force a BIND_EXPR to be created.  Otherwise we'll      do the wrong thing for ({ { 1; } }) or ({ 1; { } }).  In particular,      STATEMENT_LISTs merge, and thus we can lose track of what statement      was really last.  */
if|if
condition|(
name|cur_stmt_list
operator|&&
name|STATEMENT_LIST_STMT_EXPR
argument_list|(
name|cur_stmt_list
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|BIND_EXPR
condition|)
block|{
name|stmt
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* Queue a cleanup.  CLEANUP is an expression/statement to be executed    when the current scope is exited.  EH_ONLY is true when this is not    meant to apply to normal control flow transfer.  */
end_comment

begin_function
name|void
name|push_cleanup
parameter_list|(
name|tree
name|ARG_UNUSED
parameter_list|(
name|decl
parameter_list|)
parameter_list|,
name|tree
name|cleanup
parameter_list|,
name|bool
name|eh_only
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|list
decl_stmt|;
name|bool
name|stmt_expr
decl_stmt|;
name|code
operator|=
name|eh_only
condition|?
name|TRY_CATCH_EXPR
else|:
name|TRY_FINALLY_EXPR
expr_stmt|;
name|stmt
operator|=
name|build_stmt
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|STATEMENT_LIST_STMT_EXPR
argument_list|(
name|cur_stmt_list
argument_list|)
expr_stmt|;
name|list
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|list
expr_stmt|;
name|STATEMENT_LIST_STMT_EXPR
argument_list|(
name|list
argument_list|)
operator|=
name|stmt_expr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     Note that the operands will never have enumeral types, or function    or array types, because either they will have the default conversions    performed or they have both just been converted to some other type in which    the arithmetic is to be done.  */
end_comment

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|orig_op0
parameter_list|,
name|tree
name|orig_op1
parameter_list|,
name|int
name|convert_p
parameter_list|)
block|{
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_op_diag
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means create the expression with this type, rather than      RESULT_TYPE.  */
name|tree
name|build_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      convert it to this type.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|/* True means types are compatible as far as ObjC is concerned.  */
name|bool
name|objc_ok
decl_stmt|;
if|if
condition|(
name|convert_p
condition|)
block|{
name|op0
operator|=
name|default_conversion
argument_list|(
name|orig_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|default_conversion
argument_list|(
name|orig_op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|orig_op0
expr_stmt|;
name|op1
operator|=
name|orig_op1
expr_stmt|;
block|}
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|invalid_op_diag
operator|=
name|targetm
operator|.
name|invalid_binary_op
argument_list|(
name|code
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
name|invalid_op_diag
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|objc_ok
operator|=
name|objc_compare_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
operator|-
literal|3
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* Floating point division by zero is a legitimate way to obtain 	 infinities and NaNs.  */
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wdiv_by_zero
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|||
name|code0
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
name|enum
name|tree_code
name|tcode0
init|=
name|code0
decl_stmt|,
name|tcode1
init|=
name|code1
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|COMPLEX_TYPE
operator|||
name|code0
operator|==
name|VECTOR_TYPE
condition|)
name|tcode0
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
condition|)
name|tcode1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tcode0
operator|==
name|INTEGER_TYPE
operator|&&
name|tcode1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
comment|/* Although it would be tempting to shorten always here, that 	       loses on some targets, since the modulo instruction is 	       undefined if the quotient can't be represented in the 	       computation mode.  We shorten only if unsigned or if 	       dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|VECTOR_TYPE
operator|&&
name|code1
operator|==
name|VECTOR_TYPE
condition|)
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wdiv_by_zero
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Although it would be tempting to shorten always here, that loses 	     on some targets, since the modulo instruction is undefined if the 	     quotient can't be represented in the computation mode.  We shorten 	     only if unsigned or if dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|POINTER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
comment|/* Result of these operations is always an int, 	     but that does not mean the operands should be 	     converted to ints!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"right shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"right shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use the type of the value to be shifted.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of size 	     of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"left shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"left shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use the type of the value to be shifted.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of size 	     of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
condition|)
name|warning
argument_list|(
name|OPT_Wfloat_equal
argument_list|,
literal|"comparing floating point with == or != is unsafe"
argument_list|)
expr_stmt|;
comment|/* Result of comparison is always int, 	 but don't convert the args to int!  */
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|tt0
init|=
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
decl_stmt|;
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
decl_stmt|;
comment|/* Anything compares with void *.  void * compares with anything. 	     Otherwise, the targets must be compatible 	     and both must be object or both incomplete.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
name|result_type
operator|=
name|common_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|tt0
argument_list|)
condition|)
block|{
comment|/* op0 != orig_op0 detects the case of something 		 whose value is 0 but which isn't a valid null ptr const.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|null_pointer_constant_p
argument_list|(
name|orig_op0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids comparison of %<void *%>"
literal|" with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|tt1
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|null_pointer_constant_p
argument_list|(
name|orig_op1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids comparison of %<void *%>"
literal|" with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Avoid warning about the volatile ObjC EH puts on decls.  */
if|if
condition|(
operator|!
name|objc_ok
condition|)
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|==
name|NULL_TREE
condition|)
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|null_pointer_constant_p
argument_list|(
name|orig_op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
operator|||
operator|!
name|DECL_WEAK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"the address of %qD will never be NULL"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|null_pointer_constant_p
argument_list|(
name|orig_op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
operator|||
operator|!
name|DECL_WEAK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"the address of %qD will never be NULL"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|common_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|!=
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"comparison of complete and incomplete pointers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|null_pointer_constant_p
argument_list|(
name|orig_op1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|extra_warnings
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|null_pointer_constant_p
argument_list|(
name|orig_op0
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|code0
operator|==
name|VECTOR_TYPE
operator|&&
name|code1
operator|==
name|VECTOR_TYPE
operator|&&
operator|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|||
operator|!
name|same_scalar_type_ignoring_signedness
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|binary_op_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|||
name|code0
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
name|int
name|none_complex
init|=
operator|(
name|code0
operator|!=
name|COMPLEX_TYPE
operator|&&
name|code1
operator|!=
name|COMPLEX_TYPE
operator|)
decl_stmt|;
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|c_common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
operator|&&
name|none_complex
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|int
name|uns
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Cast OP0 and OP1 to RESULT_TYPE.  Doing so prevents 	     excessive narrowing when we call get_narrower below.  For 	     example, suppose that OP0 is of unsigned int extended 	     from signed char and that RESULT_TYPE is long long int. 	     If we explicitly cast OP0 to RESULT_TYPE, OP0 would look 	     like  	       (long long int) (unsigned int) signed_char  	     which get_narrower would narrow down to  	       (unsigned int) signed char  	     If we do not cast OP0 first, get_narrower would return 	     signed_char, which is inconsistent with the case of the 	     explicit cast.  */
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
expr_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|uns
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 (or OP1) does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* We can shorten only if the shift count is less than the 		 number of bits in the smaller type size.  */
operator|&&
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* We cannot drop an unsigned shift after sign-extension.  */
operator|&&
operator|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
if|if
condition|(
name|warn_sign_compare
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
name|int
name|op0_signed
init|=
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op1_signed
init|=
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|tree
name|primop0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
decl_stmt|;
name|tree
name|primop1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
decl_stmt|;
name|xop0
operator|=
name|orig_op0
expr_stmt|;
name|xop1
operator|=
name|orig_op1
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|xop0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|xop1
argument_list|)
expr_stmt|;
comment|/* Give warnings for comparisons between signed and unsigned 		 quantities that may fail.  		 Do the checking based on the original operand trees, so that 		 casts will be considered, but default promotions won't be.  		 Do not warn if the comparison is being done in a signed type, 		 since the signed type will only be chosen if it can represent 		 all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if both operands are the same signedness.  */
elseif|else
if|if
condition|(
name|op0_signed
operator|==
name|op1_signed
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
name|tree
name|sop
decl_stmt|,
name|uop
decl_stmt|;
name|bool
name|ovf
decl_stmt|;
if|if
condition|(
name|op0_signed
condition|)
name|sop
operator|=
name|xop0
operator|,
name|uop
operator|=
name|xop1
expr_stmt|;
else|else
name|sop
operator|=
name|xop1
operator|,
name|uop
operator|=
name|xop0
expr_stmt|;
comment|/* Do not warn if the signed quantity is an 		     unsuffixed integer literal (or some static 		     constant expression involving such literals or a 		     conditional expression involving such literals) 		     and it is non-negative.  */
if|if
condition|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|sop
argument_list|,
operator|&
name|ovf
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the comparison is an equality operation, 		     the unsigned quantity is an integral constant, and it 		     would fit in the result if the result were signed.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|uop
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|resultcode
operator|==
name|EQ_EXPR
operator|||
name|resultcode
operator|==
name|NE_EXPR
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|uop
argument_list|,
name|c_common_signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the unsigned quantity is an enumeration 		     constant and its maximum value would fit in the result 		     if the result were signed.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|uop
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|uop
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|int_fits_type_p
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|uop
argument_list|)
argument_list|)
argument_list|,
name|c_common_signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison between signed and unsigned"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn if two unsigned values are being compared in a size 		 larger than their original size, and one (and only one) is the 		 result of a `~' operator.  This comparison will always fail.  		 Also warn if one operand is a constant, and the constant 		 does not have all bits set that are set in the ~ operand 		 when it is extended.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
operator|!=
operator|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop0
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
else|else
name|primop1
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
operator|||
name|host_integerp
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|primop
decl_stmt|;
name|HOST_WIDE_INT
name|constant
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|bits
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|primop
operator|=
name|primop1
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp1
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primop
operator|=
name|primop0
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp0
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
name|bits
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|unsignedp
condition|)
block|{
name|mask
operator|=
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|constant
operator|)
operator|!=
name|mask
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison of promoted ~unsigned with constant"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsignedp0
operator|&&
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison of promoted ~unsigned with unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|binary_op_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* This can happen if one operand has a vector type, and the other 	 has a different type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|build_type
operator|==
name|NULL_TREE
condition|)
name|build_type
operator|=
name|result_type
expr_stmt|;
block|{
comment|/* Treat expressions in initializers specially as they can't trap.  */
name|tree
name|result
init|=
name|require_constant_value
condition|?
name|fold_build2_initializer
argument_list|(
name|resultcode
argument_list|,
name|build_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
else|:
name|fold_build2
argument_list|(
name|resultcode
argument_list|,
name|build_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
name|result
operator|=
name|convert
argument_list|(
name|final_type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert EXPR to be a truth-value, validating its type for this    purpose.  */
end_comment

begin_function
name|tree
name|c_objc_common_truthvalue_conversion
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
name|error
argument_list|(
literal|"used array that cannot be converted to pointer where scalar is required"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|RECORD_TYPE
case|:
name|error
argument_list|(
literal|"used struct type value where scalar is required"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|UNION_TYPE
case|:
name|error
argument_list|(
literal|"used union type value where scalar is required"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|FUNCTION_TYPE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
comment|/* ??? Should we also give an error for void and vectors rather than      leaving those to give errors later?  */
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert EXPR to a contained DECL, updating *TC, *TI and *SE as    required.  */
end_comment

begin_function
name|tree
name|c_expr_to_decl
parameter_list|(
name|tree
name|expr
parameter_list|,
name|bool
modifier|*
name|tc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|ti
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|se
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
condition|)
block|{
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* Executing a compound literal inside a function reinitializes 	 it.  */
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
operator|*
name|se
operator|=
name|true
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
return|return
name|expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like c_begin_compound_stmt, except force the retention of the BLOCK.  */
end_comment

begin_function
name|tree
name|c_begin_omp_parallel
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|block
decl_stmt|;
name|keep_next_level
argument_list|()
expr_stmt|;
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|true
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_function
name|tree
name|c_finish_omp_parallel
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
name|block
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|block
operator|=
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|make_node
argument_list|(
name|OMP_PARALLEL
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|clauses
expr_stmt|;
name|OMP_PARALLEL_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|block
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For all elements of CLAUSES, validate them vs OpenMP constraints.    Remove any elements from the list that are invalid.  */
end_comment

begin_function
name|tree
name|c_finish_omp_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|)
block|{
name|bitmap_head
name|generic_head
decl_stmt|,
name|firstprivate_head
decl_stmt|,
name|lastprivate_head
decl_stmt|;
name|tree
name|c
decl_stmt|,
name|t
decl_stmt|,
modifier|*
name|pc
init|=
operator|&
name|clauses
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bitmap_obstack_initialize
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|generic_head
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
for|for
control|(
name|pc
operator|=
operator|&
name|clauses
operator|,
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
operator|*
name|pc
control|)
block|{
name|bool
name|remove
init|=
name|false
decl_stmt|;
name|bool
name|need_complete
init|=
name|false
decl_stmt|;
name|bool
name|need_implicitly_determined
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_SHARED
case|:
name|name
operator|=
literal|"shared"
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_PRIVATE
case|:
name|name
operator|=
literal|"private"
expr_stmt|;
name|need_complete
operator|=
name|true
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|name
operator|=
literal|"reduction"
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE has invalid type for %<reduction%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|r_code
init|=
name|OMP_CLAUSE_REDUCTION_CODE
argument_list|(
name|c
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|r_name
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r_code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|r_name
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|r_name
operator|=
literal|"^"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|r_name
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|r_name
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|r_name
operator|=
literal|"||"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|r_name
condition|)
block|{
name|error
argument_list|(
literal|"%qE has invalid type for %<reduction(%s)%>"
argument_list|,
name|t
argument_list|,
name|r_name
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
block|}
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
name|name
operator|=
literal|"copyprivate"
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_COPYIN
case|:
name|name
operator|=
literal|"copyin"
expr_stmt|;
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE must be %<threadprivate%> for %<copyin%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
goto|goto
name|check_dup_generic
goto|;
name|check_dup_generic
label|:
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a variable in clause %qs"
argument_list|,
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE appears more than once in data clauses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
else|else
name|bitmap_set_bit
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
name|name
operator|=
literal|"firstprivate"
expr_stmt|;
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|need_complete
operator|=
name|true
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a variable in clause %<firstprivate%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE appears more than once in data clauses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
else|else
name|bitmap_set_bit
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
name|name
operator|=
literal|"lastprivate"
expr_stmt|;
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|need_complete
operator|=
name|true
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a variable in clause %<lastprivate%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE appears more than once in data clauses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
else|else
name|bitmap_set_bit
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
name|pc
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|remove
condition|)
block|{
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_complete
condition|)
block|{
name|t
operator|=
name|require_complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
name|remove
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|need_implicitly_determined
condition|)
block|{
specifier|const
name|char
modifier|*
name|share_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|t
argument_list|)
condition|)
name|share_name
operator|=
literal|"threadprivate"
expr_stmt|;
else|else
switch|switch
condition|(
name|c_omp_predetermined_sharing
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
case|:
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_SHARED
case|:
name|share_name
operator|=
literal|"shared"
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_PRIVATE
case|:
name|share_name
operator|=
literal|"private"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|share_name
condition|)
block|{
name|error
argument_list|(
literal|"%qE is predetermined %qs for %qs"
argument_list|,
name|t
argument_list|,
name|share_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|remove
condition|)
operator|*
name|pc
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|pc
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|bitmap_obstack_release
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|clauses
return|;
block|}
end_function

end_unit

