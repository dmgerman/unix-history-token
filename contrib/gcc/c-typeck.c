begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C compiler.    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It contains routines to build C expressions given their operands,    including computing the types of the result, C-specific error checks,    and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Nonzero if we've already printed a "missing braces around initializer"    message within this initializer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|missing_braces_mentioned
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if we explained undeclared var errors.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|undeclared_variable_notice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|qualify_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_target_types
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_types_compatible_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_lists_compatible_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_constant_value_for_broken_optimization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|default_function_array_conversion
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_arguments
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|pointer_diff
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unary_complex_lvalue
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pedantic_lvalue_warning
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|internal_build_compound_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_for_assignment
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_for_assignment
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|valid_compound_expr_initializer
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_member_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_array_bounds
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spelling_length
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|print_spelling
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warning_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|digest_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_init_element
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pending_init_elements
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_designator
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_range_stack
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pending_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_nonincremental_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_nonincremental_init_from_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|find_init_member
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|value
return|;
name|c_incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|c_incomplete_type_error
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|type_code_string
decl_stmt|;
comment|/* Avoid duplicate error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
name|error
argument_list|(
literal|"`%s' has an incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|retry
label|:
comment|/* We must print an error message.  Be clever about what it says.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|type_code_string
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|type_code_string
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|type_code_string
operator|=
literal|"enum"
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of flexible array member"
argument_list|)
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"invalid use of undefined type `%s %s'"
argument_list|,
name|type_code_string
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
name|error
argument_list|(
literal|"invalid use of incomplete typedef `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a type, apply default promotions wrt unnamed function    arguments and return the new type.  */
end_comment

begin_function
name|tree
name|c_type_promotes_to
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Preserve unsignedness if not really getting any wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
return|return
name|unsigned_type_node
return|;
return|return
name|integer_type_node
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|type
parameter_list|,
name|like
parameter_list|)
name|tree
name|type
decl_stmt|,
name|like
decl_stmt|;
block|{
return|return
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|like
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.  In particular, we assume that qualifiers    match.     This is the type for the result of most arithmetic operations    if the operands have the given two types.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* If one type is complex, form the common type of the non-complex      components, then make that complex.  Use T1 or T2 if it is the      required type.  */
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|subtype1
init|=
name|code1
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
decl_stmt|;
name|tree
name|subtype2
init|=
name|code2
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
else|:
name|t2
decl_stmt|;
name|tree
name|subtype
init|=
name|common_type
argument_list|(
name|subtype1
argument_list|,
name|subtype2
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|build_complex_type
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|attributes
argument_list|)
return|;
block|}
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Same precision.  Prefer longs to ints even when same size.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_unsigned_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	     since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
name|t1
operator|=
name|long_unsigned_type_node
expr_stmt|;
else|else
name|t1
operator|=
name|long_integer_type_node
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* Likewise, prefer long double to double even if same size.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_double_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_double_type_node
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_double_type_node
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type, 	 and combine the qualifiers of the two types' targets.  */
comment|/* This code was turned off; I don't know why. 	 But ANSI C specifies doing this with the qualifiers. 	 So I turned it on again.  */
block|{
name|tree
name|pointed_to_1
init|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|pointed_to_2
init|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|target
init|=
name|common_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|pointed_to_1
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|pointed_to_2
argument_list|)
argument_list|)
decl_stmt|;
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|target
argument_list|,
name|TYPE_QUALS
argument_list|(
name|pointed_to_1
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|pointed_to_2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
block|t1 = build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));       return build_type_attribute_variant (t1, attributes);
endif|#
directive|endif
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
name|t1
operator|=
name|build_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* If both args specify argument types, we must merge the two 	   lists, argument by argument.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_parm_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
control|)
block|{
comment|/* A null type means arg type is not specified. 	       Take whatever the other function type has.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
comment|/* Given  wait (union {union wait *u; int *i} *) 	       and  wait (union wait *), 	       prefer  union wait *  as type of parm.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ISO C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ISO C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|common_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|parm_done
label|:
empty_stmt|;
block|}
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
comment|/* ... falls through ...  */
block|}
default|default:
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  Return 2 if they are compatible    but a warning may be needed if you use them together.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
block|{
name|tree
name|t1
init|=
name|type1
decl_stmt|;
name|tree
name|t2
init|=
name|type2
decl_stmt|;
name|int
name|attrval
decl_stmt|,
name|val
decl_stmt|;
comment|/* Suppress errors caused by previously reported errors.  */
if|if
condition|(
name|t1
operator|==
name|t2
operator|||
operator|!
name|t1
operator|||
operator|!
name|t2
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* If either type is the internal version of sizetype, return the      language version.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
operator|!=
literal|0
condition|)
name|t1
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
operator|!=
literal|0
condition|)
name|t2
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Treat an enum type as the integer type of the same width and       signedness.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow for two different type nodes which have essentially the same      definition.  Note that we already checked for equality of the type      qualifiers (just above).  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
if|if
condition|(
operator|!
operator|(
name|attrval
operator|=
call|(
modifier|*
name|targetm
operator|.
name|comp_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
name|val
operator|=
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|?
literal|1
else|:
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|val
operator|=
name|function_types_compatible_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|bool
name|d1_variable
decl_stmt|,
name|d2_variable
decl_stmt|;
name|bool
name|d1_zero
decl_stmt|,
name|d2_zero
decl_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
comment|/* Target types must match incl. qualifiers.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
literal|0
operator|==
operator|(
name|val
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Sizes must match unless one is missing or variable.  */
if|if
condition|(
name|d1
operator|==
literal|0
operator|||
name|d2
operator|==
literal|0
operator|||
name|d1
operator|==
name|d2
condition|)
break|break;
name|d1_zero
operator|=
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d2_zero
operator|=
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|d1_variable
operator|=
operator|(
operator|!
name|d1_zero
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
expr_stmt|;
name|d2_variable
operator|=
operator|(
operator|!
name|d2_zero
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|d1_variable
operator|||
name|d2_variable
condition|)
break|break;
if|if
condition|(
name|d1_zero
operator|&&
name|d2_zero
condition|)
break|break;
if|if
condition|(
name|d1_zero
operator|||
name|d2_zero
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|flag_objc
operator|&&
name|objc_comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
name|val
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|attrval
operator|==
literal|2
operator|&&
name|val
operator|==
literal|1
condition|?
literal|2
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers.  REFLEXIVE is only used by ObjC - set it    to 1 or 0 depending if the check of the pointer types is meant to    be reflexive or not (typically, assignments are not reflexive,    while comparisons are reflexive). */
end_comment

begin_function
specifier|static
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|,
name|reflexive
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|reflexive
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
comment|/* Give objc_comptypes a crack at letting these types through.  */
if|if
condition|(
operator|(
name|val
operator|=
name|objc_comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|reflexive
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|val
return|;
name|val
operator|=
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"types are not quite compatible"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two function types F1 and F2 are compatible.    If either type specifies no argument types,    the other must specify a fixed number of self-promoting arg types.    Otherwise, if one type specifies only the number of arguments,     the other must specify that number of self-promoting arg types.    Otherwise, the argument types must match.  */
end_comment

begin_function
specifier|static
name|int
name|function_types_compatible_p
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
name|tree
name|f1
decl_stmt|,
name|f2
decl_stmt|;
block|{
name|tree
name|args1
decl_stmt|,
name|args2
decl_stmt|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|val1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
operator|||
operator|(
name|val
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|args1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
expr_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|args1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If one of these types comes from a non-prototype fn definition, 	 compare that with the other type's arglist. 	 If they don't match, ask for a warning (but no error).  */
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args2
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|args2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Both types have argument lists: compare them and propagate results.  */
name|val1
operator|=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|args2
argument_list|)
expr_stmt|;
return|return
name|val1
operator|!=
literal|1
condition|?
name|val1
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Check two lists of types for compatibility,    returning 0 for incompatible, 1 for compatible,    or 2 for compatible with warning.  */
end_comment

begin_function
specifier|static
name|int
name|type_lists_compatible_p
parameter_list|(
name|args1
parameter_list|,
name|args2
parameter_list|)
name|tree
name|args1
decl_stmt|,
name|args2
decl_stmt|;
block|{
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|newval
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|args1
operator|==
literal|0
operator|&&
name|args2
operator|==
literal|0
condition|)
return|return
name|val
return|;
comment|/* If one list is shorter than the other, 	 they fail to match.  */
if|if
condition|(
name|args1
operator|==
literal|0
operator|||
name|args2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* A null pointer instead of a type 	 means there is supposed to be an argument 	 but nothing is specified about what type it has. 	 So match anything that self-promotes.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c_type_promotes_to
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c_type_promotes_to
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|newval
operator|=
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Allow  wait (union {union wait *u; int *i} *) 	     and  wait (union wait *)  to be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* comptypes said ok, but record if it said to warn.  */
if|if
condition|(
name|newval
operator|>
name|val
condition|)
name|val
operator|=
name|newval
expr_stmt|;
name|args1
operator|=
name|TREE_CHAIN
argument_list|(
name|args1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TREE_CHAIN
argument_list|(
name|args2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the size to increment a pointer by.  */
end_comment

begin_function
name|tree
name|c_size_in_bytes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_one_node
return|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
return|return
name|size_one_node
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
return|return
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
comment|/* Don't change a variable array bound or initial value to a constant 	 in a place where a variable is invalid.  */
name|current_function_decl
operator|!=
literal|0
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return either DECL or its known constant value (if it has one), but    return DECL if pedantic or DECL has mode BLKmode.  This is for    bug-compatibility with the old behavior of decl_constant_value    (before GCC 3.0); every use of this function is a bug and it should    be removed before GCC 3.1.  It is not appropriate to use pedantic    in a way that affects optimization, and BLKmode is probably not the    right test for avoiding misoptimizations either.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_constant_value_for_broken_optimization
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|pedantic
operator|||
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|decl
return|;
else|else
return|return
name|decl_constant_value
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform the default conversion of arrays and functions to pointers.    Return the result of converting EXP.  For any other expression, just    return EXP.  */
end_comment

begin_function
specifier|static
name|tree
name|default_function_array_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|orig_exp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|not_lvalue
init|=
literal|0
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as      an lvalue.        Do not use STRIP_NOPS here!  It will remove conversions from pointer      to integer and cause infinite recursion.  */
name|orig_exp
operator|=
name|exp
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|not_lvalue
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Preserve the original expression code.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|exp
argument_list|,
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|orig_exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|adr
decl_stmt|;
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
name|int
name|constp
init|=
literal|0
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|int
name|lvalue_array_p
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|constp
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|||
name|constp
operator|||
name|volatilep
condition|)
name|restype
operator|=
name|c_build_qualified_type
argument_list|(
name|restype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
operator|(
name|constp
operator|*
name|TYPE_QUAL_CONST
operator|)
operator||
operator|(
name|volatilep
operator|*
name|TYPE_QUAL_VOLATILE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|restype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|default_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
name|lvalue_array_p
operator|=
operator|!
name|not_lvalue
operator|&&
name|lvalue_p
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_isoc99
operator|&&
operator|!
name|lvalue_array_p
condition|)
block|{
comment|/* Before C99, non-lvalue arrays do not decay to pointers. 	     Normally, using such an array would be invalid; but it can 	     be used correctly inside sizeof or as a statement expression. 	     Thus, do not give an error here; an error will result later.  */
return|return
name|exp
return|;
block|}
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|TREE_CONSTANT
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Perform default promotions for C data used in expressions.    Arrays and functions are converted to pointers;    enumeral types or short or char, to int.    In addition, manifest constants symbols are replaced by their values.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|orig_exp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|default_function_array_conversion
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Constants can be used directly unless they're not loadable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value unless      it is an array, in which case we must be sure that taking the      address of the array produces consistent results.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|code
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|exp
operator|=
name|decl_constant_value_for_broken_optimization
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as      an lvalue.        Do not use STRIP_NOPS here!  It will remove conversions from pointer      to integer and cause infinite recursion.  */
name|orig_exp
operator|=
name|exp
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Preserve the original expression code.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|exp
argument_list|,
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|orig_exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Normally convert enums to int,      but convert wide enums to something wider.  */
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|type
operator|=
name|c_common_type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
comment|/* If it's thinner than an int, promote it like a 	 c_promoting_integer_type_p, otherwise leave it alone.  */
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Preserve unsignedness if not really getting any wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up COMPONENT in a structure or union DECL.     If the component name is not found, returns NULL_TREE.  Otherwise,    the return value is a TREE_LIST, with each TREE_VALUE a FIELD_DECL    stepping down the chain to the component, which is in the last    TREE_VALUE of the list.  Normally the list is of length one, but if    the component is embedded within (nested) anonymous structures or    unions, the list steps down the chain to the component.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field
parameter_list|(
name|decl
parameter_list|,
name|component
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|component
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|;
comment|/* If TYPE_LANG_SPECIFIC is set, then it is a sorted array of pointers      to the field elements.  Use a binary search on this array to quickly      find the element.  Otherwise, do a linear search.  TYPE_LANG_SPECIFIC      will always be set for structures which have many elements.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
name|tree
modifier|*
name|field_array
init|=
operator|&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|elts
index|[
literal|0
index|]
decl_stmt|;
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|field
operator|=
name|field_array
index|[
name|bot
operator|+
name|half
index|]
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Step through all anon unions in linear fashion.  */
while|while
condition|(
name|DECL_NAME
argument_list|(
name|field_array
index|[
name|bot
index|]
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|field
operator|=
name|field_array
index|[
name|bot
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|anon
init|=
name|lookup_field
argument_list|(
name|field
argument_list|,
name|component
argument_list|)
decl_stmt|;
if|if
condition|(
name|anon
condition|)
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|anon
argument_list|)
return|;
block|}
block|}
comment|/* Entire record is only anon unions.  */
if|if
condition|(
name|bot
operator|>
name|top
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Restart the binary search, with new lower bound.  */
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|<
name|component
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_array
index|[
name|bot
index|]
argument_list|)
operator|==
name|component
condition|)
name|field
operator|=
name|field_array
index|[
name|bot
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|component
condition|)
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|tree
name|anon
init|=
name|lookup_field
argument_list|(
name|field
argument_list|,
name|component
argument_list|)
decl_stmt|;
if|if
condition|(
name|anon
condition|)
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|anon
argument_list|)
return|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
block|}
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an expression to refer to the COMPONENT field of    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|NULL
decl_stmt|;
name|tree
name|ref
decl_stmt|;
comment|/* If DATUM is a COMPOUND_EXPR, move our reference inside it.      If pedantic ensure that the arguments are not lvalues; otherwise,      if the component is an array, it would wrongly decay to a pointer in      C89 mode.      We cannot do this with a COND_EXPR, because in a conditional expression      the default promotions are applied to both sides, and this would yield      the wrong type of the result; for example, if the components have      type "char".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pedantic_non_lvalue
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* See if there is a field or component with name COMPONENT.  */
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|c_incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|field
operator|=
name|lookup_field
argument_list|(
name|datum
argument_list|,
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
literal|"%s has no member named `%s'"
argument_list|,
name|code
operator|==
name|RECORD_TYPE
condition|?
literal|"structure"
else|:
literal|"union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Chain the COMPONENT_REFs if necessary down to the FIELD. 	 This might be better solved in future the way the C++ front 	 end does it - by giving the anonymous entities each a 	 separate name and type, and then have build_component_ref 	 recursively call itself.  We can't do that here.  */
do|do
block|{
name|tree
name|subdatum
init|=
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|subdatum
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|subdatum
argument_list|)
argument_list|,
name|datum
argument_list|,
name|subdatum
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|subdatum
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|subdatum
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|subdatum
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|subdatum
argument_list|)
expr_stmt|;
name|datum
operator|=
name|ref
expr_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field
condition|)
do|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%s' in something not a structure or union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.  */
end_comment

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
name|tree
name|pointer
init|=
name|default_conversion
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|!
name|flag_volatile
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"dereferencing pointer to incomplete type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"dereferencing `void *' pointer"
argument_list|)
expr_stmt|;
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	     so that we get the proper error message if the result is used 	     to assign to.  Also,&* is supposed to be a no-op. 	     And ANSI C seems to specify that the type of the result 	     should be the const type.  */
comment|/* A de-reference of a pointer to const is not a const.  It is valid 	     to change it via some other pointer.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
operator|||
name|flag_volatile
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|index
parameter_list|)
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
comment|/* Subscripting with type char is likely to lose 	 on a machine where chars are signed. 	 So warn on any machine, but optionally. 	 Don't warn for unsigned char since that type is safe. 	 Don't warn for signed char because anyone who uses that 	 must have done so deliberately.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"array subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Apply default promotions *after* noticing character types.  */
name|index
operator|=
name|default_conversion
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|/* Require integer *after* promotion, for sake of enums.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|array
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a constant value which is not within 	 the array bounds cannot be stored in a register either; because we 	 would get a crash in store_bit_field/extract_bit_field when trying 	 to access a non-existent part of the register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|index
argument_list|,
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|array
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids subscripting `register' array"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_isoc99
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|foo
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are          or if the array is.  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
comment|/* This was added by rms on 16 Nov 91. 	       It fixes  vol struct foo *a;  a->elts[1]  	       in an inline function. 	       Hope it doesn't break something else.  */
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|/* Do the same warning check as above, but only on the part that's        syntactically the index and only if it is also semantically        the index.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Put the integer in IND to simplify error checking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|ar
decl_stmt|;
name|ar
operator|=
name|ind
expr_stmt|;
name|ind
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an external reference to identifier ID.  FUN indicates    whether this will be used for a function call.  */
end_comment

begin_function
name|tree
name|build_external_ref
parameter_list|(
name|id
parameter_list|,
name|fun
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|fun
decl_stmt|;
block|{
name|tree
name|ref
decl_stmt|;
name|tree
name|decl
init|=
name|lookup_name
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|objc_ivar
init|=
name|lookup_objc_ivar
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
operator|||
name|decl
operator|==
name|error_mark_node
operator|||
name|C_DECL_ANTICIPATED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|objc_ivar
condition|)
name|ref
operator|=
name|objc_ivar
expr_stmt|;
elseif|else
if|if
condition|(
name|fun
condition|)
block|{
if|if
condition|(
operator|!
name|decl
operator|||
name|decl
operator|==
name|error_mark_node
condition|)
comment|/* Ordinary implicit function declaration.  */
name|ref
operator|=
name|implicitly_declare
argument_list|(
name|id
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Implicit declaration of built-in function.  Don't 		 change the built-in declaration, but don't let this 		 go by silently, either.  */
name|implicit_decl_warning
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* only issue this warning once */
name|C_DECL_ANTICIPATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ref
operator|=
name|decl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Reference to undeclared variable, including reference to 	     builtin outside of function-call context.  */
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"`%s' undeclared here (not in a function)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
operator|!=
name|error_mark_node
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|id
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
name|error
argument_list|(
literal|"`%s' undeclared (first use in this function)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|undeclared_variable_notice
condition|)
block|{
name|error
argument_list|(
literal|"(Each undeclared identifier is reported only once"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"for each function it appears in.)"
argument_list|)
expr_stmt|;
name|undeclared_variable_notice
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|id
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
comment|/* Properly declared variable or function reference.  */
if|if
condition|(
operator|!
name|objc_ivar
condition|)
name|ref
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|!=
name|objc_ivar
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"local declaration of `%s' hides instance variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|decl
expr_stmt|;
block|}
else|else
name|ref
operator|=
name|objc_ivar
expr_stmt|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|skip_evaluation
condition|)
name|assemble_external
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|ref
operator|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
operator|&&
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
condition|)
name|DECL_NONLOCAL
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.    FUNCTION's data type may be a function type or a pointer-to-function.  */
end_comment

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
name|tree
name|fntype
decl_stmt|,
name|fundecl
init|=
literal|0
decl_stmt|;
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|assembler_name
init|=
name|NULL_TREE
decl_stmt|,
name|result
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|assembler_name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
name|fntype
operator|=
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|fundecl
operator|=
name|function
expr_stmt|;
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"called object is not a function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|fundecl
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|fundecl
argument_list|)
condition|)
name|current_function_returns_abnormally
operator|=
literal|1
expr_stmt|;
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|name
argument_list|,
name|fundecl
argument_list|)
expr_stmt|;
comment|/* Check that the arguments to the function are valid.  */
name|check_function_arguments
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|expand_tree_builtin
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|,
name|params
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
name|result
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|require_complete_type
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the argument expressions in the list VALUES    to the types in the list TYPELIST.  The result is a list of converted    argument expressions.     If TYPELIST is exhausted, or when an element has NULL as its type,    perform the default conversions.     PARMLIST is the chain of parm decls for the function being called.    It may be 0, if that info is not available.    It is used only for generating error messages.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_arguments
parameter_list|(
name|typelist
parameter_list|,
name|values
parameter_list|,
name|name
parameter_list|,
name|fundecl
parameter_list|)
name|tree
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|name
decl_stmt|,
name|fundecl
decl_stmt|;
block|{
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
name|tree
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
comment|/* Scan the given expressions and types, producing individual      converted arguments and pushing them on RESULT in reverse order.  */
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
operator|,
name|parmnum
operator|=
literal|0
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|parmnum
operator|++
control|)
block|{
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too many arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here!  We do not want an enumerator with value 0 	 to convert automatically to a pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|default_function_array_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type of formal parameter %d is incomplete"
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|/* Optionally warn about conversions that 		 differ from the default conversions.  */
if|if
condition|(
name|warn_conversion
operator|||
name|warn_traditional
condition|)
block|{
name|int
name|formal_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as integer rather than floating due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as integer rather than complex due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as complex rather than floating due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as floating rather than integer due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as complex rather than integer due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as floating rather than complex due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? At some point, messages should be written about 		     conversions between complex types, but that's too messy 		     to do now.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* Warn if any argument is passed as `float', 			 since without a prototype it would be `double'.  */
if|if
condition|(
name|formal_prec
operator|==
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as `float' rather than `double' due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Detect integer changing in width or signedness. 		     These warnings are only activated with 		     -Wconversion, not with -Wtraditional.  */
elseif|else
if|if
condition|(
name|warn_conversion
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|would_have_been
init|=
name|default_conversion
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|tree
name|type1
init|=
name|TREE_TYPE
argument_list|(
name|would_have_been
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* No warning if function asks for enum 			   and the actual arg is that enum type.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|formal_prec
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s with different width due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|type1
argument_list|)
condition|)
empty_stmt|;
comment|/* Don't complain if the formal parameter type 			 is an enum, because we can't tell now whether 			 the value was an enum--even the same enum.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|val
argument_list|,
name|type
argument_list|)
condition|)
comment|/* Change in signedness doesn't matter 			   if a constant value is unaffected.  */
empty_stmt|;
comment|/* Likewise for a constant in a NOP_EXPR.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
empty_stmt|;
if|#
directive|if
literal|0
comment|/* We never get such tree structure here.  */
if|else if (TREE_CODE (TREE_TYPE (val)) == ENUMERAL_TYPE&& int_fits_type_p (TYPE_MIN_VALUE (TREE_TYPE (val)), type)&& int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (val)), type))
comment|/* Change in signedness doesn't matter 			   if an enum value is unaffected.  */
if|;
endif|#
directive|endif
comment|/* If the value is extended from a narrower 			 unsigned type, it doesn't matter whether we 			 pass it as signed or unsigned; the value 			 certainly is the same either way.  */
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as unsigned due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|warn_for_assignment
argument_list|(
literal|"%s as signed due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|parmval
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
comment|/* arg passing  */
name|fundecl
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too few arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the entry point used by the parser    for binary operators in the input.    In addition to constructing the expression,    we check for operands that were written with other binary operators    in a way that is likely to confuse the user.  */
end_comment

begin_function
name|tree
name|parser_build_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
name|class
decl_stmt|;
name|char
name|class1
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|class2
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code1
init|=
name|ERROR_MARK
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|ERROR_MARK
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|class1
argument_list|)
condition|)
name|code1
operator|=
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|class2
argument_list|)
condition|)
name|code2
operator|=
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* Check for cases such as x+y<<z which users are likely      to misinterpret.  If parens are used, C_EXP_ORIGINAL_CODE      is cleared to prevent these warnings.  */
if|if
condition|(
name|warn_parentheses
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around + or - inside shift"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code2
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around&& within ||"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_IOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|BIT_XOR_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|BIT_XOR_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around arithmetic in operand of |"
argument_list|)
expr_stmt|;
comment|/* Check cases like x|y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around comparison in operand of |"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_XOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around arithmetic in operand of ^"
argument_list|)
expr_stmt|;
comment|/* Check cases like x^y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around comparison in operand of ^"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around + or - in operand of&"
argument_list|)
expr_stmt|;
comment|/* Check cases like x&y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around comparison in operand of&"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Similarly, check for cases like 1<=i<=10 that are probably errors.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|extra_warnings
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
name|warning
argument_list|(
literal|"comparisons like X<=Y<=Z do not have their mathematical meaning"
argument_list|)
expr_stmt|;
name|unsigned_conversion_warning
argument_list|(
name|result
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|unsigned_conversion_warning
argument_list|(
name|result
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|overflow_warning
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the code that was specified in the source,      for the sake of warnings about confusing nesting.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|class
argument_list|)
condition|)
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|result
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|flag
init|=
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
decl_stmt|;
comment|/* We used to use NOP_EXPR rather than NON_LVALUE_EXPR 	 so that convert_for_assignment wouldn't strip it. 	 That way, we got warnings for things like p = (1 - 1). 	 But it turns out we should not get those warnings.  */
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|result
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
name|flag
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     Note that the operands will never have enumeral types, or function    or array types, because either they will have the default conversions    performed or they have both just been converted to some other type in which    the arithmetic is to be done.  */
end_comment

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|orig_op0
parameter_list|,
name|orig_op1
parameter_list|,
name|convert_p
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|orig_op0
decl_stmt|,
name|orig_op1
decl_stmt|;
name|int
name|convert_p
decl_stmt|;
block|{
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means create the expression with this type, rather than      RESULT_TYPE.  */
name|tree
name|build_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      convert it to this type.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|convert_p
condition|)
block|{
name|op0
operator|=
name|default_conversion
argument_list|(
name|orig_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|default_conversion
argument_list|(
name|orig_op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|orig_op0
expr_stmt|;
name|op1
operator|=
name|orig_op1
expr_stmt|;
block|}
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* Floating point division by zero is a legitimate way to obtain 	 infinities and NaNs.  */
if|if
condition|(
name|warn_div_by_zero
operator|&&
name|skip_evaluation
operator|==
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|||
name|code0
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
comment|/* Although it would be tempting to shorten always here, that 	       loses on some targets, since the modulo instruction is 	       undefined if the quotient can't be represented in the 	       computation mode.  We shorten only if unsigned or if 	       dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|VECTOR_TYPE
operator|&&
name|code1
operator|==
name|VECTOR_TYPE
condition|)
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|warn_div_by_zero
operator|&&
name|skip_evaluation
operator|==
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Although it would be tempting to shorten always here, that loses 	     on some targets, since the modulo instruction is undefined if the 	     quotient can't be represented in the computation mode.  We shorten 	     only if unsigned or if dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|POINTER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
comment|/* Result of these operations is always an int, 	     but that does not mean the operands should be 	     converted to ints!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"right shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|"right shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use the type of the value to be shifted.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of size 	     of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"left shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|"left shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use the type of the value to be shifted.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of size 	     of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|"shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use the type of the value to be shifted.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of size 	     of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|warn_float_equal
operator|&&
operator|(
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"comparing floating point with == or != is unsafe"
argument_list|)
expr_stmt|;
comment|/* Result of comparison is always int, 	 but don't convert the args to int!  */
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|||
name|code0
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|tt0
init|=
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
decl_stmt|;
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
decl_stmt|;
comment|/* Anything compares with void *.  void * compares with anything. 	     Otherwise, the targets must be compatible 	     and both must be object or both incomplete.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|tt0
argument_list|)
condition|)
block|{
comment|/* op0 != orig_op0 detects the case of something 		 whose value is 0 but which isn't a valid null ptr const.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|op0
argument_list|)
operator|||
name|op0
operator|!=
name|orig_op0
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|tt1
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|||
name|op1
operator|!=
name|orig_op1
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
else|else
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|==
name|NULL_TREE
condition|)
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|!=
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"comparison of complete and incomplete pointers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|extra_warnings
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|code0
operator|!=
name|REAL_TYPE
operator|||
name|code1
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"unordered comparison on non-floating point argument"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|common
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|||
name|code0
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
name|int
name|none_complex
init|=
operator|(
name|code0
operator|!=
name|COMPLEX_TYPE
operator|&&
name|code1
operator|!=
name|COMPLEX_TYPE
operator|)
decl_stmt|;
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
operator|&&
name|none_complex
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 (or OP1) does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* We can shorten only if the shift count is less than the 		 number of bits in the smaller type size.  */
operator|&&
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* We cannot drop an unsigned shift after sign-extension.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
if|if
condition|(
operator|(
name|warn_sign_compare
operator|<
literal|0
condition|?
name|extra_warnings
else|:
name|warn_sign_compare
operator|!=
literal|0
operator|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
name|int
name|op0_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op1_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|tree
name|primop0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
decl_stmt|;
name|tree
name|primop1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
decl_stmt|;
name|xop0
operator|=
name|orig_op0
expr_stmt|;
name|xop1
operator|=
name|orig_op1
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|xop0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|xop1
argument_list|)
expr_stmt|;
comment|/* Give warnings for comparisons between signed and unsigned 		 quantities that may fail.   		 Do the checking based on the original operand trees, so that 		 casts will be considered, but default promotions won't be.  		 Do not warn if the comparison is being done in a signed type, 		 since the signed type will only be chosen if it can represent 		 all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if both operands are the same signedness.  */
elseif|else
if|if
condition|(
name|op0_signed
operator|==
name|op1_signed
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
name|tree
name|sop
decl_stmt|,
name|uop
decl_stmt|;
if|if
condition|(
name|op0_signed
condition|)
name|sop
operator|=
name|xop0
operator|,
name|uop
operator|=
name|xop1
expr_stmt|;
else|else
name|sop
operator|=
name|xop1
operator|,
name|uop
operator|=
name|xop0
expr_stmt|;
comment|/* Do not warn if the signed quantity is an 		     unsuffixed integer literal (or some static 		     constant expression involving such literals or a 		     conditional expression involving such literals) 		     and it is non-negative.  */
if|if
condition|(
name|c_tree_expr_nonnegative_p
argument_list|(
name|sop
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the comparison is an equality operation, 		     the unsigned quantity is an integral constant, and it 		     would fit in the result if the result were signed.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|uop
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|resultcode
operator|==
name|EQ_EXPR
operator|||
name|resultcode
operator|==
name|NE_EXPR
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|uop
argument_list|,
name|c_common_signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the unsigned quantity is an enumeration 		     constant and its maximum value would fit in the result 		     if the result were signed.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|uop
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|uop
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|int_fits_type_p
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|uop
argument_list|)
argument_list|)
argument_list|,
name|c_common_signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|"comparison between signed and unsigned"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn if two unsigned values are being compared in a size 		 larger than their original size, and one (and only one) is the 		 result of a `~' operator.  This comparison will always fail.  		 Also warn if one operand is a constant, and the constant 		 does not have all bits set that are set in the ~ operand 		 when it is extended.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
operator|!=
operator|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop0
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
else|else
name|primop1
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
operator|||
name|host_integerp
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|primop
decl_stmt|;
name|HOST_WIDE_INT
name|constant
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|bits
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|primop
operator|=
name|primop1
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp1
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primop
operator|=
name|primop0
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp0
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
name|bits
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|unsignedp
condition|)
block|{
name|mask
operator|=
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|constant
operator|)
operator|!=
name|mask
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with constant"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsignedp0
operator|&&
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|binary_op_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_type
operator|==
name|NULL_TREE
condition|)
name|build_type
operator|=
name|result_type
expr_stmt|;
block|{
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|build_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if `t' is known to be non-negative.  */
end_comment

begin_function
name|int
name|c_tree_expr_nonnegative_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STMT_EXPR
condition|)
block|{
name|t
operator|=
name|COMPOUND_BODY
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the last statement in the chain, ignoring the final 	     * scope statement */
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|SCOPE_STMT
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|con0
decl_stmt|,
name|con1
decl_stmt|,
name|lit0
decl_stmt|,
name|lit1
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type `void *' used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* If the conversion to ptrdiff_type does anything like widening or      converting a partial to an integral mode, we get a convert_expression      that is in the way to do any simplifications.      (fold-const.c doesn't know that the extra bits won't be needed.      split_tree uses STRIP_SIGN_NOPS, which leaves conversions to a      different mode in place.)      So first try to find a common term here 'by hand'; we want to cover      at least the cases that occur in legal static initializers.  */
name|con0
operator|=
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
condition|?
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
else|:
name|op0
expr_stmt|;
name|con1
operator|=
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
condition|?
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
else|:
name|op1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|con0
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|lit0
operator|=
name|TREE_OPERAND
argument_list|(
name|con0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|con0
operator|=
name|TREE_OPERAND
argument_list|(
name|con0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|lit0
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|con1
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|lit1
operator|=
name|TREE_OPERAND
argument_list|(
name|con1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|con1
operator|=
name|TREE_OPERAND
argument_list|(
name|con1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|lit1
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|con0
argument_list|,
name|con1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|lit0
expr_stmt|;
name|op1
operator|=
name|lit1
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.      Do not do default conversions on the minus operator      in case restype is a short type.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This generates an error if op1 is pointer to incomplete type.  */
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
comment|/* This generates an error if op0 is pointer to incomplete type.  */
name|op1
operator|=
name|c_size_in_bytes
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
comment|/* Divide by the size, in easiest possible way.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.    For any CODE other than ADDR_EXPR, FLAG nonzero suppresses    the default promotions (such as from short to int).    For ADDR_EXPR, the default promotions are not applied; FLAG nonzero    allows non-lvalues; this is only used to handle conversion of non-lvalue    arrays to pointers in C99.  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|flag
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|typecode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|int
name|noconvert
init|=
name|flag
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|typecode
operator|==
name|ENUMERAL_TYPE
operator|||
name|typecode
operator|==
name|BOOLEAN_TYPE
condition|)
name|typecode
operator|=
name|INTEGER_TYPE
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary plus"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|non_lvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|||
name|typecode
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary minus"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|VECTOR_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|code
operator|=
name|CONJ_EXPR
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support `~' for complex conjugation"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"wrong type argument to bit-complement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to abs"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
comment|/* Conjugating a real value is a no-op, but allow it anyway.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to conjugation"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
operator|&&
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|COMPLEX_TYPE
comment|/* These will convert to a pointer.  */
operator|&&
name|typecode
operator|!=
name|ARRAY_TYPE
operator|&&
name|typecode
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary exclamation mark"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arg
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|arg
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Increment or decrement the real part of the value, 	 and don't change the imaginary part.  */
if|if
condition|(
name|typecode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support `++' and `--' on complex types"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real
operator|=
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|real
argument_list|,
literal|1
argument_list|)
argument_list|,
name|imag
argument_list|)
return|;
block|}
comment|/* Report invalid types.  */
if|if
condition|(
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|error
argument_list|(
literal|"wrong type argument to increment"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"wrong type argument to decrement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|{
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|typecode
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* If pointer target is an undefined struct, 	       we just cannot know how to do the arithmetic.  */
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|error
argument_list|(
literal|"increment of pointer to unknown structure"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"decrement of pointer to unknown structure"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|pedwarn
argument_list|(
literal|"wrong type argument to increment"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"wrong type argument to decrement"
argument_list|)
expr_stmt|;
block|}
name|inc
operator|=
name|c_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
comment|/* If the real type has the same machine representation 		 as the type it is cast to, we can make better output 		 by adding directly to the inside of the cast.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
name|value
operator|=
name|boolean_increment
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|incremented
argument_list|)
operator|=
literal|1
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
name|value
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
break|break;
default|default:
goto|goto
name|give_up
goto|;
block|}
name|give_up
label|:
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"invalid lvalue in increment"
else|:
literal|"invalid lvalue in decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Report a read-only lvalue.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
name|val
operator|=
name|boolean_increment
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|code
condition|)
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion.  */
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Don't let this be an lvalue.  */
if|if
condition|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
if|#
directive|if
literal|0
comment|/* Turned off because inconsistent; 	 float f; *&(int)f = 3.4 stores in int format 	 whereas (int)f = 3.4 stores in float format.  */
comment|/* Address of a cast is just a cast of the address 	 of the operand of the cast.  */
if|switch (TREE_CODE (arg)) 	{ 	case NOP_EXPR: 	case CONVERT_EXPR: 	case FLOAT_EXPR: 	case FIX_TRUNC_EXPR: 	case FIX_FLOOR_EXPR: 	case FIX_ROUND_EXPR: 	case FIX_CEIL_EXPR: 	  if (pedantic) 	    pedwarn ("ISO C forbids the address of a cast expression"); 	  return convert (build_pointer_type (TREE_TYPE (arg)), 			  build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 					  0)); 	}
endif|#
directive|endif
comment|/* Anything not already handled and not a true memory reference 	 or a non-lvalue array is an error.  */
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|flag
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"invalid lvalue in unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Ordinary case; arg is a COMPONENT_REF or a decl.  */
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If the lvalue is const or volatile, merge that into the type          to which the address will point.  Note that you can't get a 	 restricted pointer by taking the address of something, so we 	 only have to deal with `const' and `volatile' here.  */
if|if
condition|(
operator|(
name|DECL_P
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
name|argtype
operator|=
name|c_build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"attempt to take address of bit-field structure member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|addr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|convert
argument_list|(
name|argtype
argument_list|,
name|addr
argument_list|)
argument_list|,
name|convert
argument_list|(
name|argtype
argument_list|,
name|byte_position
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   file-scope function counts as a constant.  */
if|if
condition|(
name|staticp
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|addr
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* If CONVERSIONS is a conversion expression or a nested sequence of such,    convert ARG with the same conversions in the same order    and return the result.  */
end_comment

begin_endif
unit|static tree convert_sequence (conversions, arg)      tree conversions;      tree arg; {   switch (TREE_CODE (conversions))     {     case NOP_EXPR:     case CONVERT_EXPR:     case FLOAT_EXPR:     case FIX_TRUNC_EXPR:     case FIX_FLOOR_EXPR:     case FIX_ROUND_EXPR:     case FIX_CEIL_EXPR:       return convert (TREE_TYPE (conversions), 		      convert_sequence (TREE_OPERAND (conversions, 0), 					arg));      default:       return arg;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language.    Lvalues can be assigned, unless their type has TYPE_READONLY.    Lvalues can have their address taken, unless they have DECL_REGISTER.  */
end_comment

begin_function
name|int
name|lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
return|return
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
return|;
case|case
name|BIND_EXPR
case|:
case|case
name|RTL_EXPR
case|:
return|return
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|ref
parameter_list|,
name|msgid
parameter_list|)
name|tree
name|ref
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|error
argument_list|(
literal|"%s"
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.  If FLAG is nonzero, then    non-lvalues are OK since we may be converting a non-lvalue array to    a pointer in C99.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|,
name|flag
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If this returns a function type, it isn't really being used as 	 an lvalue, so don't issue a warning about it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|flag
condition|)
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|flag
condition|)
name|pedantic_lvalue_warning
argument_list|(
name|COND_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|flag
condition|)
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
return|return
operator|(
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flag
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flag
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If pedantic, warn about improper lvalue.   CODE is either COND_EXPR    COMPOUND_EXPR, or CONVERT_EXPR (for casts).  */
end_comment

begin_function
specifier|static
name|void
name|pedantic_lvalue_warning
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
if|if
condition|(
name|pedantic
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|pedwarn
argument_list|(
literal|"ISO C forbids use of conditional expressions as lvalues"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|pedwarn
argument_list|(
literal|"ISO C forbids use of compound expressions as lvalues"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pedwarn
argument_list|(
literal|"ISO C forbids use of cast expressions as lvalues"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Warn about storing in something that is `const'.  */
end_comment

begin_function
name|void
name|readonly_warning
parameter_list|(
name|arg
parameter_list|,
name|msgid
parameter_list|)
name|tree
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"%s of read-only member `%s'"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|pedwarn
argument_list|(
literal|"%s of read-only variable `%s'"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"%s of read-only location"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Returns true if successful.  */
end_comment

begin_function
name|bool
name|c_mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|x
init|=
name|exp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot take address of bit-field `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|ADDR_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"global register variable `%s' used in nested function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|pedwarn
argument_list|(
literal|"register variable `%s' used in nested function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address of global register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If we are making this addressable due to its having 	       volatile components, give a different error message.  Also 	       handle the case of an unnamed parameter by not trying 	       to give the name.  */
elseif|else
if|if
condition|(
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot put object with volatile field into register"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|pedwarn
argument_list|(
literal|"address of register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|put_var_into_stack
argument_list|(
name|x
argument_list|,
comment|/*rescan=*/
name|true
argument_list|)
expr_stmt|;
comment|/* drops in */
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* poplevel deals with this now.  */
block|if (DECL_CONTEXT (x) == 0) 	  TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;
endif|#
directive|endif
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|,
name|orig_op2
init|=
name|op2
decl_stmt|;
name|ifexp
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|ifexp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Produces wrong result if within sizeof.  */
comment|/* Don't promote the operands separately if they promote      the same way.  Return the unpromoted type and let the combined      value get promoted if necessary.  */
block|if (TREE_TYPE (op1) == TREE_TYPE (op2)&& TREE_CODE (TREE_TYPE (op1)) != ARRAY_TYPE&& TREE_CODE (TREE_TYPE (op1)) != ENUMERAL_TYPE&& TREE_CODE (TREE_TYPE (op1)) != FUNCTION_TYPE)     {       if (TREE_CODE (ifexp) == INTEGER_CST) 	return pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);        return fold (build (COND_EXPR, TREE_TYPE (op1), ifexp, op1, op2));     }
endif|#
directive|endif
comment|/* Promote both alternatives.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
else|else
name|result_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
comment|/* If -Wsign-compare, warn here if type1 and type2 have 	 different signedness.  We'll promote the signed to unsigned 	 and later code won't know it used to be different. 	 Do this check on the original types, so that explicit casts 	 will be considered, but default promotions won't.  */
if|if
condition|(
operator|(
name|warn_sign_compare
operator|<
literal|0
condition|?
name|extra_warnings
else|:
name|warn_sign_compare
operator|)
operator|&&
operator|!
name|skip_evaluation
condition|)
block|{
name|int
name|unsigned_op1
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsigned_op2
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|unsigned_op1
operator|^
name|unsigned_op2
condition|)
block|{
comment|/* Do not warn if the result type is signed, since the 		 signed type will only be chosen if it can represent 		 all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the signed quantity is an unsuffixed 		 integer literal (or some static constant expression 		 involving such literals) and it is non-negative.  */
elseif|else
if|if
condition|(
operator|(
name|unsigned_op2
operator|&&
name|c_tree_expr_nonnegative_p
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|unsigned_op1
operator|&&
name|c_tree_expr_nonnegative_p
argument_list|(
name|op2
argument_list|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|"signed and unsigned type in conditional expression"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|!=
name|NOP_EXPR
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op2
argument_list|)
operator|!=
name|NOP_EXPR
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|qualify_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|qualify_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op2
operator|=
name|null_pointer_node
expr_stmt|;
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
block|}
name|result_type
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Merge const and volatile flags of the incoming types.  */
name|result_type
operator|=
name|build_type_variant
argument_list|(
name|result_type
argument_list|,
name|TREE_READONLY
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|op2
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
argument_list|)
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
return|return
name|internal_build_compound_expr
argument_list|(
name|list
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|internal_build_compound_expr
parameter_list|(
name|list
parameter_list|,
name|first_p
parameter_list|)
name|tree
name|list
decl_stmt|;
name|int
name|first_p
decl_stmt|;
block|{
name|tree
name|rest
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Convert arrays and functions to pointers when there 	 really is a comma operator.  */
if|if
condition|(
operator|!
name|first_p
condition|)
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|default_function_array_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If something inside inhibited lvalueness, we should not override.  */
comment|/* Consider (x, y+0), which is not an lvalue since y+0 is not.  */
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
block|if (TREE_CODE (list) == NON_LVALUE_EXPR) 	list = TREE_OPERAND (list, 0);
endif|#
directive|endif
comment|/* Don't let (0, 0) be null pointer constant.  */
if|if
condition|(
operator|!
name|first_p
operator|&&
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
name|rest
operator|=
name|internal_build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The left-hand operand of a comma expression is like an expression          statement: with -W or -Wunused, we should warn if it doesn't have 	 any side-effects, unless it was explicitly cast to (void).  */
if|if
condition|(
operator|(
name|extra_warnings
operator|||
name|warn_unused_value
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"left-hand operand of comma expression has no effect"
argument_list|)
expr_stmt|;
comment|/* When pedantic, a compound expression can be neither an lvalue          nor an integer constant expression.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
return|return
name|rest
return|;
block|}
comment|/* With -Wunused, we should also warn if the left-hand operand does have      side-effects, but computes a value which is not used.  For example, in      `foo() + bar(), baz()' the result of the `+' operator is not used,      so we should issue a warning.  */
elseif|else
if|if
condition|(
name|warn_unused_value
condition|)
name|warn_if_unused_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|value
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* The ObjC front-end uses TYPE_MAIN_VARIANT to tie together types differing      only in<protocol> qualifications.  But when constructing cast expressions,      the protocols do matter and must be kept around.  */
if|if
condition|(
operator|!
name|flag_objc
operator|||
operator|!
name|objc_is_id
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
block|if (TREE_CODE (value) == NON_LVALUE_EXPR)     value = TREE_OPERAND (value, 0);
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids casting nonscalar to the same type"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
name|value
operator|=
name|default_function_array_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|field
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids casts to union type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
literal|""
expr_stmt|;
name|t
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|error
argument_list|(
literal|"cast to union type from type not present in union"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|otype
decl_stmt|,
name|ovalue
decl_stmt|;
comment|/* If casting to void, avoid the error that would come 	 from default_conversion in the case of a non-lvalue array.  */
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
return|;
comment|/* Convert functions and arrays to pointers, 	 but don't convert any other types.  */
name|value
operator|=
name|default_function_array_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrisome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|in_type
init|=
name|type
decl_stmt|;
name|tree
name|in_otype
init|=
name|otype
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
name|int
name|discarded
init|=
literal|0
decl_stmt|;
comment|/* Check that the qualifiers on IN_TYPE are a superset of 	     the qualifiers of IN_OTYPE.  The outermost level of 	     POINTER_TYPE nodes is uninteresting and we stop as soon 	     as we hit a non-POINTER_TYPE node on either type.  */
do|do
block|{
name|in_otype
operator|=
name|TREE_TYPE
argument_list|(
name|in_otype
argument_list|)
expr_stmt|;
name|in_type
operator|=
name|TREE_TYPE
argument_list|(
name|in_type
argument_list|)
expr_stmt|;
comment|/* GNU C allows cv-qualified function types.  'const' 		 means the function is very pure, 'volatile' means it 		 can't return.  We need to warn when such qualifiers 		 are added, not when they're taken away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in_otype
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|in_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|added
operator||=
operator|(
name|TYPE_QUALS
argument_list|(
name|in_type
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|in_otype
argument_list|)
operator|)
expr_stmt|;
else|else
name|discarded
operator||=
operator|(
name|TYPE_QUALS
argument_list|(
name|in_otype
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|in_type
argument_list|)
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|in_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|in_otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
do|;
if|if
condition|(
name|added
condition|)
name|warning
argument_list|(
literal|"cast adds new qualifiers to function type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|discarded
condition|)
comment|/* There are qualifiers present in IN_OTYPE that are not 	       present in IN_TYPE.  */
name|warning
argument_list|(
literal|"cast discards qualifiers from pointer target type"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about possible alignment problems.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|warn_cast_align
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
comment|/* Don't warn about opaque types, where the actual alignment 	     restriction is unknown.  */
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast increases required alignment of target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast from pointer to integer of different size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_bad_function_cast
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast does not match function type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
comment|/* Don't warn about converting any constant.  */
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast to pointer from integer of different size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|flag_strict_aliasing
operator|&&
name|warn_strict_aliasing
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Casting the address of a decl to non void pointer. Warn 	     if the cast breaks type based aliasing.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"type-punning to incomplete type might break strict-aliasing rules"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|alias_sets_conflict_p
argument_list|(
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"dereferencing type-punned pointer will break strict-aliasing rules"
argument_list|)
expr_stmt|;
block|}
name|ovalue
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pedantically, don't let (void *) (FOO *) 0 be a null pointer constant.  */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|value
operator|=
name|non_lvalue
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* If pedantic, don't let a cast be an lvalue.  */
if|if
condition|(
name|value
operator|==
name|expr
operator|&&
name|pedantic
condition|)
name|value
operator|=
name|non_lvalue
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Interpret a cast of expression EXPR to type TYPE.  */
end_comment

begin_function
name|tree
name|c_cast_expr
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|int
name|saved_wsp
init|=
name|warn_strict_prototypes
decl_stmt|;
comment|/* This avoids warnings about unprototyped casts on      integers.  E.g. "#define SIG_DFL (void(*)())0".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|warn_strict_prototypes
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|groktypename
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|warn_strict_prototypes
operator|=
name|saved_wsp
expr_stmt|;
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* Handle control structure constructs used as "lvalues".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newrhs
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|COND_EXPR
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	   except that the RHS goes through a save-expr 	   so the code to compute it is only emitted once.  */
name|tree
name|cond
init|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|cond
return|;
comment|/* Make sure the code to compute the rhs comes out 	   before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* But cast it to void to avoid an "unused" error.  */
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the cast type of the lhs,      and then true type of the lhs and store it there;      then convert result back to the cast type to be the value      of the assignment.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|newrhs
operator|=
name|default_function_array_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|result
operator|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|convert
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|result
return|;
name|pedantic_lvalue_warning
argument_list|(
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"invalid lvalue in assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Warn about storing in something that is `const'.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower than one,      we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
comment|/* Convert new value to destination type.  */
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|_
argument_list|(
literal|"assignment"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Scan operands */
name|result
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
name|_
argument_list|(
literal|"assignment"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE is a string to use in error messages:    "assignment", "return", etc.  If it is null, this is parameter passing    for a function call (and different error messages are output).     FUNNAME is the name of the function being called,    as an IDENTIFIER_NODE, or null.    PARMNUM is the number of the argument, for printing in error messages.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|fundecl
parameter_list|,
name|funname
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fundecl
decl_stmt|,
name|funname
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|rhstype
decl_stmt|;
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|rhs
operator|=
name|decl_constant_value_for_broken_optimization
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
block|{
name|overflow_warning
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Check for Objective-C protocols.  This will automatically 	 issue a warning if there are protocol violations.  No need to 	 use the return value.  */
if|if
condition|(
name|flag_objc
condition|)
name|objc_comptypes
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* A type converts to a reference to it.        This code doesn't fully support references, it's just for the      special case of va_start and va_copy.  */
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot pass rvalue to reference parameter"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|c_mark_addressable
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|rhs
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* We already know that these two types are compatible, but they 	 may not be exactly identical.  In fact, `TREE_TYPE (type)' is 	 likely to be __builtin_va_list and `TREE_TYPE (rhs)' is 	 likely to be va_list, a typedef to __builtin_va_list, which 	 is different enough that it will cause problems later.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|rhs
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
comment|/* Arithmetic types all interconvert, and enum is treated like int.  */
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|||
name|codel
operator|==
name|ENUMERAL_TYPE
operator|||
name|codel
operator|==
name|COMPLEX_TYPE
operator|||
name|codel
operator|==
name|BOOLEAN_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
operator|||
name|coder
operator|==
name|COMPLEX_TYPE
operator|||
name|coder
operator|==
name|BOOLEAN_TYPE
operator|)
condition|)
return|return
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* Conversion to a transparent union from its member types.      This applies only to function arguments.  */
elseif|else
if|if
condition|(
name|codel
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|errtype
condition|)
block|{
name|tree
name|memb_types
decl_stmt|;
name|tree
name|marginal_memb_type
init|=
literal|0
decl_stmt|;
for|for
control|(
name|memb_types
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|memb_types
condition|;
name|memb_types
operator|=
name|TREE_CHAIN
argument_list|(
name|memb_types
argument_list|)
control|)
block|{
name|tree
name|memb_type
init|=
name|TREE_TYPE
argument_list|(
name|memb_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|memb_type
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|memb_type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
continue|continue;
if|if
condition|(
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|memb_type
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Any non-function converts to a [const][volatile] void * 		 and vice versa; otherwise, targets must be the same. 		 Meanwhile, the lhs target must have all the qualifiers of 		 the rhs.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|||
name|comp_target_types
argument_list|(
name|memb_type
argument_list|,
name|rhstype
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If this type won't generate any warnings, use it.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|?
operator|(
operator|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
else|:
operator|(
operator|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* Keep looking for a better type, but remember this one.  */
if|if
condition|(
operator|!
name|marginal_memb_type
condition|)
name|marginal_memb_type
operator|=
name|memb_type
expr_stmt|;
block|}
block|}
comment|/* Can convert integer zero to any pointer type.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rhs
operator|=
name|null_pointer_node
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|memb_types
operator|||
name|marginal_memb_type
condition|)
block|{
if|if
condition|(
operator|!
name|memb_types
condition|)
block|{
comment|/* We have only a marginally acceptable member type; 		 it needs a warning.  */
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|marginal_memb_type
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Const and volatile mean something different for function 		 types, so the usual warnings are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Because const and volatile on functions are 		     restrictions that say the function will not do 		     certain things, it is okay to use a const or volatile 		     function where an ordinary one is wanted, but not 		     vice-versa.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s makes qualified function pointer from unqualified"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s discards qualifiers from pointer target type"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|fundecl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C prohibits argument conversion to union type"
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|POINTER_TYPE
operator|||
name|codel
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|codel
operator|)
condition|)
block|{
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|c_common_unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
name|c_common_unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
comment|/* Check TREE_CODE to catch cases like (void *) (char *) 0 		      which are not ANSI null ptr constants.  */
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"ISO C forbids %s between function pointer and `void *'"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
comment|/* Const and volatile mean something different for function types, 	     so the usual warnings are not appropriate.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s discards qualifiers from pointer target type"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
comment|/* If this is not a case of ignoring a mismatch in signedness, 		 no warning.  */
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|ttl
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|ttr
argument_list|)
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
comment|/* If there is a mismatch, do warn.  */
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|warn_for_assignment
argument_list|(
literal|"pointer targets in %s differ in signedness"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Because const and volatile on functions are restrictions 		 that say the function will not do certain things, 		 it is okay to use a const or volatile function 		 where an ordinary one is wanted, but not vice-versa.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s makes qualified function pointer from unqualified"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|warn_for_assignment
argument_list|(
literal|"%s from incompatible pointer type"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* An explicit constant 0 can convert to a pointer, 	 or one that results from arithmetic, even including 	 a cast to integer type.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|warn_for_assignment
argument_list|(
literal|"%s makes pointer from integer without a cast"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
name|null_pointer_node
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|INTEGER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|warn_for_assignment
argument_list|(
literal|"%s makes integer from pointer without a cast"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|BOOLEAN_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
operator|!
name|errtype
condition|)
block|{
if|if
condition|(
name|funname
condition|)
block|{
name|tree
name|selector
init|=
name|objc_message_selector
argument_list|()
decl_stmt|;
if|if
condition|(
name|selector
operator|&&
name|parmnum
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"incompatible type for argument %d of `%s'"
argument_list|,
name|parmnum
operator|-
literal|2
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|selector
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"incompatible type for argument %d of `%s'"
argument_list|,
name|parmnum
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"incompatible type for argument %d of indirect function call"
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"incompatible types in %s"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Convert VALUE for assignment into inlined parameter PARM.  */
end_comment

begin_function
name|tree
name|c_convert_parm_for_inlining
parameter_list|(
name|parm
parameter_list|,
name|value
parameter_list|,
name|fn
parameter_list|)
name|tree
name|parm
decl_stmt|,
name|value
decl_stmt|,
name|fn
decl_stmt|;
block|{
name|tree
name|ret
decl_stmt|,
name|type
decl_stmt|;
comment|/* If FN was prototyped, the value has been converted already      in convert_arguments.  */
if|if
condition|(
operator|!
name|value
operator|||
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
name|value
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
comment|/* arg passing  */
argument_list|,
name|fn
argument_list|,
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|ret
operator|=
name|default_conversion
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Print a warning using MSGID.    It gets OPNAME as its one parameter.    if OPNAME is null and ARGNUM is 0, it is replaced by "passing arg of `FUNCTION'".    Otherwise if OPNAME is null, it is replaced by "passing arg ARGNUM of `FUNCTION'".    FUNCTION and ARGNUM are handled specially if we are building an    Objective-C selector.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_assignment
parameter_list|(
name|msgid
parameter_list|,
name|opname
parameter_list|,
name|function
parameter_list|,
name|argnum
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|tree
name|function
decl_stmt|;
name|int
name|argnum
decl_stmt|;
block|{
if|if
condition|(
name|opname
operator|==
literal|0
condition|)
block|{
name|tree
name|selector
init|=
name|objc_message_selector
argument_list|()
decl_stmt|;
name|char
modifier|*
name|new_opname
decl_stmt|;
if|if
condition|(
name|selector
operator|&&
name|argnum
operator|>
literal|2
condition|)
block|{
name|function
operator|=
name|selector
expr_stmt|;
name|argnum
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|argnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|function
condition|)
block|{
comment|/* Function name is known; supply it.  */
specifier|const
name|char
modifier|*
specifier|const
name|argstring
init|=
name|_
argument_list|(
literal|"passing arg of `%s'"
argument_list|)
decl_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|function
argument_list|)
operator|+
name|strlen
argument_list|(
name|argstring
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
name|argstring
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Function name unknown (call through ptr).  */
specifier|const
name|char
modifier|*
specifier|const
name|argnofun
init|=
name|_
argument_list|(
literal|"passing arg of pointer to function"
argument_list|)
decl_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|argnofun
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
name|argnofun
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|function
condition|)
block|{
comment|/* Function name is known; supply it.  */
specifier|const
name|char
modifier|*
specifier|const
name|argstring
init|=
name|_
argument_list|(
literal|"passing arg %d of `%s'"
argument_list|)
decl_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|function
argument_list|)
operator|+
name|strlen
argument_list|(
name|argstring
argument_list|)
operator|+
literal|1
operator|+
literal|25
comment|/*%d*/
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
name|argstring
argument_list|,
name|argnum
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Function name unknown (call through ptr); just give arg number.  */
specifier|const
name|char
modifier|*
specifier|const
name|argnofun
init|=
name|_
argument_list|(
literal|"passing arg %d of pointer to function"
argument_list|)
decl_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|argnofun
argument_list|)
operator|+
literal|1
operator|+
literal|25
comment|/*%d*/
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
name|argnofun
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
block|}
name|opname
operator|=
name|new_opname
expr_stmt|;
block|}
name|pedwarn
argument_list|(
name|msgid
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If VALUE is a compound expr all of whose expressions are constant, then    return its value.  Otherwise, return error_mark_node.     This is for handling COMPOUND_EXPRs as initializer elements    which is allowed with a warning when -pedantic is specified.  */
end_comment

begin_function
specifier|static
name|tree
name|valid_compound_expr_initializer
parameter_list|(
name|value
parameter_list|,
name|endtype
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|endtype
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
if|if
condition|(
name|valid_compound_expr_initializer
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|valid_compound_expr_initializer
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|&&
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|endtype
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.  */
end_comment

begin_function
name|void
name|store_init_value
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the expression if valid; else report error.  */
if|#
directive|if
literal|0
comment|/* Note that this is the only place we can detect the error      in a case such as   struct foo bar = (struct foo) { x, y };      where there is one initial value which is a constructor expression.  */
block|if (value == error_mark_node)     ;   else if (TREE_STATIC (decl)&& ! TREE_CONSTANT (value))     {       error ("initializer for static variable is not constant");       value = error_mark_node;     }   else if (TREE_STATIC (decl)&& initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)     {       error ("initializer for static variable uses complicated arithmetic");       value = error_mark_node;     }   else     {       if (pedantic&& TREE_CODE (value) == CONSTRUCTOR) 	{ 	  if (! TREE_CONSTANT (value)) 	    pedwarn ("aggregate initializer is not constant"); 	  else if (! TREE_STATIC (value)) 	    pedwarn ("aggregate initializer uses complicated arithmetic"); 	}     }
endif|#
directive|endif
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"traditional C rejects automatic aggregate initialization"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
comment|/* ANSI wants warnings about out-of-range constant initializers.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Check if we need to set array size from compound literal size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|inside_init
init|=
name|init
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|inside_init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|fold
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
condition|)
block|{
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|inside_init
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For int foo[] = (int [3]){1}; we need to set array size 		 now since later on array initializer will be just the 		 brace enclosed list of the compound literal.  */
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Methods for storing and printing names for error messages.  */
end_comment

begin_comment
comment|/* Implement a spelling stack that allows components of a name to be pushed    and popped.  Each element on the stack is this structure.  */
end_comment

begin_struct
struct|struct
name|spelling
block|{
name|int
name|kind
decl_stmt|;
union|union
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SPELLING_STRING
value|1
end_define

begin_define
define|#
directive|define
name|SPELLING_MEMBER
value|2
end_define

begin_define
define|#
directive|define
name|SPELLING_BOUNDS
value|3
end_define

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next stack element (unused).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spelling stack base.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spelling_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the spelling stack.  */
end_comment

begin_comment
comment|/* Macros to save and restore the spelling stack around push_... functions.    Alternative to SAVE_SPELLING_STACK.  */
end_comment

begin_define
define|#
directive|define
name|SPELLING_DEPTH
parameter_list|()
value|(spelling - spelling_base)
end_define

begin_define
define|#
directive|define
name|RESTORE_SPELLING_DEPTH
parameter_list|(
name|DEPTH
parameter_list|)
value|(spelling = spelling_base + (DEPTH))
end_define

begin_comment
comment|/* Push an element on the spelling stack with type KIND and assign VALUE    to MEMBER.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_SPELLING
parameter_list|(
name|KIND
parameter_list|,
name|VALUE
parameter_list|,
name|MEMBER
parameter_list|)
define|\
value|{									\   int depth = SPELLING_DEPTH ();					\ 									\   if (depth>= spelling_size)						\     {									\       spelling_size += 10;						\       if (spelling_base == 0)						\ 	spelling_base							\ 	  = (struct spelling *) xmalloc (spelling_size * sizeof (struct spelling));	\       else								\         spelling_base							\ 	  = (struct spelling *) xrealloc (spelling_base,		\ 					  spelling_size * sizeof (struct spelling));	\       RESTORE_SPELLING_DEPTH (depth);					\     }									\ 									\   spelling->kind = (KIND);						\   spelling->MEMBER = (VALUE);						\   spelling++;								\ }
end_define

begin_comment
comment|/* Push STRING on the stack.  Printed literally.  */
end_comment

begin_function
specifier|static
name|void
name|push_string
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_STRING
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a member name on the stack.  Printed as '.' STRING.  */
end_comment

begin_function
specifier|static
name|void
name|push_member_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
specifier|const
name|string
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
literal|"<anonymous>"
decl_stmt|;
name|PUSH_SPELLING
argument_list|(
name|SPELLING_MEMBER
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an array bounds on the stack.  Printed as [BOUNDS].  */
end_comment

begin_function
specifier|static
name|void
name|push_array_bounds
parameter_list|(
name|bounds
parameter_list|)
name|int
name|bounds
decl_stmt|;
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_BOUNDS
argument_list|,
name|bounds
argument_list|,
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the maximum size in bytes of the printed spelling.  */
end_comment

begin_function
specifier|static
name|int
name|spelling_length
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
name|size
operator|+=
literal|25
expr_stmt|;
else|else
name|size
operator|+=
name|strlen
argument_list|(
name|p
operator|->
name|u
operator|.
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Print the spelling to BUFFER and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|print_spelling
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|char
modifier|*
name|d
init|=
name|buffer
decl_stmt|;
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"[%d]"
argument_list|,
name|p
operator|->
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
name|d
operator|+=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_MEMBER
condition|)
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p
operator|->
name|u
operator|.
name|s
init|;
operator|(
operator|*
name|d
operator|=
operator|*
name|s
operator|++
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Issue an error message for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
name|void
name|error_init
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|error
argument_list|(
literal|"(near initialization for `%s')"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a pedantic warning for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
name|void
name|pedwarn_init
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|pedwarn
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|pedwarn
argument_list|(
literal|"(near initialization for `%s')"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a warning for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
specifier|static
name|void
name|warning_init
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|warning
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|warning
argument_list|(
literal|"(near initialization for `%s')"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Digest the parser output INIT as an initializer for type TYPE.    Return a C expression of type TYPE to represent the initial value.     REQUIRE_CONSTANT requests an error if non-constant initializers or    elements are seen.  */
end_comment

begin_function
specifier|static
name|tree
name|digest_init
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|require_constant
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|;
name|int
name|require_constant
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|inside_init
init|=
name|init
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|init
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|inside_init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|fold
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
comment|/* Initialization of an array of chars from a string constant      optionally enclosed in braces.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|typ1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|typ1
operator|==
name|char_type_node
operator|||
name|typ1
operator|==
name|signed_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_wchar_type_node
operator|||
name|typ1
operator|==
name|signed_wchar_type_node
operator|)
operator|&&
operator|(
operator|(
name|inside_init
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|inside_init
return|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"char-array initialized from wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"int-array initialized from non-wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* Subtract 1 (or sizeof (wchar_t)) 		 because it's ok to ignore the terminating null char 		 that is counted in the length of the constant.  */
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|inside_init
argument_list|)
operator|-
operator|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|)
condition|?
operator|(
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
else|:
literal|1
operator|)
argument_list|)
condition|)
name|pedwarn_init
argument_list|(
literal|"initializer-string for array of chars is too long"
argument_list|)
expr_stmt|;
return|return
name|inside_init
return|;
block|}
block|}
comment|/* Build a VECTOR_CST from a *constant* vector constructor.  If the      vector constructor is not constant (e.g. {1,2,3,foo()}) then punt      below and handle as a constructor.  */
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|inside_init
return|;
else|else
return|return
name|build_vector
argument_list|(
name|type
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|inside_init
argument_list|)
argument_list|)
return|;
block|}
comment|/* Any type can be initialized      from an expression of the same type, optionally with braces.  */
if|if
condition|(
name|inside_init
operator|&&
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|VECTOR_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|inside_init
operator|=
name|default_function_array_conversion
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|flag_isoc99
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
condition|)
block|{
comment|/* As an extension, allow initializing objects with static storage 	     duration with compound literals (which are then treated just as 	     the brace enclosed list they contain).  */
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|inside_init
argument_list|)
decl_stmt|;
name|inside_init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|!=
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
block|{
name|error_init
argument_list|(
literal|"array initialized from non-constant array expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|inside_init
operator|=
name|decl_constant_value_for_broken_optimization
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
comment|/* Compound expressions can only occur here if -pedantic or 	 -pedantic-errors is specified.  In the later case, we always want 	 an error.  In the former case, we simply want a warning.  */
if|if
condition|(
name|require_constant
operator|&&
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|inside_init
operator|=
name|valid_compound_expr_initializer
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside_init
operator|==
name|error_mark_node
condition|)
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
else|else
name|pedwarn_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
operator|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
comment|/* This test catches things like `7 / 0' which 		      result in an expression for which TREE_CONSTANT 		      is true, but which is not actually something 		      that is a legal constant.  We really should not 		      be using this function, because it is a part of 		      the back-end.  Instead, the expression should 		      already have been turned into ERROR_MARK_NODE.  */
operator|||
operator|!
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
comment|/* Handle scalar types, including conversions.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|BOOLEAN_TYPE
operator|||
name|code
operator|==
name|COMPLEX_TYPE
condition|)
block|{
comment|/* Note that convert_for_assignment calls default_conversion 	 for arrays and functions.  We must not call it in the 	 case where inside_init is a null pointer constant.  */
name|inside_init
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|_
argument_list|(
literal|"initialization"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not computable at load time"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
comment|/* Come here only for records and arrays.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_init
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|error_init
argument_list|(
literal|"invalid initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle initializers that use braces.  */
end_comment

begin_comment
comment|/* Type of object we are accumulating a constructor for.    This type is always a RECORD_TYPE, UNION_TYPE or ARRAY_TYPE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For a RECORD_TYPE or UNION_TYPE, this is the chain of fields    left to fill.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_fields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the specified index    at which to store the next element we get.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the maximum index.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_max_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For a RECORD_TYPE, this is the first field not yet written out.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_unfilled_fields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the index of the first element    not yet written out.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_unfilled_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a RECORD_TYPE, the byte index of the next consecutive field.    This is so we can generate gaps between fields, when appropriate.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_bit_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are saving up the elements rather than allocating them,    this is the list of elements so far (in reverse order,    most recent first).  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_elements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if constructor should be incrementally stored into a constructor chain,    0 if all the elements should be kept in AVL tree.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_incremental
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if so far this constructor's elements are all compile-time constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if so far this constructor's elements are all valid address constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_simple
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if this constructor is erroneous so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_erroneous
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if have called defer_addressed_constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_subconstants_deferred
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for managing pending initializer elements, organized as an    AVL tree.  */
end_comment

begin_struct
struct|struct
name|init_node
block|{
name|struct
name|init_node
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|struct
name|init_node
modifier|*
name|parent
decl_stmt|;
name|int
name|balance
decl_stmt|;
name|tree
name|purpose
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Tree of pending elements at this constructor level.    These are elements encountered out of order    which belong at places we haven't reached yet in actually    writing the output.    Will never hold tree nodes across GC runs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|init_node
modifier|*
name|constructor_pending_elts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The SPELLING_DEPTH of this constructor.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 if implicitly pushing constructor levels is allowed.  */
end_comment

begin_decl_stmt
name|int
name|constructor_no_implicit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 for C; 1 for some other languages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|require_constant_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|require_constant_elements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DECL node for which an initializer is being read.    0 means we are reading a constructor expression    such as (struct foo) {...}.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start_init saves the ASMSPEC arg here for really_start_incremental_init.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|constructor_asmspec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this is an initializer for a top-level decl.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_top_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there were any member designators in this initializer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_designated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nesting depth of designator list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|designator_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there were diagnosed errors in this designator list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|designator_errorneous
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This stack has a level for each implicit or explicit level of    structuring in the initializer, including the outermost one.  It    saves the values of most of the variables above.  */
end_comment

begin_struct_decl
struct_decl|struct
name|constructor_range_stack
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|constructor_stack
block|{
name|struct
name|constructor_stack
modifier|*
name|next
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|max_index
decl_stmt|;
name|tree
name|unfilled_index
decl_stmt|;
name|tree
name|unfilled_fields
decl_stmt|;
name|tree
name|bit_index
decl_stmt|;
name|tree
name|elements
decl_stmt|;
name|struct
name|init_node
modifier|*
name|pending_elts
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* If nonzero, this value should replace the entire      constructor at this level.  */
name|tree
name|replacement_value
decl_stmt|;
name|struct
name|constructor_range_stack
modifier|*
name|range_stack
decl_stmt|;
name|char
name|constant
decl_stmt|;
name|char
name|simple
decl_stmt|;
name|char
name|implicit
decl_stmt|;
name|char
name|erroneous
decl_stmt|;
name|char
name|outer
decl_stmt|;
name|char
name|incremental
decl_stmt|;
name|char
name|designated
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|constructor_stack
modifier|*
name|constructor_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This stack represents designators from some range designator up to    the last designator in the list.  */
end_comment

begin_struct
struct|struct
name|constructor_range_stack
block|{
name|struct
name|constructor_range_stack
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|constructor_stack
modifier|*
name|stack
decl_stmt|;
name|tree
name|range_start
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|range_end
decl_stmt|;
name|tree
name|fields
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|constructor_range_stack
modifier|*
name|constructor_range_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This stack records separate initializers that are nested.    Nested initializers can't happen in ANSI C, but GNU C allows them    in cases like { ... (struct foo) { ... } ... }.  */
end_comment

begin_struct
struct|struct
name|initializer_stack
block|{
name|struct
name|initializer_stack
modifier|*
name|next
decl_stmt|;
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
name|struct
name|constructor_stack
modifier|*
name|constructor_stack
decl_stmt|;
name|struct
name|constructor_range_stack
modifier|*
name|constructor_range_stack
decl_stmt|;
name|tree
name|elements
decl_stmt|;
name|struct
name|spelling
modifier|*
name|spelling
decl_stmt|;
name|struct
name|spelling
modifier|*
name|spelling_base
decl_stmt|;
name|int
name|spelling_size
decl_stmt|;
name|char
name|top_level
decl_stmt|;
name|char
name|require_constant_value
decl_stmt|;
name|char
name|require_constant_elements
decl_stmt|;
name|char
name|deferred
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|initializer_stack
modifier|*
name|initializer_stack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Prepare to parse and output the initializer for variable DECL.  */
end_comment

begin_function
name|void
name|start_init
parameter_list|(
name|decl
parameter_list|,
name|asmspec_tree
parameter_list|,
name|top_level
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
name|int
name|top_level
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|locus
decl_stmt|;
name|struct
name|initializer_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|initializer_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|initializer_stack
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
name|p
operator|->
name|decl
operator|=
name|constructor_decl
expr_stmt|;
name|p
operator|->
name|asmspec
operator|=
name|constructor_asmspec
expr_stmt|;
name|p
operator|->
name|require_constant_value
operator|=
name|require_constant_value
expr_stmt|;
name|p
operator|->
name|require_constant_elements
operator|=
name|require_constant_elements
expr_stmt|;
name|p
operator|->
name|constructor_stack
operator|=
name|constructor_stack
expr_stmt|;
name|p
operator|->
name|constructor_range_stack
operator|=
name|constructor_range_stack
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|spelling
operator|=
name|spelling
expr_stmt|;
name|p
operator|->
name|spelling_base
operator|=
name|spelling_base
expr_stmt|;
name|p
operator|->
name|spelling_size
operator|=
name|spelling_size
expr_stmt|;
name|p
operator|->
name|deferred
operator|=
name|constructor_subconstants_deferred
expr_stmt|;
name|p
operator|->
name|top_level
operator|=
name|constructor_top_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|initializer_stack
expr_stmt|;
name|initializer_stack
operator|=
name|p
expr_stmt|;
name|constructor_decl
operator|=
name|decl
expr_stmt|;
name|constructor_asmspec
operator|=
name|asmspec
expr_stmt|;
name|constructor_subconstants_deferred
operator|=
literal|0
expr_stmt|;
name|constructor_designated
operator|=
literal|0
expr_stmt|;
name|constructor_top_level
operator|=
name|top_level
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
name|require_constant_value
operator|=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|require_constant_elements
operator|=
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|)
operator|)
comment|/* For a scalar, you can always use any value to initialize, 	      even within braces.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|)
expr_stmt|;
name|locus
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|require_constant_value
operator|=
literal|0
expr_stmt|;
name|require_constant_elements
operator|=
literal|0
expr_stmt|;
name|locus
operator|=
literal|"(anonymous)"
expr_stmt|;
block|}
name|constructor_stack
operator|=
literal|0
expr_stmt|;
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
name|missing_braces_mentioned
operator|=
literal|0
expr_stmt|;
name|spelling_base
operator|=
literal|0
expr_stmt|;
name|spelling_size
operator|=
literal|0
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locus
condition|)
name|push_string
argument_list|(
name|locus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_init
parameter_list|()
block|{
name|struct
name|initializer_stack
modifier|*
name|p
init|=
name|initializer_stack
decl_stmt|;
comment|/* Output subconstants (string constants, usually)      that were referenced within this initializer and saved up.      Must do this if and only if we called defer_addressed_constants.  */
if|if
condition|(
name|constructor_subconstants_deferred
condition|)
name|output_deferred_addressed_constants
argument_list|()
expr_stmt|;
comment|/* Free the whole constructor stack of this initializer.  */
while|while
condition|(
name|constructor_stack
condition|)
block|{
name|struct
name|constructor_stack
modifier|*
name|q
init|=
name|constructor_stack
decl_stmt|;
name|constructor_stack
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constructor_range_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Pop back to the data of the outer initializer (if any).  */
name|constructor_decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
name|constructor_asmspec
operator|=
name|p
operator|->
name|asmspec
expr_stmt|;
name|require_constant_value
operator|=
name|p
operator|->
name|require_constant_value
expr_stmt|;
name|require_constant_elements
operator|=
name|p
operator|->
name|require_constant_elements
expr_stmt|;
name|constructor_stack
operator|=
name|p
operator|->
name|constructor_stack
expr_stmt|;
name|constructor_range_stack
operator|=
name|p
operator|->
name|constructor_range_stack
expr_stmt|;
name|constructor_elements
operator|=
name|p
operator|->
name|elements
expr_stmt|;
name|spelling
operator|=
name|p
operator|->
name|spelling
expr_stmt|;
name|spelling_base
operator|=
name|p
operator|->
name|spelling_base
expr_stmt|;
name|spelling_size
operator|=
name|p
operator|->
name|spelling_size
expr_stmt|;
name|constructor_subconstants_deferred
operator|=
name|p
operator|->
name|deferred
expr_stmt|;
name|constructor_top_level
operator|=
name|p
operator|->
name|top_level
expr_stmt|;
name|initializer_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call here when we see the initializer is surrounded by braces.    This is instead of a call to push_init_level;    it is matched by a call to pop_init_level.     TYPE is the type to initialize, for a constructor expression.    For an initializer for a decl, TYPE is zero.  */
end_comment

begin_function
name|void
name|really_start_incremental_init
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|constructor_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|constructor_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|constructor_stack
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_decl
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|constructor_type
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|max_index
operator|=
name|constructor_max_index
expr_stmt|;
name|p
operator|->
name|unfilled_index
operator|=
name|constructor_unfilled_index
expr_stmt|;
name|p
operator|->
name|unfilled_fields
operator|=
name|constructor_unfilled_fields
expr_stmt|;
name|p
operator|->
name|bit_index
operator|=
name|constructor_bit_index
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constructor_constant
expr_stmt|;
name|p
operator|->
name|simple
operator|=
name|constructor_simple
expr_stmt|;
name|p
operator|->
name|erroneous
operator|=
name|constructor_erroneous
expr_stmt|;
name|p
operator|->
name|pending_elts
operator|=
name|constructor_pending_elts
expr_stmt|;
name|p
operator|->
name|depth
operator|=
name|constructor_depth
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|implicit
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|range_stack
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|outer
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|incremental
operator|=
name|constructor_incremental
expr_stmt|;
name|p
operator|->
name|designated
operator|=
name|constructor_designated
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|constructor_stack
operator|=
name|p
expr_stmt|;
name|constructor_constant
operator|=
literal|1
expr_stmt|;
name|constructor_simple
operator|=
literal|1
expr_stmt|;
name|constructor_depth
operator|=
name|SPELLING_DEPTH
argument_list|()
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
name|constructor_pending_elts
operator|=
literal|0
expr_stmt|;
name|constructor_type
operator|=
name|type
expr_stmt|;
name|constructor_incremental
operator|=
literal|1
expr_stmt|;
name|constructor_designated
operator|=
literal|0
expr_stmt|;
name|designator_depth
operator|=
literal|0
expr_stmt|;
name|designator_errorneous
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|constructor_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
name|constructor_max_index
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect non-empty initializations of zero-length arrays.  */
if|if
condition|(
name|constructor_max_index
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|constructor_max_index
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* constructor_max_index needs to be an INTEGER_CST.  Attempts 	     to initialize VLAs will cause a proper error; avoid tree 	     checking errors as well by setting a safe value.  */
if|if
condition|(
name|constructor_max_index
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_max_index
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|constructor_max_index
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|constructor_index
operator|=
name|bitsize_zero_node
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* Vectors are like simple fixed-size arrays.  */
name|constructor_max_index
operator|=
name|build_int_2
argument_list|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|constructor_type
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|bitsize_zero_node
argument_list|)
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle the case of int x = {5}; */
name|constructor_fields
operator|=
name|constructor_type
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_type
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push down into a subobject, for initialization.    If this is for an explicit set of braces, IMPLICIT is 0.    If it is because the next element belongs at a lower level,    IMPLICIT is 1 (or 2 if the push is because of designator list).  */
end_comment

begin_function
name|void
name|push_init_level
parameter_list|(
name|implicit
parameter_list|)
name|int
name|implicit
decl_stmt|;
block|{
name|struct
name|constructor_stack
modifier|*
name|p
decl_stmt|;
name|tree
name|value
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If we've exhausted any levels that didn't have braces,      pop them now.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
operator|==
literal|0
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|constructor_max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* Unless this is an explicit brace, we need to preserve previous      content if any.  */
if|if
condition|(
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
condition|)
name|value
operator|=
name|find_init_member
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|value
operator|=
name|find_init_member
argument_list|(
name|constructor_index
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|(
expr|struct
name|constructor_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|constructor_stack
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|constructor_type
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|max_index
operator|=
name|constructor_max_index
expr_stmt|;
name|p
operator|->
name|unfilled_index
operator|=
name|constructor_unfilled_index
expr_stmt|;
name|p
operator|->
name|unfilled_fields
operator|=
name|constructor_unfilled_fields
expr_stmt|;
name|p
operator|->
name|bit_index
operator|=
name|constructor_bit_index
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constructor_constant
expr_stmt|;
name|p
operator|->
name|simple
operator|=
name|constructor_simple
expr_stmt|;
name|p
operator|->
name|erroneous
operator|=
name|constructor_erroneous
expr_stmt|;
name|p
operator|->
name|pending_elts
operator|=
name|constructor_pending_elts
expr_stmt|;
name|p
operator|->
name|depth
operator|=
name|constructor_depth
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|implicit
operator|=
name|implicit
expr_stmt|;
name|p
operator|->
name|outer
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|incremental
operator|=
name|constructor_incremental
expr_stmt|;
name|p
operator|->
name|designated
operator|=
name|constructor_designated
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|constructor_stack
expr_stmt|;
name|p
operator|->
name|range_stack
operator|=
literal|0
expr_stmt|;
name|constructor_stack
operator|=
name|p
expr_stmt|;
name|constructor_constant
operator|=
literal|1
expr_stmt|;
name|constructor_simple
operator|=
literal|1
expr_stmt|;
name|constructor_depth
operator|=
name|SPELLING_DEPTH
argument_list|()
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
name|constructor_incremental
operator|=
literal|1
expr_stmt|;
name|constructor_designated
operator|=
literal|0
expr_stmt|;
name|constructor_pending_elts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|implicit
condition|)
block|{
name|p
operator|->
name|range_stack
operator|=
name|constructor_range_stack
expr_stmt|;
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
name|designator_depth
operator|=
literal|0
expr_stmt|;
name|designator_errorneous
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't die if an entire brace-pair level is superfluous      in the containing level.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* Don't die if there are extra init elts at the end.  */
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
name|constructor_type
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|constructor_type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_depth
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|constructor_type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|push_array_bounds
argument_list|(
name|tree_low_cst
argument_list|(
name|constructor_index
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_depth
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"extra brace group at end of initializer"
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
literal|0
expr_stmt|;
name|constructor_unfilled_fields
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|constructor_constant
operator|=
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constructor_simple
operator|=
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constructor_elements
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_elements
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|implicit
operator|==
literal|1
operator|&&
name|warn_missing_braces
operator|&&
operator|!
name|missing_braces_mentioned
condition|)
block|{
name|missing_braces_mentioned
operator|=
literal|1
expr_stmt|;
name|warning_init
argument_list|(
literal|"missing braces around initializer"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|constructor_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* Vectors are like simple fixed-size arrays.  */
name|constructor_max_index
operator|=
name|build_int_2
argument_list|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|constructor_type
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
name|constructor_max_index
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect non-empty initializations of zero-length arrays.  */
if|if
condition|(
name|constructor_max_index
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|constructor_max_index
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* constructor_max_index needs to be an INTEGER_CST.  Attempts 	     to initialize VLAs will cause a proper error; avoid tree 	     checking errors as well by setting a safe value.  */
if|if
condition|(
name|constructor_max_index
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_max_index
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|constructor_max_index
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|constructor_index
operator|=
name|bitsize_zero_node
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* We need to split the char/wchar array into individual 	     characters, so that we don't have to special case it 	     everywhere.  */
name|set_nonincremental_init_from_string
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|warning_init
argument_list|(
literal|"braces around scalar initializer"
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
name|constructor_type
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* At the end of an implicit or explicit brace level,     finish up that level of constructor.    If we were outputting the elements as they are read, return 0    from inner levels (process_init_element ignores that),    but return error_mark_node from the outermost level    (that's what we want to put in DECL_INITIAL).    Otherwise, return a CONSTRUCTOR expression.  */
end_comment

begin_function
name|tree
name|pop_init_level
parameter_list|(
name|implicit
parameter_list|)
name|int
name|implicit
decl_stmt|;
block|{
name|struct
name|constructor_stack
modifier|*
name|p
decl_stmt|;
name|tree
name|constructor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|implicit
operator|==
literal|0
condition|)
block|{
comment|/* When we come to an explicit close brace, 	 pop any inner levels that didn't have explicit braces.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_range_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|constructor_stack
expr_stmt|;
comment|/* Error for initializing a flexible array member, or a zero-length      array member in an inappropriate context.  */
if|if
condition|(
name|constructor_type
operator|&&
name|constructor_fields
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
operator|&&
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Silently discard empty initializations.  The parser will 	 already have pedwarned for empty brackets.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|constructor_unfilled_index
argument_list|)
condition|)
name|constructor_type
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|constructor_depth
operator|>
literal|2
condition|)
name|error_init
argument_list|(
literal|"initialization of flexible array member in a nested context"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn_init
argument_list|(
literal|"initialization of a flexible array member"
argument_list|)
expr_stmt|;
comment|/* We have already issued an error message for the existence 	     of a flexible array member not at the end of the structure. 	     Discard the initializer so that we do not abort later.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|constructor_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
comment|/* Zero-length arrays are no longer special, so we should no longer 	   get here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Warn when some struct elements are implicitly initialized to zero.  */
if|if
condition|(
name|extra_warnings
operator|&&
name|constructor_type
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|constructor_unfilled_fields
condition|)
block|{
comment|/* Do not warn for flexible array members or zero-length arrays.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|&&
operator|(
operator|!
name|DECL_SIZE
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|constructor_unfilled_fields
argument_list|)
argument_list|)
operator|)
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
comment|/* Do not warn if this level of the initializer uses member 	   designators; it is likely to be deliberate.  */
if|if
condition|(
name|constructor_unfilled_fields
operator|&&
operator|!
name|constructor_designated
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
name|warning_init
argument_list|(
literal|"missing initializer"
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now output all pending elements.  */
name|constructor_incremental
operator|=
literal|1
expr_stmt|;
name|output_pending_init_elements
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Pad out the end of the structure.  */
if|if
condition|(
name|p
operator|->
name|replacement_value
condition|)
comment|/* If this closes a superfluous brace pair,        just pass out the element between them.  */
name|constructor
operator|=
name|p
operator|->
name|replacement_value
expr_stmt|;
elseif|else
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
block|{
comment|/* A nonincremental scalar initializer--just return 	 the element, after verifying there is just one.  */
if|if
condition|(
name|constructor_elements
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|constructor_erroneous
condition|)
name|error_init
argument_list|(
literal|"empty scalar initializer"
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|constructor_elements
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"extra elements in scalar initializer"
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|TREE_VALUE
argument_list|(
name|constructor_elements
argument_list|)
expr_stmt|;
block|}
else|else
name|constructor
operator|=
name|TREE_VALUE
argument_list|(
name|constructor_elements
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|constructor_erroneous
condition|)
name|constructor
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
name|constructor
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|constructor_type
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|constructor_elements
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_constant
condition|)
name|TREE_CONSTANT
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|constructor_constant
operator|&&
name|constructor_simple
condition|)
name|TREE_STATIC
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|constructor_type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|constructor_fields
operator|=
name|p
operator|->
name|fields
expr_stmt|;
name|constructor_index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|constructor_max_index
operator|=
name|p
operator|->
name|max_index
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|p
operator|->
name|unfilled_index
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|p
operator|->
name|unfilled_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|p
operator|->
name|bit_index
expr_stmt|;
name|constructor_elements
operator|=
name|p
operator|->
name|elements
expr_stmt|;
name|constructor_constant
operator|=
name|p
operator|->
name|constant
expr_stmt|;
name|constructor_simple
operator|=
name|p
operator|->
name|simple
expr_stmt|;
name|constructor_erroneous
operator|=
name|p
operator|->
name|erroneous
expr_stmt|;
name|constructor_incremental
operator|=
name|p
operator|->
name|incremental
expr_stmt|;
name|constructor_designated
operator|=
name|p
operator|->
name|designated
expr_stmt|;
name|constructor_pending_elts
operator|=
name|p
operator|->
name|pending_elts
expr_stmt|;
name|constructor_depth
operator|=
name|p
operator|->
name|depth
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|implicit
condition|)
name|constructor_range_stack
operator|=
name|p
operator|->
name|range_stack
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
name|constructor_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|constructor_stack
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|constructor
return|;
block|}
end_function

begin_comment
comment|/* Common handling for both array range and field name designators.    ARRAY argument is nonzero for array ranges.  Returns zero for success.  */
end_comment

begin_function
specifier|static
name|int
name|set_designator
parameter_list|(
name|array
parameter_list|)
name|int
name|array
decl_stmt|;
block|{
name|tree
name|subtype
decl_stmt|;
name|enum
name|tree_code
name|subcode
decl_stmt|;
comment|/* Don't die if an entire brace-pair level is superfluous      in the containing level.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If there were errors in this designator list already, bail out silently.  */
if|if
condition|(
name|designator_errorneous
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|designator_depth
condition|)
block|{
if|if
condition|(
name|constructor_range_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Designator list starts at the level of closest explicit 	 braces.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_designated
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|constructor_no_implicit
condition|)
block|{
name|error_init
argument_list|(
literal|"initialization designators may not nest"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
operator|!=
name|error_mark_node
condition|)
name|subtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|subtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|subcode
operator|=
name|TREE_CODE
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
operator|&&
name|subcode
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"array index in non-array initializer"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|array
operator|&&
name|subcode
operator|!=
name|RECORD_TYPE
operator|&&
name|subcode
operator|!=
name|UNION_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"field name not in record or union initializer"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|constructor_designated
operator|=
literal|1
expr_stmt|;
name|push_init_level
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If there are range designators in designator list, push a new designator    to constructor_range_stack.  RANGE_END is end of such stack range or    NULL_TREE if there is no range designator at this level.  */
end_comment

begin_function
specifier|static
name|void
name|push_range_stack
parameter_list|(
name|range_end
parameter_list|)
name|tree
name|range_end
decl_stmt|;
block|{
name|struct
name|constructor_range_stack
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|constructor_range_stack
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|constructor_range_stack
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|constructor_range_stack
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|range_start
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|stack
operator|=
name|constructor_stack
expr_stmt|;
name|p
operator|->
name|range_end
operator|=
name|range_end
expr_stmt|;
if|if
condition|(
name|constructor_range_stack
condition|)
name|constructor_range_stack
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|constructor_range_stack
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Within an array initializer, specify the next index to be initialized.    FIRST is that index.  If LAST is nonzero, then initialize a range    of indices, running from FIRST through LAST.  */
end_comment

begin_function
name|void
name|set_init_index
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|tree
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
if|if
condition|(
name|set_designator
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|designator_errorneous
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|first
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|first
operator|=
name|TREE_OPERAND
argument_list|(
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|last
operator|=
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error_init
argument_list|(
literal|"nonconstant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error_init
argument_list|(
literal|"nonconstant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error_init
argument_list|(
literal|"array index in non-array initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|first
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error_init
argument_list|(
literal|"array index in initializer exceeds array bounds"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constructor_max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|first
argument_list|)
condition|)
name|error_init
argument_list|(
literal|"array index in initializer exceeds array bounds"
argument_list|)
expr_stmt|;
else|else
block|{
name|constructor_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
condition|)
name|last
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|last
argument_list|,
name|first
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"empty index range in initializer"
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_max_index
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|last
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"array index range in initializer exceeds array bounds"
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|designator_depth
operator|++
expr_stmt|;
name|designator_errorneous
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constructor_range_stack
operator|||
name|last
condition|)
name|push_range_stack
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Within a struct initializer, specify the next field to be initialized.  */
end_comment

begin_function
name|void
name|set_init_label
parameter_list|(
name|fieldname
parameter_list|)
name|tree
name|fieldname
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|set_designator
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|designator_errorneous
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"field name not in record or union initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tail
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|==
name|fieldname
condition|)
break|break;
block|}
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unknown field `%s' specified in initializer"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|fieldname
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|constructor_fields
operator|=
name|tail
expr_stmt|;
name|designator_depth
operator|++
expr_stmt|;
name|designator_errorneous
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constructor_range_stack
condition|)
name|push_range_stack
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a new initializer to the tree of pending initializers.  PURPOSE    identifies the initializer, either array index or field in a structure.     VALUE is the value of that index or field.  */
end_comment

begin_function
specifier|static
name|void
name|add_pending_init
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|;
block|{
name|struct
name|init_node
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|q
operator|=
operator|&
name|constructor_pending_elts
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
name|q
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|purpose
argument_list|,
name|p
operator|->
name|purpose
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|p
operator|->
name|purpose
argument_list|,
name|purpose
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|p
operator|->
name|value
argument_list|)
condition|)
name|warning_init
argument_list|(
literal|"initialized field with side-effects overwritten"
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|value
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|tree
name|bitpos
decl_stmt|;
name|bitpos
operator|=
name|bit_position
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|*
name|q
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|bit_position
argument_list|(
name|p
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|purpose
operator|!=
name|purpose
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|p
operator|->
name|value
argument_list|)
condition|)
name|warning_init
argument_list|(
literal|"initialized field with side-effects overwritten"
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|value
expr_stmt|;
return|return;
block|}
block|}
block|}
name|r
operator|=
operator|(
expr|struct
name|init_node
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|init_node
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|purpose
operator|=
name|purpose
expr_stmt|;
name|r
operator|->
name|value
operator|=
name|value
expr_stmt|;
operator|*
name|q
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|struct
name|init_node
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|p
operator|->
name|left
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|balance
operator|==
literal|0
condition|)
name|p
operator|->
name|balance
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
comment|/* L rotation.  */
name|p
operator|->
name|left
operator|=
name|r
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
condition|)
name|p
operator|->
name|left
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
comment|/* LR rotation.  */
name|struct
name|init_node
modifier|*
name|t
init|=
name|r
operator|->
name|right
decl_stmt|;
name|r
operator|->
name|right
operator|=
name|t
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|right
condition|)
name|r
operator|->
name|right
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
condition|)
name|p
operator|->
name|left
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|<
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
operator|-
operator|(
name|t
operator|->
name|balance
operator|>
literal|0
operator|)
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == +1; growth of left side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* r == p->right */
block|{
if|if
condition|(
name|p
operator|->
name|balance
operator|==
literal|0
condition|)
comment|/* Growth propagation from right side.  */
name|p
operator|->
name|balance
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
comment|/* R rotation.  */
name|p
operator|->
name|right
operator|=
name|r
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|p
operator|->
name|right
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|r
expr_stmt|;
block|}
else|else
comment|/* r->balance == -1 */
block|{
comment|/* RL rotation */
name|struct
name|init_node
modifier|*
name|t
init|=
name|r
operator|->
name|left
decl_stmt|;
name|r
operator|->
name|left
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|left
condition|)
name|r
operator|->
name|left
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|t
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|p
operator|->
name|right
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|balance
operator|=
operator|(
name|t
operator|->
name|balance
operator|<
literal|0
operator|)
expr_stmt|;
name|p
operator|->
name|balance
operator|=
operator|-
operator|(
name|t
operator|->
name|balance
operator|>
literal|0
operator|)
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == -1; growth of right side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|r
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build AVL tree from a sorted chain.  */
end_comment

begin_function
specifier|static
name|void
name|set_nonincremental_init
parameter_list|()
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return;
for|for
control|(
name|chain
operator|=
name|constructor_elements
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
name|add_pending_init
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|constructor_unfilled_index
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|constructor_unfilled_index
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build AVL tree from a string constant.  */
end_comment

begin_function
specifier|static
name|void
name|set_nonincremental_init_from_string
parameter_list|(
name|str
parameter_list|)
name|tree
name|str
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|,
name|purpose
decl_stmt|,
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|val
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|wchar_bytes
decl_stmt|,
name|charwidth
decl_stmt|,
name|bitpos
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
name|wchar_bytes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
condition|)
name|wchar_bytes
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|charwidth
operator|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|TREE_STRING_LENGTH
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|purpose
operator|=
name|bitsize_zero_node
init|;
name|p
operator|<
name|end
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|purpose
argument_list|)
condition|;
name|purpose
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|purpose
argument_list|,
name|bitsize_one_node
argument_list|)
control|)
block|{
if|if
condition|(
name|wchar_bytes
operator|==
literal|1
condition|)
block|{
name|val
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|val
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|wchar_bytes
condition|;
name|byte
operator|++
control|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|bitpos
operator|=
operator|(
name|wchar_bytes
operator|-
name|byte
operator|-
literal|1
operator|)
operator|*
name|charwidth
expr_stmt|;
else|else
name|bitpos
operator|=
name|byte
operator|*
name|charwidth
expr_stmt|;
name|val
index|[
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
index|]
operator||=
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
argument_list|)
operator|)
operator|<<
operator|(
name|bitpos
operator|%
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|bitpos
operator|=
operator|(
operator|(
name|wchar_bytes
operator|-
literal|1
operator|)
operator|*
name|charwidth
operator|)
operator|+
name|HOST_BITS_PER_CHAR
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|bitpos
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|val
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bitpos
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitpos
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|<
literal|0
condition|)
name|val
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
index|[
literal|0
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|bitpos
operator|-
literal|1
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
condition|)
name|val
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
name|value
operator|=
name|build_int_2
argument_list|(
name|val
index|[
literal|1
index|]
argument_list|,
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
name|add_pending_init
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return value of FIELD in pending initializer or zero if the field was    not initialized yet.  */
end_comment

begin_function
specifier|static
name|tree
name|find_init_member
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
name|struct
name|init_node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|constructor_incremental
operator|&&
name|tree_int_cst_lt
argument_list|(
name|field
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
name|p
operator|=
name|constructor_pending_elts
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|field
argument_list|,
name|p
operator|->
name|purpose
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|p
operator|->
name|purpose
argument_list|,
name|field
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
else|else
return|return
name|p
operator|->
name|value
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|bitpos
init|=
name|bit_position
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|constructor_incremental
operator|&&
operator|(
operator|!
name|constructor_unfilled_fields
operator|||
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|bit_position
argument_list|(
name|constructor_unfilled_fields
argument_list|)
argument_list|)
operator|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
name|p
operator|=
name|constructor_pending_elts
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|field
operator|==
name|p
operator|->
name|purpose
condition|)
return|return
name|p
operator|->
name|value
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|bit_position
argument_list|(
name|p
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
else|else
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|constructor_elements
operator|&&
name|TREE_PURPOSE
argument_list|(
name|constructor_elements
argument_list|)
operator|==
name|field
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|constructor_elements
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* "Output" the next constructor element.    At top level, really output it to assembler code now.    Otherwise, collect it in a list from which we will make a CONSTRUCTOR.    TYPE is the data type that the containing data type wants here.    FIELD is the field (a FIELD_DECL) or the index that this element fills.     PENDING if non-nil means output pending elements that belong    right after this element.  (PENDING is normally 1;    it is 0 while outputting pending elements, to avoid recursion.)  */
end_comment

begin_function
specifier|static
name|void
name|output_init_element
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|,
name|pending
parameter_list|)
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|,
name|field
decl_stmt|;
name|int
name|pending
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
operator|&&
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
operator|&&
name|require_constant_value
operator|&&
operator|!
name|flag_isoc99
operator|&&
name|pending
condition|)
block|{
comment|/* As an extension, allow initializing objects with static storage 	 duration with compound literals (which are then treated just as 	 the brace enclosed list they contain).  */
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|value
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
name|constructor_erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|constructor_constant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
name|constructor_simple
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|require_constant_value
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant_elements
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"initializer element is not computable at load time"
argument_list|)
expr_stmt|;
comment|/* If this field is empty (and not at the end of structure),      don't do anything other than checking the initializer.  */
if|if
condition|(
name|field
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return;
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|require_constant_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
block|{
name|constructor_erroneous
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If this element doesn't come next in sequence,      put it on constructor_pending_elts.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
operator|!
name|constructor_incremental
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|field
argument_list|,
name|constructor_unfilled_index
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|constructor_incremental
operator|&&
name|tree_int_cst_lt
argument_list|(
name|field
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
name|add_pending_init
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|(
operator|!
name|constructor_incremental
operator|||
name|field
operator|!=
name|constructor_unfilled_fields
operator|)
condition|)
block|{
comment|/* We do this for records but not for unions.  In a union, 	 no matter which field is specified, it can be initialized 	 right away since it starts at the beginning of the union.  */
if|if
condition|(
name|constructor_incremental
condition|)
block|{
if|if
condition|(
operator|!
name|constructor_unfilled_fields
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
else|else
block|{
name|tree
name|bitpos
decl_stmt|,
name|unfillpos
decl_stmt|;
name|bitpos
operator|=
name|bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|unfillpos
operator|=
name|bit_position
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|bitpos
argument_list|,
name|unfillpos
argument_list|)
condition|)
name|set_nonincremental_init
argument_list|()
expr_stmt|;
block|}
block|}
name|add_pending_init
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|constructor_elements
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|constructor_elements
argument_list|)
argument_list|)
condition|)
name|warning_init
argument_list|(
literal|"initialized field with side-effects overwritten"
argument_list|)
expr_stmt|;
comment|/* We can have just one union field set.  */
name|constructor_elements
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, output this element either to      constructor_elements or to the assembler file.  */
if|if
condition|(
name|field
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|field
operator|=
name|copy_node
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|constructor_elements
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|constructor_elements
argument_list|)
expr_stmt|;
comment|/* Advance the variable that indicates sequential elements output.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|constructor_unfilled_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_unfilled_index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|constructor_unfilled_fields
operator|=
literal|0
expr_stmt|;
comment|/* Now output any pending elements which have become next.  */
if|if
condition|(
name|pending
condition|)
name|output_pending_init_elements
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output any pending elements which have become next.    As we output elements, constructor_unfilled_{fields,index}    advances, which may cause other elements to become next;    if so, they too are output.     If ALL is 0, we return when there are    no more pending elements to output now.     If ALL is 1, we output space as necessary so that    we can output all the pending elements.  */
end_comment

begin_function
specifier|static
name|void
name|output_pending_init_elements
parameter_list|(
name|all
parameter_list|)
name|int
name|all
decl_stmt|;
block|{
name|struct
name|init_node
modifier|*
name|elt
init|=
name|constructor_pending_elts
decl_stmt|;
name|tree
name|next
decl_stmt|;
name|retry
label|:
comment|/* Look thru the whole pending tree.      If we find an element that should be output now,      output it.  Otherwise, set NEXT to the element      that comes first among those still pending.  */
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|elt
operator|->
name|purpose
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|output_init_element
argument_list|(
name|elt
operator|->
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|,
name|constructor_unfilled_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|constructor_unfilled_index
argument_list|,
name|elt
operator|->
name|purpose
argument_list|)
condition|)
block|{
comment|/* Advance to the next smaller node.  */
if|if
condition|(
name|elt
operator|->
name|left
condition|)
name|elt
operator|=
name|elt
operator|->
name|left
expr_stmt|;
else|else
block|{
comment|/* We have reached the smallest node bigger than the 		     current unfilled index.  Fill the space first.  */
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Advance to the next bigger node.  */
if|if
condition|(
name|elt
operator|->
name|right
condition|)
name|elt
operator|=
name|elt
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have reached the biggest node in a subtree.  Find 		     the parent of it, which is the next bigger node.  */
while|while
condition|(
name|elt
operator|->
name|parent
operator|&&
name|elt
operator|->
name|parent
operator|->
name|right
operator|==
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_unfilled_index
argument_list|,
name|elt
operator|->
name|purpose
argument_list|)
condition|)
block|{
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|ctor_unfilled_bitpos
decl_stmt|,
name|elt_bitpos
decl_stmt|;
comment|/* If the current record is complete we are done.  */
if|if
condition|(
name|constructor_unfilled_fields
operator|==
literal|0
condition|)
break|break;
name|ctor_unfilled_bitpos
operator|=
name|bit_position
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
name|elt_bitpos
operator|=
name|bit_position
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
expr_stmt|;
comment|/* We can't compare fields here because there might be empty 	     fields in between.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|elt_bitpos
argument_list|,
name|ctor_unfilled_bitpos
argument_list|)
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
name|output_init_element
argument_list|(
name|elt
operator|->
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
argument_list|,
name|elt
operator|->
name|purpose
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|ctor_unfilled_bitpos
argument_list|,
name|elt_bitpos
argument_list|)
condition|)
block|{
comment|/* Advance to the next smaller node.  */
if|if
condition|(
name|elt
operator|->
name|left
condition|)
name|elt
operator|=
name|elt
operator|->
name|left
expr_stmt|;
else|else
block|{
comment|/* We have reached the smallest node bigger than the 		     current unfilled field.  Fill the space first.  */
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Advance to the next bigger node.  */
if|if
condition|(
name|elt
operator|->
name|right
condition|)
name|elt
operator|=
name|elt
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have reached the biggest node in a subtree.  Find 		     the parent of it, which is the next bigger node.  */
while|while
condition|(
name|elt
operator|->
name|parent
operator|&&
name|elt
operator|->
name|parent
operator|->
name|right
operator|==
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
operator|(
name|tree_int_cst_lt
argument_list|(
name|ctor_unfilled_bitpos
argument_list|,
name|bit_position
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Ordinarily return, but not if we want to output all      and there are elements left.  */
if|if
condition|(
operator|!
operator|(
name|all
operator|&&
name|next
operator|!=
literal|0
operator|)
condition|)
return|return;
comment|/* If it's not incremental, just skip over the gap, so that after      jumping to retry we will output the next successive element.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|constructor_unfilled_fields
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|constructor_unfilled_index
operator|=
name|next
expr_stmt|;
comment|/* ELT now points to the node in the pending tree with the next      initializer to output.  */
goto|goto
name|retry
goto|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add one non-braced element to the current constructor level.    This adjusts the current position within the constructor's type.    This may also start or terminate implicit levels    to handle a partly-braced initializer.     Once this has found the correct level for the new element,    it calls output_init_element.  */
end_comment

begin_function
name|void
name|process_init_element
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|orig_value
init|=
name|value
decl_stmt|;
name|int
name|string_flag
init|=
name|value
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
decl_stmt|;
name|designator_depth
operator|=
literal|0
expr_stmt|;
name|designator_errorneous
operator|=
literal|0
expr_stmt|;
comment|/* Handle superfluous braces around string cst as in      char x[] = {"foo"}; */
if|if
condition|(
name|string_flag
operator|&&
name|constructor_type
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|constructor_unfilled_index
argument_list|)
condition|)
block|{
if|if
condition|(
name|constructor_stack
operator|->
name|replacement_value
condition|)
name|error_init
argument_list|(
literal|"excess elements in char array initializer"
argument_list|)
expr_stmt|;
name|constructor_stack
operator|->
name|replacement_value
operator|=
name|value
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|constructor_stack
operator|->
name|replacement_value
operator|!=
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"excess elements in struct initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ignore elements of a brace group if it is entirely superfluous      and has already been diagnosed.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
return|return;
comment|/* If we've exhausted any levels that didn't have braces,      pop them now.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
operator|==
literal|0
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|constructor_max_index
operator|==
literal|0
operator|||
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
operator|)
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* In the case of [LO ... HI] = VALUE, only evaluate VALUE once.  */
if|if
condition|(
name|constructor_range_stack
condition|)
block|{
comment|/* If value is a compound literal and we'll be just using its 	 content, don't put it into a SAVE_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|COMPOUND_LITERAL_EXPR
operator|||
operator|!
name|require_constant_value
operator|||
name|flag_isoc99
condition|)
name|value
operator|=
name|save_expr
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|fieldtype
decl_stmt|;
name|enum
name|tree_code
name|fieldcode
decl_stmt|;
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in struct initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fieldtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|!=
name|error_mark_node
condition|)
name|fieldtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
name|fieldcode
operator|=
name|TREE_CODE
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
comment|/* Error for non-static initialization of a flexible array member.  */
if|if
condition|(
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|require_constant_value
operator|&&
name|TYPE_SIZE
argument_list|(
name|fieldtype
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error_init
argument_list|(
literal|"non-static initialization of a flexible array member"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|string_flag
condition|)
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|constructor_no_implicit
operator|&&
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|fieldtype
operator|&&
operator|(
name|fieldcode
operator|==
name|RECORD_TYPE
operator|||
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|||
name|fieldcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
argument_list|,
name|fieldtype
argument_list|,
name|constructor_fields
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Do the bookkeeping for an element that was 	       directly output as a constructor.  */
block|{
comment|/* For a record, keep track of end position of last field.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
condition|)
name|constructor_bit_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_position
argument_list|(
name|constructor_fields
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the current field was the first one not yet written out, 		 it isn't now, so update.  */
if|if
condition|(
name|constructor_unfilled_fields
operator|==
name|constructor_fields
condition|)
block|{
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields.  */
while|while
condition|(
name|constructor_unfilled_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_unfilled_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
block|}
block|}
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|fieldtype
decl_stmt|;
name|enum
name|tree_code
name|fieldcode
decl_stmt|;
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in union initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fieldtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|!=
name|error_mark_node
condition|)
name|fieldtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
name|fieldcode
operator|=
name|TREE_CODE
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
comment|/* Warn that traditional C rejects initialization of unions. 	     We skip the warning if the value is zero.  This is done 	     under the assumption that the zero initializer in user 	     code appears conditioned on e.g. __STDC__ to avoid 	     "missing initializer" warnings and relies on default 	     initialization to zero in the traditional C case. 	     We also skip the warning if the initializer is designated, 	     again on the assumption that this must be conditional on 	     __STDC__ anyway (and we've already complained about the 	     member-designator already).  */
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|constructor_designated
operator|&&
operator|!
operator|(
name|value
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|value
argument_list|)
operator|||
name|real_zerop
argument_list|(
name|value
argument_list|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"traditional C rejects initialization of unions"
argument_list|)
expr_stmt|;
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|string_flag
condition|)
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|constructor_no_implicit
operator|&&
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|fieldtype
operator|&&
operator|(
name|fieldcode
operator|==
name|RECORD_TYPE
operator|||
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|||
name|fieldcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
argument_list|,
name|fieldtype
argument_list|,
name|constructor_fields
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Do the bookkeeping for an element that was 	       directly output as a constructor.  */
block|{
name|constructor_bit_index
operator|=
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
block|}
name|constructor_fields
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|elttype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|eltcode
init|=
name|TREE_CODE
argument_list|(
name|elttype
argument_list|)
decl_stmt|;
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|eltcode
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|string_flag
condition|)
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|constructor_no_implicit
operator|&&
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|elttype
operator|&&
operator|(
name|eltcode
operator|==
name|RECORD_TYPE
operator|||
name|eltcode
operator|==
name|ARRAY_TYPE
operator|||
name|eltcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|constructor_max_index
operator|!=
literal|0
operator|&&
operator|(
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|constructor_max_index
argument_list|)
operator|)
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in array initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now output the actual element.  */
if|if
condition|(
name|value
condition|)
block|{
name|push_array_bounds
argument_list|(
name|tree_low_cst
argument_list|(
name|constructor_index
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
argument_list|,
name|elttype
argument_list|,
name|constructor_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
name|constructor_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
comment|/* If we are doing the bookkeeping for an element that was 	       directly output as a constructor, we must update 	       constructor_unfilled_index.  */
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|tree
name|elttype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Do a basic check of initializer size.  Note that vectors             always have a fixed size derived from their type.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in vector initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now output the actual element.  */
if|if
condition|(
name|value
condition|)
name|output_init_element
argument_list|(
name|value
argument_list|,
name|elttype
argument_list|,
name|constructor_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
comment|/* If we are doing the bookkeeping for an element that was 	       directly output as a constructor, we must update 	       constructor_unfilled_index.  */
name|constructor_unfilled_index
operator|=
name|constructor_index
expr_stmt|;
block|}
comment|/* Handle the sole element allowed in a braced initializer 	 for a scalar variable.  */
elseif|else
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in scalar initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|value
condition|)
name|output_init_element
argument_list|(
name|value
argument_list|,
name|constructor_type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Handle range initializers either at this level or anywhere higher 	 in the designator stack.  */
if|if
condition|(
name|constructor_range_stack
condition|)
block|{
name|struct
name|constructor_range_stack
modifier|*
name|p
decl_stmt|,
modifier|*
name|range_stack
decl_stmt|;
name|int
name|finish
init|=
literal|0
decl_stmt|;
name|range_stack
operator|=
name|constructor_range_stack
expr_stmt|;
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|constructor_stack
operator|!=
name|range_stack
operator|->
name|stack
condition|)
block|{
if|if
condition|(
operator|!
name|constructor_stack
operator|->
name|implicit
condition|)
name|abort
argument_list|()
expr_stmt|;
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|range_stack
init|;
operator|!
name|p
operator|->
name|range_end
operator|||
name|tree_int_cst_equal
argument_list|(
name|p
operator|->
name|index
argument_list|,
name|p
operator|->
name|range_end
argument_list|)
condition|;
name|p
operator|=
name|p
operator|->
name|prev
control|)
block|{
if|if
condition|(
operator|!
name|constructor_stack
operator|->
name|implicit
condition|)
name|abort
argument_list|()
expr_stmt|;
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|p
operator|->
name|index
argument_list|,
name|bitsize_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|p
operator|->
name|index
argument_list|,
name|p
operator|->
name|range_end
argument_list|)
operator|&&
operator|!
name|p
operator|->
name|prev
condition|)
name|finish
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|constructor_index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|constructor_fields
operator|=
name|p
operator|->
name|fields
expr_stmt|;
if|if
condition|(
name|finish
operator|&&
name|p
operator|->
name|range_end
operator|&&
name|p
operator|->
name|index
operator|==
name|p
operator|->
name|range_start
condition|)
block|{
name|finish
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break;
name|push_init_level
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|p
operator|->
name|stack
operator|=
name|constructor_stack
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|range_end
operator|&&
name|tree_int_cst_equal
argument_list|(
name|p
operator|->
name|index
argument_list|,
name|p
operator|->
name|range_end
argument_list|)
condition|)
name|p
operator|->
name|index
operator|=
name|p
operator|->
name|range_start
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|finish
condition|)
name|constructor_range_stack
operator|=
name|range_stack
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|constructor_range_stack
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a simple asm-statement, from one string literal.  */
end_comment

begin_function
name|tree
name|simple_asm_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Simple asm statements are treated as volatile.  */
name|stmt
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|ASM_STMT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_INPUT_P
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|stmt
return|;
block|}
name|error
argument_list|(
literal|"argument of `asm' is not a constant string"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build an asm-statement, whose components are a CV_QUALIFIER, a    STRING, some OUTPUTS, some INPUTS, and some CLOBBERS.  */
end_comment

begin_function
name|tree
name|build_asm_stmt
parameter_list|(
name|cv_qualifier
parameter_list|,
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|)
name|tree
name|cv_qualifier
decl_stmt|;
name|tree
name|string
decl_stmt|;
name|tree
name|outputs
decl_stmt|;
name|tree
name|inputs
decl_stmt|;
name|tree
name|clobbers
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"asm template is not a string constant"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|cv_qualifier
operator|!=
name|NULL_TREE
operator|&&
name|cv_qualifier
operator|!=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"%s qualifier ignored on asm"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cv_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|cv_qualifier
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* We can remove output conversions that change the type,      but not the mode.  */
for|for
control|(
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|tree
name|output
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|output
expr_stmt|;
comment|/* Allow conversions as LHS here.  build_modify_expr as called below 	 will do the right thing with them.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|output
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|output
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|output
argument_list|)
operator|==
name|FLOAT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|output
argument_list|)
operator|==
name|FIX_TRUNC_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|output
argument_list|)
operator|==
name|FIX_FLOOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|output
argument_list|)
operator|==
name|FIX_ROUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|output
argument_list|)
operator|==
name|FIX_CEIL_EXPR
condition|)
name|output
operator|=
name|TREE_OPERAND
argument_list|(
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lvalue_or_else
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
literal|"invalid lvalue in asm statement"
argument_list|)
expr_stmt|;
block|}
comment|/* Remove output conversions that change the type but not the mode.  */
for|for
control|(
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|tree
name|output
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|output
expr_stmt|;
block|}
comment|/* Perform default conversions on array and function inputs.       Don't do this for other types as it would screw up operands      expected to be in memory.  */
for|for
control|(
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|default_function_array_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|ASM_STMT
argument_list|,
name|cv_qualifier
argument_list|,
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tail
decl_stmt|;
comment|/* Record the contents of OUTPUTS before it is modified.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
index|[
name|i
index|]
operator|==
name|error_mark_node
condition|)
return|return;
block|}
comment|/* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of      OUTPUTS some trees for where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Restore the original value so that it's correct the next 	     time we expand this function.  */
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|o
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C `return' statement.    RETVAL is the expression for what to return,    or a null pointer for `return;' with no value.  */
end_comment

begin_function
name|tree
name|c_expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `noreturn' has a `return' statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|warn_return_type
operator|||
name|flag_isoc99
operator|)
operator|&&
name|valtype
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pedwarn_c99
argument_list|(
literal|"`return' with no value, in function returning non-void"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"`return' with a value, in function returning void"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|convert_for_assignment
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|,
name|_
argument_list|(
literal|"return"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|res
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|inner
decl_stmt|;
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|inner
operator|=
name|t
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Strip any conversions, additions, and subtractions, and see if 	 we are returning the address of a local variable.  Warn if so.  */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MINUS_EXPR
case|:
comment|/* If the second operand of the MINUS_EXPR has a pointer 		 type (or is converted from it), this may be valid, so 		 don't give a warning.  */
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
condition|)
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
break|break;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|ADDR_EXPR
case|:
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
literal|'r'
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|inner
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|inner
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|inner
argument_list|)
operator|==
name|current_function_decl
condition|)
name|warning
argument_list|(
literal|"function returns address of local variable"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
name|retval
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|add_stmt
argument_list|(
name|build_return_stmt
argument_list|(
name|retval
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|c_switch
block|{
comment|/* The SWITCH_STMT being built.  */
name|tree
name|switch_stmt
decl_stmt|;
comment|/* A splay-tree mapping the low element of a case range to the high      element, or NULL_TREE if there is no high element.  Used to      determine whether or not a new case label duplicates an old case      label.  We need a tree, rather than simply a hash table, because      of the GNU case range extension.  */
name|splay_tree
name|cases
decl_stmt|;
comment|/* The next node on the stack.  */
name|struct
name|c_switch
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A stack of the currently active switch statements.  The innermost    switch statement is on the top of the stack.  There is no need to    mark the stack for garbage collection because it is only active    during the processing of the body of a function, and we never    collect at that point.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|c_switch
modifier|*
name|switch_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start a C switch statement, testing expression EXP.  Return the new    SWITCH_STMT.  */
end_comment

begin_function
name|tree
name|c_start_case
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|orig_type
init|=
name|error_mark_node
decl_stmt|;
name|struct
name|c_switch
modifier|*
name|cs
decl_stmt|;
if|if
condition|(
name|exp
operator|!=
name|error_mark_node
condition|)
block|{
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|orig_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|orig_type
argument_list|)
operator|&&
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
operator|(
name|type
operator|==
name|long_integer_type_node
operator|||
name|type
operator|==
name|long_unsigned_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"`long' switch expression not converted to `int' in ISO C"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add this new SWITCH_STMT to the stack.  */
name|cs
operator|=
operator|(
expr|struct
name|c_switch
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|->
name|switch_stmt
operator|=
name|build_stmt
argument_list|(
name|SWITCH_STMT
argument_list|,
name|exp
argument_list|,
name|NULL_TREE
argument_list|,
name|orig_type
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cases
operator|=
name|splay_tree_new
argument_list|(
name|case_compare
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cs
operator|->
name|next
operator|=
name|switch_stack
expr_stmt|;
name|switch_stack
operator|=
name|cs
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|switch_stack
operator|->
name|switch_stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process a case label.  */
end_comment

begin_function
name|tree
name|do_case
parameter_list|(
name|low_value
parameter_list|,
name|high_value
parameter_list|)
name|tree
name|low_value
decl_stmt|;
name|tree
name|high_value
decl_stmt|;
block|{
name|tree
name|label
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|switch_stack
condition|)
block|{
name|label
operator|=
name|c_add_case_label
argument_list|(
name|switch_stack
operator|->
name|cases
argument_list|,
name|SWITCH_COND
argument_list|(
name|switch_stack
operator|->
name|switch_stmt
argument_list|)
argument_list|,
name|low_value
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|error_mark_node
condition|)
name|label
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low_value
condition|)
name|error
argument_list|(
literal|"case label not within a switch statement"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`default' label not within a switch statement"
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Finish the switch statement.  */
end_comment

begin_function
name|void
name|c_finish_case
parameter_list|()
block|{
name|struct
name|c_switch
modifier|*
name|cs
init|=
name|switch_stack
decl_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|cs
operator|->
name|switch_stmt
argument_list|,
name|SWITCH_BODY
argument_list|(
name|cs
operator|->
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop the stack.  */
name|switch_stack
operator|=
name|switch_stack
operator|->
name|next
expr_stmt|;
name|splay_tree_delete
argument_list|(
name|cs
operator|->
name|cases
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

