begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C compiler.    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It contains routines to build C expressions given their operands,    including computing the types of the result, C-specific error checks,    and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* Nonzero if we've already printed a "missing braces around initializer"    message within this initializer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|missing_braces_mentioned
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|qualify_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_target_types
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_types_compatible_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_lists_compatible_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|self_promoting_type_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_constant_value
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_arguments
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|pointer_int_sum
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|pointer_diff
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unary_complex_lvalue
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pedantic_lvalue_warning
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|internal_build_compound_expr
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_for_assignment
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_for_assignment
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|valid_compound_expr_initializer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_string
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_member_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_array_bounds
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spelling_length
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|print_spelling
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warning_init
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|digest_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_init_type_bitfields
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_init_element
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pending_init_elements
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pending_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pending_init_member
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
name|value
return|;
name|incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|incomplete_type_error
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|type_code_string
decl_stmt|;
comment|/* Avoid duplicate error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
name|error
argument_list|(
literal|"`%s' has an incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|retry
label|:
comment|/* We must print an error message.  Be clever about what it says.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|type_code_string
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|type_code_string
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|type_code_string
operator|=
literal|"enum"
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"invalid use of undefined type `%s %s'"
argument_list|,
name|type_code_string
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
name|error
argument_list|(
literal|"invalid use of incomplete typedef `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|type
parameter_list|,
name|like
parameter_list|)
name|tree
name|type
decl_stmt|,
name|like
decl_stmt|;
block|{
return|return
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|like
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.  In particular, we assume that qualifiers    match.     This is the type for the result of most arithmetic operations    if the operands have the given two types.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
name|merge_machine_type_attributes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* If one type is complex, form the common type of the non-complex      components, then make that complex.  Use T1 or T2 if it is the      required type.  */
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|subtype1
init|=
name|code1
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
decl_stmt|;
name|tree
name|subtype2
init|=
name|code2
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
else|:
name|t2
decl_stmt|;
name|tree
name|subtype
init|=
name|common_type
argument_list|(
name|subtype1
argument_list|,
name|subtype2
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|build_complex_type
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|attributes
argument_list|)
return|;
block|}
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Same precision.  Prefer longs to ints even when same size.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_unsigned_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	     since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
name|t1
operator|=
name|long_unsigned_type_node
expr_stmt|;
else|else
name|t1
operator|=
name|long_integer_type_node
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* Likewise, prefer long double to double even if same size.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_double_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_double_type_node
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_double_type_node
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type, 	 and combine the qualifiers of the two types' targets.  */
comment|/* This code was turned off; I don't know why. 	 But ANSI C specifies doing this with the qualifiers. 	 So I turned it on again.  */
block|{
name|tree
name|pointed_to_1
init|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|pointed_to_2
init|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|target
init|=
name|common_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|pointed_to_1
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|pointed_to_2
argument_list|)
argument_list|)
decl_stmt|;
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|target
argument_list|,
name|TYPE_QUALS
argument_list|(
name|pointed_to_1
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|pointed_to_2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
block|t1 = build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));       return build_type_attribute_variant (t1, attributes);
endif|#
directive|endif
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
name|t1
operator|=
name|build_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* If both args specify argument types, we must merge the two 	   lists, argument by argument.  */
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
control|)
block|{
comment|/* A null type means arg type is not specified. 	       Take whatever the other function type has.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
comment|/* Given  wait (union {union wait *u; int *i} *) 	       and  wait (union wait *), 	       prefer  union wait *  as type of parm.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ANSI C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ANSI C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|common_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|parm_done
label|:
empty_stmt|;
block|}
name|t1
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
comment|/* ... falls through ...  */
block|}
default|default:
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  Return 2 if they are compatible    but a warning may be needed if you use them together.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|type1
decl_stmt|;
specifier|register
name|tree
name|t2
init|=
name|type2
decl_stmt|;
name|int
name|attrval
decl_stmt|,
name|val
decl_stmt|;
comment|/* Suppress errors caused by previously reported errors.  */
if|if
condition|(
name|t1
operator|==
name|t2
operator|||
operator|!
name|t1
operator|||
operator|!
name|t2
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* Treat an enum type as the integer type of the same width and       signedness.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow for two different type nodes which have essentially the same      definition.  Note that we already checked for equality of the type      qualifiers (just above).  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
ifndef|#
directive|ifndef
name|COMP_TYPE_ATTRIBUTES
define|#
directive|define
name|COMP_TYPE_ATTRIBUTES
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
value|1
endif|#
directive|endif
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
if|if
condition|(
operator|!
operator|(
name|attrval
operator|=
name|COMP_TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
name|val
operator|=
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|?
literal|1
else|:
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|val
operator|=
name|function_types_compatible_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
comment|/* Target types must match incl. qualifiers.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
literal|0
operator|==
operator|(
name|val
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Sizes must match unless one is missing or variable.  */
if|if
condition|(
name|d1
operator|==
literal|0
operator|||
name|d2
operator|==
literal|0
operator|||
name|d1
operator|==
name|d2
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|maybe_objc_comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
name|val
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|attrval
operator|==
literal|2
operator|&&
name|val
operator|==
literal|1
condition|?
literal|2
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers.  */
end_comment

begin_function
specifier|static
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
comment|/* Give maybe_objc_comptypes a crack at letting these types through.  */
if|if
condition|(
operator|(
name|val
operator|=
name|maybe_objc_comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|val
return|;
name|val
operator|=
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"types are not quite compatible"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two function types F1 and F2 are compatible.    If either type specifies no argument types,    the other must specify a fixed number of self-promoting arg types.    Otherwise, if one type specifies only the number of arguments,     the other must specify that number of self-promoting arg types.    Otherwise, the argument types must match.  */
end_comment

begin_function
specifier|static
name|int
name|function_types_compatible_p
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
name|tree
name|f1
decl_stmt|,
name|f2
decl_stmt|;
block|{
name|tree
name|args1
decl_stmt|,
name|args2
decl_stmt|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|val1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
operator|||
operator|(
name|val
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|args1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
expr_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|args1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If one of these types comes from a non-prototype fn definition, 	 compare that with the other type's arglist. 	 If they don't match, ask for a warning (but no error).  */
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args2
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|args2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Both types have argument lists: compare them and propagate results.  */
name|val1
operator|=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|args2
argument_list|)
expr_stmt|;
return|return
name|val1
operator|!=
literal|1
condition|?
name|val1
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Check two lists of types for compatibility,    returning 0 for incompatible, 1 for compatible,    or 2 for compatible with warning.  */
end_comment

begin_function
specifier|static
name|int
name|type_lists_compatible_p
parameter_list|(
name|args1
parameter_list|,
name|args2
parameter_list|)
name|tree
name|args1
decl_stmt|,
name|args2
decl_stmt|;
block|{
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|newval
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|args1
operator|==
literal|0
operator|&&
name|args2
operator|==
literal|0
condition|)
return|return
name|val
return|;
comment|/* If one list is shorter than the other, 	 they fail to match.  */
if|if
condition|(
name|args1
operator|==
literal|0
operator|||
name|args2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* A null pointer instead of a type 	 means there is supposed to be an argument 	 but nothing is specified about what type it has. 	 So match anything that self-promotes.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|newval
operator|=
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Allow  wait (union {union wait *u; int *i} *) 	     and  wait (union wait *)  to be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* comptypes said ok, but record if it said to warn.  */
if|if
condition|(
name|newval
operator|>
name|val
condition|)
name|val
operator|=
name|newval
expr_stmt|;
name|args1
operator|=
name|TREE_CHAIN
argument_list|(
name|args1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TREE_CHAIN
argument_list|(
name|args2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|self_promoting_args_p
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TYPE is not affected by default promotions.  */
end_comment

begin_function
specifier|static
name|int
name|self_promoting_type_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intDI_type_node
condition|)
return|return
name|unsigned_intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intSI_type_node
condition|)
return|return
name|unsigned_intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intHI_type_node
condition|)
return|return
name|unsigned_intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intQI_type_node
condition|)
return|return
name|unsigned_intQI_type_node
return|;
return|return
name|signed_or_unsigned_type
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intDI_type_node
condition|)
return|return
name|intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intSI_type_node
condition|)
return|return
name|intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intHI_type_node
condition|)
return|return
name|intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intQI_type_node
condition|)
return|return
name|intQI_type_node
return|;
return|return
name|signed_or_unsigned_type
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|unsignedp
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Compute the value of the `sizeof' operator.  */
end_comment

begin_function
name|tree
name|c_sizeof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"sizeof applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"sizeof applied to a void type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"sizeof applied to an incomplete type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
name|t
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* size_binop does not put the constant in range, so do it now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof_nowarn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
comment|/* Convert in case a char is more than one unit.  */
name|t
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Compute the size to increment a pointer by.  */
end_comment

begin_function
name|tree
name|c_size_in_bytes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
name|t
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of TYPE, measured in bytes.  */
end_comment

begin_function
name|tree
name|c_alignof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|size_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of EXPR, measured in bytes.  For VAR_DECL's and    FIELD_DECL's return DECL_ALIGN (which can be set from an    "aligned" __attribute__ specification).  */
end_comment

begin_function
name|tree
name|c_alignof_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|expr
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`__alignof' applied to a bit-field"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
return|return
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|best
init|=
name|t
decl_stmt|;
name|int
name|bestalign
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|int
name|thisalign
decl_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisalign
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisalign
operator|>
name|bestalign
condition|)
name|best
operator|=
name|t
operator|,
name|bestalign
operator|=
name|thisalign
expr_stmt|;
block|}
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|best
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
specifier|static
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
comment|/* Don't change a variable array bound or initial value to a constant 	 in a place where a variable is invalid.  */
name|current_function_decl
operator|!=
literal|0
operator|&&
operator|!
name|pedantic
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|ITERATOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Perform default promotions for C data used in expressions.    Arrays and functions are converted to pointers;    enumeral types or short or char, to int.    In addition, manifest constants symbols are replaced by their values.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Constants can be used directly unless they're not loadable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value unless      it is an array, in which case we must be sure that taking the      address of the array produces consistent results.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|code
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as      an lvalue.  */
comment|/* Do not use STRIP_NOPS here!  It will remove conversions from pointer      to integer and cause infinite recursion.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Normally convert enums to int,      but convert wide enums to something wider.  */
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|type
operator|=
name|type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|flag_traditional
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|width
init|=
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|width
argument_list|)
decl_stmt|;
comment|/* If it's thinner than an int, promote it like a 	 C_PROMOTING_INTEGER_TYPE_P, otherwise leave it alone.  */
if|if
condition|(
name|low
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|exp
argument_list|)
return|;
else|else
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Traditionally, unsignedness is preserved in default promotions.          Also preserve unsignedness if not really getting any wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
operator|!
name|flag_allow_single_precision
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|adr
decl_stmt|;
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
name|int
name|constp
init|=
literal|0
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
block|{
name|constp
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|||
name|constp
operator|||
name|volatilep
condition|)
name|restype
operator|=
name|c_build_qualified_type
argument_list|(
name|restype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
operator|(
name|constp
operator|*
name|TYPE_QUAL_CONST
operator|)
operator||
operator|(
name|volatilep
operator|*
name|TYPE_QUAL_VOLATILE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|restype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|default_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|TREE_CONSTANT
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up component name in the structure type definition.     If this component name is found indirectly within an anonymous union,    store in *INDIRECT the component which directly contains    that anonymous union.  Otherwise, set *INDIRECT to 0.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field
parameter_list|(
name|type
parameter_list|,
name|component
parameter_list|,
name|indirect
parameter_list|)
name|tree
name|type
decl_stmt|,
name|component
decl_stmt|;
name|tree
modifier|*
name|indirect
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
comment|/* If TYPE_LANG_SPECIFIC is set, then it is a sorted array of pointers      to the field elements.  Use a binary search on this array to quickly      find the element.  Otherwise, do a linear search.  TYPE_LANG_SPECIFIC      will always be set for structures which have many elements.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
name|tree
modifier|*
name|field_array
init|=
operator|&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|elts
index|[
literal|0
index|]
decl_stmt|;
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|field
operator|=
name|field_array
index|[
name|bot
operator|+
name|half
index|]
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Step through all anon unions in linear fashion.  */
while|while
condition|(
name|DECL_NAME
argument_list|(
name|field_array
index|[
name|bot
index|]
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|anon
init|=
literal|0
decl_stmt|,
name|junk
decl_stmt|;
name|field
operator|=
name|field_array
index|[
name|bot
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|anon
operator|=
name|lookup_field
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|component
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|anon
operator|!=
name|NULL_TREE
condition|)
block|{
operator|*
name|indirect
operator|=
name|field
expr_stmt|;
return|return
name|anon
return|;
block|}
block|}
comment|/* Entire record is only anon unions.  */
if|if
condition|(
name|bot
operator|>
name|top
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Restart the binary search, with new lower bound.  */
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|<
name|component
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_array
index|[
name|bot
index|]
argument_list|)
operator|==
name|component
condition|)
name|field
operator|=
name|field_array
index|[
name|bot
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|component
condition|)
name|field
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|junk
decl_stmt|;
name|tree
name|anon
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|anon
operator|=
name|lookup_field
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|component
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|anon
operator|!=
name|NULL_TREE
condition|)
block|{
operator|*
name|indirect
operator|=
name|field
expr_stmt|;
return|return
name|anon
return|;
block|}
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
block|}
block|}
operator|*
name|indirect
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|field
return|;
block|}
end_function

begin_comment
comment|/* Make an expression to refer to the COMPONENT field of    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|field
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
comment|/* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it      unless we are not to support things not strictly ANSI.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|2
argument_list|)
argument_list|,
name|component
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* See if there is a field or component with name COMPONENT.  */
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|indirect
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|field
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|component
argument_list|,
operator|&
name|indirect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
name|code
operator|==
name|RECORD_TYPE
condition|?
literal|"structure has no member named `%s'"
else|:
literal|"union has no member named `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If FIELD was found buried within an anonymous union, 	 make one COMPONENT_REF to get that anonymous union, 	 then fall thru to make a second COMPONENT_REF to get FIELD.  */
if|if
condition|(
name|indirect
operator|!=
literal|0
condition|)
block|{
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|indirect
argument_list|)
argument_list|,
name|datum
argument_list|,
name|indirect
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|indirect
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|indirect
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|datum
operator|=
name|ref
expr_stmt|;
block|}
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|datum
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%s' in something not a structure or union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.  */
end_comment

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
specifier|register
name|tree
name|pointer
init|=
name|default_conversion
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|!
name|flag_volatile
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"dereferencing pointer to incomplete type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"dereferencing `void *' pointer"
argument_list|)
expr_stmt|;
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	     so that we get the proper error message if the result is used 	     to assign to.  Also,&* is supposed to be a no-op. 	     And ANSI C seems to specify that the type of the result 	     should be the const type.  */
comment|/* A de-reference of a pointer to const is not a const.  It is valid 	     to change it via some other pointer.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
operator|||
name|flag_volatile
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|index
parameter_list|)
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
comment|/* Subscripting with type char is likely to lose 	 on a machine where chars are signed. 	 So warn on any machine, but optionally. 	 Don't warn for unsigned char since that type is safe. 	 Don't warn for signed char because anyone who uses that 	 must have done so deliberately.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"array subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Apply default promotions *after* noticing character types.  */
name|index
operator|=
name|default_conversion
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|/* Require integer *after* promotion, for sake of enums.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a constant value which is not within 	 the array bounds cannot be stored in a register either; because we 	 would get a crash in store_bit_field/extract_bit_field when trying 	 to access a non-existent part of the register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|index
argument_list|,
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|array
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids subscripting `register' array"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are          or if the array is.  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
comment|/* This was added by rms on 16 Nov 91. 	       It fixes  vol struct foo *a;  a->elts[1]  	       in an inline function. 	       Hope it doesn't break something else.  */
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|/* Do the same warning check as above, but only on the part that's        syntactically the index and only if it is also semantically        the index.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Put the integer in IND to simplify error checking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|ar
decl_stmt|;
name|ar
operator|=
name|ind
expr_stmt|;
name|ind
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.    FUNCTION's data type may be a function type or a pointer-to-function.  */
end_comment

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
specifier|register
name|tree
name|fntype
decl_stmt|,
name|fundecl
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|assembler_name
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|assembler_name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
name|fntype
operator|=
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|fundecl
operator|=
name|function
expr_stmt|;
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"called object is not a function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|name
argument_list|,
name|fundecl
argument_list|)
expr_stmt|;
comment|/* Check for errors in format strings.  */
if|if
condition|(
name|warn_format
operator|&&
operator|(
name|name
operator|||
name|assembler_name
operator|)
condition|)
name|check_function_format
argument_list|(
name|name
argument_list|,
name|assembler_name
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|result
return|;
return|return
name|require_complete_type
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the argument expressions in the list VALUES    to the types in the list TYPELIST.  The result is a list of converted    argument expressions.     If TYPELIST is exhausted, or when an element has NULL as its type,    perform the default conversions.     PARMLIST is the chain of parm decls for the function being called.    It may be 0, if that info is not available.    It is used only for generating error messages.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_arguments
parameter_list|(
name|typelist
parameter_list|,
name|values
parameter_list|,
name|name
parameter_list|,
name|fundecl
parameter_list|)
name|tree
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|name
decl_stmt|,
name|fundecl
decl_stmt|;
block|{
specifier|register
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
specifier|register
name|tree
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
comment|/* Scan the given expressions and types, producing individual      converted arguments and pushing them on RESULT in reverse order.  */
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
operator|,
name|parmnum
operator|=
literal|0
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|parmnum
operator|++
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too many arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here!  We do not want an enumerator with value 0 	 to convert automatically to a pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"type of formal parameter %d is incomplete"
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|/* Optionally warn about conversions that 		 differ from the default conversions.  */
if|if
condition|(
name|warn_conversion
condition|)
block|{
name|int
name|formal_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as integer rather than floating due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as complex rather than floating due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as floating rather than integer due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as floating rather than complex due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? At some point, messages should be written about 		     conversions between complex types, but that's too messy 		     to do now.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* Warn if any argument is passed as `float', 			 since without a prototype it would be `double'.  */
if|if
condition|(
name|formal_prec
operator|==
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as `float' rather than `double' due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Detect integer changing in width or signedness.  */
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|would_have_been
init|=
name|default_conversion
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|tree
name|type1
init|=
name|TREE_TYPE
argument_list|(
name|would_have_been
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
condition|)
comment|/* No warning if function asks for enum 			   and the actual arg is that enum type.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|formal_prec
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s with different width due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|type1
argument_list|)
condition|)
empty_stmt|;
comment|/* Don't complain if the formal parameter type 			 is an enum, because we can't tell now whether 			 the value was an enum--even the same enum.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|val
argument_list|,
name|type
argument_list|)
condition|)
comment|/* Change in signedness doesn't matter 			   if a constant value is unaffected.  */
empty_stmt|;
comment|/* Likewise for a constant in a NOP_EXPR.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
empty_stmt|;
if|#
directive|if
literal|0
comment|/* We never get such tree structure here.  */
if|else if (TREE_CODE (TREE_TYPE (val)) == ENUMERAL_TYPE&& int_fits_type_p (TYPE_MIN_VALUE (TREE_TYPE (val)), type)&& int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (val)), type))
comment|/* Change in signedness doesn't matter 			   if an enum value is unaffected.  */
if|;
endif|#
directive|endif
comment|/* If the value is extended from a narrower 			 unsigned type, it doesn't matter whether we 			 pass it as signed or unsigned; the value 			 certainly is the same either way.  */
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as unsigned due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|warn_for_assignment
argument_list|(
literal|"%s as signed due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|parmval
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
comment|/* arg passing  */
name|fundecl
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too few arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the entry point used by the parser    for binary operators in the input.    In addition to constructing the expression,    we check for operands that were written with other binary operators    in a way that is likely to confuse the user.  */
end_comment

begin_function
name|tree
name|parser_build_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
name|class
decl_stmt|;
name|char
name|class1
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|class2
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code1
init|=
name|ERROR_MARK
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|ERROR_MARK
decl_stmt|;
if|if
condition|(
name|class1
operator|==
literal|'e'
operator|||
name|class1
operator|==
literal|'1'
operator|||
name|class1
operator|==
literal|'2'
operator|||
name|class1
operator|==
literal|'<'
condition|)
name|code1
operator|=
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|class2
operator|==
literal|'e'
operator|||
name|class2
operator|==
literal|'1'
operator|||
name|class2
operator|==
literal|'2'
operator|||
name|class2
operator|==
literal|'<'
condition|)
name|code2
operator|=
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* Check for cases such as x+y<<z which users are likely      to misinterpret.  If parens are used, C_EXP_ORIGINAL_CODE      is cleared to prevent these warnings.  */
if|if
condition|(
name|warn_parentheses
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around + or - inside shift"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code2
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around&& within ||"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_IOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|BIT_XOR_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|BIT_XOR_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around arithmetic in operand of |"
argument_list|)
expr_stmt|;
comment|/* Check cases like x|y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around comparison in operand of |"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_XOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around arithmetic in operand of ^"
argument_list|)
expr_stmt|;
comment|/* Check cases like x^y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around comparison in operand of ^"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around + or - in operand of&"
argument_list|)
expr_stmt|;
comment|/* Check cases like x&y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around comparison in operand of&"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Similarly, check for cases like 1<=i<=10 that are probably errors.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|extra_warnings
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
name|warning
argument_list|(
literal|"comparisons like X<=Y<=Z do not have their mathematical meaning"
argument_list|)
expr_stmt|;
name|unsigned_conversion_warning
argument_list|(
name|result
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|unsigned_conversion_warning
argument_list|(
name|result
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|overflow_warning
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the code that was specified in the source,      for the sake of warnings about confusing nesting.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|||
name|class
operator|==
literal|'1'
operator|||
name|class
operator|==
literal|'2'
operator|||
name|class
operator|==
literal|'<'
condition|)
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|result
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|flag
init|=
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
decl_stmt|;
comment|/* We used to use NOP_EXPR rather than NON_LVALUE_EXPR 	 so that convert_for_assignment wouldn't strip it. 	 That way, we got warnings for things like p = (1 - 1). 	 But it turns out we should not get those warnings.  */
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|result
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
name|flag
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     Note that the operands will never have enumeral types, or function    or array types, because either they will have the default conversions    performed or they have both just been converted to some other type in which    the arithmetic is to be done.  */
end_comment

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|orig_op0
parameter_list|,
name|orig_op1
parameter_list|,
name|convert_p
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|orig_op0
decl_stmt|,
name|orig_op1
decl_stmt|;
name|int
name|convert_p
decl_stmt|;
block|{
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
specifier|register
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means create the expression with this type, rather than      RESULT_TYPE.  */
name|tree
name|build_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      convert it to this type.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|convert_p
condition|)
block|{
name|op0
operator|=
name|default_conversion
argument_list|(
name|orig_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|default_conversion
argument_list|(
name|orig_op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|orig_op0
expr_stmt|;
name|op1
operator|=
name|orig_op1
expr_stmt|;
block|}
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
block|{
comment|/* Although it would be tempting to shorten always here, that 		 loses on some targets, since the modulo instruction is 		 undefined if the quotient can't be represented in the 		 computation mode.  We shorten only if unsigned or if 		 dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If one operand is a constant, and the other is a short type 	 that has been converted to an int, 	 really do the work in the short type and then convert the 	 result to int.  If we are lucky, the constant will be 0 or 1 	 in the short type, making the entire operation go away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Although it would be tempting to shorten always here, that loses 	     on some targets, since the modulo instruction is undefined if the 	     quotient can't be represented in the computation mode.  We shorten 	     only if unsigned or if dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|POINTER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
comment|/* Result of these operations is always an int, 	     but that does not mean the operands should be 	     converted to ints!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|truthvalue_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|truthvalue_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"right shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"right shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use the type of the value to be shifted. 	     This is what most traditional C compilers do.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Unless traditional, convert the shift-count to an integer, 	     regardless of size of value being shifted.  */
if|if
condition|(
operator|!
name|flag_traditional
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"left shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"left shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use the type of the value to be shifted. 	     This is what most traditional C compilers do.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Unless traditional, convert the shift-count to an integer, 	     regardless of size of value being shifted.  */
if|if
condition|(
operator|!
name|flag_traditional
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use the type of the value to be shifted. 	     This is what most traditional C compilers do.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Unless traditional, convert the shift-count to an integer, 	     regardless of size of value being shifted.  */
if|if
condition|(
operator|!
name|flag_traditional
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
comment|/* Result of comparison is always int, 	 but don't convert the args to int!  */
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|tt0
init|=
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
decl_stmt|;
comment|/* Anything compares with void *.  void * compares with anything. 	     Otherwise, the targets must be compatible 	     and both must be object or both incomplete.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt0
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
comment|/* op0 != orig_op0 detects the case of something 		 whose value is 0 but which isn't a valid null ptr const.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|op0
argument_list|)
operator|||
name|op0
operator|!=
name|orig_op0
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|||
name|op1
operator|!=
name|orig_op1
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
else|else
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|==
name|NULL_TREE
condition|)
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"comparison of complete and incomplete pointers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|extra_warnings
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|int
name|none_complex
init|=
operator|(
name|code0
operator|!=
name|COMPLEX_TYPE
operator|&&
name|code1
operator|!=
name|COMPLEX_TYPE
operator|)
decl_stmt|;
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
operator|&&
name|none_complex
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 (or OP1) does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* We can shorten only if the shift count is less than the 		 number of bits in the smaller type size.  */
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
if|if
condition|(
operator|(
name|warn_sign_compare
operator|<
literal|0
condition|?
name|extra_warnings
else|:
name|warn_sign_compare
operator|!=
literal|0
operator|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
block|{
name|int
name|op0_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op1_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|tree
name|primop0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
decl_stmt|;
name|tree
name|primop1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
decl_stmt|;
comment|/* Avoid spurious warnings for comparison with enumerators.  */
name|xop0
operator|=
name|orig_op0
expr_stmt|;
name|xop1
operator|=
name|orig_op1
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|xop0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|xop1
argument_list|)
expr_stmt|;
comment|/* Give warnings for comparisons between signed and unsigned 		 quantities that may fail.  */
comment|/* Do the checking based on the original operand trees, so that 		 casts will be considered, but default promotions won't be.  */
comment|/* Do not warn if the comparison is being done in a signed type, 		 since the signed type will only be chosen if it can represent 		 all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if both operands are unsigned.  */
elseif|else
if|if
condition|(
name|op0_signed
operator|==
name|op1_signed
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the signed quantity is an unsuffixed 		 integer literal (or some static constant expression 		 involving such literals) and it is non-negative.  */
elseif|else
if|if
condition|(
operator|(
name|op0_signed
operator|&&
name|TREE_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|xop0
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|TREE_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|xop1
argument_list|)
operator|>=
literal|0
operator|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the comparison is an equality operation,                  the unsigned quantity is an integral constant and it does                  not use the most significant bit of result_type.  */
elseif|else
if|if
condition|(
operator|(
name|resultcode
operator|==
name|EQ_EXPR
operator|||
name|resultcode
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
operator|(
name|op0_signed
operator|&&
name|TREE_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|xop1
argument_list|,
name|signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|TREE_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|xop0
argument_list|,
name|signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|"comparison between signed and unsigned"
argument_list|)
expr_stmt|;
comment|/* Warn if two unsigned values are being compared in a size 		 larger than their original size, and one (and only one) is the 		 result of a `~' operator.  This comparison will always fail.  		 Also warn if one operand is a constant, and the constant 		 does not have all bits set that are set in the ~ operand 		 when it is extended.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
operator|!=
operator|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop0
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
else|else
name|primop1
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|primop
decl_stmt|;
name|long
name|constant
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|primop
operator|=
name|primop1
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp1
expr_stmt|;
name|constant
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primop
operator|=
name|primop0
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp0
expr_stmt|;
name|constant
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|primop1
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
name|bits
operator|<
name|HOST_BITS_PER_LONG
operator|&&
name|unsignedp
condition|)
block|{
name|mask
operator|=
operator|(
operator|~
literal|0L
operator|)
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|constant
operator|)
operator|!=
name|mask
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with constant"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsignedp0
operator|&&
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|binary_op_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_type
operator|==
name|NULL_TREE
condition|)
name|build_type
operator|=
name|result_type
expr_stmt|;
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|build_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|size_exp
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
specifier|register
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type `void *' used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|c_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|size_exp
argument_list|)
comment|/* If the constant comes from pointer subtraction, 	 skip this optimization--it would cause an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
comment|/* If the constant is unsigned, and smaller than the pointer size, 	 then we must skip this optimization.  This is because it could cause 	 an overflow error if the constant is negative but INTOP is not.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|int_type
init|=
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
comment|/* Convert both subexpression types to the type of intop, 	 because weird cases involving pointer arithmetic 	 can result in a sum or difference with different type args.  */
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intop
operator|=
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as sizetype      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
condition|)
name|intop
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument with a suitable product by the object size.      Do this multiplication as signed, then convert to the appropriate      pointer type (actually unsigned integral).  */
name|intop
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|,
name|size_exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|ptrop
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
specifier|register
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type `void *' used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.      Do not do default conversions on the minus operator      in case restype is a short type.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This generates an error if op1 is pointer to incomplete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
comment|/* This generates an error if op0 is pointer to incomplete type.  */
name|op1
operator|=
name|c_size_in_bytes
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
comment|/* Divide by the size, in easiest possible way.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  NOCONVERT nonzero suppresses    the default promotions (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|noconvert
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|noconvert
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
specifier|register
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
specifier|register
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|typecode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|typecode
operator|==
name|ENUMERAL_TYPE
condition|)
name|typecode
operator|=
name|INTEGER_TYPE
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary plus"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary minus"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|code
operator|=
name|CONJ_EXPR
expr_stmt|;
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to bit-complement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to abs"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
comment|/* Conjugating a real value is a no-op, but allow it anyway.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|||
name|typecode
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to conjugation"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
operator|&&
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|COMPLEX_TYPE
comment|/* These will convert to a pointer.  */
operator|&&
name|typecode
operator|!=
name|ARRAY_TYPE
operator|&&
name|typecode
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"wrong type argument to unary exclamation mark"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arg
operator|=
name|truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|arg
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Increment or decrement the real part of the value, 	 and don't change the imaginary part.  */
if|if
condition|(
name|typecode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real
operator|=
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|real
argument_list|,
literal|1
argument_list|)
argument_list|,
name|imag
argument_list|)
return|;
block|}
comment|/* Report invalid types.  */
if|if
condition|(
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|?
literal|"wrong type argument to increment"
else|:
literal|"wrong type argument to decrement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|{
specifier|register
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|typecode
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* If pointer target is an undefined struct, 	       we just cannot know how to do the arithmetic.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|?
literal|"increment of pointer to unknown structure"
else|:
literal|"decrement of pointer to unknown structure"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|?
literal|"wrong type argument to increment"
else|:
literal|"wrong type argument to decrement"
argument_list|)
expr_stmt|;
name|inc
operator|=
name|c_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
comment|/* If the real type has the same machine representation 		 as the type it is cast to, we can make better output 		 by adding directly to the inside of the cast.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|incremented
argument_list|)
operator|=
literal|1
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
name|value
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
break|break;
default|default:
goto|goto
name|give_up
goto|;
block|}
name|give_up
label|:
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"invalid lvalue in increment"
else|:
literal|"invalid lvalue in decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Report a read-only lvalue.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|code
condition|)
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Don't let this be an lvalue.  */
if|if
condition|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
if|#
directive|if
literal|0
comment|/* Turned off because inconsistent; 	 float f; *&(int)f = 3.4 stores in int format 	 whereas (int)f = 3.4 stores in float format.  */
comment|/* Address of a cast is just a cast of the address 	 of the operand of the cast.  */
block|switch (TREE_CODE (arg)) 	{ 	case NOP_EXPR: 	case CONVERT_EXPR: 	case FLOAT_EXPR: 	case FIX_TRUNC_EXPR: 	case FIX_FLOOR_EXPR: 	case FIX_ROUND_EXPR: 	case FIX_CEIL_EXPR: 	  if (pedantic) 	    pedwarn ("ANSI C forbids the address of a cast expression"); 	  return convert (build_pointer_type (TREE_TYPE (arg)), 			  build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 					  0)); 	}
endif|#
directive|endif
comment|/* Allow the address of a constructor if all the elements 	 are constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
empty_stmt|;
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"invalid lvalue in unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Ordinary case; arg is a COMPONENT_REF or a decl.  */
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If the lvalue is const or volatile, merge that into the type          to which the address will point.  Note that you can't get a 	 restricted pointer by taking the address of something, so we 	 only have to deal with `const' and `volatile' here.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
condition|)
name|argtype
operator|=
name|c_build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"attempt to take address of bit-field structure member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|addr
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|offset
init|=
name|size_binop
argument_list|(
name|EASY_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|addr
argument_list|,
name|convert
argument_list|(
name|argtype
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
name|flag
expr_stmt|;
block|}
block|}
else|else
name|addr
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   file-scope function counts as a constant.  */
if|if
condition|(
name|staticp
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|addr
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* If CONVERSIONS is a conversion expression or a nested sequence of such,    convert ARG with the same conversions in the same order    and return the result.  */
end_comment

begin_endif
unit|static tree convert_sequence (conversions, arg)      tree conversions;      tree arg; {   switch (TREE_CODE (conversions))     {     case NOP_EXPR:     case CONVERT_EXPR:     case FLOAT_EXPR:     case FIX_TRUNC_EXPR:     case FIX_FLOOR_EXPR:     case FIX_ROUND_EXPR:     case FIX_CEIL_EXPR:       return convert (TREE_TYPE (conversions), 		      convert_sequence (TREE_OPERAND (conversions, 0), 					arg));      default:       return arg;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language.    Lvalues can be assigned, unless their type has TYPE_READONLY.    Lvalues can have their address taken, unless they have DECL_REGISTER.  */
end_comment

begin_function
name|int
name|lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
return|return
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
return|;
case|case
name|BIND_EXPR
case|:
case|case
name|RTL_EXPR
case|:
return|return
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|ref
parameter_list|,
name|msgid
parameter_list|)
name|tree
name|ref
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|error
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If this returns a function type, it isn't really being used as 	 an lvalue, so don't issue a warning about it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|pedantic_lvalue_warning
argument_list|(
name|COND_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
return|return
operator|(
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If pedantic, warn about improper lvalue.   CODE is either COND_EXPR    COMPOUND_EXPR, or CONVERT_EXPR (for casts).  */
end_comment

begin_function
specifier|static
name|void
name|pedantic_lvalue_warning
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
name|code
operator|==
name|COND_EXPR
condition|?
literal|"ANSI C forbids use of conditional expressions as lvalues"
else|:
name|code
operator|==
name|COMPOUND_EXPR
condition|?
literal|"ANSI C forbids use of compound expressions as lvalues"
else|:
literal|"ANSI C forbids use of cast expressions as lvalues"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Warn about storing in something that is `const'.  */
end_comment

begin_function
name|void
name|readonly_warning
parameter_list|(
name|arg
parameter_list|,
name|msgid
parameter_list|)
name|tree
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
comment|/* Forbid assignments to iterators.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|ITERATOR_P
argument_list|(
name|arg
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%s of iterator `%s'"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"%s of read-only member `%s'"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|pedwarn
argument_list|(
literal|"%s of read-only variable `%s'"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"%s of read-only location"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Value is 1 if successful.  */
end_comment

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot take address of bitfield `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|ADDR_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"global register variable `%s' used in nested function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pedwarn
argument_list|(
literal|"register variable `%s' used in nested function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address of global register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we are making this addressable due to its having 	       volatile components, give a different error message.  Also 	       handle the case of an unnamed parameter by not trying 	       to give the name.  */
elseif|else
if|if
condition|(
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot put object with volatile field into register"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pedwarn
argument_list|(
literal|"address of register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* drops in */
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* poplevel deals with this now.  */
block|if (DECL_CONTEXT (x) == 0) 	  TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;
endif|#
directive|endif
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
specifier|register
name|tree
name|type1
decl_stmt|;
specifier|register
name|tree
name|type2
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|,
name|orig_op2
init|=
name|op2
decl_stmt|;
name|ifexp
operator|=
name|truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|ifexp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Produces wrong result if within sizeof.  */
comment|/* Don't promote the operands separately if they promote      the same way.  Return the unpromoted type and let the combined      value get promoted if necessary.  */
block|if (TREE_TYPE (op1) == TREE_TYPE (op2)&& TREE_CODE (TREE_TYPE (op1)) != ARRAY_TYPE&& TREE_CODE (TREE_TYPE (op1)) != ENUMERAL_TYPE&& TREE_CODE (TREE_TYPE (op1)) != FUNCTION_TYPE)     {       if (TREE_CODE (ifexp) == INTEGER_CST) 	return pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);        return fold (build (COND_EXPR, TREE_TYPE (op1), ifexp, op1, op2));     }
endif|#
directive|endif
comment|/* Promote both alternatives.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
else|else
name|result_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|!=
name|NOP_EXPR
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op2
argument_list|)
operator|!=
name|NOP_EXPR
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op2
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The spec seems to say this is permitted.  */
block|if (pedantic&& TREE_CODE (type1) == FUNCTION_TYPE) 	    pedwarn ("ANSI C forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The spec seems to say this is permitted.  */
block|if (pedantic&& TREE_CODE (type2) == FUNCTION_TYPE) 	    pedwarn ("ANSI C forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Merge const and volatile flags of the incoming types.  */
name|result_type
operator|=
name|build_type_variant
argument_list|(
name|result_type
argument_list|,
name|TREE_READONLY
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|op2
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (code1 == RECORD_TYPE || code1 == UNION_TYPE)     {       result_type = TREE_TYPE (op1);       if (TREE_CONSTANT (ifexp)) 	return pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);        if (TYPE_MODE (result_type) == BLKmode) 	{ 	  register tree tempvar 	    = build_decl (VAR_DECL, NULL_TREE, result_type); 	  register tree xop1 = build_modify_expr (tempvar, op1); 	  register tree xop2 = build_modify_expr (tempvar, op2); 	  register tree result = fold (build (COND_EXPR, result_type, 					      ifexp, xop1, xop2));  	  layout_decl (tempvar, TYPE_ALIGN (result_type));
comment|/* No way to handle variable-sized objects here. 	     I fear that the entire handling of BLKmode conditional exprs 	     needs to be redone.  */
block|if (TREE_CODE (DECL_SIZE (tempvar)) != INTEGER_CST) 	    abort (); 	  DECL_RTL (tempvar) 	    = assign_stack_local (DECL_MODE (tempvar), 				  (TREE_INT_CST_LOW (DECL_SIZE (tempvar)) 				   + BITS_PER_UNIT - 1) 				  / BITS_PER_UNIT, 				  0);  	  TREE_SIDE_EFFECTS (result) 	    = TREE_SIDE_EFFECTS (ifexp) | TREE_SIDE_EFFECTS (op1) 	      | TREE_SIDE_EFFECTS (op2); 	  return build (COMPOUND_EXPR, result_type, result, tempvar); 	}     }
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
argument_list|)
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
return|return
name|internal_build_compound_expr
argument_list|(
name|list
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|internal_build_compound_expr
parameter_list|(
name|list
parameter_list|,
name|first_p
parameter_list|)
name|tree
name|list
decl_stmt|;
name|int
name|first_p
decl_stmt|;
block|{
specifier|register
name|tree
name|rest
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* If something inside inhibited lvalueness, we should not override.  */
comment|/* Consider (x, y+0), which is not an lvalue since y+0 is not.  */
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
block|if (TREE_CODE (list) == NON_LVALUE_EXPR) 	list = TREE_OPERAND (list, 0);
endif|#
directive|endif
comment|/* Don't let (0, 0) be null pointer constant.  */
if|if
condition|(
operator|!
name|first_p
operator|&&
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Convert arrays to pointers when there really is a comma operator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rest
operator|=
name|internal_build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The left-hand operand of a comma expression is like an expression          statement: with -W or -Wunused, we should warn if it doesn't have 	 any side-effects, unless it was explicitly cast to (void).  */
if|if
condition|(
operator|(
name|extra_warnings
operator|||
name|warn_unused
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"left-hand operand of comma expression has no effect"
argument_list|)
expr_stmt|;
comment|/* When pedantic, a compound expression can be neither an lvalue          nor an integer constant expression.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
return|return
name|rest
return|;
block|}
comment|/* With -Wunused, we should also warn if the left-hand operand does have      side-effects, but computes a value which is not used.  For example, in      `foo() + bar(), baz()' the result of the `+' operator is not used,      so we should issue a warning.  */
elseif|else
if|if
condition|(
name|warn_unused
condition|)
name|warn_if_unused_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
block|if (TREE_CODE (value) == NON_LVALUE_EXPR)     value = TREE_OPERAND (value, 0);
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids casting nonscalar to the same type"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|field
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids casts to union type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
literal|""
expr_stmt|;
name|t
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|error
argument_list|(
literal|"cast to union type from type not present in union"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|otype
decl_stmt|,
name|ovalue
decl_stmt|;
comment|/* If casting to void, avoid the error that would come 	 from default_conversion in the case of a non-lvalue array.  */
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
return|;
comment|/* Convert functions and arrays to pointers, 	 but don't convert any other types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrisome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* Go to the innermost object being pointed to.  */
name|tree
name|in_type
init|=
name|type
decl_stmt|;
name|tree
name|in_otype
init|=
name|otype
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|in_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|in_type
operator|=
name|TREE_TYPE
argument_list|(
name|in_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|in_otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|in_otype
operator|=
name|TREE_TYPE
argument_list|(
name|in_otype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|in_otype
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|in_type
argument_list|)
condition|)
comment|/* There are qualifiers present in IN_OTYPE that are not 	       present in IN_TYPE.  */
name|pedwarn
argument_list|(
literal|"cast discards qualifiers from pointer target type"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about possible alignment problems.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|warn_cast_align
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
comment|/* Don't warn about opaque types, where the actual alignment 	     restriction is unknown.  */
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast increases required alignment of target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast from pointer to integer of different size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_bad_function_cast
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast does not match function type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
if|#
directive|if
literal|0
comment|/* Don't warn about converting 0 to pointer, 	     provided the 0 was explicit--not cast or made by folding.  */
expr|&& !(TREE_CODE (value) == INTEGER_CST&& integer_zerop (value))
endif|#
directive|endif
comment|/* Don't warn about converting any constant.  */
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast to pointer from integer of different size"
argument_list|)
expr_stmt|;
name|ovalue
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pedantically, don't ley (void *) (FOO *) 0 be a null pointer constant.  */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|value
operator|=
name|non_lvalue
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* If pedantic, don't let a cast be an lvalue.  */
if|if
condition|(
name|value
operator|==
name|expr
operator|&&
name|pedantic
condition|)
name|value
operator|=
name|non_lvalue
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* Handle control structure constructs used as "lvalues".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newrhs
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|COND_EXPR
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	   except that the RHS goes through a save-expr 	   so the code to compute it is only emitted once.  */
name|tree
name|cond
init|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|cond
return|;
comment|/* Make sure the code to compute the rhs comes out 	   before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* But cast it to void to avoid an "unused" error.  */
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the cast type of the lhs,      and then true type of the lhs and store it there;      then convert result back to the cast type to be the value      of the assignment.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|newrhs
operator|=
name|default_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|result
operator|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|convert
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|result
return|;
name|pedantic_lvalue_warning
argument_list|(
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"invalid lvalue in assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Warn about storing in something that is `const'.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower than one,      we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
comment|/* Convert new value to destination type.  */
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|_
argument_list|(
literal|"assignment"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
name|_
argument_list|(
literal|"assignment"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE is a string to use in error messages:    "assignment", "return", etc.  If it is null, this is parameter passing    for a function call (and different error messages are output).     FUNNAME is the name of the function being called,    as an IDENTIFIER_NODE, or null.    PARMNUM is the number of the argument, for printing in error messages.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|fundecl
parameter_list|,
name|funname
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fundecl
decl_stmt|,
name|funname
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
block|{
name|overflow_warning
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Check for Objective-C protocols.  This will issue a warning if 	 there are protocol violations.  No need to use the return value.  */
name|maybe_objc_comptypes
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Arithmetic types all interconvert, and enum is treated like int.  */
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|||
name|codel
operator|==
name|ENUMERAL_TYPE
operator|||
name|codel
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
operator|||
name|coder
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
return|return
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* Conversion to a transparent union from its member types.      This applies only to function arguments.  */
elseif|else
if|if
condition|(
name|codel
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|errtype
condition|)
block|{
name|tree
name|memb_types
decl_stmt|;
name|tree
name|marginal_memb_type
init|=
literal|0
decl_stmt|;
for|for
control|(
name|memb_types
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|memb_types
condition|;
name|memb_types
operator|=
name|TREE_CHAIN
argument_list|(
name|memb_types
argument_list|)
control|)
block|{
name|tree
name|memb_type
init|=
name|TREE_TYPE
argument_list|(
name|memb_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|memb_type
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|memb_type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
continue|continue;
if|if
condition|(
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|memb_type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Any non-function converts to a [const][volatile] void * 		 and vice versa; otherwise, targets must be the same. 		 Meanwhile, the lhs target must have all the qualifiers of 		 the rhs.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
name|comp_target_types
argument_list|(
name|memb_type
argument_list|,
name|rhstype
argument_list|)
condition|)
block|{
comment|/* If this type won't generate any warnings, use it.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|?
operator|(
operator|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
else|:
operator|(
operator|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|)
operator|==
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* Keep looking for a better type, but remember this one.  */
if|if
condition|(
operator|!
name|marginal_memb_type
condition|)
name|marginal_memb_type
operator|=
name|memb_type
expr_stmt|;
block|}
block|}
comment|/* Can convert integer zero to any pointer type.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rhs
operator|=
name|null_pointer_node
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|memb_types
operator|||
name|marginal_memb_type
condition|)
block|{
if|if
condition|(
operator|!
name|memb_types
condition|)
block|{
comment|/* We have only a marginally acceptable member type; 		 it needs a warning.  */
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|marginal_memb_type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Const and volatile mean something different for function 		 types, so the usual warnings are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Because const and volatile on functions are 		     restrictions that say the function will not do 		     certain things, it is okay to use a const or volatile 		     function where an ordinary one is wanted, but not 		     vice-versa.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s makes qualified function pointer from unqualified"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s discards qualifiers from pointer target type"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|fundecl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C prohibits argument conversion to union type"
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
operator|||
operator|(
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
comment|/* Check TREE_CODE to catch cases like (void *) (char *) 0 		      which are not ANSI null ptr constants.  */
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"ANSI forbids %s between function pointer and `void *'"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
comment|/* Const and volatile mean something different for function types, 	     so the usual warnings are not appropriate.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s discards qualifiers from pointer target type"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
comment|/* If this is not a case of ignoring a mismatch in signedness, 		 no warning.  */
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
condition|)
empty_stmt|;
comment|/* If there is a mismatch, do warn.  */
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|warn_for_assignment
argument_list|(
literal|"pointer targets in %s differ in signedness"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Because const and volatile on functions are restrictions 		 that say the function will not do certain things, 		 it is okay to use a const or volatile function 		 where an ordinary one is wanted, but not vice-versa.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|ttl
argument_list|)
operator|&
operator|~
name|TYPE_QUALS
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s makes qualified function pointer from unqualified"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|warn_for_assignment
argument_list|(
literal|"%s from incompatible pointer type"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* An explicit constant 0 can convert to a pointer, 	 or one that results from arithmetic, even including 	 a cast to integer type.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|warn_for_assignment
argument_list|(
literal|"%s makes pointer from integer without a cast"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
name|null_pointer_node
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|INTEGER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|warn_for_assignment
argument_list|(
literal|"%s makes integer from pointer without a cast"
argument_list|,
name|errtype
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|errtype
condition|)
block|{
if|if
condition|(
name|funname
condition|)
block|{
name|tree
name|selector
init|=
name|maybe_building_objc_message_expr
argument_list|()
decl_stmt|;
if|if
condition|(
name|selector
operator|&&
name|parmnum
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"incompatible type for argument %d of `%s'"
argument_list|,
name|parmnum
operator|-
literal|2
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|selector
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"incompatible type for argument %d of `%s'"
argument_list|,
name|parmnum
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"incompatible type for argument %d of indirect function call"
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"incompatible types in %s"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Print a warning using MSGID.    It gets OPNAME as its one parameter.    If OPNAME is null, it is replaced by "passing arg ARGNUM of `FUNCTION'".    FUNCTION and ARGNUM are handled specially if we are building an    Objective-C selector.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_assignment
parameter_list|(
name|msgid
parameter_list|,
name|opname
parameter_list|,
name|function
parameter_list|,
name|argnum
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|tree
name|function
decl_stmt|;
name|int
name|argnum
decl_stmt|;
block|{
if|if
condition|(
name|opname
operator|==
literal|0
condition|)
block|{
name|tree
name|selector
init|=
name|maybe_building_objc_message_expr
argument_list|()
decl_stmt|;
name|char
modifier|*
name|new_opname
decl_stmt|;
if|if
condition|(
name|selector
operator|&&
name|argnum
operator|>
literal|2
condition|)
block|{
name|function
operator|=
name|selector
expr_stmt|;
name|argnum
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|function
condition|)
block|{
comment|/* Function name is known; supply it.  */
specifier|const
name|char
modifier|*
name|argstring
init|=
name|_
argument_list|(
literal|"passing arg %d of `%s'"
argument_list|)
decl_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|function
argument_list|)
operator|+
name|strlen
argument_list|(
name|argstring
argument_list|)
operator|+
literal|1
operator|+
literal|25
comment|/*%d*/
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
name|argstring
argument_list|,
name|argnum
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Function name unknown (call through ptr); just give arg number.*/
specifier|const
name|char
modifier|*
name|argnofun
init|=
name|_
argument_list|(
literal|"passing arg %d of pointer to function"
argument_list|)
decl_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|argnofun
argument_list|)
operator|+
literal|1
operator|+
literal|25
comment|/*%d*/
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
name|argnofun
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
block|}
name|opname
operator|=
name|new_opname
expr_stmt|;
block|}
name|pedwarn
argument_list|(
name|msgid
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if VALUE is a valid constant-valued expression    for use in initializing a static variable; one that can be an    element of a "constant" initializer.     Return null_pointer_node if the value is absolute;    if it is relocatable, return the variable that determines the relocation.    We assume that VALUE has been folded as much as possible;    therefore, we do not need to check for such things as    arithmetic-combinations of integers.  */
end_comment

begin_function
name|tree
name|initializer_constant_valid_p
parameter_list|(
name|value
parameter_list|,
name|endtype
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|endtype
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
return|return
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|?
name|null_pointer_node
else|:
literal|0
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
return|return
name|null_pointer_node
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Allow conversions between pointer types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between real types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow length-preserving conversions between integer types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between other integer types only if 	 explicit value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|inner
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|null_pointer_node
condition|)
return|return
name|null_pointer_node
return|;
return|return
literal|0
return|;
block|}
comment|/* Allow (int)&foo provided int is as wide as a pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Likewise conversions from int to pointers, but also allow 	 conversions from 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
block|}
comment|/* Allow conversions to union types if the value inside is okay.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|endtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|<
name|POINTER_SIZE
condition|)
return|return
literal|0
return|;
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* If either term is absolute, use the other terms relocation.  */
if|if
condition|(
name|valid0
operator|==
name|null_pointer_node
condition|)
return|return
name|valid1
return|;
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
return|return
literal|0
return|;
block|}
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|endtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|<
name|POINTER_SIZE
condition|)
return|return
literal|0
return|;
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* Win if second argument is absolute.  */
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
comment|/* Win if both arguments have the same relocation. 	   Then the value is absolute.  */
if|if
condition|(
name|valid0
operator|==
name|valid1
condition|)
return|return
name|null_pointer_node
return|;
return|return
literal|0
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* If VALUE is a compound expr all of whose expressions are constant, then    return its value.  Otherwise, return error_mark_node.     This is for handling COMPOUND_EXPRs as initializer elements    which is allowed with a warning when -pedantic is specified.  */
end_comment

begin_function
specifier|static
name|tree
name|valid_compound_expr_initializer
parameter_list|(
name|value
parameter_list|,
name|endtype
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|endtype
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
if|if
condition|(
name|valid_compound_expr_initializer
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|valid_compound_expr_initializer
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|&&
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|endtype
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.  */
end_comment

begin_function
name|void
name|store_init_value
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|pedantic
argument_list|)
expr_stmt|;
comment|/* Store the expression if valid; else report error.  */
if|#
directive|if
literal|0
comment|/* Note that this is the only place we can detect the error      in a case such as   struct foo bar = (struct foo) { x, y };      where there is one initial value which is a constructor expression.  */
block|if (value == error_mark_node)     ;   else if (TREE_STATIC (decl)&& ! TREE_CONSTANT (value))     {       error ("initializer for static variable is not constant");       value = error_mark_node;     }   else if (TREE_STATIC (decl)&& initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)     {       error ("initializer for static variable uses complicated arithmetic");       value = error_mark_node;     }   else     {       if (pedantic&& TREE_CODE (value) == CONSTRUCTOR) 	{ 	  if (! TREE_CONSTANT (value)) 	    pedwarn ("aggregate initializer is not constant"); 	  else if (! TREE_STATIC (value)) 	    pedwarn ("aggregate initializer uses complicated arithmetic"); 	}     }
endif|#
directive|endif
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
comment|/* ANSI wants warnings about out-of-range constant initializers.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Methods for storing and printing names for error messages.  */
end_comment

begin_comment
comment|/* Implement a spelling stack that allows components of a name to be pushed    and popped.  Each element on the stack is this structure.  */
end_comment

begin_struct
struct|struct
name|spelling
block|{
name|int
name|kind
decl_stmt|;
union|union
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SPELLING_STRING
value|1
end_define

begin_define
define|#
directive|define
name|SPELLING_MEMBER
value|2
end_define

begin_define
define|#
directive|define
name|SPELLING_BOUNDS
value|3
end_define

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next stack element (unused).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spelling stack base.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spelling_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the spelling stack.  */
end_comment

begin_comment
comment|/* Macros to save and restore the spelling stack around push_... functions.    Alternative to SAVE_SPELLING_STACK.  */
end_comment

begin_define
define|#
directive|define
name|SPELLING_DEPTH
parameter_list|()
value|(spelling - spelling_base)
end_define

begin_define
define|#
directive|define
name|RESTORE_SPELLING_DEPTH
parameter_list|(
name|depth
parameter_list|)
value|(spelling = spelling_base + depth)
end_define

begin_comment
comment|/* Save and restore the spelling stack around arbitrary C code.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_SPELLING_DEPTH
parameter_list|(
name|code
parameter_list|)
define|\
value|{						\   int __depth = SPELLING_DEPTH ();		\   code;						\   RESTORE_SPELLING_DEPTH (__depth);		\ }
end_define

begin_comment
comment|/* Push an element on the spelling stack with type KIND and assign VALUE    to MEMBER.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_SPELLING
parameter_list|(
name|KIND
parameter_list|,
name|VALUE
parameter_list|,
name|MEMBER
parameter_list|)
define|\
value|{									\   int depth = SPELLING_DEPTH ();					\ 									\   if (depth>= spelling_size)						\     {									\       spelling_size += 10;						\       if (spelling_base == 0)						\ 	spelling_base							\ 	  = (struct spelling *) xmalloc (spelling_size * sizeof (struct spelling));	\       else								\         spelling_base							\ 	  = (struct spelling *) xrealloc (spelling_base,		\ 					  spelling_size * sizeof (struct spelling));	\       RESTORE_SPELLING_DEPTH (depth);					\     }									\ 									\   spelling->kind = (KIND);						\   spelling->MEMBER = (VALUE);						\   spelling++;								\ }
end_define

begin_comment
comment|/* Push STRING on the stack.  Printed literally.  */
end_comment

begin_function
specifier|static
name|void
name|push_string
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_STRING
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a member name on the stack.  Printed as '.' STRING.  */
end_comment

begin_function
specifier|static
name|void
name|push_member_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
literal|"<anonymous>"
decl_stmt|;
name|PUSH_SPELLING
argument_list|(
name|SPELLING_MEMBER
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an array bounds on the stack.  Printed as [BOUNDS].  */
end_comment

begin_function
specifier|static
name|void
name|push_array_bounds
parameter_list|(
name|bounds
parameter_list|)
name|int
name|bounds
decl_stmt|;
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_BOUNDS
argument_list|,
name|bounds
argument_list|,
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the maximum size in bytes of the printed spelling.  */
end_comment

begin_function
specifier|static
name|int
name|spelling_length
parameter_list|()
block|{
specifier|register
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
name|size
operator|+=
literal|25
expr_stmt|;
else|else
name|size
operator|+=
name|strlen
argument_list|(
name|p
operator|->
name|u
operator|.
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Print the spelling to BUFFER and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|print_spelling
parameter_list|(
name|buffer
parameter_list|)
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
init|=
name|buffer
decl_stmt|;
specifier|register
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"[%d]"
argument_list|,
name|p
operator|->
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
name|d
operator|+=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_MEMBER
condition|)
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p
operator|->
name|u
operator|.
name|s
init|;
operator|(
operator|*
name|d
operator|=
operator|*
name|s
operator|++
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Issue an error message for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
name|void
name|error_init
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|error
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|error
argument_list|(
literal|"(near initialization for `%s')"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a pedantic warning for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
name|void
name|pedwarn_init
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|pedwarn
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|pedwarn
argument_list|(
literal|"(near initialization for `%s')"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a warning for a bad initializer component.    MSGID identifies the message.    The component name is taken from the spelling stack.  */
end_comment

begin_function
specifier|static
name|void
name|warning_init
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|char
modifier|*
name|ofwhat
decl_stmt|;
name|warning
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|ofwhat
operator|=
name|print_spelling
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|warning
argument_list|(
literal|"(near initialization for `%s')"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Digest the parser output INIT as an initializer for type TYPE.    Return a C expression of type TYPE to represent the initial value.     The arguments REQUIRE_CONSTANT and CONSTRUCTOR_CONSTANT request errors    if non-constant initializers or elements are seen.  CONSTRUCTOR_CONSTANT    applies only to elements of constructors.  */
end_comment

begin_function
specifier|static
name|tree
name|digest_init
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|require_constant
parameter_list|,
name|constructor_constant
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|;
name|int
name|require_constant
decl_stmt|,
name|constructor_constant
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|inside_init
init|=
name|init
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|init
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|inside_init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialization of an array of chars from a string constant      optionally enclosed in braces.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|typ1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|typ1
operator|==
name|char_type_node
operator|||
name|typ1
operator|==
name|signed_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_wchar_type_node
operator|||
name|typ1
operator|==
name|signed_wchar_type_node
operator|)
operator|&&
operator|(
operator|(
name|inside_init
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|inside_init
return|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"char-array initialized from wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"int-array initialized from non-wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Subtract 1 (or sizeof (wchar_t)) 		 because it's ok to ignore the terminating null char 		 that is counted in the length of the constant.  */
if|if
condition|(
name|size
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|inside_init
argument_list|)
operator|-
operator|(
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|?
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
else|:
literal|1
operator|)
condition|)
name|pedwarn_init
argument_list|(
literal|"initializer-string for array of chars is too long"
argument_list|)
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
block|}
comment|/* Any type can be initialized      from an expression of the same type, optionally with braces.  */
if|if
condition|(
name|inside_init
operator|&&
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
name|inside_init
operator|=
name|default_conversion
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|!=
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
block|{
name|error_init
argument_list|(
literal|"array initialized from non-constant array expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|inside_init
operator|=
name|decl_constant_value
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
comment|/* Compound expressions can only occur here if -pedantic or 	 -pedantic-errors is specified.  In the later case, we always want 	 an error.  In the former case, we simply want a warning.  */
if|if
condition|(
name|require_constant
operator|&&
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|inside_init
operator|=
name|valid_compound_expr_initializer
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside_init
operator|==
name|error_mark_node
condition|)
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
else|else
name|pedwarn_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not computable at load time"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
comment|/* Handle scalar types, including conversions.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|COMPLEX_TYPE
condition|)
block|{
comment|/* Note that convert_for_assignment calls default_conversion 	 for arrays and functions.  We must not call it in the 	 case where inside_init is a null pointer constant.  */
name|inside_init
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|_
argument_list|(
literal|"initialization"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not computable at load time"
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
comment|/* Come here only for records and arrays.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_init
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Traditionally, you can write  struct foo x = 0;      and it initializes the first element of x to 0.  */
if|if
condition|(
name|flag_traditional
condition|)
block|{
name|tree
name|top
init|=
literal|0
decl_stmt|,
name|prev
init|=
literal|0
decl_stmt|,
name|otype
init|=
name|type
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|top
operator|=
name|temp
expr_stmt|;
else|else
name|TREE_OPERAND
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|prev
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error_init
argument_list|(
literal|"invalid initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|otype
operator|!=
name|type
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|require_constant
argument_list|,
name|constructor_constant
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|top
return|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
name|error_init
argument_list|(
literal|"invalid initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle initializers that use braces.  */
end_comment

begin_comment
comment|/* Type of object we are accumulating a constructor for.    This type is always a RECORD_TYPE, UNION_TYPE or ARRAY_TYPE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For a RECORD_TYPE or UNION_TYPE, this is the chain of fields    left to fill.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_fields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the specified index    at which to store the next element we get.    This is a special INTEGER_CST node that we modify in place.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the end index of the range    to initialize with the next element, or NULL in the ordinary case    where the element is used just once.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_range_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the maximum index.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_max_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For a RECORD_TYPE, this is the first field not yet written out.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_unfilled_fields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an ARRAY_TYPE, this is the index of the first element    not yet written out.    This is a special INTEGER_CST node that we modify in place.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_unfilled_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a RECORD_TYPE, the byte index of the next consecutive field.    This is so we can generate gaps between fields, when appropriate.    This is a special INTEGER_CST node that we modify in place.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_bit_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are saving up the elements rather than allocating them,    this is the list of elements so far (in reverse order,    most recent first).  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_elements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if so far this constructor's elements are all compile-time constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if so far this constructor's elements are all valid address constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_simple
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if this constructor is erroneous so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_erroneous
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if have called defer_addressed_constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_subconstants_deferred
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for managing pending initializer elements, organized as an    AVL tree.  */
end_comment

begin_struct
struct|struct
name|init_node
block|{
name|struct
name|init_node
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|struct
name|init_node
modifier|*
name|parent
decl_stmt|;
name|int
name|balance
decl_stmt|;
name|tree
name|purpose
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Tree of pending elements at this constructor level.    These are elements encountered out of order    which belong at places we haven't reached yet in actually    writing the output.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|init_node
modifier|*
name|constructor_pending_elts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The SPELLING_DEPTH of this constructor.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 if implicitly pushing constructor levels is allowed.  */
end_comment

begin_decl_stmt
name|int
name|constructor_no_implicit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 for C; 1 for some other languages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|require_constant_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|require_constant_elements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if it is ok to output this constructor as we read it.    0 means must accumulate a CONSTRUCTOR expression.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_incremental
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DECL node for which an initializer is being read.    0 means we are reading a constructor expression    such as (struct foo) {...}.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|constructor_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start_init saves the ASMSPEC arg here for really_start_incremental_init.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|constructor_asmspec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this is an initializer for a top-level decl.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constructor_top_level
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This stack has a level for each implicit or explicit level of    structuring in the initializer, including the outermost one.  It    saves the values of most of the variables above.  */
end_comment

begin_struct
struct|struct
name|constructor_stack
block|{
name|struct
name|constructor_stack
modifier|*
name|next
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|range_end
decl_stmt|;
name|tree
name|max_index
decl_stmt|;
name|tree
name|unfilled_index
decl_stmt|;
name|tree
name|unfilled_fields
decl_stmt|;
name|tree
name|bit_index
decl_stmt|;
name|tree
name|elements
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|init_node
modifier|*
name|pending_elts
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* If nonzero, this value should replace the entire      constructor at this level.  */
name|tree
name|replacement_value
decl_stmt|;
name|char
name|constant
decl_stmt|;
name|char
name|simple
decl_stmt|;
name|char
name|implicit
decl_stmt|;
name|char
name|incremental
decl_stmt|;
name|char
name|erroneous
decl_stmt|;
name|char
name|outer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|constructor_stack
modifier|*
name|constructor_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This stack records separate initializers that are nested.    Nested initializers can't happen in ANSI C, but GNU C allows them    in cases like { ... (struct foo) { ... } ... }.  */
end_comment

begin_struct
struct|struct
name|initializer_stack
block|{
name|struct
name|initializer_stack
modifier|*
name|next
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|asmspec
decl_stmt|;
name|struct
name|constructor_stack
modifier|*
name|constructor_stack
decl_stmt|;
name|tree
name|elements
decl_stmt|;
name|struct
name|spelling
modifier|*
name|spelling
decl_stmt|;
name|struct
name|spelling
modifier|*
name|spelling_base
decl_stmt|;
name|int
name|spelling_size
decl_stmt|;
name|char
name|top_level
decl_stmt|;
name|char
name|incremental
decl_stmt|;
name|char
name|require_constant_value
decl_stmt|;
name|char
name|require_constant_elements
decl_stmt|;
name|char
name|deferred
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|initializer_stack
modifier|*
name|initializer_stack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Prepare to parse and output the initializer for variable DECL.  */
end_comment

begin_function
name|void
name|start_init
parameter_list|(
name|decl
parameter_list|,
name|asmspec_tree
parameter_list|,
name|top_level
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
name|int
name|top_level
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|locus
decl_stmt|;
name|struct
name|initializer_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|initializer_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|initializer_stack
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
name|p
operator|->
name|decl
operator|=
name|constructor_decl
expr_stmt|;
name|p
operator|->
name|asmspec
operator|=
name|constructor_asmspec
expr_stmt|;
name|p
operator|->
name|incremental
operator|=
name|constructor_incremental
expr_stmt|;
name|p
operator|->
name|require_constant_value
operator|=
name|require_constant_value
expr_stmt|;
name|p
operator|->
name|require_constant_elements
operator|=
name|require_constant_elements
expr_stmt|;
name|p
operator|->
name|constructor_stack
operator|=
name|constructor_stack
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|spelling
operator|=
name|spelling
expr_stmt|;
name|p
operator|->
name|spelling_base
operator|=
name|spelling_base
expr_stmt|;
name|p
operator|->
name|spelling_size
operator|=
name|spelling_size
expr_stmt|;
name|p
operator|->
name|deferred
operator|=
name|constructor_subconstants_deferred
expr_stmt|;
name|p
operator|->
name|top_level
operator|=
name|constructor_top_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|initializer_stack
expr_stmt|;
name|initializer_stack
operator|=
name|p
expr_stmt|;
name|constructor_decl
operator|=
name|decl
expr_stmt|;
name|constructor_incremental
operator|=
name|top_level
expr_stmt|;
name|constructor_asmspec
operator|=
name|asmspec
expr_stmt|;
name|constructor_subconstants_deferred
operator|=
literal|0
expr_stmt|;
name|constructor_top_level
operator|=
name|top_level
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
name|require_constant_value
operator|=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|require_constant_elements
operator|=
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|pedantic
operator|)
comment|/* For a scalar, you can always use any value to initialize, 	      even within braces.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|)
expr_stmt|;
name|locus
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_incremental
operator||=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|require_constant_value
operator|=
literal|0
expr_stmt|;
name|require_constant_elements
operator|=
literal|0
expr_stmt|;
name|locus
operator|=
literal|"(anonymous)"
expr_stmt|;
block|}
name|constructor_stack
operator|=
literal|0
expr_stmt|;
name|missing_braces_mentioned
operator|=
literal|0
expr_stmt|;
name|spelling_base
operator|=
literal|0
expr_stmt|;
name|spelling_size
operator|=
literal|0
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locus
condition|)
name|push_string
argument_list|(
name|locus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_init
parameter_list|()
block|{
name|struct
name|initializer_stack
modifier|*
name|p
init|=
name|initializer_stack
decl_stmt|;
comment|/* Output subconstants (string constants, usually)      that were referenced within this initializer and saved up.      Must do this if and only if we called defer_addressed_constants.  */
if|if
condition|(
name|constructor_subconstants_deferred
condition|)
name|output_deferred_addressed_constants
argument_list|()
expr_stmt|;
comment|/* Free the whole constructor stack of this initializer.  */
while|while
condition|(
name|constructor_stack
condition|)
block|{
name|struct
name|constructor_stack
modifier|*
name|q
init|=
name|constructor_stack
decl_stmt|;
name|constructor_stack
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Pop back to the data of the outer initializer (if any).  */
name|constructor_decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
name|constructor_asmspec
operator|=
name|p
operator|->
name|asmspec
expr_stmt|;
name|constructor_incremental
operator|=
name|p
operator|->
name|incremental
expr_stmt|;
name|require_constant_value
operator|=
name|p
operator|->
name|require_constant_value
expr_stmt|;
name|require_constant_elements
operator|=
name|p
operator|->
name|require_constant_elements
expr_stmt|;
name|constructor_stack
operator|=
name|p
operator|->
name|constructor_stack
expr_stmt|;
name|constructor_elements
operator|=
name|p
operator|->
name|elements
expr_stmt|;
name|spelling
operator|=
name|p
operator|->
name|spelling
expr_stmt|;
name|spelling_base
operator|=
name|p
operator|->
name|spelling_base
expr_stmt|;
name|spelling_size
operator|=
name|p
operator|->
name|spelling_size
expr_stmt|;
name|constructor_subconstants_deferred
operator|=
name|p
operator|->
name|deferred
expr_stmt|;
name|constructor_top_level
operator|=
name|p
operator|->
name|top_level
expr_stmt|;
name|initializer_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call here when we see the initializer is surrounded by braces.    This is instead of a call to push_init_level;    it is matched by a call to pop_init_level.     TYPE is the type to initialize, for a constructor expression.    For an initializer for a decl, TYPE is zero.  */
end_comment

begin_function
name|void
name|really_start_incremental_init
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|constructor_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|constructor_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|constructor_stack
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_decl
argument_list|)
expr_stmt|;
comment|/* Turn off constructor_incremental if type is a struct with bitfields.      Do this before the first push, so that the corrected value      is available in finish_init.  */
name|check_init_type_bitfields
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|constructor_type
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|range_end
operator|=
name|constructor_range_end
expr_stmt|;
name|p
operator|->
name|max_index
operator|=
name|constructor_max_index
expr_stmt|;
name|p
operator|->
name|unfilled_index
operator|=
name|constructor_unfilled_index
expr_stmt|;
name|p
operator|->
name|unfilled_fields
operator|=
name|constructor_unfilled_fields
expr_stmt|;
name|p
operator|->
name|bit_index
operator|=
name|constructor_bit_index
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constructor_constant
expr_stmt|;
name|p
operator|->
name|simple
operator|=
name|constructor_simple
expr_stmt|;
name|p
operator|->
name|erroneous
operator|=
name|constructor_erroneous
expr_stmt|;
name|p
operator|->
name|pending_elts
operator|=
name|constructor_pending_elts
expr_stmt|;
name|p
operator|->
name|depth
operator|=
name|constructor_depth
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|implicit
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|incremental
operator|=
name|constructor_incremental
expr_stmt|;
name|p
operator|->
name|outer
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|constructor_stack
operator|=
name|p
expr_stmt|;
name|constructor_constant
operator|=
literal|1
expr_stmt|;
name|constructor_simple
operator|=
literal|1
expr_stmt|;
name|constructor_depth
operator|=
name|SPELLING_DEPTH
argument_list|()
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
name|constructor_pending_elts
operator|=
literal|0
expr_stmt|;
name|constructor_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|constructor_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|copy_node
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|sbitsizetype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|constructor_range_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
name|constructor_max_index
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|copy_node
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|constructor_index
operator|=
name|copy_node
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|copy_node
argument_list|(
name|constructor_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle the case of int x = {5}; */
name|constructor_fields
operator|=
name|constructor_type
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_type
expr_stmt|;
block|}
if|if
condition|(
name|constructor_incremental
condition|)
block|{
name|int
name|momentary
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|constructor_decl
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|constructor_decl
argument_list|,
name|constructor_asmspec
argument_list|,
name|constructor_top_level
argument_list|)
expr_stmt|;
name|assemble_variable
argument_list|(
name|constructor_decl
argument_list|,
name|constructor_top_level
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constructor_incremental
condition|)
block|{
name|defer_addressed_constants
argument_list|()
expr_stmt|;
name|constructor_subconstants_deferred
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push down into a subobject, for initialization.    If this is for an explicit set of braces, IMPLICIT is 0.    If it is because the next element belongs at a lower level,    IMPLICIT is 1.  */
end_comment

begin_function
name|void
name|push_init_level
parameter_list|(
name|implicit
parameter_list|)
name|int
name|implicit
decl_stmt|;
block|{
name|struct
name|constructor_stack
modifier|*
name|p
decl_stmt|;
comment|/* If we've exhausted any levels that didn't have braces,      pop them now.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
operator|==
literal|0
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* Structure elements may require alignment.  Do this now if necessary      for the subaggregate, and if it comes next in sequence.  Don't do      this for subaggregates that will go on the pending list.  */
if|if
condition|(
name|constructor_incremental
operator|&&
name|constructor_type
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|constructor_fields
operator|&&
name|constructor_fields
operator|==
name|constructor_unfilled_fields
condition|)
block|{
comment|/* Advance to offset of this element.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|constructor_bit_index
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|constructor_fields
argument_list|)
argument_list|)
condition|)
block|{
comment|/* By using unsigned arithmetic, the result will be correct even 	     in case of overflows, if BITS_PER_UNIT is a power of two.  */
name|unsigned
name|next
init|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|constructor_fields
argument_list|)
argument_list|)
operator|/
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|unsigned
name|here
init|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_bit_index
argument_list|)
operator|/
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|assemble_zeros
argument_list|(
operator|(
name|next
operator|-
name|here
operator|)
operator|*
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
operator|/
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* Indicate that we have now filled the structure up to the current 	 field.  */
name|constructor_unfilled_fields
operator|=
name|constructor_fields
expr_stmt|;
block|}
name|p
operator|=
operator|(
expr|struct
name|constructor_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|constructor_stack
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|constructor_type
expr_stmt|;
name|p
operator|->
name|fields
operator|=
name|constructor_fields
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|constructor_index
expr_stmt|;
name|p
operator|->
name|range_end
operator|=
name|constructor_range_end
expr_stmt|;
name|p
operator|->
name|max_index
operator|=
name|constructor_max_index
expr_stmt|;
name|p
operator|->
name|unfilled_index
operator|=
name|constructor_unfilled_index
expr_stmt|;
name|p
operator|->
name|unfilled_fields
operator|=
name|constructor_unfilled_fields
expr_stmt|;
name|p
operator|->
name|bit_index
operator|=
name|constructor_bit_index
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|constructor_elements
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constructor_constant
expr_stmt|;
name|p
operator|->
name|simple
operator|=
name|constructor_simple
expr_stmt|;
name|p
operator|->
name|erroneous
operator|=
name|constructor_erroneous
expr_stmt|;
name|p
operator|->
name|pending_elts
operator|=
name|constructor_pending_elts
expr_stmt|;
name|p
operator|->
name|depth
operator|=
name|constructor_depth
expr_stmt|;
name|p
operator|->
name|replacement_value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|implicit
operator|=
name|implicit
expr_stmt|;
name|p
operator|->
name|incremental
operator|=
name|constructor_incremental
expr_stmt|;
name|p
operator|->
name|outer
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|constructor_stack
expr_stmt|;
name|constructor_stack
operator|=
name|p
expr_stmt|;
name|constructor_constant
operator|=
literal|1
expr_stmt|;
name|constructor_simple
operator|=
literal|1
expr_stmt|;
name|constructor_depth
operator|=
name|SPELLING_DEPTH
argument_list|()
expr_stmt|;
name|constructor_elements
operator|=
literal|0
expr_stmt|;
name|constructor_pending_elts
operator|=
literal|0
expr_stmt|;
comment|/* Don't die if an entire brace-pair level is superfluous      in the containing level.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* Don't die if there are extra init elts at the end.  */
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
name|constructor_type
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|constructor_type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_depth
operator|++
expr_stmt|;
if|if
condition|(
name|constructor_fields
operator|!=
name|constructor_unfilled_fields
condition|)
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|constructor_type
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|push_array_bounds
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_index
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_depth
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|constructor_index
argument_list|,
name|constructor_unfilled_index
argument_list|)
operator|||
name|constructor_range_end
operator|!=
literal|0
condition|)
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"extra brace group at end of initializer"
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
literal|0
expr_stmt|;
name|constructor_unfilled_fields
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Turn off constructor_incremental if type is a struct with bitfields.  */
name|check_init_type_bitfields
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|implicit
operator|&&
name|warn_missing_braces
operator|&&
operator|!
name|missing_braces_mentioned
condition|)
block|{
name|missing_braces_mentioned
operator|=
literal|1
expr_stmt|;
name|warning_init
argument_list|(
literal|"missing braces around initializer"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|constructor_fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|copy_node
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|sbitsizetype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|constructor_range_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
condition|)
block|{
name|constructor_max_index
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_index
operator|=
name|copy_node
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|constructor_index
operator|=
name|copy_node
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|copy_node
argument_list|(
name|constructor_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning_init
argument_list|(
literal|"braces around scalar initializer"
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
name|constructor_type
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|constructor_type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Don't read a struct incrementally if it has any bitfields,    because the incremental reading code doesn't know how to    handle bitfields yet.  */
end_comment

begin_function
specifier|static
name|void
name|check_init_type_bitfields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|check_init_type_bitfields
argument_list|(
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|tail
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|tail
argument_list|)
condition|)
comment|/* We also use the nonincremental algorithm for initiliazation 	   of unions whose first member is a bitfield, becuase the 	   incremental algorithm has no code for dealing with 	   bitfields. */
name|constructor_incremental
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|check_init_type_bitfields
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of an implicit or explicit brace level,     finish up that level of constructor.    If we were outputting the elements as they are read, return 0    from inner levels (process_init_element ignores that),    but return error_mark_node from the outermost level    (that's what we want to put in DECL_INITIAL).    Otherwise, return a CONSTRUCTOR expression.  */
end_comment

begin_function
name|tree
name|pop_init_level
parameter_list|(
name|implicit
parameter_list|)
name|int
name|implicit
decl_stmt|;
block|{
name|struct
name|constructor_stack
modifier|*
name|p
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|tree
name|constructor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|implicit
operator|==
literal|0
condition|)
block|{
comment|/* When we come to an explicit close brace, 	 pop any inner levels that didn't have explicit braces.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|constructor_stack
expr_stmt|;
if|if
condition|(
name|constructor_type
operator|!=
literal|0
condition|)
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* Warn when some struct elements are implicitly initialized to zero.  */
if|if
condition|(
name|extra_warnings
operator|&&
name|constructor_type
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|constructor_unfilled_fields
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
name|warning_init
argument_list|(
literal|"missing initializer"
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
comment|/* Now output all pending elements.  */
name|output_pending_init_elements
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* c-parse.in warns about {}.  */
comment|/* In ANSI, each brace level must have at least one element.  */
block|if (! implicit&& pedantic&& (TREE_CODE (constructor_type) == ARRAY_TYPE 	  ? integer_zerop (constructor_unfilled_index) 	  : constructor_unfilled_fields == TYPE_FIELDS (constructor_type)))     pedwarn_init ("empty braces in initializer");
endif|#
directive|endif
comment|/* Pad out the end of the structure.  */
if|if
condition|(
name|p
operator|->
name|replacement_value
condition|)
block|{
comment|/* If this closes a superfluous brace pair, 	 just pass out the element between them.  */
name|constructor
operator|=
name|p
operator|->
name|replacement_value
expr_stmt|;
comment|/* If this is the top level thing within the initializer, 	 and it's for a variable, then since we already called 	 assemble_variable, we must output the value now.  */
if|if
condition|(
name|p
operator|->
name|next
operator|==
literal|0
operator|&&
name|constructor_decl
operator|!=
literal|0
operator|&&
name|constructor_incremental
condition|)
block|{
name|constructor
operator|=
name|digest_init
argument_list|(
name|constructor_type
argument_list|,
name|constructor
argument_list|,
name|require_constant_value
argument_list|,
name|require_constant_elements
argument_list|)
expr_stmt|;
comment|/* If initializing an array of unknown size, 	     determine the size now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|failure
decl_stmt|;
name|int
name|momentary_p
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|momentary_p
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* We shouldn't have an incomplete array type within 		 some other type.  */
if|if
condition|(
name|constructor_stack
operator|->
name|next
condition|)
name|abort
argument_list|()
expr_stmt|;
name|failure
operator|=
name|complete_array_type
argument_list|(
name|constructor_type
argument_list|,
name|constructor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary_p
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|output_constant
argument_list|(
name|constructor
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
operator|!
name|constructor_incremental
condition|)
block|{
comment|/* A nonincremental scalar initializer--just return 	 the element, after verifying there is just one.  */
if|if
condition|(
name|constructor_elements
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"empty scalar initializer"
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|constructor_elements
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"extra elements in scalar initializer"
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|TREE_VALUE
argument_list|(
name|constructor_elements
argument_list|)
expr_stmt|;
block|}
else|else
name|constructor
operator|=
name|TREE_VALUE
argument_list|(
name|constructor_elements
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|constructor_incremental
condition|)
block|{
if|if
condition|(
name|constructor_erroneous
condition|)
name|constructor
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
name|int
name|momentary
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|constructor
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|constructor_type
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|constructor_elements
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor_constant
condition|)
name|TREE_CONSTANT
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|constructor_constant
operator|&&
name|constructor_simple
condition|)
name|TREE_STATIC
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|filled
decl_stmt|;
name|int
name|momentary
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* Find the offset of the end of that field.  */
name|filled
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|constructor_bit_index
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* If initializing an array of unknown size, 	     determine the size now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|maxindex
init|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|constructor_unfilled_index
argument_list|,
name|integer_one_node
argument_list|)
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|constructor_type
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|maxindex
operator|=
name|copy_node
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
comment|/* TYPE_MAX_VALUE is always one less than the number of elements 		 in the array, because we start counting at zero.  Therefore, 		 warn only if the value is less than zero.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|tree_int_cst_sgn
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|error_with_decl
argument_list|(
name|constructor_decl
argument_list|,
literal|"zero or negative array size `%s'"
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|constructor_type
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|filled
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|constructor_unfilled_index
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|filled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filled
operator|!=
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|filled
argument_list|)
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
block|}
name|constructor_type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|constructor_fields
operator|=
name|p
operator|->
name|fields
expr_stmt|;
name|constructor_index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|constructor_range_end
operator|=
name|p
operator|->
name|range_end
expr_stmt|;
name|constructor_max_index
operator|=
name|p
operator|->
name|max_index
expr_stmt|;
name|constructor_unfilled_index
operator|=
name|p
operator|->
name|unfilled_index
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|p
operator|->
name|unfilled_fields
expr_stmt|;
name|constructor_bit_index
operator|=
name|p
operator|->
name|bit_index
expr_stmt|;
name|constructor_elements
operator|=
name|p
operator|->
name|elements
expr_stmt|;
name|constructor_constant
operator|=
name|p
operator|->
name|constant
expr_stmt|;
name|constructor_simple
operator|=
name|p
operator|->
name|simple
expr_stmt|;
name|constructor_erroneous
operator|=
name|p
operator|->
name|erroneous
expr_stmt|;
name|constructor_pending_elts
operator|=
name|p
operator|->
name|pending_elts
expr_stmt|;
name|constructor_depth
operator|=
name|p
operator|->
name|depth
expr_stmt|;
name|constructor_incremental
operator|=
name|p
operator|->
name|incremental
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
name|constructor_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|constructor_stack
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|constructor
return|;
block|}
end_function

begin_comment
comment|/* Within an array initializer, specify the next index to be initialized.    FIRST is that index.  If LAST is nonzero, then initialize a range    of indices, running from FIRST through LAST.  */
end_comment

begin_function
name|void
name|set_init_index
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|tree
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|first
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
operator|(
name|first
operator|)
operator|=
name|TREE_OPERAND
argument_list|(
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
operator|(
name|last
operator|)
operator|=
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error_init
argument_list|(
literal|"nonconstant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error_init
argument_list|(
literal|"nonconstant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|constructor_unfilled_index
condition|)
name|error_init
argument_list|(
literal|"array index in non-array initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|first
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|error_init
argument_list|(
literal|"duplicate array index in initializer"
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|last
argument_list|,
name|first
argument_list|)
condition|)
name|error_init
argument_list|(
literal|"empty index range in initializer"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids specifying element to initialize"
argument_list|)
expr_stmt|;
name|constructor_range_end
operator|=
name|last
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Within a struct initializer, specify the next field to be initialized.  */
end_comment

begin_function
name|void
name|set_init_label
parameter_list|(
name|fieldname
parameter_list|)
name|tree
name|fieldname
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|int
name|passed
init|=
literal|0
decl_stmt|;
comment|/* Don't die if an entire brace-pair level is superfluous      in the containing level.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|tail
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|tail
operator|==
name|constructor_unfilled_fields
condition|)
name|passed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|==
name|fieldname
condition|)
break|break;
block|}
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unknown field `%s' specified in initializer"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|fieldname
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|passed
condition|)
name|error
argument_list|(
literal|"field `%s' already initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|fieldname
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|constructor_fields
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids specifying structure member to initialize"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a new initializer to the tree of pending initializers.  PURPOSE    indentifies the initializer, either array index or field in a structure.     VALUE is the value of that index or field.  */
end_comment

begin_function
specifier|static
name|void
name|add_pending_init
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|;
block|{
name|struct
name|init_node
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|q
operator|=
operator|&
name|constructor_pending_elts
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
name|q
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|purpose
argument_list|,
name|p
operator|->
name|purpose
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|purpose
operator|!=
name|purpose
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|q
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|*
name|q
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|purpose
argument_list|)
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|p
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|purpose
operator|!=
name|purpose
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|r
operator|=
operator|(
expr|struct
name|init_node
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|init_node
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|purpose
operator|=
name|purpose
expr_stmt|;
name|r
operator|->
name|value
operator|=
name|value
expr_stmt|;
operator|*
name|q
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|struct
name|init_node
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|p
operator|->
name|left
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|balance
operator|==
literal|0
condition|)
name|p
operator|->
name|balance
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
comment|/* L rotation. */
name|p
operator|->
name|left
operator|=
name|r
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
condition|)
name|p
operator|->
name|left
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
comment|/* LR rotation. */
name|struct
name|init_node
modifier|*
name|t
init|=
name|r
operator|->
name|right
decl_stmt|;
name|r
operator|->
name|right
operator|=
name|t
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|right
condition|)
name|r
operator|->
name|right
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
condition|)
name|p
operator|->
name|left
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|<
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
operator|-
operator|(
name|t
operator|->
name|balance
operator|>
literal|0
operator|)
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == +1; growth of left side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* r == p->right */
block|{
if|if
condition|(
name|p
operator|->
name|balance
operator|==
literal|0
condition|)
comment|/* Growth propagation from right side.  */
name|p
operator|->
name|balance
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
comment|/* R rotation. */
name|p
operator|->
name|right
operator|=
name|r
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|p
operator|->
name|right
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|r
expr_stmt|;
block|}
else|else
comment|/* r->balance == -1 */
block|{
comment|/* RL rotation */
name|struct
name|init_node
modifier|*
name|t
init|=
name|r
operator|->
name|left
decl_stmt|;
name|r
operator|->
name|left
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|left
condition|)
name|r
operator|->
name|left
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|t
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|p
operator|->
name|right
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|balance
operator|=
operator|(
name|t
operator|->
name|balance
operator|<
literal|0
operator|)
expr_stmt|;
name|p
operator|->
name|balance
operator|=
operator|-
operator|(
name|t
operator|->
name|balance
operator|>
literal|0
operator|)
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|constructor_pending_elts
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == -1; growth of right side balances the node. */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|r
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if FIELD is equal to the index of a pending initializer.  */
end_comment

begin_function
specifier|static
name|int
name|pending_init_member
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
name|struct
name|init_node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|constructor_pending_elts
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|field
operator|==
name|p
operator|->
name|purpose
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|field
argument_list|,
name|p
operator|->
name|purpose
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
else|else
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|field
operator|==
name|p
operator|->
name|purpose
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|p
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
else|else
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* "Output" the next constructor element.    At top level, really output it to assembler code now.    Otherwise, collect it in a list from which we will make a CONSTRUCTOR.    TYPE is the data type that the containing data type wants here.    FIELD is the field (a FIELD_DECL) or the index that this element fills.     PENDING if non-nil means output pending elements that belong    right after this element.  (PENDING is normally 1;    it is 0 while outputting pending elements, to avoid recursion.)  */
end_comment

begin_function
specifier|static
name|void
name|output_init_element
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|,
name|pending
parameter_list|)
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|,
name|field
decl_stmt|;
name|int
name|pending
decl_stmt|;
block|{
name|int
name|duplicate
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
operator|&&
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
name|constructor_erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|constructor_constant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
name|constructor_simple
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|require_constant_value
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant_elements
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element is not computable at load time"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this element duplicates one on constructor_pending_elts,      print a message and ignore it.  Don't do this when we're      processing elements taken off constructor_pending_elts,      because we'd always get spurious errors.  */
if|if
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|pending_init_member
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"duplicate initializer"
argument_list|)
expr_stmt|;
name|duplicate
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If this element doesn't come next in sequence,      put it on constructor_pending_elts.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|field
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|duplicate
condition|)
comment|/* The copy_node is needed in case field is actually 	   constructor_index, which is modified in place.  */
name|add_pending_init
argument_list|(
name|copy_node
argument_list|(
name|field
argument_list|)
argument_list|,
name|digest_init
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|require_constant_value
argument_list|,
name|require_constant_elements
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|field
operator|!=
name|constructor_unfilled_fields
condition|)
block|{
comment|/* We do this for records but not for unions.  In a union, 	 no matter which field is specified, it can be initialized 	 right away since it starts at the beginning of the union.  */
if|if
condition|(
operator|!
name|duplicate
condition|)
name|add_pending_init
argument_list|(
name|field
argument_list|,
name|digest_init
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|require_constant_value
argument_list|,
name|require_constant_elements
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, output this element either to 	 constructor_elements or to the assembler file.  */
if|if
condition|(
operator|!
name|duplicate
condition|)
block|{
if|if
condition|(
operator|!
name|constructor_incremental
condition|)
block|{
if|if
condition|(
name|field
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|field
operator|=
name|copy_node
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|constructor_elements
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|digest_init
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|require_constant_value
argument_list|,
name|require_constant_elements
argument_list|)
argument_list|,
name|constructor_elements
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Structure elements may require alignment. 		 Do this, if necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* Advance to offset of this element.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|constructor_bit_index
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
comment|/* By using unsigned arithmetic, the result will be 			 correct even in case of overflows, if BITS_PER_UNIT 			 is a power of two.  */
name|unsigned
name|next
init|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
operator|/
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|unsigned
name|here
init|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_bit_index
argument_list|)
operator|/
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|assemble_zeros
argument_list|(
operator|(
name|next
operator|-
name|here
operator|)
operator|*
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
operator|/
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
block|}
name|output_constant
argument_list|(
name|digest_init
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|require_constant_value
argument_list|,
name|require_constant_elements
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a record or union, 		 keep track of end position of last field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Advance the variable that indicates sequential elements output.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|tem
init|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_unfilled_index
argument_list|,
name|integer_one_node
argument_list|)
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_unfilled_fields
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|constructor_unfilled_fields
operator|=
literal|0
expr_stmt|;
comment|/* Now output any pending elements which have become next.  */
if|if
condition|(
name|pending
condition|)
name|output_pending_init_elements
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output any pending elements which have become next.    As we output elements, constructor_unfilled_{fields,index}    advances, which may cause other elements to become next;    if so, they too are output.     If ALL is 0, we return when there are    no more pending elements to output now.     If ALL is 1, we output space as necessary so that    we can output all the pending elements.  */
end_comment

begin_function
specifier|static
name|void
name|output_pending_init_elements
parameter_list|(
name|all
parameter_list|)
name|int
name|all
decl_stmt|;
block|{
name|struct
name|init_node
modifier|*
name|elt
init|=
name|constructor_pending_elts
decl_stmt|;
name|tree
name|next
decl_stmt|;
name|retry
label|:
comment|/* Look thru the whole pending tree.      If we find an element that should be output now,      output it.  Otherwise, set NEXT to the element      that comes first among those still pending.  */
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|elt
operator|->
name|purpose
argument_list|,
name|constructor_unfilled_index
argument_list|)
condition|)
name|output_init_element
argument_list|(
name|elt
operator|->
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|,
name|constructor_unfilled_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|constructor_unfilled_index
argument_list|,
name|elt
operator|->
name|purpose
argument_list|)
condition|)
block|{
comment|/* Advance to the next smaller node.  */
if|if
condition|(
name|elt
operator|->
name|left
condition|)
name|elt
operator|=
name|elt
operator|->
name|left
expr_stmt|;
else|else
block|{
comment|/* We have reached the smallest node bigger than the 		     current unfilled index.  Fill the space first.  */
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Advance to the next bigger node.  */
if|if
condition|(
name|elt
operator|->
name|right
condition|)
name|elt
operator|=
name|elt
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have reached the biggest node in a subtree.  Find 		     the parent of it, which is the next bigger node.  */
while|while
condition|(
name|elt
operator|->
name|parent
operator|&&
name|elt
operator|->
name|parent
operator|->
name|right
operator|==
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_unfilled_index
argument_list|,
name|elt
operator|->
name|purpose
argument_list|)
condition|)
block|{
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* If the current record is complete we are done.  */
if|if
condition|(
name|constructor_unfilled_fields
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|elt
operator|->
name|purpose
operator|==
name|constructor_unfilled_fields
condition|)
block|{
name|output_init_element
argument_list|(
name|elt
operator|->
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|constructor_unfilled_fields
argument_list|)
argument_list|,
name|constructor_unfilled_fields
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|constructor_unfilled_fields
argument_list|)
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Advance to the next smaller node.  */
if|if
condition|(
name|elt
operator|->
name|left
condition|)
name|elt
operator|=
name|elt
operator|->
name|left
expr_stmt|;
else|else
block|{
comment|/* We have reached the smallest node bigger than the 		     current unfilled field.  Fill the space first.  */
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Advance to the next bigger node.  */
if|if
condition|(
name|elt
operator|->
name|right
condition|)
name|elt
operator|=
name|elt
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have reached the biggest node in a subtree.  Find 		     the parent of it, which is the next bigger node.  */
while|while
condition|(
name|elt
operator|->
name|parent
operator|&&
name|elt
operator|->
name|parent
operator|->
name|right
operator|==
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|tree_int_cst_lt
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|constructor_unfilled_fields
argument_list|)
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|elt
operator|->
name|purpose
argument_list|)
argument_list|)
condition|)
block|{
name|next
operator|=
name|elt
operator|->
name|purpose
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Ordinarily return, but not if we want to output all      and there are elements left.  */
if|if
condition|(
operator|!
operator|(
name|all
operator|&&
name|next
operator|!=
literal|0
operator|)
condition|)
return|return;
comment|/* Generate space up to the position of NEXT.  */
if|if
condition|(
name|constructor_incremental
condition|)
block|{
name|tree
name|filled
decl_stmt|;
name|tree
name|nextpos_tree
init|=
name|size_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|tail
decl_stmt|;
comment|/* Find the last field written out, if any.  */
for|for
control|(
name|tail
operator|=
name|TYPE_FIELDS
argument_list|(
name|constructor_type
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|==
name|constructor_unfilled_fields
condition|)
break|break;
if|if
condition|(
name|tail
condition|)
comment|/* Find the offset of the end of that field.  */
name|filled
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|tail
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|filled
operator|=
name|size_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nextpos_tree
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|next
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|filled
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|constructor_unfilled_index
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nextpos_tree
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|next
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|filled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filled
condition|)
block|{
name|int
name|nextpos
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|nextpos_tree
argument_list|)
decl_stmt|;
name|assemble_zeros
argument_list|(
name|nextpos
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|filled
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If it's not incremental, just skip over the gap, 	 so that after jumping to retry we will output the next 	 successive element.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|constructor_unfilled_fields
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ELT now points to the node in the pending tree with the next      initializer to output.  */
goto|goto
name|retry
goto|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add one non-braced element to the current constructor level.    This adjusts the current position within the constructor's type.    This may also start or terminate implicit levels    to handle a partly-braced initializer.     Once this has found the correct level for the new element,    it calls output_init_element.     Note: if we are incrementally outputting this constructor,    this function may be called with a null argument    representing a sub-constructor that was already incrementally output.    When that happens, we output nothing, but we do the bookkeeping    to skip past that element of the current constructor.  */
end_comment

begin_function
name|void
name|process_init_element
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|orig_value
init|=
name|value
decl_stmt|;
name|int
name|string_flag
init|=
name|value
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
decl_stmt|;
comment|/* Handle superfluous braces around string cst as in      char x[] = {"foo"}; */
if|if
condition|(
name|string_flag
operator|&&
name|constructor_type
operator|&&
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|constructor_unfilled_index
argument_list|)
condition|)
block|{
name|constructor_stack
operator|->
name|replacement_value
operator|=
name|value
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|constructor_stack
operator|->
name|replacement_value
operator|!=
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"excess elements in struct initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ignore elements of a brace group if it is entirely superfluous      and has already been diagnosed.  */
if|if
condition|(
name|constructor_type
operator|==
literal|0
condition|)
return|return;
comment|/* If we've exhausted any levels that didn't have braces,      pop them now.  */
while|while
condition|(
name|constructor_stack
operator|->
name|implicit
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|constructor_fields
operator|==
literal|0
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|constructor_max_index
operator|==
literal|0
operator|||
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
operator|)
condition|)
name|process_init_element
argument_list|(
name|pop_init_level
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|fieldtype
decl_stmt|;
name|enum
name|tree_code
name|fieldcode
decl_stmt|;
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in struct initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fieldtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|!=
name|error_mark_node
condition|)
name|fieldtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
name|fieldcode
operator|=
name|TREE_CODE
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|string_flag
condition|)
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|constructor_no_implicit
operator|&&
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|fieldtype
operator|&&
operator|(
name|fieldcode
operator|==
name|RECORD_TYPE
operator|||
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|||
name|fieldcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
argument_list|,
name|fieldtype
argument_list|,
name|constructor_fields
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Do the bookkeeping for an element that was 	       directly output as a constructor.  */
block|{
comment|/* For a record, keep track of end position of last field.  */
name|tree
name|temp
init|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|constructor_fields
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
block|}
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
comment|/* Skip any nameless bit fields at the beginning.  */
while|while
condition|(
name|constructor_fields
operator|!=
literal|0
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|constructor_fields
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|constructor_fields
argument_list|)
operator|==
literal|0
condition|)
name|constructor_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|fieldtype
decl_stmt|;
name|enum
name|tree_code
name|fieldcode
decl_stmt|;
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in union initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fieldtype
operator|=
name|TREE_TYPE
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|!=
name|error_mark_node
condition|)
name|fieldtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
name|fieldcode
operator|=
name|TREE_CODE
argument_list|(
name|fieldtype
argument_list|)
expr_stmt|;
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|string_flag
condition|)
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|constructor_no_implicit
operator|&&
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|fieldtype
operator|&&
operator|(
name|fieldcode
operator|==
name|RECORD_TYPE
operator|||
name|fieldcode
operator|==
name|ARRAY_TYPE
operator|||
name|fieldcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
condition|)
block|{
name|push_member_name
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
argument_list|,
name|fieldtype
argument_list|,
name|constructor_fields
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Do the bookkeeping for an element that was 	       directly output as a constructor.  */
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_bit_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|DECL_SIZE
argument_list|(
name|constructor_fields
argument_list|)
argument_list|)
expr_stmt|;
name|constructor_unfilled_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|constructor_fields
argument_list|)
expr_stmt|;
block|}
name|constructor_fields
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|constructor_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|elttype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|constructor_type
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|eltcode
init|=
name|TREE_CODE
argument_list|(
name|elttype
argument_list|)
decl_stmt|;
comment|/* Accept a string constant to initialize a subarray.  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|eltcode
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|string_flag
condition|)
name|value
operator|=
name|orig_value
expr_stmt|;
comment|/* Otherwise, if we have come to a subaggregate, 	     and we don't have an element of its type, push into it.  */
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|constructor_no_implicit
operator|&&
name|value
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|elttype
operator|&&
operator|(
name|eltcode
operator|==
name|RECORD_TYPE
operator|||
name|eltcode
operator|==
name|ARRAY_TYPE
operator|||
name|eltcode
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|push_init_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|constructor_max_index
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_index
argument_list|)
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in array initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* In the case of [LO .. HI] = VALUE, only evaluate VALUE once.  */
if|if
condition|(
name|constructor_range_end
condition|)
block|{
if|if
condition|(
name|constructor_max_index
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|constructor_max_index
argument_list|,
name|constructor_range_end
argument_list|)
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in array initializer"
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_range_end
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_max_index
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_range_end
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_max_index
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|save_expr
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Now output the actual element. 	     Ordinarily, output once. 	     If there is a range, repeat it till we advance past the range.  */
do|do
block|{
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|push_array_bounds
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_index
argument_list|)
argument_list|)
expr_stmt|;
name|output_init_element
argument_list|(
name|value
argument_list|,
name|elttype
argument_list|,
name|constructor_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|constructor_depth
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|constructor_index
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
comment|/* If we are doing the bookkeeping for an element that was 		   directly output as a constructor, 		   we must update constructor_unfilled_index.  */
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|constructor_index
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_unfilled_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|constructor_index
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|constructor_range_end
operator|==
literal|0
operator|||
name|tree_int_cst_lt
argument_list|(
name|constructor_range_end
argument_list|,
name|constructor_index
argument_list|)
operator|)
condition|)
do|;
break|break;
block|}
comment|/* Handle the sole element allowed in a braced initializer 	 for a scalar variable.  */
if|if
condition|(
name|constructor_fields
operator|==
literal|0
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in scalar initializer"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
condition|)
name|output_init_element
argument_list|(
name|value
argument_list|,
name|constructor_type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constructor_fields
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If the (lexically) previous elments are not now saved,      we can discard the storage for them.  */
if|if
condition|(
name|constructor_incremental
operator|&&
name|constructor_pending_elts
operator|==
literal|0
operator|&&
name|value
operator|!=
literal|0
operator|&&
name|constructor_stack
operator|==
literal|0
condition|)
name|clear_momentary
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
specifier|register
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"asm template is not a string constant"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Record the contents of OUTPUTS before it is modified.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Perform default conversions on array and function inputs.  */
comment|/* Don't do this for other types--      it would screw up operands expected to be in memory.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the ASM_OPERANDS insn;      store into the TREE_VALUEs of OUTPUTS some trees for      where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C `return' statement.    RETVAL is the expression for what to return,    or a null pointer for `return;' with no value.  */
end_comment

begin_function
name|void
name|c_expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `noreturn' has a `return' statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn_return_type
operator|&&
name|valtype
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"`return' with no value, in function returning non-void"
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"`return' with a value, in function returning void"
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|convert_for_assignment
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|,
name|_
argument_list|(
literal|"return"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|res
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|inner
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return;
name|inner
operator|=
name|t
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Strip any conversions, additions, and subtractions, and see if 	 we are returning the address of a local variable.  Warn if so.  */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MINUS_EXPR
case|:
comment|/* If the second operand of the MINUS_EXPR has a pointer 		 type (or is converted from it), this may be valid, so 		 don't give a warning.  */
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
condition|)
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
break|break;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|ADDR_EXPR
case|:
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
literal|'r'
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|inner
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|inner
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|inner
argument_list|)
operator|==
name|current_function_decl
condition|)
name|warning
argument_list|(
literal|"function returns address of local variable"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a C switch statement, testing expression EXP.    Return EXP if it is valid, an error node otherwise.  */
end_comment

begin_function
name|tree
name|c_expand_start_case
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|INTEGER_TYPE
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|index
decl_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_traditional
operator|&&
operator|(
name|type
operator|==
name|long_integer_type_node
operator|||
name|type
operator|==
name|long_unsigned_type_node
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"`long' switch expression not converted to `int' in ANSI C"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|index
operator|=
name|get_unwidened
argument_list|(
name|exp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	 because if we did, int_fits_type_p would do the wrong thing 	 when checking case values for being in range, 	 and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|index
expr_stmt|;
block|}
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
literal|"switch statement"
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

end_unit

