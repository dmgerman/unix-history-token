begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow functions for trees.    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_comment
comment|/* This file contains functions for building the Control Flow Graph (CFG)    for a function tree.  */
end_comment

begin_comment
comment|/* Local declarations.  */
end_comment

begin_comment
comment|/* Initial capacity for the basic block array.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|initial_cfg_capacity
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This hash table allows us to efficiently lookup all CASE_LABEL_EXPRs    which use a particular edge.  The CASE_LABEL_EXPRs are chained together    via their TREE_CHAIN field, which we clear after we're done with the    hash table to prevent problems with duplication of SWITCH_EXPRs.     Access to this list of CASE_LABEL_EXPRs allows us to efficiently    update the case vector in response to edge redirections.     Right now this table is set up and torn down at key points in the    compilation process.  It would be nice if we could make the table    more persistent.  The key is getting notification of changes to    the CFG (particularly edge removal, creation and redirection).  */
end_comment

begin_struct
struct|struct
name|edge_to_cases_elt
block|{
comment|/* The edge itself.  Necessary for hashing and equality tests.  */
name|edge
name|e
decl_stmt|;
comment|/* The case labels associated with this edge.  We link these up via      their TREE_CHAIN field, then we wipe out the TREE_CHAIN fields      when we destroy the hash table.  This prevents problems when copying      SWITCH_EXPRs.  */
name|tree
name|case_labels
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|htab_t
name|edge_to_cases
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CFG statistics.  */
end_comment

begin_struct
struct|struct
name|cfg_stats_d
block|{
name|long
name|num_merged_labels
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cfg_stats_d
name|cfg_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we found a computed goto while building basic blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|found_computed_goto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Basic blocks and flowgraphs.  */
end_comment

begin_function_decl
specifier|static
name|basic_block
name|create_bb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_blocks
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|factor_computed_gotos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Edges.  */
end_comment

begin_function_decl
specifier|static
name|void
name|make_edges
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_cond_expr_edges
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_switch_expr_edges
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_goto_expr_edges
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|tree_redirect_edge_and_branch
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|tree_try_redirect_by_replacing_jump
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|split_critical_edges
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Various helpers.  */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|bool
name|stmt_starts_bb_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tree_verify_flow_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tree_make_forwarder_block
parameter_list|(
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tree_cfg2vcg
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|change_bb_for_stmt
parameter_list|(
name|tree
name|t
parameter_list|,
name|basic_block
name|bb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Flowgraph optimization and cleanup.  */
end_comment

begin_function_decl
specifier|static
name|void
name|tree_merge_blocks
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tree_can_merge_blocks_p
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_bb
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|find_taken_edge_computed_goto
parameter_list|(
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|find_taken_edge_cond_expr
parameter_list|(
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|find_taken_edge_switch_expr
parameter_list|(
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_case_label_for_value
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|init_empty_tree_cfg
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the basic block array.  */
name|init_flow
argument_list|()
expr_stmt|;
name|profile_status
operator|=
name|PROFILE_ABSENT
expr_stmt|;
name|n_basic_blocks
operator|=
name|NUM_FIXED_BLOCKS
expr_stmt|;
name|last_basic_block
operator|=
name|NUM_FIXED_BLOCKS
expr_stmt|;
name|basic_block_info
operator|=
name|VEC_alloc
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|initial_cfg_capacity
argument_list|)
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|basic_block_info
argument_list|,
name|initial_cfg_capacity
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|initial_cfg_capacity
argument_list|)
expr_stmt|;
comment|/* Build a mapping of labels to their associated blocks.  */
name|label_to_block_map
operator|=
name|VEC_alloc
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|initial_cfg_capacity
argument_list|)
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|label_to_block_map
argument_list|,
name|initial_cfg_capacity
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|label_to_block_map
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|initial_cfg_capacity
argument_list|)
expr_stmt|;
name|SET_BASIC_BLOCK
argument_list|(
name|ENTRY_BLOCK
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|SET_BASIC_BLOCK
argument_list|(
name|EXIT_BLOCK
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 			      Create basic blocks ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Entry point to the CFG builder for trees.  TP points to the list of    statements to be added to the flowgraph.  */
end_comment

begin_function
specifier|static
name|void
name|build_tree_cfg
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|)
block|{
comment|/* Register specific tree functions.  */
name|tree_register_cfg_hooks
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_stats
argument_list|)
argument_list|)
expr_stmt|;
name|init_empty_tree_cfg
argument_list|()
expr_stmt|;
name|found_computed_goto
operator|=
literal|0
expr_stmt|;
name|make_blocks
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Computed gotos are hell to deal with, especially if there are      lots of them with a large number of destinations.  So we factor      them to a common computed goto location before we build the      edge list.  After we convert back to normal form, we will un-factor      the computed gotos since factoring introduces an unwanted jump.  */
if|if
condition|(
name|found_computed_goto
condition|)
name|factor_computed_gotos
argument_list|()
expr_stmt|;
comment|/* Make sure there is always at least one block, even if it's empty.  */
if|if
condition|(
name|n_basic_blocks
operator|==
name|NUM_FIXED_BLOCKS
condition|)
name|create_empty_bb
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Adjust the size of the array.  */
if|if
condition|(
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
operator|<
operator|(
name|size_t
operator|)
name|n_basic_blocks
condition|)
block|{
name|size_t
name|old_size
init|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|p
decl_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|basic_block_info
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|p
operator|=
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p
index|[
name|old_size
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|n_basic_blocks
operator|-
name|old_size
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* To speed up statement iterator walks, we first purge dead labels.  */
name|cleanup_dead_labels
argument_list|()
expr_stmt|;
comment|/* Group case nodes to reduce the number of edges.      We do this after cleaning up dead labels because otherwise we miss      a lot of obvious case merging opportunities.  */
name|group_case_labels
argument_list|()
expr_stmt|;
comment|/* Create the edges of the flowgraph.  */
name|make_edges
argument_list|()
expr_stmt|;
comment|/* Debugging dumps.  */
comment|/* Write the flowgraph to a VCG file.  */
block|{
name|int
name|local_dump_flags
decl_stmt|;
name|FILE
modifier|*
name|vcg_file
init|=
name|dump_begin
argument_list|(
name|TDI_vcg
argument_list|,
operator|&
name|local_dump_flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|vcg_file
condition|)
block|{
name|tree_cfg2vcg
argument_list|(
name|vcg_file
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_vcg
argument_list|,
name|vcg_file
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_stmts
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Dump a textual representation of the flowgraph.  */
if|if
condition|(
name|dump_file
condition|)
name|dump_tree_cfg
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|execute_build_cfg
parameter_list|(
name|void
parameter_list|)
block|{
name|build_tree_cfg
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_build_cfg
init|=
block|{
literal|"cfg"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|execute_build_cfg
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_CFG
block|,
comment|/* tv_id */
name|PROP_gimple_leh
block|,
comment|/* properties_required */
name|PROP_cfg
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Search the CFG for any computed gotos.  If found, factor them to a    common computed goto site.  Also record the location of that site so    that we can un-factor the gotos after we have converted back to    normal form.  */
end_comment

begin_function
specifier|static
name|void
name|factor_computed_gotos
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|factored_label_decl
init|=
name|NULL
decl_stmt|;
name|tree
name|var
init|=
name|NULL
decl_stmt|;
name|tree
name|factored_computed_goto_label
init|=
name|NULL
decl_stmt|;
name|tree
name|factored_computed_goto
init|=
name|NULL
decl_stmt|;
comment|/* We know there are one or more computed gotos in this function.      Examine the last statement in each basic block to see if the block      ends with a computed goto.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|tree
name|last
decl_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
continue|continue;
name|last
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
comment|/* Ignore the computed goto we create when we factor the original 	 computed gotos.  */
if|if
condition|(
name|last
operator|==
name|factored_computed_goto
condition|)
continue|continue;
comment|/* If the last statement is a computed goto, factor it.  */
if|if
condition|(
name|computed_goto_p
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|tree
name|assignment
decl_stmt|;
comment|/* The first time we find a computed goto we need to create 	     the factored goto block and the variable each original 	     computed goto will use for their goto destination.  */
if|if
condition|(
operator|!
name|factored_computed_goto
condition|)
block|{
name|basic_block
name|new_bb
init|=
name|create_empty_bb
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|new_bsi
init|=
name|bsi_start
argument_list|(
name|new_bb
argument_list|)
decl_stmt|;
comment|/* Create the destination of the factored goto.  Each original 		 computed goto will put its desired destination into this 		 variable and jump to the label we create immediately 		 below.  */
name|var
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"gotovar"
argument_list|)
expr_stmt|;
comment|/* Build a label for the new block which will contain the 		 factored computed goto.  */
name|factored_label_decl
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|factored_computed_goto_label
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|factored_label_decl
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|new_bsi
argument_list|,
name|factored_computed_goto_label
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
comment|/* Build our new computed goto.  */
name|factored_computed_goto
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|new_bsi
argument_list|,
name|factored_computed_goto
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the original computed goto's destination into VAR.  */
name|assignment
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|var
argument_list|,
name|GOTO_DESTINATION
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|assignment
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* And re-vector the computed goto to the new destination.  */
name|GOTO_DESTINATION
argument_list|(
name|last
argument_list|)
operator|=
name|factored_label_decl
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Build a flowgraph for the statement_list STMT_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|make_blocks
parameter_list|(
name|tree
name|stmt_list
parameter_list|)
block|{
name|tree_stmt_iterator
name|i
init|=
name|tsi_start
argument_list|(
name|stmt_list
argument_list|)
decl_stmt|;
name|tree
name|stmt
init|=
name|NULL
decl_stmt|;
name|bool
name|start_new_block
init|=
name|true
decl_stmt|;
name|bool
name|first_stmt_of_list
init|=
name|true
decl_stmt|;
name|basic_block
name|bb
init|=
name|ENTRY_BLOCK_PTR
decl_stmt|;
while|while
condition|(
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|tree
name|prev_stmt
decl_stmt|;
name|prev_stmt
operator|=
name|stmt
expr_stmt|;
name|stmt
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* If the statement starts a new basic block or if we have determined 	 in a previous pass that we need to create a new block for STMT, do 	 so now.  */
if|if
condition|(
name|start_new_block
operator|||
name|stmt_starts_bb_p
argument_list|(
name|stmt
argument_list|,
name|prev_stmt
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_stmt_of_list
condition|)
name|stmt_list
operator|=
name|tsi_split_statement_list_before
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
name|bb
operator|=
name|create_basic_block
argument_list|(
name|stmt_list
argument_list|,
name|NULL
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|start_new_block
operator|=
name|false
expr_stmt|;
block|}
comment|/* Now add STMT to BB and create the subgraphs for special statement 	 codes.  */
name|set_bb_for_stmt
argument_list|(
name|stmt
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|computed_goto_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|found_computed_goto
operator|=
name|true
expr_stmt|;
comment|/* If STMT is a basic block terminator, set START_NEW_BLOCK for the 	 next iteration.  */
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|start_new_block
operator|=
name|true
expr_stmt|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
name|first_stmt_of_list
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create and return a new empty basic block after bb AFTER.  */
end_comment

begin_function
specifier|static
name|basic_block
name|create_bb
parameter_list|(
name|void
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|e
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|e
argument_list|)
expr_stmt|;
comment|/* Create and initialize a new basic block.  Since alloc_block uses      ggc_alloc_cleared to allocate a basic block, we do not have to      clear the newly allocated basic block here.  */
name|bb
operator|=
name|alloc_block
argument_list|()
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|last_basic_block
expr_stmt|;
name|bb
operator|->
name|flags
operator|=
name|BB_NEW
expr_stmt|;
name|bb
operator|->
name|stmt_list
operator|=
name|h
condition|?
operator|(
name|tree
operator|)
name|h
else|:
name|alloc_stmt_list
argument_list|()
expr_stmt|;
comment|/* Add the new block to the linked list of blocks.  */
name|link_block
argument_list|(
name|bb
argument_list|,
name|after
argument_list|)
expr_stmt|;
comment|/* Grow the basic block array if needed.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|last_basic_block
operator|==
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
condition|)
block|{
name|size_t
name|old_size
init|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
decl_stmt|;
name|size_t
name|new_size
init|=
name|last_basic_block
operator|+
operator|(
name|last_basic_block
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|basic_block
modifier|*
name|p
decl_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|basic_block_info
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|basic_block_info
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p
index|[
name|old_size
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the newly created block to the array.  */
name|SET_BASIC_BLOCK
argument_list|(
name|last_basic_block
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|n_basic_blocks
operator|++
expr_stmt|;
name|last_basic_block
operator|++
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 				 Edge creation ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Fold COND_EXPR_COND of each COND_EXPR.  */
end_comment

begin_function
name|void
name|fold_cond_expr_cond
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|cond
decl_stmt|;
name|bool
name|zerop
decl_stmt|,
name|onep
decl_stmt|;
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|zerop
operator|=
name|integer_zerop
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|onep
operator|=
name|integer_onep
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|fold_undefer_overflow_warnings
argument_list|(
operator|(
operator|(
name|zerop
operator|||
name|onep
operator|)
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|stmt
argument_list|)
operator|)
argument_list|,
name|stmt
argument_list|,
name|WARN_STRICT_OVERFLOW_CONDITIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerop
condition|)
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|boolean_false_node
expr_stmt|;
elseif|else
if|if
condition|(
name|onep
condition|)
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|boolean_true_node
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Join all the blocks in the flowgraph.  */
end_comment

begin_function
specifier|static
name|void
name|make_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|omp_region
modifier|*
name|cur_region
init|=
name|NULL
decl_stmt|;
comment|/* Create an edge from entry to the first block with executable      statements in it.  */
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|NUM_FIXED_BLOCKS
argument_list|)
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
comment|/* Traverse the basic block array placing edges.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|last
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|bool
name|fallthru
decl_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|last
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GOTO_EXPR
case|:
name|make_goto_expr_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|make_cond_expr_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|make_switch_expr_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|RESX_EXPR
case|:
name|make_eh_edges
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* If this function receives a nonlocal goto, then we need to 		 make edges from this call site to all the nonlocal goto 		 handlers.  */
if|if
condition|(
name|tree_can_make_abnormal_goto
argument_list|(
name|last
argument_list|)
condition|)
name|make_abnormal_goto_edges
argument_list|(
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If this statement has reachable exception handlers, then 		 create abnormal edges to them.  */
name|make_eh_edges
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* Some calls are known not to return.  */
name|fallthru
operator|=
operator|!
operator|(
name|call_expr_flags
argument_list|(
name|last
argument_list|)
operator|&
name|ECF_NORETURN
operator|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|is_ctrl_altering_stmt
argument_list|(
name|last
argument_list|)
condition|)
block|{
comment|/* A MODIFY_EXPR may have a CALL_EXPR on its RHS and the 		     CALL_EXPR may have an abnormal edge.  Search the RHS for 		     this case and create any required edges.  */
if|if
condition|(
name|tree_can_make_abnormal_goto
argument_list|(
name|last
argument_list|)
condition|)
name|make_abnormal_goto_edges
argument_list|(
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|make_eh_edges
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
name|fallthru
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_PARALLEL
case|:
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SINGLE
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
case|case
name|OMP_SECTION
case|:
name|cur_region
operator|=
name|new_omp_region
argument_list|(
name|bb
argument_list|,
name|code
argument_list|,
name|cur_region
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_SECTIONS
case|:
name|cur_region
operator|=
name|new_omp_region
argument_list|(
name|bb
argument_list|,
name|code
argument_list|,
name|cur_region
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OMP_RETURN
case|:
comment|/* In the case of an OMP_SECTION, the edge will go somewhere 		 other than the next block.  This will be created later.  */
name|cur_region
operator|->
name|exit
operator|=
name|bb
expr_stmt|;
name|fallthru
operator|=
name|cur_region
operator|->
name|type
operator|!=
name|OMP_SECTION
expr_stmt|;
name|cur_region
operator|=
name|cur_region
operator|->
name|outer
expr_stmt|;
break|break;
case|case
name|OMP_CONTINUE
case|:
name|cur_region
operator|->
name|cont
operator|=
name|bb
expr_stmt|;
switch|switch
condition|(
name|cur_region
operator|->
name|type
condition|)
block|{
case|case
name|OMP_FOR
case|:
comment|/* ??? Technically there should be a some sort of loopback 		     edge here, but it goes to a block that doesn't exist yet, 		     and without it, updating the ssa form would be a real 		     bear.  Fortunately, we don't yet do ssa before expanding 		     these nodes.  */
break|break;
case|case
name|OMP_SECTIONS
case|:
comment|/* Wire up the edges into and out of the nested sections.  */
comment|/* ??? Similarly wrt loopback.  */
block|{
name|struct
name|omp_region
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cur_region
operator|->
name|inner
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
name|gcc_assert
argument_list|(
name|i
operator|->
name|type
operator|==
name|OMP_SECTION
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cur_region
operator|->
name|entry
argument_list|,
name|i
operator|->
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|i
operator|->
name|exit
argument_list|,
name|bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fallthru
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|gcc_assert
argument_list|(
operator|!
name|stmt_ends_bb_p
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
name|fallthru
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|fallthru
condition|)
name|make_edge
argument_list|(
name|bb
argument_list|,
name|bb
operator|->
name|next_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|root_omp_region
condition|)
name|free_omp_regions
argument_list|()
expr_stmt|;
comment|/* Fold COND_EXPR_COND of each COND_EXPR.  */
name|fold_cond_expr_cond
argument_list|()
expr_stmt|;
comment|/* Clean up the graph and warn for unreachable code.  */
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the edges for a COND_EXPR starting at block BB.    At this point, both clauses must contain only simple gotos.  */
end_comment

begin_function
specifier|static
name|void
name|make_cond_expr_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|entry
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|basic_block
name|then_bb
decl_stmt|,
name|else_bb
decl_stmt|;
name|tree
name|then_label
decl_stmt|,
name|else_label
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|gcc_assert
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|entry
argument_list|)
operator|==
name|COND_EXPR
argument_list|)
expr_stmt|;
comment|/* Entry basic blocks for each component.  */
name|then_label
operator|=
name|GOTO_DESTINATION
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|else_label
operator|=
name|GOTO_DESTINATION
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|then_bb
operator|=
name|label_to_block
argument_list|(
name|then_label
argument_list|)
expr_stmt|;
name|else_bb
operator|=
name|label_to_block
argument_list|(
name|else_label
argument_list|)
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|then_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|e
operator|->
name|goto_locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|e
operator|->
name|goto_locus
operator|=
name|EXPR_LOCUS
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|e
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|else_bb
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|e
operator|->
name|goto_locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|e
operator|->
name|goto_locus
operator|=
name|EXPR_LOCUS
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Hashing routine for EDGE_TO_CASES.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|edge_to_cases_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|edge
name|e
init|=
operator|(
operator|(
expr|struct
name|edge_to_cases_elt
operator|*
operator|)
name|p
operator|)
operator|->
name|e
decl_stmt|;
comment|/* Hash on the edge itself (which is a pointer).  */
return|return
name|htab_hash_pointer
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Equality routine for EDGE_TO_CASES, edges are unique, so testing    for equality is just a pointer comparison.  */
end_comment

begin_function
specifier|static
name|int
name|edge_to_cases_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|edge
name|e1
init|=
operator|(
operator|(
expr|struct
name|edge_to_cases_elt
operator|*
operator|)
name|p1
operator|)
operator|->
name|e
decl_stmt|;
name|edge
name|e2
init|=
operator|(
operator|(
expr|struct
name|edge_to_cases_elt
operator|*
operator|)
name|p2
operator|)
operator|->
name|e
decl_stmt|;
return|return
name|e1
operator|==
name|e2
return|;
block|}
end_function

begin_comment
comment|/* Called for each element in the hash table (P) as we delete the    edge to cases hash table.     Clear all the TREE_CHAINs to prevent problems with copying of    SWITCH_EXPRs and structure sharing rules, then free the hash table    element.  */
end_comment

begin_function
specifier|static
name|void
name|edge_to_cases_cleanup
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|edge_to_cases_elt
modifier|*
name|elt
init|=
operator|(
expr|struct
name|edge_to_cases_elt
operator|*
operator|)
name|p
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|t
operator|=
name|elt
operator|->
name|case_labels
init|;
name|t
condition|;
name|t
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start recording information mapping edges to case labels.  */
end_comment

begin_function
name|void
name|start_recording_case_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|edge_to_cases
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|edge_to_cases
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|edge_to_cases_hash
argument_list|,
name|edge_to_cases_eq
argument_list|,
name|edge_to_cases_cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if we are recording information for case labels.  */
end_comment

begin_function
specifier|static
name|bool
name|recording_case_labels_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|edge_to_cases
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stop recording information mapping edges to case labels and    remove any information we have recorded.  */
end_comment

begin_function
name|void
name|end_recording_case_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|edge_to_cases
argument_list|)
expr_stmt|;
name|edge_to_cases
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that CASE_LABEL (a CASE_LABEL_EXPR) references edge E.  */
end_comment

begin_function
specifier|static
name|void
name|record_switch_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|case_label
parameter_list|)
block|{
name|struct
name|edge_to_cases_elt
modifier|*
name|elt
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* Build a hash table element so we can see if E is already      in the table.  */
name|elt
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_to_cases_elt
argument_list|)
expr_stmt|;
name|elt
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|elt
operator|->
name|case_labels
operator|=
name|case_label
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|edge_to_cases
argument_list|,
name|elt
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
comment|/* E was not in the hash table.  Install E into the hash table.  */
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|elt
expr_stmt|;
block|}
else|else
block|{
comment|/* E was already in the hash table.  Free ELT as we do not need it 	 anymore.  */
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
comment|/* Get the entry stored in the hash table.  */
name|elt
operator|=
operator|(
expr|struct
name|edge_to_cases_elt
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
comment|/* Add it to the chain of CASE_LABEL_EXPRs referencing E.  */
name|TREE_CHAIN
argument_list|(
name|case_label
argument_list|)
operator|=
name|elt
operator|->
name|case_labels
expr_stmt|;
name|elt
operator|->
name|case_labels
operator|=
name|case_label
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If we are inside a {start,end}_recording_cases block, then return    a chain of CASE_LABEL_EXPRs from T which reference E.     Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|get_cases_for_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|struct
name|edge_to_cases_elt
name|elt
decl_stmt|,
modifier|*
name|elt_p
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|vec
decl_stmt|;
comment|/* If we are not recording cases, then we do not have CASE_LABEL_EXPR      chains available.  Return NULL so the caller can detect this case.  */
if|if
condition|(
operator|!
name|recording_case_labels_p
argument_list|()
condition|)
return|return
name|NULL
return|;
name|restart
label|:
name|elt
operator|.
name|e
operator|=
name|e
expr_stmt|;
name|elt
operator|.
name|case_labels
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|edge_to_cases
argument_list|,
operator|&
name|elt
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
block|{
name|elt_p
operator|=
operator|(
expr|struct
name|edge_to_cases_elt
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
return|return
name|elt_p
operator|->
name|case_labels
return|;
block|}
comment|/* If we did not find E in the hash table, then this must be the first      time we have been queried for information about E& T.  Add all the      elements from T to the hash table then perform the query again.  */
name|vec
operator|=
name|SWITCH_LABELS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|lab
init|=
name|CASE_LABEL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
name|label_bb
init|=
name|label_to_block
argument_list|(
name|lab
argument_list|)
decl_stmt|;
name|record_switch_edge
argument_list|(
name|find_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|label_bb
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
end_function

begin_comment
comment|/* Create the edges for a SWITCH_EXPR starting at block BB.    At this point, the switch body has been lowered and the    SWITCH_LABELS filled in, so this is in effect a multi-way branch.  */
end_comment

begin_function
specifier|static
name|void
name|make_switch_expr_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|entry
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|vec
decl_stmt|;
name|vec
operator|=
name|SWITCH_LABELS
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|lab
init|=
name|CASE_LABEL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
name|label_bb
init|=
name|label_to_block
argument_list|(
name|lab
argument_list|)
decl_stmt|;
name|make_edge
argument_list|(
name|bb
argument_list|,
name|label_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the basic block holding label DEST.  */
end_comment

begin_function
name|basic_block
name|label_to_block_fn
parameter_list|(
name|struct
name|function
modifier|*
name|ifun
parameter_list|,
name|tree
name|dest
parameter_list|)
block|{
name|int
name|uid
init|=
name|LABEL_DECL_UID
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* We would die hard when faced by an undefined label.  Emit a label to      the very first basic block.  This will hopefully make even the dataflow      and undefined variable warnings quite right.  */
if|if
condition|(
operator|(
name|errorcount
operator|||
name|sorrycount
operator|)
operator|&&
name|uid
operator|<
literal|0
condition|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_start
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|NUM_FIXED_BLOCKS
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|stmt
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|uid
operator|=
name|LABEL_DECL_UID
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|ifun
operator|->
name|cfg
operator|->
name|x_label_to_block_map
argument_list|)
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|uid
condition|)
return|return
name|NULL
return|;
return|return
name|VEC_index
argument_list|(
name|basic_block
argument_list|,
name|ifun
operator|->
name|cfg
operator|->
name|x_label_to_block_map
argument_list|,
name|uid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create edges for an abnormal goto statement at block BB.  If FOR_CALL    is true, the source statement is a CALL_EXPR instead of a GOTO_EXPR.  */
end_comment

begin_function
name|void
name|make_abnormal_goto_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bool
name|for_call
parameter_list|)
block|{
name|basic_block
name|target_bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|target_bb
argument_list|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|target_bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|target
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
break|break;
name|target
operator|=
name|LABEL_EXPR_LABEL
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* Make an edge to every label block that has been marked as a 	   potential target for a computed goto or a non-local goto.  */
if|if
condition|(
operator|(
name|FORCED_LABEL
argument_list|(
name|target
argument_list|)
operator|&&
operator|!
name|for_call
operator|)
operator|||
operator|(
name|DECL_NONLOCAL
argument_list|(
name|target
argument_list|)
operator|&&
name|for_call
operator|)
condition|)
block|{
name|make_edge
argument_list|(
name|bb
argument_list|,
name|target_bb
argument_list|,
name|EDGE_ABNORMAL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create edges for a goto statement at block BB.  */
end_comment

begin_function
specifier|static
name|void
name|make_goto_expr_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|last
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|tree
name|goto_t
init|=
name|bsi_stmt
argument_list|(
name|last
argument_list|)
decl_stmt|;
comment|/* A simple GOTO creates normal edges.  */
if|if
condition|(
name|simple_goto_p
argument_list|(
name|goto_t
argument_list|)
condition|)
block|{
name|tree
name|dest
init|=
name|GOTO_DESTINATION
argument_list|(
name|goto_t
argument_list|)
decl_stmt|;
name|edge
name|e
init|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|label_to_block
argument_list|(
name|dest
argument_list|)
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|e
operator|->
name|goto_locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|goto_t
argument_list|)
expr_stmt|;
else|#
directive|else
name|e
operator|->
name|goto_locus
operator|=
name|EXPR_LOCUS
argument_list|(
name|goto_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsi_remove
argument_list|(
operator|&
name|last
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* A computed GOTO creates abnormal edges.  */
name|make_abnormal_goto_edges
argument_list|(
name|bb
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 			       Flowgraph analysis ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Cleanup useless labels in basic blocks.  This is something we wish    to do early because it allows us to group case labels before creating    the edges for the CFG, and it speeds up block statement iterators in    all passes later on.    We only run this pass once, running it more than once is probably not    profitable.  */
end_comment

begin_comment
comment|/* A map from basic block index to the leading label of that block.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|label_for_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback for for_each_eh_region.  Helper for cleanup_dead_labels.  */
end_comment

begin_function
specifier|static
name|void
name|update_eh_label
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|)
block|{
name|tree
name|old_label
init|=
name|get_eh_region_tree_label
argument_list|(
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_label
condition|)
block|{
name|tree
name|new_label
decl_stmt|;
name|basic_block
name|bb
init|=
name|label_to_block
argument_list|(
name|old_label
argument_list|)
decl_stmt|;
comment|/* ??? After optimizing, there may be EH regions with labels 	 that have already been removed from the function body, so 	 there is no basic block for them.  */
if|if
condition|(
operator|!
name|bb
condition|)
return|return;
name|new_label
operator|=
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
name|set_eh_region_tree_label
argument_list|(
name|region
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given LABEL return the first label in the same basic block.  */
end_comment

begin_function
specifier|static
name|tree
name|main_block_label
parameter_list|(
name|tree
name|label
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|label_to_block
argument_list|(
name|label
argument_list|)
decl_stmt|;
comment|/* label_to_block possibly inserted undefined label into the chain.  */
if|if
condition|(
operator|!
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
condition|)
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|label
expr_stmt|;
return|return
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Cleanup redundant labels.  This is a three-step process:      1) Find the leading label for each block.      2) Redirect all references to labels to the leading labels.      3) Cleanup all useless labels.  */
end_comment

begin_function
name|void
name|cleanup_dead_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|label_for_bb
operator|=
name|XCNEWVEC
argument_list|(
name|tree
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* Find a suitable label for each block.  We use the first user-defined      label if there is one, or otherwise just the first label we see.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|label
decl_stmt|,
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
break|break;
name|label
operator|=
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If we have not yet seen a label for the current block, 	     remember this one and see if there are more labels.  */
if|if
condition|(
operator|!
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
condition|)
block|{
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|label
expr_stmt|;
continue|continue;
block|}
comment|/* If we did see a label for the current block already, but it 	     is an artificially created label, replace it if the current 	     label is a user defined label.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|label
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
condition|)
block|{
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|label
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now redirect all jumps/branches to the selected label.      First do so for each block ending in a control statement.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stmt
condition|)
continue|continue;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
block|{
name|tree
name|true_branch
decl_stmt|,
name|false_branch
decl_stmt|;
name|true_branch
operator|=
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|false_branch
operator|=
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|GOTO_DESTINATION
argument_list|(
name|true_branch
argument_list|)
operator|=
name|main_block_label
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|true_branch
argument_list|)
argument_list|)
expr_stmt|;
name|GOTO_DESTINATION
argument_list|(
name|false_branch
argument_list|)
operator|=
name|main_block_label
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|false_branch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SWITCH_EXPR
case|:
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|vec
init|=
name|SWITCH_LABELS
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|size_t
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
decl_stmt|;
comment|/* Replace all destination labels.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|label
init|=
name|main_block_label
argument_list|(
name|CASE_LABEL
argument_list|(
name|elt
argument_list|)
argument_list|)
decl_stmt|;
name|CASE_LABEL
argument_list|(
name|elt
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
break|break;
block|}
comment|/* We have to handle GOTO_EXPRs until they're removed, and we don't 	   remove them until after we've created the CFG edges.  */
case|case
name|GOTO_EXPR
case|:
if|if
condition|(
operator|!
name|computed_goto_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
operator|=
name|main_block_label
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
name|for_each_eh_region
argument_list|(
name|update_eh_label
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
comment|/* Finally, purge dead labels.  All user-defined labels, labels that      can be the target of non-local gotos, labels which have their      address taken and labels which have attributes or alignment are      preserved.  */
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
name|tree
name|label_for_this_bb
init|=
name|label_for_bb
index|[
name|bb
operator|->
name|index
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|label_for_this_bb
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
control|)
block|{
name|tree
name|label
decl_stmt|,
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
break|break;
name|label
operator|=
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|label_for_this_bb
operator|||
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|label
argument_list|)
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
expr|\
operator|||
name|DECL_ATTRIBUTES
argument_list|(
name|label
argument_list|)
operator|||
name|DECL_USER_ALIGN
argument_list|(
name|label
argument_list|)
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
expr|\
operator|||
name|DECL_NONLOCAL
argument_list|(
name|label
argument_list|)
operator|||
name|FORCED_LABEL
argument_list|(
name|label
argument_list|)
condition|)
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
else|else
name|bsi_remove
argument_list|(
operator|&
name|i
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|label_for_bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for blocks ending in a multiway branch (a SWITCH_EXPR in GIMPLE),    and scan the sorted vector of cases.  Combine the ones jumping to the    same label.    Eg. three separate entries 1: 2: 3: become one entry 1..3:  */
end_comment

begin_function
name|void
name|group_case_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
name|tree
name|labels
init|=
name|SWITCH_LABELS
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|int
name|old_size
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|new_size
init|=
name|old_size
decl_stmt|;
name|tree
name|default_case
init|=
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|old_size
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tree
name|default_label
decl_stmt|;
comment|/* The default label is always the last case in a switch 	     statement after gimplification.  */
name|default_label
operator|=
name|CASE_LABEL
argument_list|(
name|default_case
argument_list|)
expr_stmt|;
comment|/* Look for possible opportunities to merge cases. 	     Ignore the last element of the label vector because it 	     must be the default case.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|old_size
operator|-
literal|1
condition|)
block|{
name|tree
name|base_case
decl_stmt|,
name|base_label
decl_stmt|,
name|base_high
decl_stmt|;
name|base_case
operator|=
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|base_case
argument_list|)
expr_stmt|;
name|base_label
operator|=
name|CASE_LABEL
argument_list|(
name|base_case
argument_list|)
expr_stmt|;
comment|/* Discard cases that have the same destination as the 		 default case.  */
if|if
condition|(
name|base_label
operator|==
name|default_label
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|new_size
operator|--
expr_stmt|;
continue|continue;
block|}
name|base_high
operator|=
name|CASE_HIGH
argument_list|(
name|base_case
argument_list|)
condition|?
name|CASE_HIGH
argument_list|(
name|base_case
argument_list|)
else|:
name|CASE_LOW
argument_list|(
name|base_case
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* Try to merge case labels.  Break out when we reach the end 		 of the label vector or when we cannot merge the next case 		 label with the current one.  */
while|while
condition|(
name|i
operator|<
name|old_size
operator|-
literal|1
condition|)
block|{
name|tree
name|merge_case
init|=
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|merge_label
init|=
name|CASE_LABEL
argument_list|(
name|merge_case
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|base_high
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Merge the cases if they jump to the same place, 		     and their ranges are consecutive.  */
if|if
condition|(
name|merge_label
operator|==
name|base_label
operator|&&
name|tree_int_cst_equal
argument_list|(
name|CASE_LOW
argument_list|(
name|merge_case
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|base_high
operator|=
name|CASE_HIGH
argument_list|(
name|merge_case
argument_list|)
condition|?
name|CASE_HIGH
argument_list|(
name|merge_case
argument_list|)
else|:
name|CASE_LOW
argument_list|(
name|merge_case
argument_list|)
expr_stmt|;
name|CASE_HIGH
argument_list|(
name|base_case
argument_list|)
operator|=
name|base_high
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|new_size
operator|--
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
comment|/* Compress the case labels in the label vector, and adjust the 	     length of the vector.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|new_size
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|j
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_LENGTH
argument_list|(
name|labels
argument_list|)
operator|=
name|new_size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Checks whether we can merge block B into block A.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_can_merge_blocks_p
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|a
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|single_succ_edge
argument_list|(
name|a
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|single_succ
argument_list|(
name|a
argument_list|)
operator|!=
name|b
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|b
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
comment|/* If A ends by a statement causing exceptions or something similar, we      cannot merge the blocks.  */
name|stmt
operator|=
name|last_stmt
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Do not allow a block with only a non-local label to be merged.  */
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* It must be possible to eliminate all phi nodes in B.  If ssa form      is not up-to-date, we cannot eliminate any phis.  */
name|phi
operator|=
name|phi_nodes
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|phi
condition|)
block|{
if|if
condition|(
name|need_ssa_update_p
argument_list|()
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_propagate_copy
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Do not remove user labels.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|b
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
break|break;
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Protect the loop latches.  */
if|if
condition|(
name|current_loops
operator|&&
name|b
operator|->
name|loop_father
operator|->
name|latch
operator|==
name|b
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Replaces all uses of NAME by VAL.  */
end_comment

begin_function
name|void
name|replace_uses_by
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|FOR_EACH_IMM_USE_STMT
argument_list|(
argument|stmt
argument_list|,
argument|imm_iter
argument_list|,
argument|name
argument_list|)
block|{
name|FOR_EACH_IMM_USE_ON_STMT
argument_list|(
argument|use
argument_list|,
argument|imm_iter
argument_list|)
block|{
name|replace_exp
argument_list|(
name|use
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|e
operator|=
name|PHI_ARG_EDGE
argument_list|(
name|stmt
argument_list|,
name|PHI_ARG_INDEX_FROM_USE
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
comment|/* This can only occur for virtual operands, since 		     for the real ones SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name)) 		     would prevent replacement.  */
name|gcc_assert
argument_list|(
operator|!
name|is_gimple_reg
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
condition|)
block|{
name|tree
name|rhs
decl_stmt|;
name|fold_stmt_inplace
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|mark_new_vars_to_rename
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|num_imm_uses
argument_list|(
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Also update the trees stored in loop structures.  */
if|if
condition|(
name|current_loops
condition|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|current_loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|substitute_in_loop_info
argument_list|(
name|loop
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge block B into block A.  */
end_comment

begin_function
specifier|static
name|void
name|tree_merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree_stmt_iterator
name|last
decl_stmt|;
name|tree
name|phi
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Merging blocks %d and %d\n"
argument_list|,
name|a
operator|->
name|index
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Remove all single-valued PHI nodes from block B of the form      V_i = PHI<V_j> by propagating V_j to all the uses of V_i.  */
name|bsi
operator|=
name|bsi_last
argument_list|(
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|b
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|phi_nodes
argument_list|(
name|b
argument_list|)
control|)
block|{
name|tree
name|def
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|,
name|use
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|copy
decl_stmt|;
name|bool
name|may_replace_uses
init|=
name|may_propagate_copy
argument_list|(
name|def
argument_list|,
name|use
argument_list|)
decl_stmt|;
comment|/* In case we have loops to care about, do not propagate arguments of 	 loop closed ssa phi nodes.  */
if|if
condition|(
name|current_loops
operator|&&
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|use
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|a
operator|->
name|loop_father
operator|!=
name|b
operator|->
name|loop_father
condition|)
name|may_replace_uses
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|may_replace_uses
condition|)
block|{
name|gcc_assert
argument_list|(
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that just emitting the copies is fine -- there is no problem 	     with ordering of phi nodes.  This is because A is the single 	     predecessor of B, therefore results of the phi nodes cannot 	     appear as arguments of the phi nodes.  */
name|copy
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|def
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|copy
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|SET_PHI_RESULT
argument_list|(
name|phi
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|def
argument_list|)
operator|=
name|copy
expr_stmt|;
block|}
else|else
name|replace_uses_by
argument_list|(
name|def
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|remove_phi_node
argument_list|(
name|phi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure that B follows A.  */
name|move_block_after
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|single_succ_edge
argument_list|(
name|a
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|last_stmt
argument_list|(
name|a
argument_list|)
operator|||
operator|!
name|stmt_ends_bb_p
argument_list|(
name|last_stmt
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove labels from B and set bb_for_stmt to A for other statements.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|b
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|tree
name|label
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Now that we can thread computed gotos, we might have 	     a situation where we have a forced label in block B 	     However, the label at the start of block B might still be 	     used in other ways (think about the runtime checking for 	     Fortran assigned gotos).  So we can not just delete the 	     label.  Instead we move the label to the start of block A.  */
if|if
condition|(
name|FORCED_LABEL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
block|{
name|block_stmt_iterator
name|dest_bsi
init|=
name|bsi_start
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|dest_bsi
argument_list|,
name|label
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|change_bb_for_stmt
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Merge the chains.  */
name|last
operator|=
name|tsi_last
argument_list|(
name|a
operator|->
name|stmt_list
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|last
argument_list|,
name|b
operator|->
name|stmt_list
argument_list|,
name|TSI_NEW_STMT
argument_list|)
expr_stmt|;
name|b
operator|->
name|stmt_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the one of two successors of BB that is not reachable by a    reached by a complex edge, if there is one.  Else, return BB.  We use    this in optimizations that use post-dominators for their heuristics,    to catch the cases in C++ where function calls are involved.  */
end_comment

begin_function
name|basic_block
name|single_noncomplex_succ
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e0
decl_stmt|,
name|e1
decl_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|bb
return|;
name|e0
operator|=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1
operator|=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e0
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
return|return
name|e1
operator|->
name|dest
return|;
if|if
condition|(
name|e1
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
return|return
name|e0
operator|->
name|dest
return|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Walk the function tree removing unnecessary statements.       * Empty statement nodes are removed       * Unnecessary TRY_FINALLY and TRY_CATCH blocks are removed       * Unnecessary COND_EXPRs are removed       * Some unnecessary BIND_EXPRs are removed     Clearly more work could be done.  The trick is doing the analysis    and removal fast enough to be a net improvement in compile times.     Note that when we remove a control structure such as a COND_EXPR    BIND_EXPR, or TRY block, we will need to repeat this optimization pass    to ensure we eliminate all the useless code.  */
end_comment

begin_struct
struct|struct
name|rus_data
block|{
name|tree
modifier|*
name|last_goto
decl_stmt|;
name|bool
name|repeat
decl_stmt|;
name|bool
name|may_throw
decl_stmt|;
name|bool
name|may_branch
decl_stmt|;
name|bool
name|has_label
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|remove_useless_stmts_1
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|struct
name|rus_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bool
name|remove_useless_stmts_warn_notreached
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|location_t
name|loc
init|=
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOCATION_LINE
argument_list|(
name|loc
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hwill never be executed"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|stmt
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
if|if
condition|(
name|remove_useless_stmts_warn_notreached
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|remove_useless_stmts_warn_notreached
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|remove_useless_stmts_warn_notreached
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|remove_useless_stmts_warn_notreached
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
if|if
condition|(
name|remove_useless_stmts_warn_notreached
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|remove_useless_stmts_warn_notreached
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
case|case
name|CATCH_EXPR
case|:
return|return
name|remove_useless_stmts_warn_notreached
argument_list|(
name|CATCH_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
case|case
name|EH_FILTER_EXPR
case|:
return|return
name|remove_useless_stmts_warn_notreached
argument_list|(
name|EH_FILTER_FAILURE
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
return|return
name|remove_useless_stmts_warn_notreached
argument_list|(
name|BIND_EXPR_BLOCK
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
default|default:
comment|/* Not a live container.  */
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_useless_stmts_cond
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|struct
name|rus_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|then_clause
decl_stmt|,
name|else_clause
decl_stmt|,
name|cond
decl_stmt|;
name|bool
name|save_has_label
decl_stmt|,
name|then_has_label
decl_stmt|,
name|else_has_label
decl_stmt|;
name|save_has_label
operator|=
name|data
operator|->
name|has_label
expr_stmt|;
name|data
operator|->
name|has_label
operator|=
name|false
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|COND_EXPR_THEN
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|then_has_label
operator|=
name|data
operator|->
name|has_label
expr_stmt|;
name|data
operator|->
name|has_label
operator|=
name|false
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|COND_EXPR_ELSE
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|else_has_label
operator|=
name|data
operator|->
name|has_label
expr_stmt|;
name|data
operator|->
name|has_label
operator|=
name|save_has_label
operator||
name|then_has_label
operator||
name|else_has_label
expr_stmt|;
name|then_clause
operator|=
name|COND_EXPR_THEN
argument_list|(
operator|*
name|stmt_p
argument_list|)
expr_stmt|;
name|else_clause
operator|=
name|COND_EXPR_ELSE
argument_list|(
operator|*
name|stmt_p
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|COND_EXPR_COND
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If neither arm does anything at all, we can remove the whole IF.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|then_clause
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|else_clause
argument_list|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
comment|/* If there are no reachable statements in an arm, then we can      zap the entire conditional.  */
elseif|else
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
operator|&&
operator|!
name|else_has_label
condition|)
block|{
if|if
condition|(
name|warn_notreached
condition|)
name|remove_useless_stmts_warn_notreached
argument_list|(
name|else_clause
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|then_clause
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|cond
argument_list|)
operator|&&
operator|!
name|then_has_label
condition|)
block|{
if|if
condition|(
name|warn_notreached
condition|)
name|remove_useless_stmts_warn_notreached
argument_list|(
name|then_clause
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|else_clause
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
comment|/* Check a couple of simple things on then/else with single stmts.  */
else|else
block|{
name|tree
name|then_stmt
init|=
name|expr_only
argument_list|(
name|then_clause
argument_list|)
decl_stmt|;
name|tree
name|else_stmt
init|=
name|expr_only
argument_list|(
name|else_clause
argument_list|)
decl_stmt|;
comment|/* Notice branches to a common destination.  */
if|if
condition|(
name|then_stmt
operator|&&
name|else_stmt
operator|&&
name|TREE_CODE
argument_list|(
name|then_stmt
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|else_stmt
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
operator|(
name|GOTO_DESTINATION
argument_list|(
name|then_stmt
argument_list|)
operator|==
name|GOTO_DESTINATION
argument_list|(
name|else_stmt
argument_list|)
operator|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|then_stmt
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the THEN/ELSE clause merely assigns a value to a variable or 	 parameter which is already known to contain that value, then 	 remove the useless THEN/ELSE clause.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|else_stmt
operator|&&
name|TREE_CODE
argument_list|(
name|else_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|else_stmt
argument_list|,
literal|0
argument_list|)
operator|==
name|cond
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|else_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|COND_EXPR_ELSE
argument_list|(
operator|*
name|stmt_p
argument_list|)
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|stmt
init|=
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|?
name|then_stmt
else|:
name|else_stmt
operator|)
decl_stmt|;
name|tree
modifier|*
name|location
init|=
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|?
operator|&
name|COND_EXPR_THEN
argument_list|(
operator|*
name|stmt_p
argument_list|)
else|:
operator|&
name|COND_EXPR_ELSE
argument_list|(
operator|*
name|stmt_p
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
condition|)
operator|*
name|location
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Protect GOTOs in the arm of COND_EXPRs from being removed.  They      would be re-introduced during lowering.  */
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_useless_stmts_tf
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|struct
name|rus_data
modifier|*
name|data
parameter_list|)
block|{
name|bool
name|save_may_branch
decl_stmt|,
name|save_may_throw
decl_stmt|;
name|bool
name|this_may_branch
decl_stmt|,
name|this_may_throw
decl_stmt|;
comment|/* Collect may_branch and may_throw information for the body only.  */
name|save_may_branch
operator|=
name|data
operator|->
name|may_branch
expr_stmt|;
name|save_may_throw
operator|=
name|data
operator|->
name|may_throw
expr_stmt|;
name|data
operator|->
name|may_branch
operator|=
name|false
expr_stmt|;
name|data
operator|->
name|may_throw
operator|=
name|false
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|this_may_branch
operator|=
name|data
operator|->
name|may_branch
expr_stmt|;
name|this_may_throw
operator|=
name|data
operator|->
name|may_throw
expr_stmt|;
name|data
operator|->
name|may_branch
operator||=
name|save_may_branch
expr_stmt|;
name|data
operator|->
name|may_throw
operator||=
name|save_may_throw
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If the body is empty, then we can emit the FINALLY block without      the enclosing TRY_FINALLY_EXPR.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the handler is empty, then we can emit the TRY block without      the enclosing TRY_FINALLY_EXPR.  */
elseif|else
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the body neither throws, nor branches, then we can safely      string the TRY and FINALLY blocks together.  */
elseif|else
if|if
condition|(
operator|!
name|this_may_branch
operator|&&
operator|!
name|this_may_throw
condition|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
operator|*
name|stmt_p
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_useless_stmts_tc
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|struct
name|rus_data
modifier|*
name|data
parameter_list|)
block|{
name|bool
name|save_may_throw
decl_stmt|,
name|this_may_throw
decl_stmt|;
name|tree_stmt_iterator
name|i
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
comment|/* Collect may_throw information for the body only.  */
name|save_may_throw
operator|=
name|data
operator|->
name|may_throw
expr_stmt|;
name|data
operator|->
name|may_throw
operator|=
name|false
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|this_may_throw
operator|=
name|data
operator|->
name|may_throw
expr_stmt|;
name|data
operator|->
name|may_throw
operator|=
name|save_may_throw
expr_stmt|;
comment|/* If the body cannot throw, then we can drop the entire TRY_CATCH_EXPR.  */
if|if
condition|(
operator|!
name|this_may_throw
condition|)
block|{
if|if
condition|(
name|warn_notreached
condition|)
name|remove_useless_stmts_warn_notreached
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
return|return;
block|}
comment|/* Process the catch clause specially.  We may be able to tell that      no exceptions propagate past this point.  */
name|this_may_throw
operator|=
name|true
expr_stmt|;
name|i
operator|=
name|tsi_start
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|CATCH_EXPR
case|:
for|for
control|(
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|stmt
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* If we catch all exceptions, then the body does not 	     propagate exceptions past this point.  */
if|if
condition|(
name|CATCH_TYPES
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL
condition|)
name|this_may_throw
operator|=
name|false
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|CATCH_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EH_FILTER_EXPR
case|:
if|if
condition|(
name|EH_FILTER_MUST_NOT_THROW
argument_list|(
name|stmt
argument_list|)
condition|)
name|this_may_throw
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|EH_FILTER_TYPES
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL
condition|)
name|this_may_throw
operator|=
name|false
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|EH_FILTER_FAILURE
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Otherwise this is a cleanup.  */
name|remove_useless_stmts_1
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If the cleanup is empty, then we can emit the TRY block without 	 the enclosing TRY_CATCH_EXPR.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|stmt_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
break|break;
block|}
name|data
operator|->
name|may_throw
operator||=
name|this_may_throw
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_useless_stmts_bind
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|struct
name|rus_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|block
decl_stmt|;
comment|/* First remove anything underneath the BIND_EXPR.  */
name|remove_useless_stmts_1
argument_list|(
operator|&
name|BIND_EXPR_BODY
argument_list|(
operator|*
name|stmt_p
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If the BIND_EXPR has no variables, then we can pull everything      up one level and remove the BIND_EXPR, unless this is the toplevel      BIND_EXPR for the current function or an inlined function.       When this situation occurs we will want to apply this      optimization again.  */
name|block
operator|=
name|BIND_EXPR_BLOCK
argument_list|(
operator|*
name|stmt_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|BIND_EXPR_VARS
argument_list|(
operator|*
name|stmt_p
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|*
name|stmt_p
operator|!=
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|(
operator|!
name|block
operator|||
operator|!
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|)
operator|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|BIND_EXPR_BODY
argument_list|(
operator|*
name|stmt_p
argument_list|)
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_useless_stmts_goto
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|struct
name|rus_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|dest
init|=
name|GOTO_DESTINATION
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|data
operator|->
name|may_branch
operator|=
name|true
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
comment|/* Record the last goto expr, so that we can delete it if unnecessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|data
operator|->
name|last_goto
operator|=
name|stmt_p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_useless_stmts_label
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|struct
name|rus_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|label
init|=
name|LABEL_EXPR_LABEL
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|data
operator|->
name|has_label
operator|=
name|true
expr_stmt|;
comment|/* We do want to jump across non-local label receiver code.  */
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|label
argument_list|)
condition|)
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|data
operator|->
name|last_goto
operator|&&
name|GOTO_DESTINATION
argument_list|(
operator|*
name|data
operator|->
name|last_goto
argument_list|)
operator|==
name|label
condition|)
block|{
operator|*
name|data
operator|->
name|last_goto
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
name|data
operator|->
name|repeat
operator|=
name|true
expr_stmt|;
block|}
comment|/* ??? Add something here to delete unused labels.  */
block|}
end_function

begin_comment
comment|/* If the function is "const" or "pure", then clear TREE_SIDE_EFFECTS on its    decl.  This allows us to eliminate redundant or useless    calls to "const" functions.     Gimplifier already does the same operation, but we may notice functions    being const and pure once their calls has been gimplified, so we need    to update the flag.  */
end_comment

begin_function
specifier|static
name|void
name|update_call_expr_flags
parameter_list|(
name|tree
name|call
parameter_list|)
block|{
name|tree
name|decl
init|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return;
if|if
condition|(
name|call_expr_flags
argument_list|(
name|call
argument_list|)
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|call
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_NOTHROW
argument_list|(
name|call
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* T is CALL_EXPR.  Set current_function_calls_* flags.  */
end_comment

begin_function
name|void
name|notice_special_calls
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|flags
init|=
name|call_expr_flags
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_MAY_BE_ALLOCA
condition|)
name|current_function_calls_alloca
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_RETURNS_TWICE
condition|)
name|current_function_calls_setjmp
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear flags set by notice_special_calls.  Used by dead code removal    to update the flags.  */
end_comment

begin_function
name|void
name|clear_special_calls
parameter_list|(
name|void
parameter_list|)
block|{
name|current_function_calls_alloca
operator|=
name|false
expr_stmt|;
name|current_function_calls_setjmp
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_useless_stmts_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|struct
name|rus_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|,
name|op
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|remove_useless_stmts_cond
argument_list|(
name|tp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
name|remove_useless_stmts_tf
argument_list|(
name|tp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_CATCH_EXPR
case|:
name|remove_useless_stmts_tc
argument_list|(
name|tp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
name|remove_useless_stmts_bind
argument_list|(
name|tp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
name|remove_useless_stmts_goto
argument_list|(
name|tp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
name|remove_useless_stmts_label
argument_list|(
name|tp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
name|fold_stmt
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|may_branch
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|fold_stmt
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|notice_special_calls
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|update_call_expr_flags
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_could_throw_p
argument_list|(
name|t
argument_list|)
condition|)
name|data
operator|->
name|may_throw
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
name|fold_stmt
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|op
operator|=
name|get_call_expr_in
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
condition|)
block|{
name|update_call_expr_flags
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|notice_special_calls
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_could_throw_p
argument_list|(
name|t
argument_list|)
condition|)
name|data
operator|->
name|may_throw
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|i
init|=
name|tsi_start
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|t
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tsi_delink
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|remove_useless_stmts_1
argument_list|(
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|t
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|tsi_link_before
argument_list|(
operator|&
name|i
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ASM_EXPR
case|:
name|fold_stmt
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|data
operator|->
name|last_goto
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|remove_useless_stmts
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|rus_data
name|data
decl_stmt|;
name|clear_special_calls
argument_list|()
expr_stmt|;
do|do
block|{
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|remove_useless_stmts_1
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|data
operator|.
name|repeat
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_remove_useless_stmts
init|=
block|{
literal|"useless"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|remove_useless_stmts
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_gimple_any
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove PHI nodes associated with basic block BB and all edges out of BB.  */
end_comment

begin_function
specifier|static
name|void
name|remove_phi_nodes_and_edges_for_unreachable_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
comment|/* Since this block is no longer reachable, we can just delete all      of its PHI nodes.  */
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
name|phi
condition|)
block|{
name|tree
name|next
init|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|remove_phi_node
argument_list|(
name|phi
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|phi
operator|=
name|next
expr_stmt|;
block|}
comment|/* Remove edges to BB's successors.  */
while|while
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
name|remove_edge
argument_list|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove statements of basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|remove_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|source_location
name|loc
init|=
name|UNKNOWN_LOCATION
decl_stmt|;
else|#
directive|else
name|source_locus
name|loc
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Removing basic block %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_flags
operator|&
name|TDF_DETAILS
condition|)
block|{
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|dump_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we remove the header or the latch of a loop, mark the loop for      removal by setting its header and latch to NULL.  */
if|if
condition|(
name|current_loops
condition|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|bb
operator|->
name|loop_father
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|==
name|bb
operator|||
name|loop
operator|->
name|header
operator|==
name|bb
condition|)
block|{
name|loop
operator|->
name|latch
operator|=
name|NULL
expr_stmt|;
name|loop
operator|->
name|header
operator|=
name|NULL
expr_stmt|;
comment|/* Also clean up the information associated with the loop.  Updating 	     it would waste time. More importantly, it may refer to ssa 	     names that were defined in other removed basic block -- these 	     ssa names are now removed and invalid.  */
name|free_numbers_of_iterations_estimates_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove all the instructions in the block.  */
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
operator|&&
operator|(
name|FORCED_LABEL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|||
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
name|block_stmt_iterator
name|new_bsi
decl_stmt|;
comment|/* A non-reachable non-local label may still be referenced. 	     But it no longer needs to carry the extra semantics of 	     non-locality.  */
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FORCED_LABEL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|new_bb
operator|=
name|bb
operator|->
name|prev_bb
expr_stmt|;
name|new_bsi
operator|=
name|bsi_start
argument_list|(
name|new_bb
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|new_bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Release SSA definitions if we are in SSA.  Note that we 	     may be called when not in SSA.  For example, 	     final_cleanup calls this function via 	     cleanup_tree_cfg.  */
if|if
condition|(
name|in_ssa_p
condition|)
name|release_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|i
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Don't warn for removed gotos.  Gotos are often removed due to 	 jump threading, thus resulting in bogus warnings.  Not great, 	 since this way we lose warnings for gotos in the original 	 program that are indeed unreachable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|GOTO_EXPR
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
operator|&&
operator|!
name|loc
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|loc
operator|=
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|source_locus
name|t
decl_stmt|;
name|t
operator|=
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|LOCATION_LINE
argument_list|(
operator|*
name|t
argument_list|)
operator|>
literal|0
condition|)
name|loc
operator|=
name|t
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* If requested, give a warning that the first statement in the      block is unreachable.  We walk statements backwards in the      loop above, so the last statement we process is the first statement      in the block.  */
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
if|if
condition|(
name|loc
operator|>
name|BUILTINS_LOCATION
condition|)
name|warning
argument_list|(
name|OPT_Wunreachable_code
argument_list|,
literal|"%Hwill never be executed"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|loc
condition|)
name|warning
argument_list|(
name|OPT_Wunreachable_code
argument_list|,
literal|"%Hwill never be executed"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|remove_phi_nodes_and_edges_for_unreachable_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a basic block BB ending with COND_EXPR or SWITCH_EXPR, and a    predicate VAL, return the edge that will be taken out of the block.    If VAL does not match a unique edge, NULL is returned.  */
end_comment

begin_function
name|edge
name|find_taken_edge
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|stmt
operator|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|is_ctrl_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|find_taken_edge_cond_expr
argument_list|(
name|bb
argument_list|,
name|val
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
return|return
name|find_taken_edge_switch_expr
argument_list|(
name|bb
argument_list|,
name|val
argument_list|)
return|;
if|if
condition|(
name|computed_goto_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* Only optimize if the argument is a label, if the argument is 	 not a label then we can not construct a proper CFG.           It may be the case that we only need to allow the LABEL_REF to          appear inside an ADDR_EXPR, but we also allow the LABEL_REF to          appear inside a LABEL_EXPR just to be safe.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|LABEL_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
return|return
name|find_taken_edge_computed_goto
argument_list|(
name|bb
argument_list|,
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a constant value VAL and the entry block BB to a GOTO_EXPR    statement, determine which of the outgoing edges will be taken out of the    block.  Return NULL if either edge may be taken.  */
end_comment

begin_function
specifier|static
name|edge
name|find_taken_edge_computed_goto
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|basic_block
name|dest
decl_stmt|;
name|edge
name|e
init|=
name|NULL
decl_stmt|;
name|dest
operator|=
name|label_to_block
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
condition|)
block|{
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Given a constant value VAL and the entry block BB to a COND_EXPR    statement, determine which of the two edges will be taken out of the    block.  Return NULL if either edge may be taken.  */
end_comment

begin_function
specifier|static
name|edge
name|find_taken_edge_cond_expr
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|edge
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|;
name|extract_true_false_edges_from_block
argument_list|(
name|bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
return|return
operator|(
name|zero_p
argument_list|(
name|val
argument_list|)
condition|?
name|false_edge
else|:
name|true_edge
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an INTEGER_CST VAL and the entry block BB to a SWITCH_EXPR    statement, determine which edge will be taken out of the block.  Return    NULL if any edge may be taken.  */
end_comment

begin_function
specifier|static
name|edge
name|find_taken_edge_switch_expr
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|tree
name|switch_expr
decl_stmt|,
name|taken_case
decl_stmt|;
name|basic_block
name|dest_bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|switch_expr
operator|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|taken_case
operator|=
name|find_case_label_for_value
argument_list|(
name|switch_expr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|dest_bb
operator|=
name|label_to_block
argument_list|(
name|CASE_LABEL
argument_list|(
name|taken_case
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|dest_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Return the CASE_LABEL_EXPR that SWITCH_EXPR will take for VAL.    We can make optimal use here of the fact that the case labels are    sorted: We can do a binary search for a case matching VAL.  */
end_comment

begin_function
specifier|static
name|tree
name|find_case_label_for_value
parameter_list|(
name|tree
name|switch_expr
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|tree
name|vec
init|=
name|SWITCH_LABELS
argument_list|(
name|switch_expr
argument_list|)
decl_stmt|;
name|size_t
name|low
decl_stmt|,
name|high
decl_stmt|,
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
decl_stmt|;
name|tree
name|default_case
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|n
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|low
operator|=
operator|-
literal|1
operator|,
name|high
operator|=
name|n
operator|-
literal|1
init|;
name|high
operator|-
name|low
operator|>
literal|1
condition|;
control|)
block|{
name|size_t
name|i
init|=
operator|(
name|high
operator|+
name|low
operator|)
operator|/
literal|2
decl_stmt|;
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|cmp
decl_stmt|;
comment|/* Cache the result of comparing CASE_LOW and val.  */
name|cmp
operator|=
name|tree_int_cst_compare
argument_list|(
name|CASE_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|high
operator|=
name|i
expr_stmt|;
else|else
name|low
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* A singe-valued case label.  */
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
name|t
return|;
block|}
else|else
block|{
comment|/* A case range.  We can only handle integer ranges.  */
if|if
condition|(
name|cmp
operator|<=
literal|0
operator|&&
name|tree_int_cst_compare
argument_list|(
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
name|default_case
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 			      Debugging functions ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Dump tree-specific information of block BB to file OUTF.  */
end_comment

begin_function
name|void
name|tree_dump_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|FILE
modifier|*
name|outf
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|dump_generic_bb
argument_list|(
name|outf
argument_list|,
name|bb
argument_list|,
name|indent
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a basic block on stderr.  */
end_comment

begin_function
name|void
name|debug_tree_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump basic block with index N on stderr.  */
end_comment

begin_function
name|basic_block
name|debug_tree_bb_n
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|debug_tree_bb
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BASIC_BLOCK
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Dump the CFG on stderr.     FLAGS are the same used by the tree dumping functions    (see TDF_* in tree-pass.h).  */
end_comment

begin_function
name|void
name|debug_tree_cfg
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|dump_tree_cfg
argument_list|(
name|stderr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the program showing basic block boundaries on the given FILE.     FLAGS are the same used by the tree dumping functions (see TDF_* in    tree.h).  */
end_comment

begin_function
name|void
name|dump_tree_cfg
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|TDF_DETAILS
condition|)
block|{
specifier|const
name|char
modifier|*
name|funcname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Function %s\n\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; \n%d basic blocks, %d edges, last basic block %d.\n\n"
argument_list|,
name|n_basic_blocks
argument_list|,
name|n_edges
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|brief_dump_cfg
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TDF_STATS
condition|)
name|dump_cfg_stats
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|dump_function_to_file
argument_list|(
name|current_function_decl
argument_list|,
name|file
argument_list|,
name|flags
operator||
name|TDF_BLOCKS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump CFG statistics on FILE.  */
end_comment

begin_function
name|void
name|dump_cfg_stats
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|static
name|long
name|max_num_merged_labels
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|long
name|num_edges
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt_str
init|=
literal|"%-30s%-13s%12s\n"
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt_str_1
init|=
literal|"%-30s%13d%11lu%c\n"
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt_str_2
init|=
literal|"%-30s%13ld%11lu%c\n"
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt_str_3
init|=
literal|"%-43s%11lu%c\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|funcname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nCFG Statistics for %s\n\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str
argument_list|,
literal|""
argument_list|,
literal|"  Number of  "
argument_list|,
literal|"Memory"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str
argument_list|,
literal|""
argument_list|,
literal|"  instances  "
argument_list|,
literal|"used "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|size
operator|=
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|basic_block_def
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"Basic blocks"
argument_list|,
name|n_basic_blocks
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|num_edges
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|num_edges
operator|+=
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
expr_stmt|;
name|size
operator|=
name|num_edges
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|edge_def
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_2
argument_list|,
literal|"Edges"
argument_list|,
name|num_edges
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_3
argument_list|,
literal|"Total memory used by CFG data"
argument_list|,
name|SCALE
argument_list|(
name|total
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_stats
operator|.
name|num_merged_labels
operator|>
name|max_num_merged_labels
condition|)
name|max_num_merged_labels
operator|=
name|cfg_stats
operator|.
name|num_merged_labels
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Coalesced label blocks: %ld (Max so far: %ld)\n"
argument_list|,
name|cfg_stats
operator|.
name|num_merged_labels
argument_list|,
name|max_num_merged_labels
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump CFG statistics on stderr.  Keep extern so that it's always    linked in the final executable.  */
end_comment

begin_function
name|void
name|debug_cfg_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_cfg_stats
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the flowgraph to a .vcg FILE.  */
end_comment

begin_function
specifier|static
name|void
name|tree_cfg2vcg
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
specifier|const
name|char
modifier|*
name|funcname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* Write the file header.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"graph: { title: \"%s\"\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"node: { title: \"ENTRY\" label: \"ENTRY\" }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"node: { title: \"EXIT\" label: \"EXIT\" }\n"
argument_list|)
expr_stmt|;
comment|/* Write blocks and edges.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"edge: { sourcename: \"ENTRY\" targetname: \"%d\""
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" linestyle: dotted priority: 10"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" linestyle: solid priority: 100"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|enum
name|tree_code
name|head_code
decl_stmt|,
name|end_code
decl_stmt|;
specifier|const
name|char
modifier|*
name|head_name
decl_stmt|,
modifier|*
name|end_name
decl_stmt|;
name|int
name|head_line
init|=
literal|0
decl_stmt|;
name|int
name|end_line
init|=
literal|0
decl_stmt|;
name|tree
name|first
init|=
name|first_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|tree
name|last
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|head_code
operator|=
name|TREE_CODE
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|head_name
operator|=
name|tree_code_name
index|[
name|head_code
index|]
expr_stmt|;
name|head_line
operator|=
name|get_lineno
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
else|else
name|head_name
operator|=
literal|"no-statement"
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|end_code
operator|=
name|TREE_CODE
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|end_name
operator|=
name|tree_code_name
index|[
name|end_code
index|]
expr_stmt|;
name|end_line
operator|=
name|get_lineno
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
else|else
name|end_name
operator|=
literal|"no-statement"
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"node: { title: \"%d\" label: \"#%d\\n%s (%d)\\n%s (%d)\"}\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|head_name
argument_list|,
name|head_line
argument_list|,
name|end_name
argument_list|,
name|end_line
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"edge: { sourcename: \"%d\" targetname: \"EXIT\""
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"edge: { sourcename: \"%d\" targetname: \"%d\""
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" priority: 10 linestyle: dotted"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" priority: 100 linestyle: solid"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"}\n\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 			     Miscellaneous helpers ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Return true if T represents a stmt that always transfers control.  */
end_comment

begin_function
name|bool
name|is_ctrl_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SWITCH_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|GOTO_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RETURN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RESX_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a statement that may alter the flow of control    (e.g., a call to a non-returning function).  */
end_comment

begin_function
name|bool
name|is_ctrl_altering_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|call
decl_stmt|;
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|call
operator|=
name|get_call_expr_in
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
condition|)
block|{
comment|/* A non-pure/const CALL_EXPR alters flow control if the current 	 function has nonlocal labels.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|call
argument_list|)
operator|&&
name|current_function_has_nonlocal_label
condition|)
return|return
name|true
return|;
comment|/* A CALL_EXPR also alters control flow if it does not return.  */
if|if
condition|(
name|call_expr_flags
argument_list|(
name|call
argument_list|)
operator|&
name|ECF_NORETURN
condition|)
return|return
name|true
return|;
block|}
comment|/* OpenMP directives alter control flow.  */
if|if
condition|(
name|OMP_DIRECTIVE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If a statement can throw, it alters control flow.  */
return|return
name|tree_can_throw_internal
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a computed goto.  */
end_comment

begin_function
name|bool
name|computed_goto_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|LABEL_DECL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a simple local goto.  */
end_comment

begin_function
name|bool
name|simple_goto_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T can make an abnormal transfer of control flow.    Transfers of control flow associated with EH are excluded.  */
end_comment

begin_function
name|bool
name|tree_can_make_abnormal_goto
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|computed_goto_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|&&
name|current_function_has_nonlocal_label
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if T should start a new basic block.  PREV_T is the    statement preceding T.  It is used when T is a label or a case label.    Labels should only start a new basic block if their previous statement    wasn't a label.  Otherwise, sequence of labels would generate    unnecessary basic blocks that only contain a single label.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|stmt_starts_bb_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|prev_t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
comment|/* LABEL_EXPRs start a new basic block only if the preceding      statement wasn't a label of the same type.  This prevents the      creation of consecutive blocks that have nothing but a single      label.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
comment|/* Nonlocal and computed GOTO targets always start a new block.  */
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|FORCED_LABEL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|prev_t
operator|&&
name|TREE_CODE
argument_list|(
name|prev_t
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|prev_t
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|cfg_stats
operator|.
name|num_merged_labels
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if T should end a basic block.  */
end_comment

begin_function
name|bool
name|stmt_ends_bb_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|is_ctrl_stmt
argument_list|(
name|t
argument_list|)
operator|||
name|is_ctrl_altering_stmt
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add gotos that used to be represented implicitly in the CFG.  */
end_comment

begin_function
name|void
name|disband_implicit_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|last
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|label
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|last
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* Remove superfluous gotos from COND_EXPR branches.  Moved 	     from cfg_remove_useless_stmts here since it violates the 	     invariants for tree--cfg correspondence and thus fits better 	     here where we do it anyway.  */
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|bb
operator|->
name|next_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALSE_VALUE
condition|)
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
block|{
comment|/* Remove the RETURN_EXPR if we may fall though to the exit 	     instead.  */
name|gcc_assert
argument_list|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|==
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bsi_remove
argument_list|(
operator|&
name|last
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* There can be no fallthru edge if the last statement is a control 	 one.  */
if|if
condition|(
name|stmt
operator|&&
name|is_ctrl_stmt
argument_list|(
name|stmt
argument_list|)
condition|)
continue|continue;
comment|/* Find a fallthru edge and emit the goto if necessary.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
operator|!
name|e
operator|||
name|e
operator|->
name|dest
operator|==
name|bb
operator|->
name|next_bb
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|label
operator|=
name|tree_block_label
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|e
operator|->
name|goto_locus
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_EXPR_LOCUS
argument_list|(
name|stmt
argument_list|,
name|e
operator|->
name|goto_locus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsi_insert_after
argument_list|(
operator|&
name|last
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove block annotations and other datastructures.  */
end_comment

begin_function
name|void
name|delete_tree_cfg_annotations
parameter_list|(
name|void
parameter_list|)
block|{
name|label_to_block_map
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the first statement in basic block BB.  */
end_comment

begin_function
name|tree
name|first_stmt
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|i
init|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
decl_stmt|;
return|return
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|?
name|bsi_stmt
argument_list|(
name|i
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the last statement in basic block BB.  */
end_comment

begin_function
name|tree
name|last_stmt
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|b
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
return|return
operator|!
name|bsi_end_p
argument_list|(
name|b
argument_list|)
condition|?
name|bsi_stmt
argument_list|(
name|b
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the last statement in block BB.  */
end_comment

begin_function
name|tree
modifier|*
name|last_stmt_ptr
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|last
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
return|return
operator|!
name|bsi_end_p
argument_list|(
name|last
argument_list|)
condition|?
name|bsi_stmt_ptr
argument_list|(
name|last
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the last statement of an otherwise empty block.  Return NULL    if the block is totally empty, or if it contains more than one    statement.  */
end_comment

begin_function
name|tree
name|last_and_only_stmt
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|i
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|tree
name|last
decl_stmt|,
name|prev
decl_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|last
operator|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bsi_prev
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|last
return|;
comment|/* Empty statements should no longer appear in the instruction stream.      Everything that might have appeared before should be deleted by      remove_useless_stmts, and the optimizers should just bsi_remove      instead of smashing with build_empty_stmt.       Thus the only thing that should appear here in a block containing      one executable statement is a label.  */
name|prev
operator|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
return|return
name|last
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Mark BB as the basic block holding statement T.  */
end_comment

begin_function
name|void
name|set_bb_for_stmt
parameter_list|(
name|tree
name|t
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
name|PHI_BB
argument_list|(
name|t
argument_list|)
operator|=
name|bb
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|set_bb_for_stmt
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ann
operator|->
name|bb
operator|=
name|bb
expr_stmt|;
comment|/* If the statement is a label, add the label to block-to-labels map         so that we can speed up edge creation for GOTO_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|int
name|uid
decl_stmt|;
name|t
operator|=
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|uid
operator|=
name|LABEL_DECL_UID
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
operator|-
literal|1
condition|)
block|{
name|unsigned
name|old_len
init|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|label_to_block_map
argument_list|)
decl_stmt|;
name|LABEL_DECL_UID
argument_list|(
name|t
argument_list|)
operator|=
name|uid
operator|=
name|cfun
operator|->
name|last_label_uid
operator|++
expr_stmt|;
if|if
condition|(
name|old_len
operator|<=
operator|(
name|unsigned
operator|)
name|uid
condition|)
block|{
name|basic_block
modifier|*
name|addr
decl_stmt|;
name|unsigned
name|new_len
init|=
literal|3
operator|*
name|uid
operator|/
literal|2
decl_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|label_to_block_map
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|addr
operator|=
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|label_to_block_map
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|new_len
operator|-
name|old_len
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* We're moving an existing label.  Make sure that we've 		removed it from the old block.  */
name|gcc_assert
argument_list|(
operator|!
name|bb
operator|||
operator|!
name|VEC_index
argument_list|(
name|basic_block
argument_list|,
name|label_to_block_map
argument_list|,
name|uid
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|basic_block
argument_list|,
name|label_to_block_map
argument_list|,
name|uid
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Faster version of set_bb_for_stmt that assume that statement is being moved    from one basic block to another.      For BB splitting we can run into quadratic case, so performance is quite    important and knowing that the tables are big enough, change_bb_for_stmt    can inline as leaf function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|change_bb_for_stmt
parameter_list|(
name|tree
name|t
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|get_stmt_ann
argument_list|(
name|t
argument_list|)
operator|->
name|bb
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
name|VEC_replace
argument_list|(
name|basic_block
argument_list|,
name|label_to_block_map
argument_list|,
name|LABEL_DECL_UID
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds iterator for STMT.  */
end_comment

begin_function
specifier|extern
name|block_stmt_iterator
name|bsi_for_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
if|if
condition|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|==
name|stmt
condition|)
return|return
name|bsi
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark statement T as modified, and update it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|update_modified_stmts
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|stmt
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|update_stmt_if_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|update_stmt_if_modified
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert statement (or statement list) T before the statement    pointed-to by iterator I.  M specifies how to update iterator I    after insertion (see enum bsi_iterator_update).  */
end_comment

begin_function
name|void
name|bsi_insert_before
parameter_list|(
name|block_stmt_iterator
modifier|*
name|i
parameter_list|,
name|tree
name|t
parameter_list|,
name|enum
name|bsi_iterator_update
name|m
parameter_list|)
block|{
name|set_bb_for_stmt
argument_list|(
name|t
argument_list|,
name|i
operator|->
name|bb
argument_list|)
expr_stmt|;
name|update_modified_stmts
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
operator|&
name|i
operator|->
name|tsi
argument_list|,
name|t
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert statement (or statement list) T after the statement    pointed-to by iterator I.  M specifies how to update iterator I    after insertion (see enum bsi_iterator_update).  */
end_comment

begin_function
name|void
name|bsi_insert_after
parameter_list|(
name|block_stmt_iterator
modifier|*
name|i
parameter_list|,
name|tree
name|t
parameter_list|,
name|enum
name|bsi_iterator_update
name|m
parameter_list|)
block|{
name|set_bb_for_stmt
argument_list|(
name|t
argument_list|,
name|i
operator|->
name|bb
argument_list|)
expr_stmt|;
name|update_modified_stmts
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
operator|->
name|tsi
argument_list|,
name|t
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the statement pointed to by iterator I.  The iterator is updated    to the next statement.     When REMOVE_EH_INFO is true we remove the statement pointed to by    iterator I from the EH tables.  Otherwise we do not modify the EH    tables.     Generally, REMOVE_EH_INFO should be true when the statement is going to    be removed from the IL and not reinserted elsewhere.  */
end_comment

begin_function
name|void
name|bsi_remove
parameter_list|(
name|block_stmt_iterator
modifier|*
name|i
parameter_list|,
name|bool
name|remove_eh_info
parameter_list|)
block|{
name|tree
name|t
init|=
name|bsi_stmt
argument_list|(
operator|*
name|i
argument_list|)
decl_stmt|;
name|set_bb_for_stmt
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delink_stmt_imm_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
operator|&
name|i
operator|->
name|tsi
argument_list|)
expr_stmt|;
name|mark_stmt_modified
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_eh_info
condition|)
name|remove_stmt_from_eh_region
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the statement at FROM so it comes right after the statement at TO.  */
end_comment

begin_function
name|void
name|bsi_move_after
parameter_list|(
name|block_stmt_iterator
modifier|*
name|from
parameter_list|,
name|block_stmt_iterator
modifier|*
name|to
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|from
argument_list|)
decl_stmt|;
name|bsi_remove
argument_list|(
name|from
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
name|to
argument_list|,
name|stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the statement at FROM so it comes right before the statement at TO.  */
end_comment

begin_function
name|void
name|bsi_move_before
parameter_list|(
name|block_stmt_iterator
modifier|*
name|from
parameter_list|,
name|block_stmt_iterator
modifier|*
name|to
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|from
argument_list|)
decl_stmt|;
name|bsi_remove
argument_list|(
name|from
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|to
argument_list|,
name|stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the statement at FROM to the end of basic block BB.  */
end_comment

begin_function
name|void
name|bsi_move_to_bb_end
parameter_list|(
name|block_stmt_iterator
modifier|*
name|from
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|last
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* Have to check bsi_end_p because it could be an empty block.  */
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|last
argument_list|)
operator|&&
name|is_ctrl_stmt
argument_list|(
name|bsi_stmt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
name|bsi_move_before
argument_list|(
name|from
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
else|else
name|bsi_move_after
argument_list|(
name|from
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace the contents of the statement pointed to by iterator BSI    with STMT.  If UPDATE_EH_INFO is true, the exception handling    information of the original statement is moved to the new statement.  */
end_comment

begin_function
name|void
name|bsi_replace
parameter_list|(
specifier|const
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bool
name|update_eh_info
parameter_list|)
block|{
name|int
name|eh_region
decl_stmt|;
name|tree
name|orig_stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
decl_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|stmt
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|orig_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|set_bb_for_stmt
argument_list|(
name|stmt
argument_list|,
name|bsi
operator|->
name|bb
argument_list|)
expr_stmt|;
comment|/* Preserve EH region information from the original statement, if      requested by the caller.  */
if|if
condition|(
name|update_eh_info
condition|)
block|{
name|eh_region
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|orig_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_region
operator|>=
literal|0
condition|)
block|{
name|remove_stmt_from_eh_region
argument_list|(
name|orig_stmt
argument_list|)
expr_stmt|;
name|add_stmt_to_eh_region
argument_list|(
name|stmt
argument_list|,
name|eh_region
argument_list|)
expr_stmt|;
block|}
block|}
name|delink_stmt_imm_use
argument_list|(
name|orig_stmt
argument_list|)
expr_stmt|;
operator|*
name|bsi_stmt_ptr
argument_list|(
operator|*
name|bsi
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|mark_stmt_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|update_modified_stmts
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the statement pointed-to by BSI into edge E.  Every attempt    is made to place the statement in an existing basic block, but    sometimes that isn't possible.  When it isn't possible, the edge is    split and the statement is added to the new block.     In all cases, the returned *BSI points to the correct location.  The    return value is true if insertion should be done after the location,    or false if it should be done before the location.  If new basic block    has to be created, it is stored in *NEW_BB.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_find_edge_insert_loc
parameter_list|(
name|edge
name|e
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|basic_block
modifier|*
name|new_bb
parameter_list|)
block|{
name|basic_block
name|dest
decl_stmt|,
name|src
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|restart
label|:
comment|/* If the destination has one predecessor which has no PHI nodes,      insert there.  Except for the exit block.       The requirement for no PHI nodes could be relaxed.  Basically we      would have to examine the PHIs to prove that none of them used      the value set by the statement we want to insert on E.  That      hardly seems worth the effort.  */
if|if
condition|(
name|single_pred_p
argument_list|(
name|dest
argument_list|)
operator|&&
operator|!
name|phi_nodes
argument_list|(
name|dest
argument_list|)
operator|&&
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
operator|*
name|bsi
operator|=
name|bsi_start
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
operator|*
name|bsi
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Make sure we insert after any leading labels.  */
name|tmp
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|bsi_next
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
operator|*
name|bsi
argument_list|)
condition|)
break|break;
name|tmp
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsi_end_p
argument_list|(
operator|*
name|bsi
argument_list|)
condition|)
block|{
operator|*
name|bsi
operator|=
name|bsi_last
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
comment|/* If the source has one successor, the edge is not abnormal and      the last statement does not end a basic block, insert there.      Except for the entry block.  */
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
operator|&&
name|single_succ_p
argument_list|(
name|src
argument_list|)
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
operator|*
name|bsi
operator|=
name|bsi_last
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
operator|*
name|bsi
argument_list|)
condition|)
return|return
name|true
return|;
name|tmp
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt_ends_bb_p
argument_list|(
name|tmp
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Insert code just before returning the value.  We may need to decompose          the return in the case it contains non-trivial operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|op
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bsi_prev
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* Otherwise, create a new basic block, and split this edge.  */
name|dest
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bb
condition|)
operator|*
name|new_bb
operator|=
name|dest
expr_stmt|;
name|e
operator|=
name|single_pred_edge
argument_list|(
name|dest
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
end_function

begin_comment
comment|/* This routine will commit all pending edge insertions, creating any new    basic blocks which are necessary.  */
end_comment

begin_function
name|void
name|bsi_commit_edge_inserts
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bsi_commit_one_edge_insert
argument_list|(
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|bsi_commit_one_edge_insert
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commit insertions pending at edge E. If a new block is created, set NEW_BB    to this block, otherwise set it to NULL.  */
end_comment

begin_function
name|void
name|bsi_commit_one_edge_insert
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
modifier|*
name|new_bb
parameter_list|)
block|{
if|if
condition|(
name|new_bb
condition|)
operator|*
name|new_bb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
init|=
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|tree_find_edge_insert_loc
argument_list|(
name|e
argument_list|,
operator|&
name|bsi
argument_list|,
name|new_bb
argument_list|)
condition|)
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
else|else
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add STMT to the pending list of edge E.  No actual insertion is    made until a call to bsi_commit_edge_inserts () is made.  */
end_comment

begin_function
name|void
name|bsi_insert_on_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
operator|&
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to bsi_insert_on_edge+bsi_commit_edge_inserts.  If a new    block has to be created, it is returned.  */
end_comment

begin_function
name|basic_block
name|bsi_insert_on_edge_immediate
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|new_bb
init|=
name|NULL
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_find_edge_insert_loc
argument_list|(
name|e
argument_list|,
operator|&
name|bsi
argument_list|,
operator|&
name|new_bb
argument_list|)
condition|)
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
else|else
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	     Tree specific functions for CFG manipulation ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Reinstall those PHI arguments queued in OLD_EDGE to NEW_EDGE.  */
end_comment

begin_function
specifier|static
name|void
name|reinstall_phi_args
parameter_list|(
name|edge
name|new_edge
parameter_list|,
name|edge
name|old_edge
parameter_list|)
block|{
name|tree
name|var
decl_stmt|,
name|phi
decl_stmt|;
if|if
condition|(
operator|!
name|PENDING_STMT
argument_list|(
name|old_edge
argument_list|)
condition|)
return|return;
for|for
control|(
name|var
operator|=
name|PENDING_STMT
argument_list|(
name|old_edge
argument_list|)
operator|,
name|phi
operator|=
name|phi_nodes
argument_list|(
name|new_edge
operator|->
name|dest
argument_list|)
init|;
name|var
operator|&&
name|phi
condition|;
name|var
operator|=
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
operator|,
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|result
init|=
name|TREE_PURPOSE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|result
operator|==
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|arg
argument_list|,
name|new_edge
argument_list|)
expr_stmt|;
block|}
name|PENDING_STMT
argument_list|(
name|old_edge
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the basic block after which the new basic block created    by splitting edge EDGE_IN should be placed.  Tries to keep the new block    near its "logical" location.  This is of most help to humans looking    at debugging dumps.  */
end_comment

begin_function
specifier|static
name|basic_block
name|split_edge_bb_loc
parameter_list|(
name|edge
name|edge_in
parameter_list|)
block|{
name|basic_block
name|dest
init|=
name|edge_in
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|dest
operator|->
name|prev_bb
operator|&&
name|find_edge
argument_list|(
name|dest
operator|->
name|prev_bb
argument_list|,
name|dest
argument_list|)
condition|)
return|return
name|edge_in
operator|->
name|src
return|;
else|else
return|return
name|dest
operator|->
name|prev_bb
return|;
block|}
end_function

begin_comment
comment|/* Split a (typically critical) edge EDGE_IN.  Return the new block.    Abort on abnormal edges.  */
end_comment

begin_function
specifier|static
name|basic_block
name|tree_split_edge
parameter_list|(
name|edge
name|edge_in
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|,
name|after_bb
decl_stmt|,
name|dest
decl_stmt|;
name|edge
name|new_edge
decl_stmt|,
name|e
decl_stmt|;
comment|/* Abnormal edges cannot be split.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|edge_in
operator|->
name|dest
expr_stmt|;
name|after_bb
operator|=
name|split_edge_bb_loc
argument_list|(
name|edge_in
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|create_empty_bb
argument_list|(
name|after_bb
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|edge_in
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|count
operator|=
name|edge_in
operator|->
name|count
expr_stmt|;
name|new_edge
operator|=
name|make_edge
argument_list|(
name|new_bb
argument_list|,
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|new_edge
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|new_edge
operator|->
name|count
operator|=
name|edge_in
operator|->
name|count
expr_stmt|;
name|e
operator|=
name|redirect_edge_and_branch
argument_list|(
name|edge_in
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|reinstall_phi_args
argument_list|(
name|new_edge
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Return true when BB has label LABEL in it.  */
end_comment

begin_function
specifier|static
name|bool
name|has_label_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|label
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
operator|==
name|label
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Callback for walk_tree, check that all elements with address taken are    properly noticed as such.  The DATA is an int* that is 1 if TP was seen    inside a PHI node.  */
end_comment

begin_function
specifier|static
name|tree
name|verify_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|,
name|x
decl_stmt|;
name|bool
name|in_phi
init|=
operator|(
name|data
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Check operand N for being valid GIMPLE and give error MSG if not.  */
define|#
directive|define
name|CHECK_OP
parameter_list|(
name|N
parameter_list|,
name|MSG
parameter_list|)
define|\
value|do { if (!is_gimple_val (TREE_OPERAND (t, N)))		\        { error (MSG); return TREE_OPERAND (t, N); }} while (0)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
if|if
condition|(
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"SSA name in freelist but still referenced"
argument_list|)
expr_stmt|;
return|return
operator|*
name|tp
return|;
block|}
break|break;
case|case
name|ASSERT_EXPR
case|:
name|x
operator|=
name|fold
argument_list|(
name|ASSERT_EXPR_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|boolean_false_node
condition|)
block|{
name|error
argument_list|(
literal|"ASSERT_EXPR with an always-false condition"
argument_list|)
expr_stmt|;
return|return
operator|*
name|tp
return|;
block|}
break|break;
case|case
name|MODIFY_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|&&
name|is_gimple_reg
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"GIMPLE register modified with BIT_FIELD_REF"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
block|{
name|bool
name|old_invariant
decl_stmt|;
name|bool
name|old_constant
decl_stmt|;
name|bool
name|old_side_effects
decl_stmt|;
name|bool
name|new_invariant
decl_stmt|;
name|bool
name|new_constant
decl_stmt|;
name|bool
name|new_side_effects
decl_stmt|;
comment|/* ??? tree-ssa-alias.c may have overlooked dead PHI nodes, missing 	   dead PHIs that take the address of something.  But if the PHI 	   result is dead, the fact that it takes the address of anything 	   is irrelevant.  Because we can not tell from here if a PHI result 	   is dead, we just skip this check for PHIs altogether.  This means 	   we may be missing "valid" checks, but what can you do? 	   This was PR19217.  */
if|if
condition|(
name|in_phi
condition|)
break|break;
name|old_invariant
operator|=
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|old_constant
operator|=
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|old_side_effects
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|new_invariant
operator|=
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|new_side_effects
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|new_constant
operator|=
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_invariant
operator|!=
name|new_invariant
condition|)
block|{
name|error
argument_list|(
literal|"invariant not recomputed when ADDR_EXPR changed"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|old_constant
operator|!=
name|new_constant
condition|)
block|{
name|error
argument_list|(
literal|"constant not recomputed when ADDR_EXPR changed"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|old_side_effects
operator|!=
name|new_side_effects
condition|)
block|{
name|error
argument_list|(
literal|"side effects not recomputed when ADDR_EXPR changed"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* Skip any references (they will be checked when we recurse down the 	   tree) and ensure that any variable used as a prefix is marked 	   addressable.  */
for|for
control|(
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address taken, but ADDRESSABLE bit not set"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
break|break;
block|}
case|case
name|COND_EXPR
case|:
name|x
operator|=
name|COND_EXPR_COND
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"non-boolean used in condition"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
if|if
condition|(
operator|!
name|is_gimple_condexpr
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid conditional operand"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
name|CHECK_OP
argument_list|(
literal|0
argument_list|,
literal|"invalid operand to unary operator"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
comment|/* We have a nest of references.  Verify that each of the operands 	 that determine where to reference is either a constant or a variable, 	 verify that the base is valid, and then show we've already checked 	 the subtrees.  */
while|while
condition|(
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
name|CHECK_OP
argument_list|(
literal|2
argument_list|,
literal|"invalid COMPONENT_REF offset operator"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|CHECK_OP
argument_list|(
literal|1
argument_list|,
literal|"invalid array index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
name|CHECK_OP
argument_list|(
literal|2
argument_list|,
literal|"invalid array lower bound"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
condition|)
name|CHECK_OP
argument_list|(
literal|3
argument_list|,
literal|"invalid array stride"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|CHECK_OP
argument_list|(
literal|1
argument_list|,
literal|"invalid operand to BIT_FIELD_REF"
argument_list|)
expr_stmt|;
name|CHECK_OP
argument_list|(
literal|2
argument_list|,
literal|"invalid operand to BIT_FIELD_REF"
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|is_gimple_lvalue
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid reference prefix"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
name|CHECK_OP
argument_list|(
literal|0
argument_list|,
literal|"invalid operand to binary operator"
argument_list|)
expr_stmt|;
name|CHECK_OP
argument_list|(
literal|1
argument_list|,
literal|"invalid operand to binary operator"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
undef|#
directive|undef
name|CHECK_OP
block|}
end_function

begin_comment
comment|/* Verify STMT, return true if STMT is not in GIMPLE form.    TODO: Implement type checking.  */
end_comment

begin_function
specifier|static
name|bool
name|verify_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
name|last_in_block
parameter_list|)
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|OMP_DIRECTIVE_P
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* OpenMP directives are validated by the FE and never operated 	 on by the optimizers.  Furthermore, OMP_FOR may contain 	 non-gimple expressions when the main index variable has had 	 its address taken.  This does not affect the loop itself 	 because the header of an OMP_FOR is merely used to determine 	 how to setup the parallel iteration.  */
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|is_gimple_stmt
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"is not a valid GIMPLE statement"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|addr
operator|=
name|walk_tree
argument_list|(
operator|&
name|stmt
argument_list|,
name|verify_expr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|debug_generic_stmt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If the statement is marked as part of an EH region, then it is      expected that the statement could throw.  Verify that when we      have optimizations that simplify statements such that we prove      that they cannot throw, that we update other data structures      to match.  */
if|if
condition|(
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tree_could_throw_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"statement marked for throw, but doesn%'t"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|last_in_block
operator|&&
name|tree_can_throw_internal
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"statement marked for throw in middle of block"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
name|false
return|;
name|fail
label|:
name|debug_generic_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true when the T can be shared.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_node_can_be_shared
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|t
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CASE_LABEL_EXPR
condition|)
return|return
name|true
return|;
while|while
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
operator|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IMAGPART_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_trees.  Verify tree sharing.  */
end_comment

begin_function
specifier|static
name|tree
name|verify_node_sharing
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|htab_t
name|htab
init|=
operator|(
name|htab_t
operator|)
name|data
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|tree_node_can_be_shared
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
name|false
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
operator|*
name|tp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
operator|(
name|tree
operator|)
operator|*
name|slot
return|;
operator|*
name|slot
operator|=
operator|*
name|tp
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Verify the GIMPLE statement chain.  */
end_comment

begin_function
name|void
name|verify_stmts
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bool
name|err
init|=
name|false
decl_stmt|;
name|htab_t
name|htab
decl_stmt|;
name|tree
name|addr
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_STMT_VERIFY
argument_list|)
expr_stmt|;
name|htab
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|int
name|phi_num_args
init|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"bb_for_stmt (phi) is set to a wrong basic block"
argument_list|)
expr_stmt|;
name|err
operator||=
name|true
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|phi_num_args
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|t
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|addr
decl_stmt|;
comment|/* Addressable variables do have SSA_NAMEs but they 		 are not considered gimple values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"PHI def is not a GIMPLE value"
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|err
operator||=
name|true
expr_stmt|;
block|}
name|addr
operator|=
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|verify_expr
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|debug_generic_stmt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|err
operator||=
name|true
expr_stmt|;
block|}
name|addr
operator|=
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|verify_node_sharing
argument_list|,
name|htab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|error
argument_list|(
literal|"incorrect sharing of tree nodes"
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|err
operator||=
name|true
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"bb_for_stmt (stmt) is set to a wrong basic block"
argument_list|)
expr_stmt|;
name|err
operator||=
name|true
expr_stmt|;
block|}
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|err
operator||=
name|verify_stmt
argument_list|(
name|stmt
argument_list|,
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|walk_tree
argument_list|(
operator|&
name|stmt
argument_list|,
name|verify_node_sharing
argument_list|,
name|htab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|error
argument_list|(
literal|"incorrect sharing of tree nodes"
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|debug_generic_stmt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|err
operator||=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|err
condition|)
name|internal_error
argument_list|(
literal|"verify_stmts failed"
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_STMT_VERIFY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verifies that the flow information is OK.  */
end_comment

begin_function
specifier|static
name|int
name|tree_verify_flow_info
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|stmt_list
condition|)
block|{
name|error
argument_list|(
literal|"ENTRY_BLOCK has a statement list associated with it"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|EXIT_BLOCK_PTR
operator|->
name|stmt_list
condition|)
block|{
name|error
argument_list|(
literal|"EXIT_BLOCK has a statement list associated with it"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|error
argument_list|(
literal|"fallthru to exit from bb %d"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bool
name|found_ctrl_stmt
init|=
name|false
decl_stmt|;
name|stmt
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Skip labels on the start of basic block.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|prev_stmt
init|=
name|stmt
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
break|break;
if|if
condition|(
name|prev_stmt
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"nonlocal label "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is not first in a sequence of labels in bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|label_to_block
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"label "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" to block does not match in bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|decl_function_context
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
name|error
argument_list|(
literal|"label "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" has incorrect context in bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Verify that body of basic block BB is free of control flow.  */
for|for
control|(
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|found_ctrl_stmt
condition|)
block|{
name|error
argument_list|(
literal|"control flow in the middle of basic block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|found_ctrl_stmt
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"label "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in the middle of basic block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
continue|continue;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|err
operator||=
name|verify_eh_edges
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ctrl_stmt
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|error
argument_list|(
literal|"fallthru edge after a control statement in bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
condition|)
block|{
comment|/* Verify that there are no edges with EDGE_TRUE/FALSE_FLAG set 	     after anything else but if statement.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"true/false edge after a non-COND_EXPR in bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
block|{
name|edge
name|true_edge
decl_stmt|;
name|edge
name|false_edge
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|!=
name|GOTO_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|!=
name|GOTO_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"structured COND_EXPR at the end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|extract_true_false_edges_from_block
argument_list|(
name|bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|true_edge
operator|||
operator|!
name|false_edge
operator|||
operator|!
operator|(
name|true_edge
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
operator|)
operator|||
operator|!
operator|(
name|false_edge
operator|->
name|flags
operator|&
name|EDGE_FALSE_VALUE
operator|)
operator|||
operator|(
name|true_edge
operator|->
name|flags
operator|&
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_ABNORMAL
operator|)
operator|)
operator|||
operator|(
name|false_edge
operator|->
name|flags
operator|&
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_ABNORMAL
operator|)
operator|)
operator|||
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>=
literal|3
condition|)
block|{
name|error
argument_list|(
literal|"wrong outgoing edge flags at end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_label_p
argument_list|(
name|true_edge
operator|->
name|dest
argument_list|,
name|GOTO_DESTINATION
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<then%> label does not match edge at end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_label_p
argument_list|(
name|false_edge
operator|->
name|dest
argument_list|,
name|GOTO_DESTINATION
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<else%> label does not match edge at end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GOTO_EXPR
case|:
if|if
condition|(
name|simple_goto_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"explicit goto at end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME.  We should double check that the labels in the 		 destination blocks have their address taken.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
operator|)
operator|||
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong outgoing edge flags at end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RETURN_EXPR
case|:
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|||
operator|(
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator|&
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_ABNORMAL
operator||
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong outgoing edge flags at end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|error
argument_list|(
literal|"return edge does not point to exit in bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SWITCH_EXPR
case|:
block|{
name|tree
name|prev
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|vec
decl_stmt|;
name|vec
operator|=
name|SWITCH_LABELS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
expr_stmt|;
comment|/* Mark all the destination basic blocks.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|lab
init|=
name|CASE_LABEL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
name|label_bb
init|=
name|label_to_block
argument_list|(
name|lab
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|label_bb
operator|->
name|aux
operator|||
name|label_bb
operator|->
name|aux
operator|==
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
name|label_bb
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
comment|/* Verify that the case labels are sorted.  */
name|prev
operator|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|c
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CASE_LOW
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"found default case not at end of case vector"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|CASE_LOW
argument_list|(
name|prev
argument_list|)
argument_list|,
name|CASE_LOW
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"case labels not sorted: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|prev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is greater than "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" but comes before it.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|prev
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|CASE_LOW
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|n
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no default case found at end of case vector"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|aux
condition|)
block|{
name|error
argument_list|(
literal|"extra outgoing edge %d->%d"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_FALLTHRU
operator||
name|EDGE_ABNORMAL
operator||
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong outgoing edge flags at end of bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check that we have all of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|lab
init|=
name|CASE_LABEL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
name|label_bb
init|=
name|label_to_block
argument_list|(
name|lab
argument_list|)
decl_stmt|;
if|if
condition|(
name|label_bb
operator|->
name|aux
operator|!=
operator|(
name|void
operator|*
operator|)
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"missing edge %i->%i"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|label_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
default|default:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
operator|>=
name|DOM_NO_FAST_QUERY
condition|)
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Updates phi nodes after creating a forwarder block joined    by edge FALLTHRU.  */
end_comment

begin_function
specifier|static
name|void
name|tree_make_forwarder_block
parameter_list|(
name|edge
name|fallthru
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|dummy
decl_stmt|,
name|bb
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|new_phi
decl_stmt|,
name|var
decl_stmt|;
name|dummy
operator|=
name|fallthru
operator|->
name|src
expr_stmt|;
name|bb
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|single_pred_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return;
comment|/* If we redirected a branch we must create new phi nodes at the      start of BB.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|dummy
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|var
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|var
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
operator|=
name|new_phi
expr_stmt|;
name|SET_PHI_RESULT
argument_list|(
name|phi
argument_list|,
name|make_ssa_name
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
argument_list|,
name|phi
argument_list|)
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|fallthru
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure that the PHI node chain is in the same order.  */
name|set_phi_nodes
argument_list|(
name|bb
argument_list|,
name|phi_reverse
argument_list|(
name|phi_nodes
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the arguments we have stored on edges.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|==
name|fallthru
condition|)
continue|continue;
name|flush_pending_stmts
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a non-special label in the head of basic block BLOCK.    Create one if it doesn't exist.  */
end_comment

begin_function
name|tree
name|tree_block_label
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|,
name|s
init|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|tree
name|label
decl_stmt|,
name|stmt
decl_stmt|;
for|for
control|(
name|i
operator|=
name|s
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|first
operator|=
name|false
operator|,
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
break|break;
name|label
operator|=
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NONLOCAL
argument_list|(
name|label
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|bsi_move_before
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
block|}
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|s
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Attempt to perform edge redirection by replacing a possibly complex    jump instruction by a goto or by removing the jump completely.    This can apply only if all edges now point to the same block.  The    parameters and return values are equivalent to    redirect_edge_and_branch.  */
end_comment

begin_function
specifier|static
name|edge
name|tree_try_redirect_by_replacing_jump
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|block_stmt_iterator
name|b
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
comment|/* We can replace or remove a complex jump only when we have exactly      two edges.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|src
operator|->
name|succs
argument_list|)
operator|!=
literal|2
comment|/* Verify that all targets will be TARGET.  Specifically, the 	 edge that is not E must also go to TARGET.  */
operator|||
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
name|EDGE_SUCC
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|e
argument_list|)
operator|->
name|dest
operator|!=
name|target
condition|)
return|return
name|NULL
return|;
name|b
operator|=
name|bsi_last
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|NULL
return|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
name|bsi_remove
argument_list|(
operator|&
name|b
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|e
operator|=
name|ssa_redirect_edge
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
return|return
name|e
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Redirect E to DEST.  Return NULL on failure.  Otherwise, return the    edge representing the redirected branch.  */
end_comment

begin_function
specifier|static
name|edge
name|tree_redirect_edge_and_branch
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge
name|ret
decl_stmt|;
name|tree
name|label
decl_stmt|,
name|stmt
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|(
name|ret
operator|=
name|tree_try_redirect_by_replacing_jump
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|dest
condition|)
return|return
name|NULL
return|;
name|label
operator|=
name|tree_block_label
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|?
name|NULL
else|:
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stmt
condition|?
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
else|:
name|ERROR_MARK
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|stmt
operator|=
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|?
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
else|:
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
operator|)
expr_stmt|;
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
operator|=
name|label
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
comment|/* No non-abnormal edges should lead from a non-simple goto, and 	 simple ones should be represented implicitly.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|SWITCH_EXPR
case|:
block|{
name|tree
name|cases
init|=
name|get_cases_for_edge
argument_list|(
name|e
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
comment|/* If we have a list of cases associated with E, then use it 	   as it's a lot faster than walking the entire case vector.  */
if|if
condition|(
name|cases
condition|)
block|{
name|edge
name|e2
init|=
name|find_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|tree
name|last
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
name|cases
expr_stmt|;
while|while
condition|(
name|cases
condition|)
block|{
name|last
operator|=
name|cases
expr_stmt|;
name|CASE_LABEL
argument_list|(
name|cases
argument_list|)
operator|=
name|label
expr_stmt|;
name|cases
operator|=
name|TREE_CHAIN
argument_list|(
name|cases
argument_list|)
expr_stmt|;
block|}
comment|/* If there was already an edge in the CFG, then we need 	       to move all the cases associated with E to E2.  */
if|if
condition|(
name|e2
condition|)
block|{
name|tree
name|cases2
init|=
name|get_cases_for_edge
argument_list|(
name|e2
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|cases2
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|cases2
argument_list|)
operator|=
name|first
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|vec
init|=
name|SWITCH_LABELS
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|label_to_block
argument_list|(
name|CASE_LABEL
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|e
operator|->
name|dest
condition|)
name|CASE_LABEL
argument_list|(
name|elt
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|RETURN_EXPR
case|:
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
break|break;
default|default:
comment|/* Otherwise it must be a fallthru edge, and we don't need to 	 do anything besides redirecting it.  */
name|gcc_assert
argument_list|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Update/insert PHI nodes as necessary.  */
comment|/* Now update the edges in the CFG.  */
name|e
operator|=
name|ssa_redirect_edge
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Simple wrapper, as we can always redirect fallthru edges.  */
end_comment

begin_function
specifier|static
name|basic_block
name|tree_redirect_edge_and_branch_force
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|e
operator|=
name|tree_redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Splits basic block BB after statement STMT (but at least after the    labels).  If STMT is NULL, BB is split just after the labels.  */
end_comment

begin_function
specifier|static
name|basic_block
name|tree_split_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|stmt
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree_stmt_iterator
name|tsi_tgt
decl_stmt|;
name|tree
name|act
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|new_bb
operator|=
name|create_empty_bb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Redirect the outgoing edges.  */
name|new_bb
operator|->
name|succs
operator|=
name|bb
operator|->
name|succs
expr_stmt|;
name|bb
operator|->
name|succs
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|new_bb->succs
argument_list|)
name|e
operator|->
name|src
operator|=
name|new_bb
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
operator|(
name|tree
operator|)
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
name|stmt
operator|=
name|NULL
expr_stmt|;
comment|/* Move everything from BSI to the new basic block.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|act
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|act
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
continue|continue;
if|if
condition|(
operator|!
name|stmt
condition|)
break|break;
if|if
condition|(
name|stmt
operator|==
name|act
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
return|return
name|new_bb
return|;
comment|/* Split the statement list - avoid re-creating new containers as this      brings ugly quadratic memory consumption in the inliner.        (We are still quadratic since we need to update stmt BB pointers,      sadly.)  */
name|new_bb
operator|->
name|stmt_list
operator|=
name|tsi_split_statement_list_before
argument_list|(
operator|&
name|bsi
operator|.
name|tsi
argument_list|)
expr_stmt|;
for|for
control|(
name|tsi_tgt
operator|=
name|tsi_start
argument_list|(
name|new_bb
operator|->
name|stmt_list
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi_tgt
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|tsi_tgt
argument_list|)
control|)
name|change_bb_for_stmt
argument_list|(
name|tsi_stmt
argument_list|(
name|tsi_tgt
argument_list|)
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Moves basic block BB after block AFTER.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_move_block_after
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|->
name|prev_bb
operator|==
name|after
condition|)
return|return
name|true
return|;
name|unlink_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|link_block
argument_list|(
name|bb
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if basic_block can be duplicated.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_can_duplicate_bb_p
parameter_list|(
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a duplicate of the basic block BB.  NOTE: This does not    preserve SSA form.  */
end_comment

begin_function
specifier|static
name|basic_block
name|tree_duplicate_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|bsi_tgt
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|new_bb
operator|=
name|create_empty_bb
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
comment|/* Copy the PHI nodes.  We ignore PHI node arguments here because      the incoming edges have not been setup yet.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|copy
init|=
name|create_phi_node
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|new_bb
argument_list|)
decl_stmt|;
name|create_new_def_for
argument_list|(
name|PHI_RESULT
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
name|PHI_RESULT_PTR
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Keep the chain of PHI nodes in the same order so that they can be      updated by ssa_redirect_edge.  */
name|set_phi_nodes
argument_list|(
name|new_bb
argument_list|,
name|phi_reverse
argument_list|(
name|phi_nodes
argument_list|(
name|new_bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_tgt
operator|=
name|bsi_start
argument_list|(
name|new_bb
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|def_operand_p
name|def_p
decl_stmt|;
name|ssa_op_iter
name|op_iter
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|copy
decl_stmt|;
name|int
name|region
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
continue|continue;
comment|/* Create a new copy of STMT and duplicate STMT's virtual 	 operands.  */
name|copy
operator|=
name|unshare_expr
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi_tgt
argument_list|,
name|copy
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|copy_virtual_operands
argument_list|(
name|copy
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|region
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|>=
literal|0
condition|)
name|add_stmt_to_eh_region
argument_list|(
name|copy
argument_list|,
name|region
argument_list|)
expr_stmt|;
comment|/* Create new names for all the definitions created by COPY and 	 add replacement mappings for each new name.  */
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|copy
argument_list|,
argument|op_iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
name|create_new_def_for
argument_list|(
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
argument_list|,
name|copy
argument_list|,
name|def_p
argument_list|)
expr_stmt|;
block|}
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Basic block BB_COPY was created by code duplication.  Add phi node    arguments for edges going out of BB_COPY.  The blocks that were    duplicated have BB_DUPLICATED set.  */
end_comment

begin_function
name|void
name|add_phi_args_after_copy_bb
parameter_list|(
name|basic_block
name|bb_copy
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|dest
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|e_copy
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|phi_copy
decl_stmt|,
name|phi_next
decl_stmt|,
name|def
decl_stmt|;
name|bb
operator|=
name|get_bb_original
argument_list|(
name|bb_copy
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e_copy
argument_list|,
argument|ei
argument_list|,
argument|bb_copy->succs
argument_list|)
block|{
if|if
condition|(
operator|!
name|phi_nodes
argument_list|(
name|e_copy
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|e_copy
operator|->
name|dest
operator|->
name|flags
operator|&
name|BB_DUPLICATED
condition|)
name|dest
operator|=
name|get_bb_original
argument_list|(
name|e_copy
operator|->
name|dest
argument_list|)
expr_stmt|;
else|else
name|dest
operator|=
name|e_copy
operator|->
name|dest
expr_stmt|;
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* During loop unrolling the target of the latch edge is copied. 	     In this case we are not looking for edge to dest, but to 	     duplicated block whose original was dest.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|dest
operator|->
name|flags
operator|&
name|BB_DUPLICATED
operator|)
operator|&&
name|get_bb_original
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|==
name|dest
condition|)
break|break;
name|gcc_assert
argument_list|(
name|e
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|,
name|phi_copy
operator|=
name|phi_nodes
argument_list|(
name|e_copy
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|phi_next
operator|,
name|phi_copy
operator|=
name|PHI_CHAIN
argument_list|(
name|phi_copy
argument_list|)
control|)
block|{
name|phi_next
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi_copy
argument_list|,
name|def
argument_list|,
name|e_copy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Blocks in REGION_COPY array of length N_REGION were created by    duplication of basic blocks.  Add phi node arguments for edges    going from these blocks.  */
end_comment

begin_function
name|void
name|add_phi_args_after_copy
parameter_list|(
name|basic_block
modifier|*
name|region_copy
parameter_list|,
name|unsigned
name|n_region
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
name|region_copy
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|BB_DUPLICATED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
name|add_phi_args_after_copy_bb
argument_list|(
name|region_copy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
name|region_copy
index|[
name|i
index|]
operator|->
name|flags
operator|&=
operator|~
name|BB_DUPLICATED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Duplicates a REGION (set of N_REGION basic blocks) with just a single    important exit edge EXIT.  By important we mean that no SSA name defined    inside region is live over the other exit edges of the region.  All entry    edges to the region must go to ENTRY->dest.  The edge ENTRY is redirected    to the duplicate of the region.  SSA form, dominance and loop information    is updated.  The new basic blocks are stored to REGION_COPY in the same    order as they had in REGION, provided that REGION_COPY is not NULL.    The function returns false if it is unable to copy the region,    true otherwise.  */
end_comment

begin_function
name|bool
name|tree_duplicate_sese_region
parameter_list|(
name|edge
name|entry
parameter_list|,
name|edge
name|exit
parameter_list|,
name|basic_block
modifier|*
name|region
parameter_list|,
name|unsigned
name|n_region
parameter_list|,
name|basic_block
modifier|*
name|region_copy
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n_doms
decl_stmt|;
name|bool
name|free_region_copy
init|=
name|false
decl_stmt|,
name|copying_header
init|=
name|false
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|entry
operator|->
name|dest
operator|->
name|loop_father
decl_stmt|;
name|edge
name|exit_copy
decl_stmt|;
name|basic_block
modifier|*
name|doms
decl_stmt|;
name|edge
name|redirected
decl_stmt|;
name|int
name|total_freq
init|=
literal|0
decl_stmt|,
name|entry_freq
init|=
literal|0
decl_stmt|;
name|gcov_type
name|total_count
init|=
literal|0
decl_stmt|,
name|entry_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|can_copy_bbs_p
argument_list|(
name|region
argument_list|,
name|n_region
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Some sanity checking.  Note that we do not check for all possible      missuses of the functions.  I.e. if you ask to copy something weird,      it will work, but the state of structures probably will not be      correct.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
block|{
comment|/* We do not handle subloops, i.e. all the blocks must belong to the 	 same loop.  */
if|if
condition|(
name|region
index|[
name|i
index|]
operator|->
name|loop_father
operator|!=
name|loop
condition|)
return|return
name|false
return|;
if|if
condition|(
name|region
index|[
name|i
index|]
operator|!=
name|entry
operator|->
name|dest
operator|&&
name|region
index|[
name|i
index|]
operator|==
name|loop
operator|->
name|header
condition|)
return|return
name|false
return|;
block|}
name|loop
operator|->
name|copy
operator|=
name|loop
expr_stmt|;
comment|/* In case the function is used for loop header copying (which is the primary      use), ensure that EXIT and its copy will be new latch and entry edges.  */
if|if
condition|(
name|loop
operator|->
name|header
operator|==
name|entry
operator|->
name|dest
condition|)
block|{
name|copying_header
operator|=
name|true
expr_stmt|;
name|loop
operator|->
name|copy
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|exit
operator|->
name|src
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|region
index|[
name|i
index|]
operator|!=
name|exit
operator|->
name|src
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|region
index|[
name|i
index|]
argument_list|,
name|exit
operator|->
name|src
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|region_copy
condition|)
block|{
name|region_copy
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_region
argument_list|)
expr_stmt|;
name|free_region_copy
operator|=
name|true
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|need_ssa_update_p
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Record blocks outside the region that are dominated by something      inside.  */
name|doms
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|initialize_original_copy_tables
argument_list|()
expr_stmt|;
name|n_doms
operator|=
name|get_dominated_by_region
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|region
argument_list|,
name|n_region
argument_list|,
name|doms
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|dest
operator|->
name|count
condition|)
block|{
name|total_count
operator|=
name|entry
operator|->
name|dest
operator|->
name|count
expr_stmt|;
name|entry_count
operator|=
name|entry
operator|->
name|count
expr_stmt|;
comment|/* Fix up corner cases, to avoid division by zero or creation of negative 	 frequencies.  */
if|if
condition|(
name|entry_count
operator|>
name|total_count
condition|)
name|entry_count
operator|=
name|total_count
expr_stmt|;
block|}
else|else
block|{
name|total_freq
operator|=
name|entry
operator|->
name|dest
operator|->
name|frequency
expr_stmt|;
name|entry_freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Fix up corner cases, to avoid division by zero or creation of negative 	 frequencies.  */
if|if
condition|(
name|total_freq
operator|==
literal|0
condition|)
name|total_freq
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|entry_freq
operator|>
name|total_freq
condition|)
name|entry_freq
operator|=
name|total_freq
expr_stmt|;
block|}
name|copy_bbs
argument_list|(
name|region
argument_list|,
name|n_region
argument_list|,
name|region_copy
argument_list|,
operator|&
name|exit
argument_list|,
literal|1
argument_list|,
operator|&
name|exit_copy
argument_list|,
name|loop
argument_list|,
name|split_edge_bb_loc
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_count
condition|)
block|{
name|scale_bbs_frequencies_gcov_type
argument_list|(
name|region
argument_list|,
name|n_region
argument_list|,
name|total_count
operator|-
name|entry_count
argument_list|,
name|total_count
argument_list|)
expr_stmt|;
name|scale_bbs_frequencies_gcov_type
argument_list|(
name|region_copy
argument_list|,
name|n_region
argument_list|,
name|entry_count
argument_list|,
name|total_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scale_bbs_frequencies_int
argument_list|(
name|region
argument_list|,
name|n_region
argument_list|,
name|total_freq
operator|-
name|entry_freq
argument_list|,
name|total_freq
argument_list|)
expr_stmt|;
name|scale_bbs_frequencies_int
argument_list|(
name|region_copy
argument_list|,
name|n_region
argument_list|,
name|entry_freq
argument_list|,
name|total_freq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copying_header
condition|)
block|{
name|loop
operator|->
name|header
operator|=
name|exit
operator|->
name|dest
expr_stmt|;
name|loop
operator|->
name|latch
operator|=
name|exit
operator|->
name|src
expr_stmt|;
block|}
comment|/* Redirect the entry and add the phi node arguments.  */
name|redirected
operator|=
name|redirect_edge_and_branch
argument_list|(
name|entry
argument_list|,
name|get_bb_copy
argument_list|(
name|entry
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|redirected
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|flush_pending_stmts
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Concerning updating of dominators:  We must recount dominators      for entry block and its copy.  Anything that is outside of the      region, but was dominated by something inside needs recounting as      well.  */
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|entry
operator|->
name|dest
argument_list|,
name|entry
operator|->
name|src
argument_list|)
expr_stmt|;
name|doms
index|[
name|n_doms
operator|++
index|]
operator|=
name|get_bb_original
argument_list|(
name|entry
operator|->
name|dest
argument_list|)
expr_stmt|;
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|doms
argument_list|,
name|n_doms
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|doms
argument_list|)
expr_stmt|;
comment|/* Add the other PHI node arguments.  */
name|add_phi_args_after_copy
argument_list|(
name|region_copy
argument_list|,
name|n_region
argument_list|)
expr_stmt|;
comment|/* Update the SSA web.  */
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_region_copy
condition|)
name|free
argument_list|(
name|region_copy
argument_list|)
expr_stmt|;
name|free_original_copy_tables
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* DEF_VEC_P(basic_block); DEF_VEC_ALLOC_P(basic_block,heap); */
end_comment

begin_comment
comment|/* Add all the blocks dominated by ENTRY to the array BBS_P.  Stop    adding blocks when the dominator traversal reaches EXIT.  This    function silently assumes that ENTRY strictly dominates EXIT.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|gather_blocks_in_sese_region
argument_list|(
name|basic_block
name|entry
argument_list|,
name|basic_block
name|exit
argument_list|,
name|VEC
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|bbs_p
argument_list|)
block|{
name|basic_block
name|son
decl_stmt|;
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|entry
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
block|{
name|VEC_safe_push
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
operator|*
name|bbs_p
argument_list|,
name|son
argument_list|)
expr_stmt|;
if|if
condition|(
name|son
operator|!=
name|exit
condition|)
name|gather_blocks_in_sese_region
argument_list|(
name|son
argument_list|,
name|exit
argument_list|,
name|bbs_p
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_struct
struct|struct
name|move_stmt_d
block|{
name|tree
name|block
decl_stmt|;
name|tree
name|from_context
decl_stmt|;
name|tree
name|to_context
decl_stmt|;
name|bitmap
name|vars_to_remove
decl_stmt|;
name|htab_t
name|new_label_map
decl_stmt|;
name|bool
name|remap_decls_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper for move_block_to_fn.  Set TREE_BLOCK in every expression    contained in *TP and change the DECL_CONTEXT of every local    variable referenced in *TP.  */
end_comment

begin_function
specifier|static
name|tree
name|move_stmt_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|move_stmt_d
modifier|*
name|p
init|=
operator|(
expr|struct
name|move_stmt_d
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|block
operator|&&
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
name|TREE_BLOCK
argument_list|(
name|t
argument_list|)
operator|=
name|p
operator|->
name|block
expr_stmt|;
if|if
condition|(
name|OMP_DIRECTIVE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|OMP_RETURN
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|OMP_CONTINUE
condition|)
block|{
comment|/* Do not remap variables inside OMP directives.  Variables 	 referenced in clauses and directive header belong to the 	 parent function and should not be moved into the child 	 function.  */
name|bool
name|save_remap_decls_p
init|=
name|p
operator|->
name|remap_decls_p
decl_stmt|;
name|p
operator|->
name|remap_decls_p
operator|=
name|false
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|move_stmt_r
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|remap_decls_p
operator|=
name|save_remap_decls_p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|p
operator|->
name|from_context
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|new_label_map
condition|)
block|{
name|struct
name|tree_map
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|t
expr_stmt|;
name|out
operator|=
name|htab_find_with_hash
argument_list|(
name|p
operator|->
name|new_label_map
argument_list|,
operator|&
name|in
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
operator|*
name|tp
operator|=
name|t
operator|=
name|out
operator|->
name|to
expr_stmt|;
block|}
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|p
operator|->
name|to_context
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|remap_decls_p
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|p
operator|->
name|to_context
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|struct
name|function
modifier|*
name|f
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|p
operator|->
name|to_context
argument_list|)
decl_stmt|;
name|f
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|t
argument_list|,
name|f
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
comment|/* Mark T to be removed from the original function, 	         otherwise it will be given a DECL_RTL when the 		 original function is expanded.  */
name|bitmap_set_bit
argument_list|(
name|p
operator|->
name|vars_to_remove
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Move basic block BB from function CFUN to function DEST_FN.  The    block is moved out of the original linked list and placed after    block AFTER in the new list.  Also, the block is removed from the    original array of blocks and placed in DEST_FN's array of blocks.    If UPDATE_EDGE_COUNT_P is true, the edge counts on both CFGs is    updated to reflect the moved edges.     On exit, local variables that need to be removed from    CFUN->UNEXPANDED_VAR_LIST will have been added to VARS_TO_REMOVE.  */
end_comment

begin_function
specifier|static
name|void
name|move_block_to_fn
parameter_list|(
name|struct
name|function
modifier|*
name|dest_cfun
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|after
parameter_list|,
name|bool
name|update_edge_count_p
parameter_list|,
name|bitmap
name|vars_to_remove
parameter_list|,
name|htab_t
name|new_label_map
parameter_list|,
name|int
name|eh_offset
parameter_list|)
block|{
name|struct
name|control_flow_graph
modifier|*
name|cfg
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|struct
name|move_stmt_d
name|d
decl_stmt|;
name|unsigned
name|old_len
decl_stmt|,
name|new_len
decl_stmt|;
name|basic_block
modifier|*
name|addr
decl_stmt|;
comment|/* Link BB to the new linked list.  */
name|move_block_after
argument_list|(
name|bb
argument_list|,
name|after
argument_list|)
expr_stmt|;
comment|/* Update the edge count in the corresponding flowgraphs.  */
if|if
condition|(
name|update_edge_count_p
condition|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|cfun
operator|->
name|cfg
operator|->
name|x_n_edges
operator|--
expr_stmt|;
name|dest_cfun
operator|->
name|cfg
operator|->
name|x_n_edges
operator|++
expr_stmt|;
block|}
comment|/* Remove BB from the original basic block array.  */
name|VEC_replace
argument_list|(
name|basic_block
argument_list|,
name|cfun
operator|->
name|cfg
operator|->
name|x_basic_block_info
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|cfg
operator|->
name|x_n_basic_blocks
operator|--
expr_stmt|;
comment|/* Grow DEST_CFUN's basic block array if needed.  */
name|cfg
operator|=
name|dest_cfun
operator|->
name|cfg
expr_stmt|;
name|cfg
operator|->
name|x_n_basic_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|index
operator|>
name|cfg
operator|->
name|x_last_basic_block
condition|)
name|cfg
operator|->
name|x_last_basic_block
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|old_len
operator|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|cfg
operator|->
name|x_basic_block_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cfg
operator|->
name|x_last_basic_block
operator|>=
name|old_len
condition|)
block|{
name|new_len
operator|=
name|cfg
operator|->
name|x_last_basic_block
operator|+
operator|(
name|cfg
operator|->
name|x_last_basic_block
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|cfg
operator|->
name|x_basic_block_info
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|addr
operator|=
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|cfg
operator|->
name|x_basic_block_info
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|new_len
operator|-
name|old_len
operator|)
argument_list|)
expr_stmt|;
block|}
name|VEC_replace
argument_list|(
name|basic_block
argument_list|,
name|cfg
operator|->
name|x_basic_block_info
argument_list|,
name|cfg
operator|->
name|x_last_basic_block
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* The statements in BB need to be associated with a new TREE_BLOCK.      Labels need to be associated with a new label-to-block map.  */
name|memset
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|vars_to_remove
operator|=
name|vars_to_remove
expr_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|int
name|region
decl_stmt|;
name|d
operator|.
name|from_context
operator|=
name|cfun
operator|->
name|decl
expr_stmt|;
name|d
operator|.
name|to_context
operator|=
name|dest_cfun
operator|->
name|decl
expr_stmt|;
name|d
operator|.
name|remap_decls_p
operator|=
name|true
expr_stmt|;
name|d
operator|.
name|new_label_map
operator|=
name|new_label_map
expr_stmt|;
if|if
condition|(
name|TREE_BLOCK
argument_list|(
name|stmt
argument_list|)
condition|)
name|d
operator|.
name|block
operator|=
name|DECL_INITIAL
argument_list|(
name|dest_cfun
operator|->
name|decl
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|stmt
argument_list|,
name|move_stmt_r
argument_list|,
operator|&
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|tree
name|label
init|=
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|int
name|uid
init|=
name|LABEL_DECL_UID
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|uid
operator|>
operator|-
literal|1
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|cfg
operator|->
name|x_label_to_block_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_len
operator|<=
operator|(
name|unsigned
operator|)
name|uid
condition|)
block|{
name|new_len
operator|=
literal|3
operator|*
name|uid
operator|/
literal|2
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|gc
argument_list|,
name|cfg
operator|->
name|x_label_to_block_map
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|addr
operator|=
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|cfg
operator|->
name|x_label_to_block_map
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|new_len
operator|-
name|old_len
operator|)
argument_list|)
expr_stmt|;
block|}
name|VEC_replace
argument_list|(
name|basic_block
argument_list|,
name|cfg
operator|->
name|x_label_to_block_map
argument_list|,
name|uid
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|basic_block
argument_list|,
name|cfun
operator|->
name|cfg
operator|->
name|x_label_to_block_map
argument_list|,
name|uid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|==
name|dest_cfun
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
name|dest_cfun
operator|->
name|last_label_uid
condition|)
name|dest_cfun
operator|->
name|last_label_uid
operator|=
name|uid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RESX_EXPR
operator|&&
name|eh_offset
operator|!=
literal|0
condition|)
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
name|eh_offset
argument_list|)
expr_stmt|;
name|region
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|>=
literal|0
condition|)
block|{
name|add_stmt_to_eh_region_fn
argument_list|(
name|dest_cfun
argument_list|,
name|stmt
argument_list|,
name|region
operator|+
name|eh_offset
argument_list|)
expr_stmt|;
name|remove_stmt_from_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Examine the statements in BB (which is in SRC_CFUN); find and return    the outermost EH region.  Use REGION as the incoming base EH region.  */
end_comment

begin_function
specifier|static
name|int
name|find_outermost_region_in_block
parameter_list|(
name|struct
name|function
modifier|*
name|src_cfun
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|region
parameter_list|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|int
name|stmt_region
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RESX_EXPR
condition|)
name|stmt_region
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stmt_region
operator|=
name|lookup_stmt_eh_region_fn
argument_list|(
name|src_cfun
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt_region
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|region
operator|<
literal|0
condition|)
name|region
operator|=
name|stmt_region
expr_stmt|;
elseif|else
if|if
condition|(
name|stmt_region
operator|!=
name|region
condition|)
block|{
name|region
operator|=
name|eh_region_outermost
argument_list|(
name|src_cfun
argument_list|,
name|stmt_region
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|region
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|region
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|new_label_mapper
parameter_list|(
name|tree
name|decl
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|htab_t
name|hash
init|=
operator|(
name|htab_t
operator|)
name|data
decl_stmt|;
name|struct
name|tree_map
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
argument_list|)
expr_stmt|;
name|m
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|hash
operator|=
name|DECL_UID
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|m
operator|->
name|from
operator|=
name|decl
expr_stmt|;
name|m
operator|->
name|to
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|LABEL_DECL_UID
argument_list|(
name|m
operator|->
name|to
argument_list|)
operator|=
name|LABEL_DECL_UID
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|hash
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|slot
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|m
expr_stmt|;
return|return
name|m
operator|->
name|to
return|;
block|}
end_function

begin_comment
comment|/* Move a single-entry, single-exit region delimited by ENTRY_BB and    EXIT_BB to function DEST_CFUN.  The whole region is replaced by a    single basic block in the original CFG and the new basic block is    returned.  DEST_CFUN must not have a CFG yet.     Note that the region need not be a pure SESE region.  Blocks inside    the region may contain calls to abort/exit.  The only restriction    is that ENTRY_BB should be the only entry point and it must    dominate EXIT_BB.     All local variables referenced in the region are assumed to be in    the corresponding BLOCK_VARS and unexpanded variable lists    associated with DEST_CFUN.  */
end_comment

begin_function
name|basic_block
name|move_sese_region_to_fn
parameter_list|(
name|struct
name|function
modifier|*
name|dest_cfun
parameter_list|,
name|basic_block
name|entry_bb
parameter_list|,
name|basic_block
name|exit_bb
parameter_list|)
block|{
name|VEC
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|)
operator|*
name|bbs
expr_stmt|;
name|basic_block
name|after
decl_stmt|,
name|bb
decl_stmt|,
modifier|*
name|entry_pred
decl_stmt|,
modifier|*
name|exit_succ
decl_stmt|;
name|struct
name|function
modifier|*
name|saved_cfun
decl_stmt|;
name|int
modifier|*
name|entry_flag
decl_stmt|,
modifier|*
name|exit_flag
decl_stmt|,
name|eh_offset
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num_entry_edges
decl_stmt|,
name|num_exit_edges
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bitmap
name|vars_to_remove
decl_stmt|;
name|htab_t
name|new_label_map
decl_stmt|;
name|saved_cfun
operator|=
name|cfun
expr_stmt|;
comment|/* Collect all the blocks in the region.  Manually add ENTRY_BB      because it won't be added by dfs_enumerate_from.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* If ENTRY does not strictly dominate EXIT, this cannot be an SESE      region.  */
name|gcc_assert
argument_list|(
name|entry_bb
operator|!=
name|exit_bb
operator|&&
operator|(
operator|!
name|exit_bb
operator|||
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|exit_bb
argument_list|,
name|entry_bb
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bbs
operator|=
name|NULL
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|bbs
argument_list|,
name|entry_bb
argument_list|)
expr_stmt|;
name|gather_blocks_in_sese_region
argument_list|(
name|entry_bb
argument_list|,
name|exit_bb
argument_list|,
operator|&
name|bbs
argument_list|)
expr_stmt|;
comment|/* Detach ENTRY_BB and EXIT_BB from CFUN->CFG.  We need to remember      the predecessor edges to ENTRY_BB and the successor edges to      EXIT_BB so that we can re-attach them to the new basic block that      will replace the region.  */
name|num_entry_edges
operator|=
name|EDGE_COUNT
argument_list|(
name|entry_bb
operator|->
name|preds
argument_list|)
expr_stmt|;
name|entry_pred
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_entry_edges
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|entry_flag
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_entry_edges
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|entry_bb
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|entry_flag
index|[
name|i
index|]
operator|=
name|e
operator|->
name|flags
expr_stmt|;
name|entry_pred
index|[
name|i
operator|++
index|]
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_bb
condition|)
block|{
name|num_exit_edges
operator|=
name|EDGE_COUNT
argument_list|(
name|exit_bb
operator|->
name|succs
argument_list|)
expr_stmt|;
name|exit_succ
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_exit_edges
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|exit_flag
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_exit_edges
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|exit_bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|exit_flag
index|[
name|i
index|]
operator|=
name|e
operator|->
name|flags
expr_stmt|;
name|exit_succ
index|[
name|i
operator|++
index|]
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|num_exit_edges
operator|=
literal|0
expr_stmt|;
name|exit_succ
operator|=
name|NULL
expr_stmt|;
name|exit_flag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Switch context to the child function to initialize DEST_FN's CFG.  */
name|gcc_assert
argument_list|(
name|dest_cfun
operator|->
name|cfg
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|cfun
operator|=
name|dest_cfun
expr_stmt|;
name|init_empty_tree_cfg
argument_list|()
expr_stmt|;
comment|/* Initialize EH information for the new function.  */
name|eh_offset
operator|=
literal|0
expr_stmt|;
name|new_label_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|saved_cfun
operator|->
name|eh
condition|)
block|{
name|int
name|region
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|basic_block
argument_list|,
name|bbs
argument_list|,
name|i
argument_list|,
name|bb
argument_list|)
condition|;
name|i
operator|++
control|)
name|region
operator|=
name|find_outermost_region_in_block
argument_list|(
name|saved_cfun
argument_list|,
name|bb
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|init_eh_for_function
argument_list|()
expr_stmt|;
if|if
condition|(
name|region
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_label_map
operator|=
name|htab_create
argument_list|(
literal|17
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|eh_offset
operator|=
name|duplicate_eh_regions
argument_list|(
name|saved_cfun
argument_list|,
name|new_label_mapper
argument_list|,
name|new_label_map
argument_list|,
name|region
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|cfun
operator|=
name|saved_cfun
expr_stmt|;
comment|/* Move blocks from BBS into DEST_CFUN.  */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|bbs
argument_list|)
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|after
operator|=
name|dest_cfun
operator|->
name|cfg
operator|->
name|x_entry_block_ptr
expr_stmt|;
name|vars_to_remove
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|basic_block
argument_list|,
name|bbs
argument_list|,
name|i
argument_list|,
name|bb
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* No need to update edge counts on the last block.  It has 	 already been updated earlier when we detached the region from 	 the original CFG.  */
name|move_block_to_fn
argument_list|(
name|dest_cfun
argument_list|,
name|bb
argument_list|,
name|after
argument_list|,
name|bb
operator|!=
name|exit_bb
argument_list|,
name|vars_to_remove
argument_list|,
name|new_label_map
argument_list|,
name|eh_offset
argument_list|)
expr_stmt|;
name|after
operator|=
name|bb
expr_stmt|;
block|}
if|if
condition|(
name|new_label_map
condition|)
name|htab_delete
argument_list|(
name|new_label_map
argument_list|)
expr_stmt|;
comment|/* Remove the variables marked in VARS_TO_REMOVE from      CFUN->UNEXPANDED_VAR_LIST.  Otherwise, they will be given a      DECL_RTL in the context of CFUN.  */
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|vars_to_remove
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|cfun
operator|->
name|unexpanded_var_list
init|;
operator|*
name|p
condition|;
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|vars_to_remove
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|vars_to_remove
argument_list|)
expr_stmt|;
comment|/* Rewire the entry and exit blocks.  The successor to the entry      block turns into the successor of DEST_FN's ENTRY_BLOCK_PTR in      the child function.  Similarly, the predecessor of DEST_FN's      EXIT_BLOCK_PTR turns into the predecessor of EXIT_BLOCK_PTR.  We      need to switch CFUN between DEST_CFUN and SAVED_CFUN so that the      various CFG manipulation function get to the right CFG.       FIXME, this is silly.  The CFG ought to become a parameter to      these helpers.  */
name|cfun
operator|=
name|dest_cfun
expr_stmt|;
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|entry_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_bb
condition|)
name|make_edge
argument_list|(
name|exit_bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cfun
operator|=
name|saved_cfun
expr_stmt|;
comment|/* Back in the original function, the SESE region has disappeared,      create a new basic block in its place.  */
name|bb
operator|=
name|create_empty_bb
argument_list|(
name|entry_pred
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entry_edges
condition|;
name|i
operator|++
control|)
name|make_edge
argument_list|(
name|entry_pred
index|[
name|i
index|]
argument_list|,
name|bb
argument_list|,
name|entry_flag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_exit_edges
condition|;
name|i
operator|++
control|)
name|make_edge
argument_list|(
name|bb
argument_list|,
name|exit_succ
index|[
name|i
index|]
argument_list|,
name|exit_flag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_bb
condition|)
block|{
name|free
argument_list|(
name|exit_flag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exit_succ
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entry_flag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry_pred
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|bbs
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Dump FUNCTION_DECL FN to file FILE using FLAGS (see TDF_* in tree.h)  */
end_comment

begin_function
name|void
name|dump_function_to_file
parameter_list|(
name|tree
name|fn
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|,
name|vars
decl_stmt|,
name|var
decl_stmt|;
name|bool
name|ignore_topmost_bind
init|=
name|false
decl_stmt|,
name|any_var
init|=
name|false
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|chain
decl_stmt|;
name|struct
name|function
modifier|*
name|saved_cfun
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s ("
argument_list|,
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|fn
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
condition|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|arg
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_DETAILS
condition|)
name|dump_eh_tree
argument_list|(
name|file
argument_list|,
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_RAW
condition|)
block|{
name|dump_node
argument_list|(
name|fn
argument_list|,
name|TDF_SLIM
operator||
name|flags
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Switch CFUN to point to FN.  */
name|saved_cfun
operator|=
name|cfun
expr_stmt|;
name|cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* When GIMPLE is lowered, the variables are no longer available in      BIND_EXPRs, so display them separately.  */
if|if
condition|(
name|cfun
operator|&&
name|cfun
operator|->
name|decl
operator|==
name|fn
operator|&&
name|cfun
operator|->
name|unexpanded_var_list
condition|)
block|{
name|ignore_topmost_bind
operator|=
name|true
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vars
operator|=
name|cfun
operator|->
name|unexpanded_var_list
init|;
name|vars
condition|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
control|)
block|{
name|var
operator|=
name|TREE_VALUE
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|print_generic_decl
argument_list|(
name|file
argument_list|,
name|var
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|any_var
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfun
operator|&&
name|cfun
operator|->
name|decl
operator|==
name|fn
operator|&&
name|cfun
operator|->
name|cfg
operator|&&
name|basic_block_info
condition|)
block|{
comment|/* Make a CFG based dump.  */
name|check_bb_profile
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_topmost_bind
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_var
operator|&&
name|n_basic_blocks
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|dump_generic_bb
argument_list|(
name|file
argument_list|,
name|bb
argument_list|,
literal|2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|check_bb_profile
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|indent
decl_stmt|;
comment|/* Make a tree based dump.  */
name|chain
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|TREE_CODE
argument_list|(
name|chain
argument_list|)
operator|==
name|BIND_EXPR
condition|)
block|{
if|if
condition|(
name|ignore_topmost_bind
condition|)
block|{
name|chain
operator|=
name|BIND_EXPR_BODY
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ignore_topmost_bind
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|any_var
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt_indented
argument_list|(
name|file
argument_list|,
name|chain
argument_list|,
name|flags
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_topmost_bind
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
comment|/* Restore CFUN.  */
name|cfun
operator|=
name|saved_cfun
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump FUNCTION_DECL FN to stderr using FLAGS (see TDF_* in tree.h)  */
end_comment

begin_function
name|void
name|debug_function
parameter_list|(
name|tree
name|fn
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dump_function_to_file
argument_list|(
name|fn
argument_list|,
name|stderr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty print of the loops intermediate representation.  */
end_comment

begin_function_decl
specifier|static
name|void
name|print_loop
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_pred_bbs
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|basic_block
name|bb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_succ_bbs
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|basic_block
name|bb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print on FILE the indexes for the predecessors of basic_block BB.  */
end_comment

begin_function
specifier|static
name|void
name|print_pred_bbs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb_%d "
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print on FILE the indexes for the successors of basic_block BB.  */
end_comment

begin_function
specifier|static
name|void
name|print_succ_bbs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb_%d "
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty print LOOP on FILE, indented INDENT spaces.  */
end_comment

begin_function
specifier|static
name|void
name|print_loop
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|char
modifier|*
name|s_indent
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|loop
operator|==
name|NULL
condition|)
return|return;
name|s_indent
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|size_t
operator|)
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|s_indent
argument_list|,
literal|' '
argument_list|,
operator|(
name|size_t
operator|)
name|indent
argument_list|)
expr_stmt|;
name|s_indent
index|[
name|indent
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Print the loop's header.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%sloop_%d\n"
argument_list|,
name|s_indent
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* Print the loop's body.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s{\n"
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|==
name|loop
condition|)
block|{
comment|/* Print the basic_block's header.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s  bb_%d (preds = {"
argument_list|,
name|s_indent
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_pred_bbs
argument_list|(
name|file
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}, succs = {"
argument_list|)
expr_stmt|;
name|print_succ_bbs
argument_list|(
name|file
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"})\n"
argument_list|)
expr_stmt|;
comment|/* Print the basic_block's body.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s  {\n"
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
name|tree_dump_bb
argument_list|(
name|bb
argument_list|,
name|file
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s  }\n"
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
block|}
name|print_loop
argument_list|(
name|file
argument_list|,
name|loop
operator|->
name|inner
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s}\n"
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
name|print_loop
argument_list|(
name|file
argument_list|,
name|loop
operator|->
name|next
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Follow a CFG edge from the entry point of the program, and on entry    of a loop, pretty print the loop structure on FILE.  */
end_comment

begin_function
name|void
name|print_loop_ir
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|&&
name|bb
operator|->
name|loop_father
condition|)
name|print_loop
argument_list|(
name|file
argument_list|,
name|bb
operator|->
name|loop_father
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging loops structure at tree level.  */
end_comment

begin_function
name|void
name|debug_loop_ir
parameter_list|(
name|void
parameter_list|)
block|{
name|print_loop_ir
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if BB ends with a call, possibly followed by some    instructions that must stay with the call.  Return false,    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_block_ends_with_call_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
return|return
name|get_call_expr_in
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if BB ends with a conditional branch.  Return false,    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_block_ends_with_condjump_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
return|return
operator|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if we need to add fake edge to exit at statement T.    Helper function for tree_flow_call_edges_add.  */
end_comment

begin_function
specifier|static
name|bool
name|need_fake_edge_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|call
decl_stmt|;
comment|/* NORETURN and LONGJMP calls already have an edge to exit.      CONST and PURE calls do not need one.      We don't currently check for CONST and PURE here, although      it would be a good idea, because those attributes are      figured out from the RTL in mark_constant_function, and      the counter incrementation code from -fprofile-arcs      leads to different results from -fbranch-probabilities.  */
name|call
operator|=
name|get_call_expr_in
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|&&
operator|!
operator|(
name|call_expr_flags
argument_list|(
name|call
argument_list|)
operator|&
name|ECF_NORETURN
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ASM_EXPR
operator|&&
operator|(
name|ASM_VOLATILE_P
argument_list|(
name|t
argument_list|)
operator|||
name|ASM_INPUT_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add fake edges to the function exit for any non constant and non    noreturn calls, volatile inline assembly in the bitmap of blocks    specified by BLOCKS or to the whole CFG if BLOCKS is zero.  Return    the number of blocks that were split.     The goal is to expose cases in which entering a basic block does    not imply that all subsequent instructions must be executed.  */
end_comment

begin_function
specifier|static
name|int
name|tree_flow_call_edges_add
parameter_list|(
name|sbitmap
name|blocks
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|blocks_split
init|=
literal|0
decl_stmt|;
name|int
name|last_bb
init|=
name|last_basic_block
decl_stmt|;
name|bool
name|check_last_block
init|=
name|false
decl_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|==
name|NUM_FIXED_BLOCKS
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|blocks
condition|)
name|check_last_block
operator|=
name|true
expr_stmt|;
else|else
name|check_last_block
operator|=
name|TEST_BIT
argument_list|(
name|blocks
argument_list|,
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* In the last basic block, before epilogue generation, there will be      a fallthru edge to EXIT.  Special care is required if the last insn      of the last basic block is a call because make_edge folds duplicate      edges, which would result in the fallthru edge also being marked      fake, which would result in the fallthru edge being removed by      remove_fake_edges, which would result in an invalid CFG.       Moreover, we can't elide the outgoing fake edge, since the block      profiler needs to take this into account in order to solve the minimal      spanning tree in the case that the call doesn't return.       Handle this by adding a dummy instruction in a new last basic block.  */
if|if
condition|(
name|check_last_block
condition|)
block|{
name|basic_block
name|bb
init|=
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|t
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|need_fake_edge_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|build_empty_stmt
argument_list|()
argument_list|)
expr_stmt|;
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Now add fake edges to the function exit for any non constant      calls since there is no way that we can determine if they will      return or not...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|last_stmt
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
continue|continue;
if|if
condition|(
name|blocks
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|blocks
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
block|{
name|last_stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
do|do
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fake_edge_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* The handling above of the final block before the 		     epilogue should be enough to verify that there is 		     no edge to the exit block in CFG already. 		     Calling make_edge in such case would cause us to 		     mark that edge as fake and remove it later.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|stmt
operator|==
name|last_stmt
condition|)
block|{
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Note that the following may create a new basic block 		     and renumber the existing basic blocks.  */
if|if
condition|(
name|stmt
operator|!=
name|last_stmt
condition|)
block|{
name|e
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|blocks_split
operator|++
expr_stmt|;
block|}
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
do|;
block|}
block|}
if|if
condition|(
name|blocks_split
condition|)
name|verify_flow_info
argument_list|()
expr_stmt|;
return|return
name|blocks_split
return|;
block|}
end_function

begin_comment
comment|/* Purge dead abnormal call edges from basic block BB.  */
end_comment

begin_function
name|bool
name|tree_purge_dead_abnormal_call_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|bool
name|changed
init|=
name|tree_purge_dead_eh_edges
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_function_has_nonlocal_label
condition|)
block|{
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|stmt
operator|&&
name|tree_can_make_abnormal_goto
argument_list|(
name|stmt
argument_list|)
operator|)
condition|)
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
comment|/* See tree_purge_dead_eh_edges below.  */
if|if
condition|(
name|changed
condition|)
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Purge dead EH edges from basic block BB.  */
end_comment

begin_function
name|bool
name|tree_purge_dead_eh_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|tree_can_throw_internal
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
comment|/* Removal of dead EH edges might change dominators of not      just immediate successors.  E.g. when bb1 is changed so that      it no longer can throw and bb1->bb3 and bb1->bb4 are dead      eh edges purged by this function in:            0 	  / \ 	 v   v 	 1-->2         / \  |        v   v |        3-->4 |         \    v 	 --->5 	     | 	     -      idom(bb5) must be recomputed.  For now just free the dominance      info.  */
if|if
condition|(
name|changed
condition|)
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_function
name|bool
name|tree_purge_all_dead_eh_edges
parameter_list|(
name|bitmap
name|blocks
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|changed
operator||=
name|tree_purge_dead_eh_edges
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* This function is called whenever a new edge is created or    redirected.  */
end_comment

begin_function
specifier|static
name|void
name|tree_execute_on_growing_pred
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|phi_nodes
argument_list|(
name|bb
argument_list|)
condition|)
name|reserve_phi_args_for_new_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called immediately before edge E is removed from    the edge vector E->dest->preds.  */
end_comment

begin_function
specifier|static
name|void
name|tree_execute_on_shrinking_pred
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
name|remove_phi_args
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------   Helper functions for Loop versioning   ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Adjust phi nodes for 'first' basic block.  'second' basic block is a copy    of 'first'. Both of them are dominated by 'new_head' basic block. When    'new_head' was created by 'second's incoming edge it received phi arguments    on the edge by split_edge(). Later, additional edge 'e' was created to    connect 'new_head' and 'first'. Now this routine adds phi args on this    additional edge 'e' that new_head to second edge received as part of edge    splitting. */
end_comment

begin_function
specifier|static
name|void
name|tree_lv_adjust_loop_header_phi
parameter_list|(
name|basic_block
name|first
parameter_list|,
name|basic_block
name|second
parameter_list|,
name|basic_block
name|new_head
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|tree
name|phi1
decl_stmt|,
name|phi2
decl_stmt|;
name|edge
name|e2
init|=
name|find_edge
argument_list|(
name|new_head
argument_list|,
name|second
argument_list|)
decl_stmt|;
comment|/* Because NEW_HEAD has been created by splitting SECOND's incoming      edge, we should always have an edge from NEW_HEAD to SECOND.  */
name|gcc_assert
argument_list|(
name|e2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Browse all 'second' basic block phi nodes and add phi args to      edge 'e' for 'first' head. PHI args are always in correct order.  */
for|for
control|(
name|phi2
operator|=
name|phi_nodes
argument_list|(
name|second
argument_list|)
operator|,
name|phi1
operator|=
name|phi_nodes
argument_list|(
name|first
argument_list|)
init|;
name|phi2
operator|&&
name|phi1
condition|;
name|phi2
operator|=
name|PHI_CHAIN
argument_list|(
name|phi2
argument_list|)
operator|,
name|phi1
operator|=
name|PHI_CHAIN
argument_list|(
name|phi1
argument_list|)
control|)
block|{
name|tree
name|def
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi2
argument_list|,
name|e2
operator|->
name|dest_idx
argument_list|)
decl_stmt|;
name|add_phi_arg
argument_list|(
name|phi1
argument_list|,
name|def
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adds a if else statement to COND_BB with condition COND_EXPR.    SECOND_HEAD is the destination of the THEN and FIRST_HEAD is    the destination of the ELSE part.  */
end_comment

begin_function
specifier|static
name|void
name|tree_lv_add_condition_to_bb
parameter_list|(
name|basic_block
name|first_head
parameter_list|,
name|basic_block
name|second_head
parameter_list|,
name|basic_block
name|cond_bb
parameter_list|,
name|void
modifier|*
name|cond_e
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|goto1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|goto2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|new_cond_expr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cond_expr
init|=
operator|(
name|tree
operator|)
name|cond_e
decl_stmt|;
name|edge
name|e0
decl_stmt|;
comment|/* Build new conditional expr */
name|goto1
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|first_head
argument_list|)
argument_list|)
expr_stmt|;
name|goto2
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|second_head
argument_list|)
argument_list|)
expr_stmt|;
name|new_cond_expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond_expr
argument_list|,
name|goto1
argument_list|,
name|goto2
argument_list|)
expr_stmt|;
comment|/* Add new cond in cond_bb.  */
name|bsi
operator|=
name|bsi_start
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|new_cond_expr
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
comment|/* Adjust edges appropriately to connect new head with first head      as well as second head.  */
name|e0
operator|=
name|single_succ_edge
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|e0
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e0
operator|->
name|flags
operator||=
name|EDGE_FALSE_VALUE
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|cfg_hooks
name|tree_cfg_hooks
init|=
block|{
literal|"tree"
block|,
name|tree_verify_flow_info
block|,
name|tree_dump_bb
block|,
comment|/* dump_bb  */
name|create_bb
block|,
comment|/* create_basic_block  */
name|tree_redirect_edge_and_branch
block|,
comment|/* redirect_edge_and_branch  */
name|tree_redirect_edge_and_branch_force
block|,
comment|/* redirect_edge_and_branch_force  */
name|remove_bb
block|,
comment|/* delete_basic_block  */
name|tree_split_block
block|,
comment|/* split_block  */
name|tree_move_block_after
block|,
comment|/* move_block_after  */
name|tree_can_merge_blocks_p
block|,
comment|/* can_merge_blocks_p  */
name|tree_merge_blocks
block|,
comment|/* merge_blocks  */
name|tree_predict_edge
block|,
comment|/* predict_edge  */
name|tree_predicted_by_p
block|,
comment|/* predicted_by_p  */
name|tree_can_duplicate_bb_p
block|,
comment|/* can_duplicate_block_p  */
name|tree_duplicate_bb
block|,
comment|/* duplicate_block  */
name|tree_split_edge
block|,
comment|/* split_edge  */
name|tree_make_forwarder_block
block|,
comment|/* make_forward_block  */
name|NULL
block|,
comment|/* tidy_fallthru_edge  */
name|tree_block_ends_with_call_p
block|,
comment|/* block_ends_with_call_p */
name|tree_block_ends_with_condjump_p
block|,
comment|/* block_ends_with_condjump_p */
name|tree_flow_call_edges_add
block|,
comment|/* flow_call_edges_add */
name|tree_execute_on_growing_pred
block|,
comment|/* execute_on_growing_pred */
name|tree_execute_on_shrinking_pred
block|,
comment|/* execute_on_shrinking_pred */
name|tree_duplicate_loop_to_header_edge
block|,
comment|/* duplicate loop for trees */
name|tree_lv_add_condition_to_bb
block|,
comment|/* lv_add_condition_to_bb */
name|tree_lv_adjust_loop_header_phi
block|,
comment|/* lv_adjust_loop_header_phi*/
name|extract_true_false_edges_from_block
block|,
comment|/* extract_cond_bb_edges */
name|flush_pending_stmts
comment|/* flush_pending_stmts */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Split all critical edges.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|split_critical_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* split_edge can redirect edges out of SWITCH_EXPRs, which can get      expensive.  So we want to enable recording of edge to CASE_LABEL_EXPR      mappings around the calls to split_edge.  */
name|start_recording_case_labels
argument_list|()
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
block|{
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|end_recording_case_labels
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_split_crit_edges
init|=
block|{
literal|"crited"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|split_critical_edges
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_SPLIT_EDGES
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties required */
name|PROP_no_crit_edges
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return EXP if it is a valid GIMPLE rvalue, else gimplify it into    a temporary, make sure and register it to be renamed if necessary,    and finally return the temporary.  Put the statements to compute    EXP before the current statement in BSI.  */
end_comment

begin_function
name|tree
name|gimplify_val
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|new_stmt
decl_stmt|,
name|orig_stmt
decl_stmt|;
if|if
condition|(
name|is_gimple_val
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
name|t
operator|=
name|make_rename_temp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|orig_stmt
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|new_stmt
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|orig_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_BLOCK
argument_list|(
name|new_stmt
argument_list|)
operator|=
name|TREE_BLOCK
argument_list|(
name|orig_stmt
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|new_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_ssa_p
condition|)
name|mark_new_vars_to_rename
argument_list|(
name|new_stmt
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a ternary operation and gimplify it.  Emit code before BSI.    Return the gimple_val holding the result.  */
end_comment

begin_function
name|tree
name|gimplify_build3
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|,
name|tree
name|c
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
name|ret
operator|=
name|fold_build3
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|gimplify_val
argument_list|(
name|bsi
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a binary operation and gimplify it.  Emit code before BSI.    Return the gimple_val holding the result.  */
end_comment

begin_function
name|tree
name|gimplify_build2
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
name|ret
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|gimplify_val
argument_list|(
name|bsi
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a unary operation and gimplify it.  Emit code before BSI.    Return the gimple_val holding the result.  */
end_comment

begin_function
name|tree
name|gimplify_build1
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|a
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
name|ret
operator|=
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|gimplify_val
argument_list|(
name|bsi
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit return warnings.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_warn_function_return
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|source_location
name|location
decl_stmt|;
else|#
directive|else
name|location_t
modifier|*
name|locus
decl_stmt|;
endif|#
directive|endif
name|tree
name|last
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* If we have a path to EXIT, then we do return.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|location
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
else|#
directive|else
name|locus
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
block|{
name|last
operator|=
name|last_stmt
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|RETURN_EXPR
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|&&
operator|(
name|location
operator|=
name|EXPR_LOCATION
argument_list|(
name|last
argument_list|)
operator|)
operator|!=
name|UNKNOWN_LOCATION
condition|)
else|#
directive|else
operator|&&
operator|(
name|locus
operator|=
name|EXPR_LOCUS
argument_list|(
name|last
argument_list|)
operator|)
operator|!=
name|NULL
block|)
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
if|if
condition|(
name|location
operator|==
name|UNKNOWN_LOCATION
condition|)
name|location
operator|=
name|cfun
operator|->
name|function_end_locus
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%H%<noreturn%> function does return"
argument_list|,
operator|&
name|location
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|locus
condition|)
name|locus
operator|=
operator|&
name|cfun
operator|->
name|function_end_locus
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%H%<noreturn%> function does return"
argument_list|,
name|locus
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* If we see "return;" in some basic block, then we do reach the end      without returning a value.  */
end_comment

begin_elseif
elseif|else
if|if
condition|(
name|warn_return_type
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
block|{
name|tree
name|last
init|=
name|last_stmt
argument_list|(
name|e
operator|->
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|last
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|location
operator|=
name|EXPR_LOCATION
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|==
name|UNKNOWN_LOCATION
condition|)
name|location
operator|=
name|cfun
operator|->
name|function_end_locus
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hcontrol reaches end of non-void function"
argument_list|,
operator|&
name|location
argument_list|)
expr_stmt|;
else|#
directive|else
name|locus
operator|=
name|EXPR_LOCUS
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locus
condition|)
name|locus
operator|=
operator|&
name|cfun
operator|->
name|function_end_locus
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hcontrol reaches end of non-void function"
argument_list|,
name|locus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_NO_WARNING
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_elseif

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/* Given a basic block B which ends with a conditional and has    precisely two successors, determine which of the edges is taken if    the conditional is true and which is taken if the conditional is    false.  Set TRUE_EDGE and FALSE_EDGE appropriately.  */
end_comment

begin_macro
unit|void
name|extract_true_false_edges_from_block
argument_list|(
argument|basic_block b
argument_list|,
argument|edge *true_edge
argument_list|,
argument|edge *false_edge
argument_list|)
end_macro

begin_block
block|{
name|edge
name|e
init|=
name|EDGE_SUCC
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
block|{
operator|*
name|true_edge
operator|=
name|e
expr_stmt|;
operator|*
name|false_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|false_edge
operator|=
name|e
expr_stmt|;
operator|*
name|true_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_warn_function_return
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|execute_warn_function_return
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Emit noreturn warnings.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_warn_function_noreturn
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|warn_missing_noreturn
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|lang_hooks
operator|.
name|function
operator|.
name|missing_noreturn_ok_p
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wmissing_noreturn
argument_list|,
literal|"%Jfunction might be possible candidate "
literal|"for attribute %<noreturn%>"
argument_list|,
name|cfun
operator|->
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_warn_function_noreturn
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|execute_warn_function_noreturn
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

