begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Forward propagation of expressions for single use variables.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* This pass propagates the RHS of assignment statements into use    sites of the LHS of the assignment.  It's basically a specialized    form of tree combination.   It is hoped all of this can disappear    when we have a generalized tree combiner.     Note carefully that after propagation the resulting statement    must still be a proper gimple statement.  Right now we simply    only perform propagations we know will result in valid gimple    code.  One day we'll want to generalize this code.     One class of common cases we handle is forward propagating a single use    variable into a COND_EXPR.         bb0:        x = a COND b;        if (x) goto ... else goto ...     Will be transformed into:       bb0:        if (a COND b) goto ... else goto ...      Similarly for the tests (x == 0), (x != 0), (x == 1) and (x != 1).     Or (assuming c1 and c2 are constants):       bb0:        x = a + c1;          if (x EQ/NEQ c2) goto ... else goto ...     Will be transformed into:       bb0:         if (a EQ/NEQ (c2 - c1)) goto ... else goto ...     Similarly for x = a - c1.         Or       bb0:        x = !a        if (x) goto ... else goto ...     Will be transformed into:       bb0:         if (a == 0) goto ... else goto ...     Similarly for the tests (x == 0), (x != 0), (x == 1) and (x != 1).    For these cases, we propagate A into all, possibly more than one,    COND_EXPRs that use X.     Or       bb0:        x = (typecast) a        if (x) goto ... else goto ...     Will be transformed into:       bb0:         if (a != 0) goto ... else goto ...     (Assuming a is an integral type and x is a boolean or x is an     integral and a is a boolean.)     Similarly for the tests (x == 0), (x != 0), (x == 1) and (x != 1).    For these cases, we propagate A into all, possibly more than one,    COND_EXPRs that use X.     In addition to eliminating the variable and the statement which assigns    a value to the variable, we may be able to later thread the jump without    adding insane complexity in the dominator optimizer.     Also note these transformations can cascade.  We handle this by having    a worklist of COND_EXPR statements to examine.  As we make a change to    a statement, we put it back on the worklist to examine on the next    iteration of the main loop.     A second class of propagation opportunities arises for ADDR_EXPR    nodes.       ptr =&x->y->z;      res = *ptr;     Will get turned into       res = x->y->z;     Or       ptr =&x[0];      ptr2 = ptr +<constant>;     Will get turned into       ptr2 =&x[constant/elementsize];    Or       ptr =&x[0];      offset = index * element_size;      offset_p = (pointer) offset;      ptr2 = ptr + offset_p    Will get turned into:       ptr2 =&x[index];    We also propagate casts into SWITCH_EXPR and COND_EXPR conditions to   allow us to remove the cast and {NOT_EXPR,NEG_EXPR} into a subsequent   {NOT_EXPR,NEG_EXPR}.     This will (of course) be extended as other needs arise.  */
end_comment

begin_comment
comment|/* Set to true if we delete EH edges during the optimization.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|cfg_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given an SSA_NAME VAR, return true if and only if VAR is defined by    a comparison.  */
end_comment

begin_function
specifier|static
name|bool
name|ssa_name_defined_by_comparison_p
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|tree
name|def
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|COMPARISON_CLASS_P
argument_list|(
name|rhs
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Forward propagate a single-use variable into COND once.  Return a    new condition if successful.  Return NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|forward_propagate_into_cond_1
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
modifier|*
name|test_var_p
parameter_list|)
block|{
name|tree
name|new_cond
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|tree_code
name|cond_code
init|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|tree
name|test_var
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|tree
name|def_rhs
decl_stmt|;
comment|/* If the condition is not a lone variable or an equality test of an      SSA_NAME against an integral constant, then we do not have an      optimizable case.       Note these conditions also ensure the COND_EXPR has no      virtual operands or other side effects.  */
if|if
condition|(
name|cond_code
operator|!=
name|SSA_NAME
operator|&&
operator|!
operator|(
operator|(
name|cond_code
operator|==
name|EQ_EXPR
operator|||
name|cond_code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Extract the single variable used in the test into TEST_VAR.  */
if|if
condition|(
name|cond_code
operator|==
name|SSA_NAME
condition|)
name|test_var
operator|=
name|cond
expr_stmt|;
else|else
name|test_var
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now get the defining statement for TEST_VAR.  Skip this case if      it's not defined by some MODIFY_EXPR.  */
name|def
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|test_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|def_rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If TEST_VAR is set by adding or subtracting a constant      from an SSA_NAME, then it is interesting to us as we      can adjust the constant in the conditional and thus      eliminate the arithmetic operation.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* The first operand must be an SSA_NAME and the second 	 operand must be a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|op1
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't propagate if the first operand occurs in 	 an abnormal PHI.  */
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|has_single_use
argument_list|(
name|test_var
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|new_code
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* If the variable was defined via X + C, then we must 	     subtract C from the constant in the conditional. 	     Otherwise we add C to the constant in the 	     conditional.  The result must fold into a valid 	     gimple operand to be optimizable.  */
name|new_code
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
name|t
operator|=
name|int_const_binop
argument_list|(
name|new_code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|new_cond
operator|=
name|build2
argument_list|(
name|cond_code
argument_list|,
name|boolean_type_node
argument_list|,
name|op0
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These cases require comparisons of a naked SSA_NAME or      comparison of an SSA_NAME against zero or one.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If TEST_VAR is set from a relational operation 	 between two SSA_NAMEs or a combination of an SSA_NAME 	 and a constant, then it is interesting.  */
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|def_rhs
argument_list|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Both operands of DEF_RHS must be SSA_NAMEs or 	     constants.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|op0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't propagate if the first operand occurs in 	     an abnormal PHI.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't propagate if the second operand occurs in 	     an abnormal PHI.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|has_single_use
argument_list|(
name|test_var
argument_list|)
condition|)
block|{
comment|/* TEST_VAR was set from a relational operator.  */
name|new_cond
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
argument_list|,
name|boolean_type_node
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Invert the conditional if necessary.  */
if|if
condition|(
operator|(
name|cond_code
operator|==
name|EQ_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|cond_code
operator|==
name|NE_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|new_cond
operator|=
name|invert_truthvalue
argument_list|(
name|new_cond
argument_list|)
expr_stmt|;
comment|/* If we did not get a simple relational 		     expression or bare SSA_NAME, then we can 		     not optimize this case.  */
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|new_cond
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|new_cond
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|new_cond
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
comment|/* If TEST_VAR is set from a TRUTH_NOT_EXPR, then it 	 is interesting.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
name|enum
name|tree_code
name|new_code
decl_stmt|;
name|def_rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DEF_RHS must be an SSA_NAME or constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|def_rhs
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't propagate if the operand occurs in 	     an abnormal PHI.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|def_rhs
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|cond_code
operator|==
name|SSA_NAME
operator|||
operator|(
name|cond_code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|cond_code
operator|==
name|EQ_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|new_code
operator|=
name|EQ_EXPR
expr_stmt|;
else|else
name|new_code
operator|=
name|NE_EXPR
expr_stmt|;
name|new_cond
operator|=
name|build2
argument_list|(
name|new_code
argument_list|,
name|boolean_type_node
argument_list|,
name|def_rhs
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|def_rhs
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If TEST_VAR was set from a cast of an integer type 	 to a boolean type or a cast of a boolean to an 	 integral, then it is interesting.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|outer_type
decl_stmt|;
name|tree
name|inner_type
decl_stmt|;
name|outer_type
operator|=
name|TREE_TYPE
argument_list|(
name|def_rhs
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|outer_type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|outer_type
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|ssa_name_defined_by_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
name|NULL_TREE
return|;
comment|/* Don't propagate if the operand occurs in 	     an abnormal PHI.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|has_single_use
argument_list|(
name|test_var
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|new_code
decl_stmt|;
name|tree
name|new_arg
decl_stmt|;
if|if
condition|(
name|cond_code
operator|==
name|SSA_NAME
operator|||
operator|(
name|cond_code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|cond_code
operator|==
name|EQ_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|new_code
operator|=
name|NE_EXPR
expr_stmt|;
else|else
name|new_code
operator|=
name|EQ_EXPR
expr_stmt|;
name|new_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_cond
operator|=
name|build2
argument_list|(
name|new_code
argument_list|,
name|boolean_type_node
argument_list|,
name|new_arg
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|test_var_p
operator|=
name|test_var
expr_stmt|;
return|return
name|new_cond
return|;
block|}
end_function

begin_comment
comment|/* COND is a condition of the form:       x == const or x != const     Look back to x's defining statement and see if x is defined as       x = (type) y;     If const is unchanged if we convert it to type, then we can build    the equivalent expression:         y == const or y != const     Which may allow further optimizations.     Return the equivalent comparison or NULL if no such equivalent comparison    was found.  */
end_comment

begin_function
specifier|static
name|tree
name|find_equivalent_equality_comparison
parameter_list|(
name|tree
name|cond
parameter_list|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|op0
argument_list|)
decl_stmt|;
while|while
condition|(
name|def_stmt
operator|&&
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OP0 might have been a parameter, so first make sure it      was defined by a MODIFY_EXPR.  */
if|if
condition|(
name|def_stmt
operator|&&
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|def_rhs
init|=
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If either operand to the comparison is a pointer to 	 a function, then we can not apply this optimization 	 as some targets require function pointers to be 	 canonicalized and in this case this optimization would 	 eliminate a necessary canonicalization.  */
if|if
condition|(
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Now make sure the RHS of the MODIFY_EXPR is a typecast.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|def_rhs_inner
init|=
name|TREE_OPERAND
argument_list|(
name|def_rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|def_rhs_inner_type
init|=
name|TREE_TYPE
argument_list|(
name|def_rhs_inner
argument_list|)
decl_stmt|;
name|tree
name|new
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|def_rhs_inner_type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|def_rhs
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If the inner type of the conversion is a pointer to 	     a function, then we can not apply this optimization 	     as some targets require function pointers to be 	     canonicalized.  This optimization would result in 	     canonicalization of the pointer when it was not originally 	     needed/intended.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|def_rhs_inner_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|def_rhs_inner_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|NULL
return|;
comment|/* What we want to prove is that if we convert OP1 to 	     the type of the object inside the NOP_EXPR that the 	     result is still equivalent to SRC.   	     If that is true, the build and return new equivalent 	     condition which uses the source of the typecast and the 	     new constant (which has only changed its type).  */
name|new
operator|=
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|def_rhs
argument_list|)
argument_list|,
name|def_rhs_inner_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_val
argument_list|(
name|new
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|new
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|def_rhs_inner
argument_list|,
name|new
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* STMT is a COND_EXPR     This routine attempts to find equivalent forms of the condition    which we may be able to optimize better.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_cond
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* First see if we have test of an SSA_NAME against a constant 	     where the SSA_NAME is defined by an earlier typecast which 	     is irrelevant when performing tests against the given 	     constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
condition|)
block|{
name|tree
name|new_cond
init|=
name|find_equivalent_equality_comparison
argument_list|(
name|cond
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_cond
condition|)
block|{
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|new_cond
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Forward propagate a single-use variable into COND_EXPR as many    times as possible.  */
end_comment

begin_function
specifier|static
name|void
name|forward_propagate_into_cond
parameter_list|(
name|tree
name|cond_expr
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cond_expr
argument_list|)
operator|==
name|COND_EXPR
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|test_var
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|cond_expr
argument_list|)
decl_stmt|;
name|tree
name|new_cond
init|=
name|forward_propagate_into_cond_1
argument_list|(
name|cond
argument_list|,
operator|&
name|test_var
argument_list|)
decl_stmt|;
comment|/* Return if unsuccessful.  */
if|if
condition|(
name|new_cond
operator|==
name|NULL_TREE
condition|)
break|break;
comment|/* Dump details.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Replaced '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|cond
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"' with '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|new_cond
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
name|COND_EXPR_COND
argument_list|(
name|cond_expr
argument_list|)
operator|=
name|new_cond
expr_stmt|;
name|update_stmt
argument_list|(
name|cond_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_zero_uses
argument_list|(
name|test_var
argument_list|)
condition|)
block|{
name|tree
name|def
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|test_var
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There are further simplifications that can be performed      on COND_EXPRs.  Specifically, when comparing an SSA_NAME      against a constant where the SSA_NAME is the result of a      conversion.  Perhaps this should be folded into the rest      of the COND_EXPR simplification code.  */
name|simplify_cond
argument_list|(
name|cond_expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just substituted an ADDR_EXPR into stmt.  Update all the     relevant data structures to match.  */
end_comment

begin_function
specifier|static
name|void
name|tidy_after_forward_propagate_addr
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
comment|/* We may have turned a trapping insn into a non-trapping insn.  */
if|if
condition|(
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|)
operator|&&
name|tree_purge_dead_eh_edges
argument_list|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
name|cfg_changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mark_new_vars_to_rename
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* STMT defines LHS which is contains the address of the 0th element    in an array.  USE_STMT uses LHS to compute the address of an    arbitrary element within the array.  The (variable) byte offset    of the element is contained in OFFSET.     We walk back through the use-def chains of OFFSET to verify that    it is indeed computing the offset of an element within the array    and extract the index corresponding to the given byte offset.     We then try to fold the entire address expression into a form&array[index].     If we are successful, we replace the right hand side of USE_STMT    with the new address computation.  */
end_comment

begin_function
specifier|static
name|bool
name|forward_propagate_addr_into_variable_array_index
parameter_list|(
name|tree
name|offset
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|use_stmt
parameter_list|)
block|{
name|tree
name|index
decl_stmt|;
comment|/* The offset must be defined by a simple MODIFY_EXPR statement.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
comment|/* The RHS of the statement which defines OFFSET must be a gimple      cast of another SSA_NAME.  */
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_cast
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
comment|/* Get the defining statement of the offset before type      conversion.  */
name|offset
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* The statement which defines OFFSET before type conversion      must be a simple MODIFY_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
comment|/* The RHS of the statement which defines OFFSET must be a      multiplication of an object by the size of the array elements.       This implicitly verifies that the size of the array elements      is constant.  */
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|MULT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|!
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The first operand to the MULT_EXPR is the desired index.  */
name|index
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Replace the pointer addition with array indexing.  */
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|unshare_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|index
expr_stmt|;
comment|/* That should have created gimple, so there is no need to      record information to undo the propagation.  */
name|fold_stmt_inplace
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
name|tidy_after_forward_propagate_addr
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* STMT is a statement of the form SSA_NAME = ADDR_EXPR<whatever>.     Try to forward propagate the ADDR_EXPR into the use USE_STMT.    Often this will allow for removal of an ADDR_EXPR and INDIRECT_REF    node or for recovery of array indexing from pointer arithmetic.        CHANGED is an optional pointer to a boolean variable set to true if    either the LHS or RHS was changed in the USE_STMT.       Return true if the propagation was successful (the propagation can    be not totally successful, yet things may have been changed).  */
end_comment

begin_function
specifier|static
name|bool
name|forward_propagate_addr_expr_1
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|use_stmt
parameter_list|,
name|bool
modifier|*
name|changed
parameter_list|)
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|array_ref
decl_stmt|;
comment|/* Strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS.       ADDR_EXPR will not appear on the LHS.  */
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now see if the LHS node is an INDIRECT_REF using NAME.  If so,       propagate the ADDR_EXPR into the use of NAME and fold the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|==
name|name
condition|)
block|{
comment|/* This should always succeed in creating gimple, so there is 	 no need to save enough state to undo this propagation.  */
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|=
name|unshare_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fold_stmt_inplace
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
name|tidy_after_forward_propagate_addr
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
block|}
comment|/* Trivial case.  The use statement could be a trivial copy.  We      go ahead and handle that case here since it's trivial and      removes the need to run copy-prop before this pass to get      the best results.  Also note that by handling this case here      we can catch some cascading effects, ie the single use is      in a copy, and the copy is used later by a single INDIRECT_REF      for example.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
operator|==
name|name
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|unshare_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tidy_after_forward_propagate_addr
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Strip away any outer COMPONENT_REF, ARRAY_REF or ADDR_EXPR      nodes from the RHS.  */
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now see if the RHS node is an INDIRECT_REF using NAME.  If so,       propagate the ADDR_EXPR into the use of NAME and fold the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|name
condition|)
block|{
comment|/* This should always succeed in creating gimple, so there is          no need to save enough state to undo this propagation.  */
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|unshare_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fold_stmt_inplace
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
name|tidy_after_forward_propagate_addr
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* The remaining cases are all for turning pointer arithmetic into      array indexing.  They only apply when we have the address of      element zero in an array.  If that is not the case then there      is nothing to do.  */
name|array_ref
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array_ref
argument_list|)
operator|!=
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
operator|!
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the use of the ADDR_EXPR must be a PLUS_EXPR, or else there      is nothing to do. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|PLUS_EXPR
condition|)
return|return
name|false
return|;
comment|/* Try to optimize&x[0] + C where C is a multiple of the size      of the elements in X into&x[C/element size].  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|orig
init|=
name|unshare_expr
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|unshare_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If folding succeeds, then we have just exposed new variables 	 in USE_STMT which will need to be renamed.  If folding fails, 	 then we need to put everything back the way it was.  */
if|if
condition|(
name|fold_stmt_inplace
argument_list|(
name|use_stmt
argument_list|)
condition|)
block|{
name|tidy_after_forward_propagate_addr
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|orig
expr_stmt|;
name|update_stmt
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Try to optimize&x[0] + OFFSET where OFFSET is defined by      converting a multiplication of an index by the size of the      array elements, then the result is converted into the proper      type for the arithmetic.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
comment|/* Avoid problems with IVopts creating PLUS_EXPRs with a 	 different type than their operands.  */
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|bool
name|res
decl_stmt|;
name|tree
name|offset_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|res
operator|=
name|forward_propagate_addr_into_variable_array_index
argument_list|(
name|offset_stmt
argument_list|,
name|lhs
argument_list|,
name|stmt
argument_list|,
name|use_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* Same as the previous case, except the operands of the PLUS_EXPR      were reversed.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
comment|/* Avoid problems with IVopts creating PLUS_EXPRs with a 	 different type than their operands.  */
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|bool
name|res
decl_stmt|;
name|tree
name|offset_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|res
operator|=
name|forward_propagate_addr_into_variable_array_index
argument_list|(
name|offset_stmt
argument_list|,
name|lhs
argument_list|,
name|stmt
argument_list|,
name|use_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
return|return
name|res
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* STMT is a statement of the form SSA_NAME = ADDR_EXPR<whatever>.    SOME is a pointer to a boolean value indicating whether we    propagated the address expression anywhere.     Try to forward propagate the ADDR_EXPR into all uses of the SSA_NAME.    Often this will allow for removal of an ADDR_EXPR and INDIRECT_REF    node or for recovery of array indexing from pointer arithmetic.    Returns true, if all uses have been propagated into.  */
end_comment

begin_function
specifier|static
name|bool
name|forward_propagate_addr_expr
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
modifier|*
name|some
parameter_list|)
block|{
name|int
name|stmt_loop_depth
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|loop_depth
decl_stmt|;
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|imm_use_iterator
name|iter
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|;
name|bool
name|all
init|=
name|true
decl_stmt|;
name|FOR_EACH_IMM_USE_STMT
argument_list|(
argument|use_stmt
argument_list|,
argument|iter
argument_list|,
argument|name
argument_list|)
block|{
name|bool
name|result
decl_stmt|;
comment|/* If the use is not in a simple assignment statement, then 	 there is nothing we can do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
block|{
name|all
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
comment|/* If the use is in a deeper loop nest, then we do not want 	 to propagate the ADDR_EXPR into the loop as that is likely 	 adding expression evaluations into the loop.  */
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
operator|->
name|loop_depth
operator|>
name|stmt_loop_depth
condition|)
block|{
name|all
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
comment|/* If the use_stmt has side-effects, don't propagate into it.  */
if|if
condition|(
name|stmt_ann
argument_list|(
name|use_stmt
argument_list|)
operator|->
name|has_volatile_ops
condition|)
block|{
name|all
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|result
operator|=
name|forward_propagate_addr_expr_1
argument_list|(
name|stmt
argument_list|,
name|use_stmt
argument_list|,
name|some
argument_list|)
expr_stmt|;
operator|*
name|some
operator||=
name|result
expr_stmt|;
name|all
operator|&=
name|result
expr_stmt|;
block|}
return|return
name|all
return|;
block|}
end_function

begin_comment
comment|/* If we have lhs = ~x (STMT), look and see if earlier we had x = ~y.    If so, we can change STMT into lhs = y which can later be copy    propagated.  Similarly for negation.      This could trivially be formulated as a forward propagation     to immediate uses.  However, we already had an implementation    from DOM which used backward propagation via the use-def links.     It turns out that backward propagation is actually faster as    there's less work to do for each NOT/NEG expression we find.    Backwards propagation needs to look at the statement in a single    backlink.  Forward propagation needs to look at potentially more    than one forward link.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_not_neg_expr
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|rhs_def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* See if the RHS_DEF_STMT has the same form as our statement.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs_def_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs_def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|tree
name|rhs_def_operand
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs_def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Verify that RHS_DEF_OPERAND is a suitable SSA_NAME.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs_def_operand
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|rhs_def_operand
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|rhs_def_operand
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* STMT is a SWITCH_EXPR for which we attempt to find equivalent forms of    the condition which we may be able to optimize better.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_switch_expr
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|cond
init|=
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|to
decl_stmt|,
name|ti
decl_stmt|;
comment|/* The optimization that we really care about is removing unnecessary      casts.  That will let us do much better in propagating the inferred      constant at the switch target.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|def
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|def
operator|=
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|int
name|need_precision
decl_stmt|;
name|bool
name|fail
decl_stmt|;
name|def
operator|=
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* ??? Why was Jeff testing this?  We are gimple...  */
name|gcc_assert
argument_list|(
name|is_gimple_val
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|ti
operator|=
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
expr_stmt|;
comment|/* If we have an extension that preserves value, then we 		 can copy the source value into the switch.  */
name|need_precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|fail
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|ti
argument_list|)
condition|)
name|fail
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|to
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|ti
argument_list|)
condition|)
name|fail
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|to
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|ti
argument_list|)
condition|)
name|need_precision
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|to
argument_list|)
operator|<
name|need_precision
condition|)
name|fail
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|def
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Main entry point for the forward propagation optimizer.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_forward_propagate_single_use_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|todoflags
init|=
literal|0
decl_stmt|;
name|cfg_changed
operator|=
name|false
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* Note we update BSI within the loop as necessary.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
comment|/* If this statement sets an SSA_NAME to an address, 	     try to propagate the address into the uses of the SSA_NAME.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|bool
name|some
init|=
name|false
decl_stmt|;
if|if
condition|(
name|forward_propagate_addr_expr
argument_list|(
name|stmt
argument_list|,
operator|&
name|some
argument_list|)
condition|)
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|some
condition|)
name|todoflags
operator||=
name|TODO_update_smt_usage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEGATE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|simplify_not_neg_expr
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
else|else
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
name|simplify_switch_expr
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|forward_propagate_into_cond
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
else|else
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfg_changed
condition|)
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
return|return
name|todoflags
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_forwprop
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_forwprop
init|=
block|{
literal|"forwprop"
block|,
comment|/* name */
name|gate_forwprop
block|,
comment|/* gate */
name|tree_ssa_forward_propagate_single_use_vars
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_FORWPROP
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
comment|/* todo_flags_finish */
operator||
name|TODO_ggc_collect
operator||
name|TODO_update_ssa
operator||
name|TODO_verify_ssa
block|,
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

