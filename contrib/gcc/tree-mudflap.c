begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Mudflap: narrow-pointer bounds-checking by tree rewriting.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Frank Ch. Eigler<fche@redhat.com>    and Graydon Hoare<graydon@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|<demangle.h>
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Internal function decls */
end_comment

begin_comment
comment|/* Options.  */
end_comment

begin_define
define|#
directive|define
name|flag_mudflap_threads
value|(flag_mudflap == 2)
end_define

begin_comment
comment|/* Helpers.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|mf_build_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mf_varname_tree
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mf_file_function_line_tree
parameter_list|(
name|location_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Indirection-related instrumentation.  */
end_comment

begin_function_decl
specifier|static
name|void
name|mf_decl_cache_locals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mf_decl_clear_locals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mf_xform_derefs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|execute_mudflap_function_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Addressable variables instrumentation.  */
end_comment

begin_function_decl
specifier|static
name|void
name|mf_xform_decls
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mx_xfn_xform_decls
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mx_register_decls
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|execute_mudflap_function_decls
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Some generally helpful functions for mudflap instrumentation.  */
end_comment

begin_comment
comment|/* Build a reference to a literal string.  */
end_comment

begin_function
specifier|static
name|tree
name|mf_build_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|mf_mark
argument_list|(
name|build_string
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|string
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|mf_mark
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a properly typed STRING_CST node that describes the given    declaration.  It will be used as an argument for __mf_register().    Try to construct a helpful string, including file/function/variable    name.  */
end_comment

begin_function
specifier|static
name|tree
name|mf_varname_tree
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|static
name|pretty_printer
name|buf_rec
decl_stmt|;
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
name|pretty_printer
modifier|*
name|buf
init|=
operator|&
name|buf_rec
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf_contents
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|gcc_assert
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|pp_construct
argument_list|(
name|buf
argument_list|,
comment|/* prefix */
name|NULL
argument_list|,
comment|/* line-width */
literal|0
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
name|pp_clear_output_area
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Add FILENAME[:LINENUMBER[:COLUMNNUMBER]].  */
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sourcefile
decl_stmt|;
name|unsigned
name|sourceline
init|=
name|xloc
operator|.
name|line
decl_stmt|;
name|unsigned
name|sourcecolumn
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|sourcecolumn
operator|=
name|xloc
operator|.
name|column
expr_stmt|;
endif|#
directive|endif
name|sourcefile
operator|=
name|xloc
operator|.
name|file
expr_stmt|;
if|if
condition|(
name|sourcefile
operator|==
name|NULL
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
name|sourcefile
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourcefile
operator|==
name|NULL
condition|)
name|sourcefile
operator|=
literal|"<unknown file>"
expr_stmt|;
name|pp_string
argument_list|(
name|buf
argument_list|,
name|sourcefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceline
operator|!=
literal|0
condition|)
block|{
name|pp_string
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buf
argument_list|,
name|sourceline
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourcecolumn
operator|!=
literal|0
condition|)
block|{
name|pp_string
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buf
argument_list|,
name|sourcecolumn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Add (FUNCTION) */
name|pp_string
argument_list|(
name|buf
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|funcname
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|funcname
operator|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcname
operator|==
name|NULL
condition|)
name|funcname
operator|=
literal|"anonymous fn"
expr_stmt|;
name|pp_string
argument_list|(
name|buf
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
block|}
name|pp_string
argument_list|(
name|buf
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_string
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* Add<variable-declaration>, possibly demangled.  */
block|{
specifier|const
name|char
modifier|*
name|declname
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"GNU C++"
argument_list|,
name|lang_hooks
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The gcc/cp decl_printable_name hook doesn't do as good a job as 	       the libiberty demangler.  */
name|declname
operator|=
name|cplus_demangle
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|DMGL_AUTO
operator||
name|DMGL_VERBOSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declname
operator|==
name|NULL
condition|)
name|declname
operator|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declname
operator|==
name|NULL
condition|)
name|declname
operator|=
literal|"<unnamed variable>"
expr_stmt|;
name|pp_string
argument_list|(
name|buf
argument_list|,
name|declname
argument_list|)
expr_stmt|;
block|}
comment|/* Return the lot as a new STRING_CST.  */
name|buf_contents
operator|=
name|pp_base_formatted_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|result
operator|=
name|mf_build_string
argument_list|(
name|buf_contents
argument_list|)
expr_stmt|;
name|pp_clear_output_area
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* And another friend, for producing a simpler message.  */
end_comment

begin_function
specifier|static
name|tree
name|mf_file_function_line_tree
parameter_list|(
name|location_t
name|location
parameter_list|)
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|location
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|,
modifier|*
name|colon
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|op
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|linecolbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* Enough for two decimal numbers plus a colon.  */
name|char
modifier|*
name|string
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* Add FILENAME[:LINENUMBER[:COLUMNNUMBER]].  */
name|file
operator|=
name|xloc
operator|.
name|file
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
name|file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
if|if
condition|(
name|xloc
operator|.
name|line
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
if|if
condition|(
name|xloc
operator|.
name|column
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|linecolbuf
argument_list|,
literal|"%d:%d"
argument_list|,
name|xloc
operator|.
name|line
argument_list|,
name|xloc
operator|.
name|column
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|linecolbuf
argument_list|,
literal|"%d"
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
name|colon
operator|=
literal|":"
expr_stmt|;
name|line
operator|=
name|linecolbuf
expr_stmt|;
block|}
else|else
name|colon
operator|=
name|line
operator|=
literal|""
expr_stmt|;
comment|/* Add (FUNCTION).  */
name|name
operator|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|op
operator|=
literal|" ("
expr_stmt|;
name|cp
operator|=
literal|")"
expr_stmt|;
block|}
else|else
name|op
operator|=
name|name
operator|=
name|cp
operator|=
literal|""
expr_stmt|;
name|string
operator|=
name|concat
argument_list|(
name|file
argument_list|,
name|colon
argument_list|,
name|line
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|cp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|mf_build_string
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* global tree nodes */
end_comment

begin_comment
comment|/* Global tree objects for global variables and functions exported by    mudflap runtime library.  mf_init_extern_trees must be called    before using these.  */
end_comment

begin_comment
comment|/* uintptr_t (usually "unsigned long") */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_uintptr_type
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* struct __mf_cache { uintptr_t low; uintptr_t high; }; */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_cache_struct_type
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* struct __mf_cache * const */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_cache_structptr_type
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern struct __mf_cache __mf_lookup_cache []; */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_cache_array_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern unsigned char __mf_lc_shift; */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_cache_shift_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern uintptr_t __mf_lc_mask; */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_cache_mask_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Their function-scope local shadows, used in single-threaded mode only.  */
end_comment

begin_comment
comment|/* auto const unsigned char __mf_lc_shift_l; */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_cache_shift_decl_l
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* auto const uintptr_t __mf_lc_mask_l; */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_cache_mask_decl_l
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern void __mf_check (void *ptr, size_t sz, int type, const char *); */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_check_fndecl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern void __mf_register (void *ptr, size_t sz, int type, const char *); */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_register_fndecl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern void __mf_unregister (void *ptr, size_t sz, int type); */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_unregister_fndecl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern void __mf_init (); */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_init_fndecl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* extern int __mf_set_options (const char*); */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|mf_set_options_fndecl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Helper for mudflap_init: construct a decl with the given category,    name, and type, mark it an external reference, and pushdecl it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|mf_make_builtin
parameter_list|(
name|enum
name|tree_code
name|category
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
init|=
name|mf_mark
argument_list|(
name|build_decl
argument_list|(
name|category
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Helper for mudflap_init: construct a tree corresponding to the type      struct __mf_cache { uintptr_t low; uintptr_t high; };      where uintptr_t is the FIELD_TYPE argument.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|mf_make_mf_cache_struct_type
parameter_list|(
name|tree
name|field_type
parameter_list|)
block|{
comment|/* There is, abominably, no language-independent way to construct a      RECORD_TYPE.  So we have to call the basic type construction      primitives by hand.  */
name|tree
name|fieldlo
init|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"low"
argument_list|)
argument_list|,
name|field_type
argument_list|)
decl_stmt|;
name|tree
name|fieldhi
init|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"high"
argument_list|)
argument_list|,
name|field_type
argument_list|)
decl_stmt|;
name|tree
name|struct_type
init|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fieldlo
argument_list|)
operator|=
name|struct_type
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fieldhi
argument_list|)
operator|=
name|struct_type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fieldlo
argument_list|)
operator|=
name|fieldhi
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|struct_type
argument_list|)
operator|=
name|fieldlo
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|struct_type
argument_list|)
operator|=
name|get_identifier
argument_list|(
literal|"__mf_cache"
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|struct_type
argument_list|)
expr_stmt|;
return|return
name|struct_type
return|;
block|}
end_function

begin_define
define|#
directive|define
name|build_function_type_0
parameter_list|(
name|rtype
parameter_list|)
define|\
value|build_function_type (rtype, void_list_node)
end_define

begin_define
define|#
directive|define
name|build_function_type_1
parameter_list|(
name|rtype
parameter_list|,
name|arg1
parameter_list|)
define|\
value|build_function_type (rtype, tree_cons (0, arg1, void_list_node))
end_define

begin_define
define|#
directive|define
name|build_function_type_3
parameter_list|(
name|rtype
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
define|\
value|build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2,   \                                                              tree_cons (0, arg3, void_list_node))))
end_define

begin_define
define|#
directive|define
name|build_function_type_4
parameter_list|(
name|rtype
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
define|\
value|build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2,   \                                                              tree_cons (0, arg3, tree_cons (0, arg4, \                                                                                             void_list_node)))))
end_define

begin_comment
comment|/* Initialize the global tree nodes that correspond to mf-runtime.h    declarations.  */
end_comment

begin_function
name|void
name|mudflap_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|bool
name|done
init|=
name|false
decl_stmt|;
name|tree
name|mf_const_string_type
decl_stmt|;
name|tree
name|mf_cache_array_type
decl_stmt|;
name|tree
name|mf_check_register_fntype
decl_stmt|;
name|tree
name|mf_unregister_fntype
decl_stmt|;
name|tree
name|mf_init_fntype
decl_stmt|;
name|tree
name|mf_set_options_fntype
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
name|done
operator|=
name|true
expr_stmt|;
name|mf_uintptr_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|ptr_mode
argument_list|,
comment|/*unsignedp=*/
name|true
argument_list|)
expr_stmt|;
name|mf_const_string_type
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
name|mf_cache_struct_type
operator|=
name|mf_make_mf_cache_struct_type
argument_list|(
name|mf_uintptr_type
argument_list|)
expr_stmt|;
name|mf_cache_structptr_type
operator|=
name|build_pointer_type
argument_list|(
name|mf_cache_struct_type
argument_list|)
expr_stmt|;
name|mf_cache_array_type
operator|=
name|build_array_type
argument_list|(
name|mf_cache_struct_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mf_check_register_fntype
operator|=
name|build_function_type_4
argument_list|(
name|void_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|size_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|mf_const_string_type
argument_list|)
expr_stmt|;
name|mf_unregister_fntype
operator|=
name|build_function_type_3
argument_list|(
name|void_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|size_type_node
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|mf_init_fntype
operator|=
name|build_function_type_0
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|mf_set_options_fntype
operator|=
name|build_function_type_1
argument_list|(
name|integer_type_node
argument_list|,
name|mf_const_string_type
argument_list|)
expr_stmt|;
name|mf_cache_array_decl
operator|=
name|mf_make_builtin
argument_list|(
name|VAR_DECL
argument_list|,
literal|"__mf_lookup_cache"
argument_list|,
name|mf_cache_array_type
argument_list|)
expr_stmt|;
name|mf_cache_shift_decl
operator|=
name|mf_make_builtin
argument_list|(
name|VAR_DECL
argument_list|,
literal|"__mf_lc_shift"
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|mf_cache_mask_decl
operator|=
name|mf_make_builtin
argument_list|(
name|VAR_DECL
argument_list|,
literal|"__mf_lc_mask"
argument_list|,
name|mf_uintptr_type
argument_list|)
expr_stmt|;
comment|/* Don't process these in mudflap_enqueue_decl, should they come by      there for some reason.  */
name|mf_mark
argument_list|(
name|mf_cache_array_decl
argument_list|)
expr_stmt|;
name|mf_mark
argument_list|(
name|mf_cache_shift_decl
argument_list|)
expr_stmt|;
name|mf_mark
argument_list|(
name|mf_cache_mask_decl
argument_list|)
expr_stmt|;
name|mf_check_fndecl
operator|=
name|mf_make_builtin
argument_list|(
name|FUNCTION_DECL
argument_list|,
literal|"__mf_check"
argument_list|,
name|mf_check_register_fntype
argument_list|)
expr_stmt|;
name|mf_register_fndecl
operator|=
name|mf_make_builtin
argument_list|(
name|FUNCTION_DECL
argument_list|,
literal|"__mf_register"
argument_list|,
name|mf_check_register_fntype
argument_list|)
expr_stmt|;
name|mf_unregister_fndecl
operator|=
name|mf_make_builtin
argument_list|(
name|FUNCTION_DECL
argument_list|,
literal|"__mf_unregister"
argument_list|,
name|mf_unregister_fntype
argument_list|)
expr_stmt|;
name|mf_init_fndecl
operator|=
name|mf_make_builtin
argument_list|(
name|FUNCTION_DECL
argument_list|,
literal|"__mf_init"
argument_list|,
name|mf_init_fntype
argument_list|)
expr_stmt|;
name|mf_set_options_fndecl
operator|=
name|mf_make_builtin
argument_list|(
name|FUNCTION_DECL
argument_list|,
literal|"__mf_set_options"
argument_list|,
name|mf_set_options_fntype
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|build_function_type_4
end_undef

begin_undef
undef|#
directive|undef
name|build_function_type_3
end_undef

begin_undef
undef|#
directive|undef
name|build_function_type_1
end_undef

begin_undef
undef|#
directive|undef
name|build_function_type_0
end_undef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Memory reference transforms. Perform the mudflap indirection-related    tree transforms on the current function.     This is the second part of the mudflap instrumentation.  It works on    low-level GIMPLE using the CFG, because we want to run this pass after    tree optimizations have been performed, but we have to preserve the CFG    for expansion from trees to RTL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_mudflap_function_ops
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Don't instrument functions such as the synthetic constructor      built during mudflap_finish_file.  */
if|if
condition|(
name|mf_marked_p
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
literal|0
return|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
comment|/* In multithreaded mode, don't cache the lookup cache parameters.  */
if|if
condition|(
operator|!
name|flag_mudflap_threads
condition|)
name|mf_decl_cache_locals
argument_list|()
expr_stmt|;
name|mf_xform_derefs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_mudflap_threads
condition|)
name|mf_decl_clear_locals
argument_list|()
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create and initialize local shadow variables for the lookup cache    globals.  Put their decls in the *_l globals for use by    mf_build_check_statement_for.  */
end_comment

begin_function
specifier|static
name|void
name|mf_decl_cache_locals
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|shift_init_stmts
decl_stmt|,
name|mask_init_stmts
decl_stmt|;
name|tree_stmt_iterator
name|tsi
decl_stmt|;
comment|/* Build the cache vars.  */
name|mf_cache_shift_decl_l
operator|=
name|mf_mark
argument_list|(
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|mf_cache_shift_decl
argument_list|)
argument_list|,
literal|"__mf_lookup_shift_l"
argument_list|)
argument_list|)
expr_stmt|;
name|mf_cache_mask_decl_l
operator|=
name|mf_mark
argument_list|(
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|mf_cache_mask_decl
argument_list|)
argument_list|,
literal|"__mf_lookup_mask_l"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build initialization nodes for the cache vars.  We just load the      globals into the cache variables.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|mf_cache_shift_decl_l
argument_list|)
argument_list|,
name|mf_cache_shift_decl_l
argument_list|,
name|mf_cache_shift_decl
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|DECL_SOURCE_LOCATION
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|shift_init_stmts
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|mf_cache_mask_decl_l
argument_list|)
argument_list|,
name|mf_cache_mask_decl_l
argument_list|,
name|mf_cache_mask_decl
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|DECL_SOURCE_LOCATION
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|mask_init_stmts
operator|=
name|t
expr_stmt|;
comment|/* Anticipating multiple entry points, we insert the cache vars      initializers in each successor of the ENTRY_BLOCK_PTR.  */
for|for
control|(
name|tsi
operator|=
name|tsi_start
argument_list|(
name|shift_init_stmts
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
control|)
name|insert_edge_copies
argument_list|(
name|tsi_stmt
argument_list|(
name|tsi
argument_list|)
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
for|for
control|(
name|tsi
operator|=
name|tsi_start
argument_list|(
name|mask_init_stmts
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
control|)
name|insert_edge_copies
argument_list|(
name|tsi_stmt
argument_list|(
name|tsi
argument_list|)
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mf_decl_clear_locals
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Unset local shadows.  */
name|mf_cache_shift_decl_l
operator|=
name|NULL_TREE
expr_stmt|;
name|mf_cache_mask_decl_l
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mf_build_check_statement_for
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|limit
parameter_list|,
name|block_stmt_iterator
modifier|*
name|instr_bsi
parameter_list|,
name|location_t
modifier|*
name|locus
parameter_list|,
name|tree
name|dirflag
parameter_list|)
block|{
name|tree_stmt_iterator
name|head
decl_stmt|,
name|tsi
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|cond_bb
decl_stmt|,
name|then_bb
decl_stmt|,
name|join_bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|cond
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|tree
name|mf_base
decl_stmt|;
name|tree
name|mf_elem
decl_stmt|;
name|tree
name|mf_limit
decl_stmt|;
comment|/* We first need to split the current basic block, and start altering      the CFG.  This allows us to insert the statements we're about to      construct into the right basic blocks.  */
name|cond_bb
operator|=
name|bb_for_stmt
argument_list|(
name|bsi_stmt
argument_list|(
operator|*
name|instr_bsi
argument_list|)
argument_list|)
expr_stmt|;
name|bsi
operator|=
operator|*
name|instr_bsi
expr_stmt|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|e
operator|=
name|split_block
argument_list|(
name|cond_bb
argument_list|,
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|e
operator|=
name|split_block_after_labels
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|cond_bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|join_bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* A recap at this point: join_bb is the basic block at whose head      is the gimple statement for which this check expression is being      built.  cond_bb is the (possibly new, synthetic) basic block the      end of which will contain the cache-lookup code, and a      conditional that jumps to the cache-miss code or, much more      likely, over to join_bb.  */
comment|/* Create the bb that contains the cache-miss fallback block (mf_check).  */
name|then_bb
operator|=
name|create_empty_bb
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|cond_bb
argument_list|,
name|then_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|then_bb
argument_list|,
name|join_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
comment|/* Mark the pseudo-fallthrough edge from cond_bb to join_bb.  */
name|e
operator|=
name|find_edge
argument_list|(
name|cond_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|EDGE_FALSE_VALUE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|cond_bb
operator|->
name|count
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
comment|/* Update dominance info.  Note that bb_join's data was      updated by split_block.  */
if|if
condition|(
name|dom_info_available_p
argument_list|(
name|CDI_DOMINATORS
argument_list|)
condition|)
block|{
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|then_bb
argument_list|,
name|cond_bb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|join_bb
argument_list|,
name|cond_bb
argument_list|)
expr_stmt|;
block|}
comment|/* Build our local variables.  */
name|mf_elem
operator|=
name|create_tmp_var
argument_list|(
name|mf_cache_structptr_type
argument_list|,
literal|"__mf_elem"
argument_list|)
expr_stmt|;
name|mf_base
operator|=
name|create_tmp_var
argument_list|(
name|mf_uintptr_type
argument_list|,
literal|"__mf_base"
argument_list|)
expr_stmt|;
name|mf_limit
operator|=
name|create_tmp_var
argument_list|(
name|mf_uintptr_type
argument_list|,
literal|"__mf_limit"
argument_list|)
expr_stmt|;
comment|/* Build: __mf_base = (uintptr_t)<base address expression>.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|mf_base
argument_list|,
name|convert
argument_list|(
name|mf_uintptr_type
argument_list|,
name|unshare_expr
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|head
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Build: __mf_limit = (uintptr_t)<limit address expression>.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|mf_limit
argument_list|,
name|convert
argument_list|(
name|mf_uintptr_type
argument_list|,
name|unshare_expr
argument_list|(
name|limit
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Build: __mf_elem =&__mf_lookup_cache [(__mf_base>> __mf_shift)& __mf_mask].  */
name|t
operator|=
name|build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mf_uintptr_type
argument_list|,
name|mf_base
argument_list|,
operator|(
name|flag_mudflap_threads
condition|?
name|mf_cache_shift_decl
else|:
name|mf_cache_shift_decl_l
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|mf_uintptr_type
argument_list|,
name|t
argument_list|,
operator|(
name|flag_mudflap_threads
condition|?
name|mf_cache_mask_decl
else|:
name|mf_cache_mask_decl_l
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|mf_cache_array_decl
argument_list|)
argument_list|)
argument_list|,
name|mf_cache_array_decl
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|mf_cache_structptr_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|mf_elem
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Quick validity check.       if (__mf_elem->low> __mf_base          || (__mf_elem_high< __mf_limit))         {           __mf_check ();           ... and only if single-threaded:           __mf_lookup_shift_1 = f...;           __mf_lookup_mask_l = ...;         }       It is expected that this body of code is rarely executed so we mark      the edge to the THEN clause of the conditional jump as unlikely.  */
comment|/* Construct t<-- '__mf_elem->low> __mf_base'.  */
name|t
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|mf_uintptr_type
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|mf_cache_struct_type
argument_list|,
name|mf_elem
argument_list|)
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|mf_cache_struct_type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|t
argument_list|,
name|mf_base
argument_list|)
expr_stmt|;
comment|/* Construct '__mf_elem->high< __mf_limit'.       First build:         1) u<--  '__mf_elem->high'         2) v<--  '__mf_limit'.       Then build 'u<-- (u< v).  */
name|u
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|mf_uintptr_type
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|mf_cache_struct_type
argument_list|,
name|mf_elem
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|mf_cache_struct_type
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|v
operator|=
name|mf_limit
expr_stmt|;
name|u
operator|=
name|build2
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Build the composed conditional: t<-- 't || u'.  Then store the      result of the evaluation of 't' in a temporary variable which we      can use as the condition for the conditional jump.  */
name|t
operator|=
name|build2
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|cond
operator|=
name|create_tmp_var
argument_list|(
name|boolean_type_node
argument_list|,
literal|"__mf_unlikely_cond"
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|cond
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Build the conditional jump.  'cond' is just a temporary so we can      simply build a void COND_EXPR.  We do need labels in both arms though.  */
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|then_bb
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|join_bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* At this point, after so much hard work, we have only constructed      the conditional jump,       if (__mf_elem->low> __mf_base          || (__mf_elem_high< __mf_limit))       The lowered GIMPLE tree representing this code is in the statement      list starting at 'head'.       We can insert this now in the current basic block, i.e. the one that      the statement we're instrumenting was originally in.  */
name|bsi
operator|=
name|bsi_last
argument_list|(
name|cond_bb
argument_list|)
expr_stmt|;
for|for
control|(
name|tsi
operator|=
name|head
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
control|)
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|tsi_stmt
argument_list|(
name|tsi
argument_list|)
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/*  Now build up the body of the cache-miss handling:       __mf_check();      refresh *_l vars.       This is the body of the conditional.  */
name|u
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|mf_file_function_line_tree
argument_list|(
name|locus
operator|==
name|NULL
condition|?
name|UNKNOWN_LOCATION
else|:
operator|*
name|locus
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|u
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dirflag
argument_list|,
name|u
argument_list|)
expr_stmt|;
comment|/* NB: we pass the overall [base..limit] range to mf_check.  */
name|u
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|mf_uintptr_type
argument_list|,
name|mf_limit
argument_list|,
name|mf_base
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|mf_base
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|mf_check_fndecl
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|head
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_mudflap_threads
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|mf_cache_shift_decl_l
argument_list|,
name|mf_cache_shift_decl
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|mf_cache_mask_decl_l
argument_list|,
name|mf_cache_mask_decl
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the check code in the THEN block.  */
name|bsi
operator|=
name|bsi_start
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
for|for
control|(
name|tsi
operator|=
name|head
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
control|)
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|tsi_stmt
argument_list|(
name|tsi
argument_list|)
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
operator|*
name|instr_bsi
operator|=
name|bsi_start
argument_list|(
name|join_bb
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
name|instr_bsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether the given decl, generally a VAR_DECL or PARM_DECL, is    eligible for instrumentation.  For the mudflap1 pass, this implies    that it should be registered with the libmudflap runtime.  For the    mudflap2 pass this means instrumenting an indirection operation with    respect to the object. */
end_comment

begin_function
specifier|static
name|int
name|mf_decl_eligible_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
comment|/* The decl must have its address taken.  In the case of              arrays, this flag is also set if the indexes are not              compile-time known valid constants.  */
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
comment|/* XXX: not sufficient: return-by-value structs! */
comment|/* The type of the variable must be complete.  */
operator|&&
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* The decl hasn't been decomposed somehow.  */
operator|&&
operator|!
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mf_xform_derefs_1
parameter_list|(
name|block_stmt_iterator
modifier|*
name|iter
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|,
name|location_t
modifier|*
name|locus
parameter_list|,
name|tree
name|dirflag
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|base
decl_stmt|,
name|limit
decl_stmt|,
name|addr
decl_stmt|,
name|size
decl_stmt|,
name|t
decl_stmt|;
comment|/* Don't instrument read operations.  */
if|if
condition|(
name|dirflag
operator|==
name|integer_zero_node
operator|&&
name|flag_mudflap_ignore_reads
condition|)
return|return;
comment|/* Don't instrument marked nodes.  */
if|if
condition|(
name|mf_marked_p
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
return|return;
name|t
operator|=
operator|*
name|tp
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
name|size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
case|case
name|COMPONENT_REF
case|:
block|{
comment|/* This is trickier than it may first appear.  The reason is            that we are looking at expressions from the "inside out" at            this point.  We may have a complex nested aggregate/array            expression (e.g. "a.b[i].c"), maybe with an indirection as            the leftmost operator ("p->a.b.d"), where instrumentation            is necessary.  Or we may have an innocent "a.b.c"            expression that must not be instrumented.  We need to            recurse all the way down the nesting structure to figure it            out: looking just at the outer node is not enough.  */
name|tree
name|var
decl_stmt|;
name|int
name|component_ref_only
init|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|)
decl_stmt|;
comment|/* If we have a bitfield component reference, we must note the 	   innermost addressable object in ELT, from which we will 	   construct the byte-addressable bounds of the bitfield.  */
name|tree
name|elt
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|bitfield_ref_p
init|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Iterate to the top of the ARRAY_REF/COMPONENT_REF            containment hierarchy to find the outermost VAR_DECL.  */
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|bitfield_ref_p
operator|&&
name|elt
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|COMPONENT_REF
operator|)
condition|)
name|elt
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|component_ref_only
operator|=
literal|0
expr_stmt|;
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INDIRECT_REF_P
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|STRING_CST
argument_list|)
expr_stmt|;
comment|/* Don't instrument this access if the underlying                    variable is not "eligible".  This test matches                    those arrays that have only known-valid indexes,                    and thus are not labeled TREE_ADDRESSABLE.  */
if|if
condition|(
operator|!
name|mf_decl_eligible_p
argument_list|(
name|var
argument_list|)
operator|||
name|component_ref_only
condition|)
return|return;
else|else
block|{
name|base
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Handle the case of ordinary non-indirection structure            accesses.  These have only nested COMPONENT_REF nodes (no            INDIRECT_REF), but pass through the above filter loop.            Note that it's possible for such a struct variable to match            the eligible_p test because someone else might take its            address sometime.  */
comment|/* We need special processing for bitfield components, because            their addresses cannot be taken.  */
if|if
condition|(
name|bitfield_ref_p
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|size
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
condition|)
name|elt
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|elt
condition|?
name|elt
else|:
name|base
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|addr
argument_list|,
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|byte_position
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|limit
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|mf_uintptr_type
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|mf_uintptr_type
argument_list|,
name|convert
argument_list|(
name|mf_uintptr_type
argument_list|,
name|addr
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INDIRECT_REF
case|:
name|addr
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|addr
expr_stmt|;
name|limit
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_MEM_REF
case|:
name|addr
operator|=
name|tree_mem_ref_addr
argument_list|(
name|ptr_type_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|base
operator|=
name|addr
expr_stmt|;
name|limit
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|ptr_type_node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_RANGE_REF
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"mudflap checking not yet implemented for ARRAY_RANGE_REF"
argument_list|)
expr_stmt|;
return|return;
case|case
name|BIT_FIELD_REF
case|:
comment|/* ??? merge with COMPONENT_REF code above? */
block|{
name|tree
name|ofs
decl_stmt|,
name|rem
decl_stmt|,
name|bpu
decl_stmt|;
comment|/* If we're not dereferencing something, then the access            must be ok.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
return|return;
name|bpu
operator|=
name|bitsize_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ofs
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|rem
operator|=
name|size_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|ofs
argument_list|,
name|bpu
argument_list|)
expr_stmt|;
name|ofs
operator|=
name|size_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|ofs
argument_list|,
name|bpu
argument_list|)
expr_stmt|;
name|size
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|size
argument_list|,
name|bpu
argument_list|)
expr_stmt|;
name|size
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|addr
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|addr
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|base
operator|=
name|addr
expr_stmt|;
name|limit
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return;
block|}
name|mf_build_check_statement_for
argument_list|(
name|base
argument_list|,
name|limit
argument_list|,
name|iter
argument_list|,
name|locus
argument_list|,
name|dirflag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mf_xform_derefs
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|next
decl_stmt|;
name|block_stmt_iterator
name|i
decl_stmt|;
name|int
name|saved_last_basic_block
init|=
name|last_basic_block
decl_stmt|;
name|bb
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
expr_stmt|;
do|do
block|{
name|next
operator|=
name|bb
operator|->
name|next_bb
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|s
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Only a few GIMPLE statements can reference memory.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
name|mf_xform_derefs_1
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|s
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|mf_xform_derefs_1
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|s
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|mf_xform_derefs_1
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|s
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
name|mf_xform_derefs_1
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|s
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
block|}
name|bb
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|bb
operator|&&
name|bb
operator|->
name|index
operator|<=
name|saved_last_basic_block
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* ADDR_EXPR transforms.  Perform the declaration-related mudflap tree    transforms on the current function.     This is the first part of the mudflap instrumentation.  It works on    high-level GIMPLE because after lowering, all variables are moved out    of their BIND_EXPR binding context, and we lose liveness information    for the declarations we wish to instrument.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_mudflap_function_decls
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Don't instrument functions such as the synthetic constructor      built during mudflap_finish_file.  */
if|if
condition|(
name|mf_marked_p
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
literal|0
return|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|mf_xform_decls
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This struct is passed between mf_xform_decls to store state needed    during the traversal searching for objects that have their    addresses taken.  */
end_comment

begin_struct
struct|struct
name|mf_xform_decls_data
block|{
name|tree
name|param_decls
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Synthesize a CALL_EXPR and a TRY_FINALLY_EXPR, for this chain of    _DECLs if appropriate.  Arrange to call the __mf_register function    now, and the __mf_unregister function later for each.  */
end_comment

begin_function
specifier|static
name|void
name|mx_register_decls
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
modifier|*
name|stmt_list
parameter_list|)
block|{
name|tree
name|finally_stmts
init|=
name|NULL_TREE
decl_stmt|;
name|tree_stmt_iterator
name|initially_stmts
init|=
name|tsi_start
argument_list|(
operator|*
name|stmt_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|mf_decl_eligible_p
argument_list|(
name|decl
argument_list|)
comment|/* Not already processed.  */
operator|&&
operator|!
name|mf_marked_p
argument_list|(
name|decl
argument_list|)
comment|/* Automatic variable.  */
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|size
init|=
name|NULL_TREE
decl_stmt|,
name|variable_name
decl_stmt|;
name|tree
name|unregister_fncall
decl_stmt|,
name|unregister_fncall_params
decl_stmt|;
name|tree
name|register_fncall
decl_stmt|,
name|register_fncall_params
decl_stmt|;
name|size
operator|=
name|convert
argument_list|(
name|size_type_node
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (& VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK) */
name|unregister_fncall_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|mf_mark
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
comment|/* __MF_TYPE_STACK */
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|3
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* __mf_unregister (...) */
name|unregister_fncall
operator|=
name|build_function_call_expr
argument_list|(
name|mf_unregister_fndecl
argument_list|,
name|unregister_fncall_params
argument_list|)
expr_stmt|;
comment|/* (& VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK, "name") */
name|variable_name
operator|=
name|mf_varname_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|register_fncall_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|mf_mark
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
comment|/* __MF_TYPE_STACK */
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|3
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|variable_name
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* __mf_register (...) */
name|register_fncall
operator|=
name|build_function_call_expr
argument_list|(
name|mf_register_fndecl
argument_list|,
name|register_fncall_params
argument_list|)
expr_stmt|;
comment|/* Accumulate the two calls.  */
comment|/* ??? Set EXPR_LOCATION.  */
name|gimplify_stmt
argument_list|(
operator|&
name|register_fncall
argument_list|)
expr_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|unregister_fncall
argument_list|)
expr_stmt|;
comment|/* Add the __mf_register call at the current appending point.  */
if|if
condition|(
name|tsi_end_p
argument_list|(
name|initially_stmts
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"mudflap cannot track %qs in stub function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tsi_link_before
argument_list|(
operator|&
name|initially_stmts
argument_list|,
name|register_fncall
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Accumulate the FINALLY piece.  */
name|append_to_statement_list
argument_list|(
name|unregister_fncall
argument_list|,
operator|&
name|finally_stmts
argument_list|)
expr_stmt|;
block|}
name|mf_mark
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Actually, (initially_stmts!=NULL)<=> (finally_stmts!=NULL) */
if|if
condition|(
name|finally_stmts
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|t
init|=
name|build2
argument_list|(
name|TRY_FINALLY_EXPR
argument_list|,
name|void_type_node
argument_list|,
operator|*
name|stmt_list
argument_list|,
name|finally_stmts
argument_list|)
decl_stmt|;
operator|*
name|stmt_list
operator|=
name|NULL
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process every variable mentioned in BIND_EXPRs.  */
end_comment

begin_function
specifier|static
name|tree
name|mx_xfn_xform_decls
parameter_list|(
name|tree
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|continue_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mf_xform_decls_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|mf_xform_decls_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
name|NULL_TREE
operator|||
operator|*
name|t
operator|==
name|error_mark_node
condition|)
block|{
operator|*
name|continue_p
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
operator|*
name|continue_p
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
case|case
name|BIND_EXPR
case|:
block|{
comment|/* Process function parameters now (but only once).  */
name|mx_register_decls
argument_list|(
name|d
operator|->
name|param_decls
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|param_decls
operator|=
name|NULL_TREE
expr_stmt|;
name|mx_register_decls
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
operator|*
name|t
argument_list|)
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Perform the object lifetime tracking mudflap transform on the given function    tree.  The tree is mutated in place, with possibly copied subtree nodes.     For every auto variable declared, if its address is ever taken    within the function, then supply its lifetime to the mudflap    runtime with the __mf_register and __mf_unregister calls. */
end_comment

begin_function
specifier|static
name|void
name|mf_xform_decls
parameter_list|(
name|tree
name|fnbody
parameter_list|,
name|tree
name|fnparams
parameter_list|)
block|{
name|struct
name|mf_xform_decls_data
name|d
decl_stmt|;
name|d
operator|.
name|param_decls
operator|=
name|fnparams
expr_stmt|;
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|fnbody
argument_list|,
name|mx_xfn_xform_decls
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Externally visible mudflap functions.  */
end_comment

begin_comment
comment|/* Mark and return the given tree node to prevent further mudflap    transforms.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (union tree_node))
argument_list|)
name|htab_t
name|marked_trees
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_function
name|tree
name|mf_mark
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|marked_trees
operator|==
name|NULL
condition|)
name|marked_trees
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|marked_trees
argument_list|,
name|t
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|t
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|int
name|mf_marked_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|void
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|marked_trees
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|entry
operator|=
name|htab_find
argument_list|(
name|marked_trees
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remember given node as a static of some kind: global data,    function-scope static, or an anonymous constant.  Its assembler    label is given.  */
end_comment

begin_comment
comment|/* A list of globals whose incomplete declarations we encountered.    Instead of emitting the __mf_register call for them here, it's    delayed until program finish time.  If they're still incomplete by    then, warnings are emitted.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|deferred_static_decls
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A list of statements for calling __mf_register() at startup time.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|enqueued_call_stmt_chain
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|mudflap_register_call
parameter_list|(
name|tree
name|obj
parameter_list|,
name|tree
name|object_size
parameter_list|,
name|tree
name|varname
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|,
name|args
decl_stmt|,
name|call_stmt
decl_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|varname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* __MF_TYPE_STATIC */
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert
argument_list|(
name|size_type_node
argument_list|,
name|object_size
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|call_stmt
operator|=
name|build_function_call_expr
argument_list|(
name|mf_register_fndecl
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|call_stmt
argument_list|,
operator|&
name|enqueued_call_stmt_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mudflap_enqueue_decl
parameter_list|(
name|tree
name|obj
parameter_list|)
block|{
if|if
condition|(
name|mf_marked_p
argument_list|(
name|obj
argument_list|)
condition|)
return|return;
comment|/* We don't need to process variable decls that are internally      generated extern.  If we did, we'd end up with warnings for them      during mudflap_finish_file ().  That would confuse the user,      since the text would refer to variables that don't show up in the      user's source code.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|obj
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|obj
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|obj
argument_list|)
condition|)
return|return;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|deferred_static_decls
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mudflap_enqueue_constant
parameter_list|(
name|tree
name|obj
parameter_list|)
block|{
name|tree
name|object_size
decl_stmt|,
name|varname
decl_stmt|;
if|if
condition|(
name|mf_marked_p
argument_list|(
name|obj
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|obj
argument_list|)
operator|==
name|STRING_CST
condition|)
name|object_size
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|object_size
operator|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|obj
argument_list|)
operator|==
name|STRING_CST
condition|)
name|varname
operator|=
name|mf_build_string
argument_list|(
literal|"string literal"
argument_list|)
expr_stmt|;
else|else
name|varname
operator|=
name|mf_build_string
argument_list|(
literal|"constant"
argument_list|)
expr_stmt|;
name|mudflap_register_call
argument_list|(
name|obj
argument_list|,
name|object_size
argument_list|,
name|varname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit any file-wide instrumentation.  */
end_comment

begin_function
name|void
name|mudflap_finish_file
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|ctor_statements
init|=
name|NULL_TREE
decl_stmt|;
comment|/* No need to continue when there were errors.  */
if|if
condition|(
name|errorcount
operator|!=
literal|0
operator|||
name|sorrycount
operator|!=
literal|0
condition|)
return|return;
comment|/* Insert a call to __mf_init.  */
block|{
name|tree
name|call2_stmt
init|=
name|build_function_call_expr
argument_list|(
name|mf_init_fndecl
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|append_to_statement_list
argument_list|(
name|call2_stmt
argument_list|,
operator|&
name|ctor_statements
argument_list|)
expr_stmt|;
block|}
comment|/* If appropriate, call __mf_set_options to pass along read-ignore mode.  */
if|if
condition|(
name|flag_mudflap_ignore_reads
condition|)
block|{
name|tree
name|arg
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|mf_build_string
argument_list|(
literal|"-ignore-reads"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|call_stmt
init|=
name|build_function_call_expr
argument_list|(
name|mf_set_options_fndecl
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|append_to_statement_list
argument_list|(
name|call_stmt
argument_list|,
operator|&
name|ctor_statements
argument_list|)
expr_stmt|;
block|}
comment|/* Process all enqueued object decls.  */
if|if
condition|(
name|deferred_static_decls
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|obj
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|deferred_static_decls
argument_list|,
name|i
argument_list|,
name|obj
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf_marked_p
argument_list|(
name|obj
argument_list|)
condition|)
continue|continue;
comment|/* Omit registration for static unaddressed objects.  NB:              Perform registration for non-static objects regardless of              TREE_USED or TREE_ADDRESSABLE, because they may be used              from other compilation units.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|obj
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|obj
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"mudflap cannot track unknown size extern %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|obj
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mudflap_register_call
argument_list|(
name|obj
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
argument_list|,
name|mf_varname_tree
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|deferred_static_decls
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Append all the enqueued registration calls.  */
if|if
condition|(
name|enqueued_call_stmt_chain
condition|)
block|{
name|append_to_statement_list
argument_list|(
name|enqueued_call_stmt_chain
argument_list|,
operator|&
name|ctor_statements
argument_list|)
expr_stmt|;
name|enqueued_call_stmt_chain
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|cgraph_build_static_cdtor
argument_list|(
literal|'I'
argument_list|,
name|ctor_statements
argument_list|,
name|MAX_RESERVED_INIT_PRIORITY
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_mudflap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_mudflap
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_mudflap_1
init|=
block|{
literal|"mudflap1"
block|,
comment|/* name */
name|gate_mudflap
block|,
comment|/* gate */
name|execute_mudflap_function_decls
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_gimple_any
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_mudflap_2
init|=
block|{
literal|"mudflap2"
block|,
comment|/* name */
name|gate_mudflap
block|,
comment|/* gate */
name|execute_mudflap_function_ops
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_gimple_leh
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_verify_flow
operator||
name|TODO_verify_stmts
operator||
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-tree-mudflap.h"
end_include

end_unit

