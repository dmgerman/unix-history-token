begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lower complex number operations to scalar operations.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_comment
comment|/* For each complex ssa name, a lattice value.  We're interested in finding    out whether a complex number is degenerate in some way, having only real    or only complex parts.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|UNINITIALIZED
init|=
literal|0
block|,
name|ONLY_REAL
init|=
literal|1
block|,
name|ONLY_IMAG
init|=
literal|2
block|,
name|VARYING
init|=
literal|3
block|}
name|complex_lattice_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PAIR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<< 2 | (b))
end_define

begin_expr_stmt
name|DEF_VEC_I
argument_list|(
name|complex_lattice_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_I
argument_list|(
name|complex_lattice_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|complex_lattice_t
argument_list|,
name|heap
argument_list|)
operator|*
name|complex_lattice_values
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* For each complex variable, a pair of variables for the components exists in    the hashtable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|complex_variable_components
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each complex SSA_NAME, a pair of ssa names for the components.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|complex_ssa_name_components
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Lookup UID in the complex_variable_components hashtable and return the    associated tree.  */
end_comment

begin_function
specifier|static
name|tree
name|cvc_lookup
parameter_list|(
name|unsigned
name|int
name|uid
parameter_list|)
block|{
name|struct
name|int_tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|complex_variable_components
argument_list|,
operator|&
name|in
argument_list|,
name|uid
argument_list|)
expr_stmt|;
return|return
name|h
condition|?
name|h
operator|->
name|to
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert the pair UID, TO into the complex_variable_components hashtable.  */
end_comment

begin_function
specifier|static
name|void
name|cvc_insert
parameter_list|(
name|unsigned
name|int
name|uid
parameter_list|,
name|tree
name|to
parameter_list|)
block|{
name|struct
name|int_tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|XNEW
argument_list|(
expr|struct
name|int_tree_map
argument_list|)
expr_stmt|;
name|h
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|complex_variable_components
argument_list|,
name|h
argument_list|,
name|uid
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|int_tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if T is not a zero constant.  In the case of real values,    we're only interested in +0.0.  */
end_comment

begin_function
specifier|static
name|int
name|some_nonzerop
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|zerop
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REAL_CST
condition|)
name|zerop
operator|=
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|,
name|dconst0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|zerop
operator|=
name|integer_zerop
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|!
name|zerop
return|;
block|}
end_function

begin_comment
comment|/* Compute a lattice value from T.  It may be a gimple_val, or, as a     special exception, a COMPLEX_EXPR.  */
end_comment

begin_function
specifier|static
name|complex_lattice_t
name|find_lattice_value
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
name|complex_lattice_t
name|ret
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
return|return
name|VEC_index
argument_list|(
name|complex_lattice_t
argument_list|,
name|complex_lattice_values
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
name|real
operator|=
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|imag
operator|=
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_EXPR
case|:
name|real
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imag
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|r
operator|=
name|some_nonzerop
argument_list|(
name|real
argument_list|)
expr_stmt|;
name|i
operator|=
name|some_nonzerop
argument_list|(
name|imag
argument_list|)
expr_stmt|;
name|ret
operator|=
name|r
operator|*
name|ONLY_REAL
operator|+
name|i
operator|*
name|ONLY_IMAG
expr_stmt|;
comment|/* ??? On occasion we could do better than mapping 0+0i to real, but we      certainly don't want to leave it UNINITIALIZED, which eventually gets      mapped to VARYING.  */
if|if
condition|(
name|ret
operator|==
name|UNINITIALIZED
condition|)
name|ret
operator|=
name|ONLY_REAL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Determine if LHS is something for which we're interested in seeing    simulation results.  */
end_comment

begin_function
specifier|static
name|bool
name|is_complex_reg
parameter_list|(
name|tree
name|lhs
parameter_list|)
block|{
return|return
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|is_gimple_reg
argument_list|(
name|lhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark the incoming parameters to the function as VARYING.  */
end_comment

begin_function
specifier|static
name|void
name|init_parameter_lattice_values
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|is_complex_reg
argument_list|(
name|parm
argument_list|)
operator|&&
name|var_ann
argument_list|(
name|parm
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tree
name|ssa_name
init|=
name|default_def
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|VEC_replace
argument_list|(
name|complex_lattice_t
argument_list|,
name|complex_lattice_values
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|ssa_name
argument_list|)
argument_list|,
name|VARYING
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize DONT_SIMULATE_AGAIN for each stmt and phi.  Return false if    we found no statements we want to simulate, and thus there's nothing for    the entire pass to do.  */
end_comment

begin_function
specifier|static
name|bool
name|init_dont_simulate_again
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|bool
name|saw_a_complex_op
init|=
name|false
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|DONT_SIMULATE_AGAIN
argument_list|(
name|phi
argument_list|)
operator|=
operator|!
name|is_complex_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|orig_stmt
decl_stmt|,
name|stmt
decl_stmt|,
name|rhs
init|=
name|NULL
decl_stmt|;
name|bool
name|dsa
decl_stmt|;
name|orig_stmt
operator|=
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
comment|/* Most control-altering statements must be initially  	     simulated, else we won't cover the entire cfg.  */
name|dsa
operator|=
operator|!
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
comment|/* We don't care what the lattice value of<retval> is, 		 since it's never used as an input to another computation.  */
name|dsa
operator|=
name|true
expr_stmt|;
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|MODIFY_EXPR
case|:
name|dsa
operator|=
operator|!
name|is_complex_reg
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|rhs
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|saw_a_complex_op
operator|=
name|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|DONT_SIMULATE_AGAIN
argument_list|(
name|orig_stmt
argument_list|)
operator|=
name|dsa
expr_stmt|;
block|}
block|}
return|return
name|saw_a_complex_op
return|;
block|}
end_function

begin_comment
comment|/* Evaluate statement STMT against the complex lattice defined above.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|complex_visit_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|edge
modifier|*
name|taken_edge_p
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
modifier|*
name|result_p
parameter_list|)
block|{
name|complex_lattice_t
name|new_l
decl_stmt|,
name|old_l
decl_stmt|,
name|op1_l
decl_stmt|,
name|op2_l
decl_stmt|;
name|unsigned
name|int
name|ver
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|SSA_PROP_VARYING
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* These conditions should be satisfied due to the initial filter      set up in init_dont_simulate_again.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
operator|*
name|result_p
operator|=
name|lhs
expr_stmt|;
name|ver
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|old_l
operator|=
name|VEC_index
argument_list|(
name|complex_lattice_t
argument_list|,
name|complex_lattice_values
argument_list|,
name|ver
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
case|case
name|COMPLEX_EXPR
case|:
case|case
name|COMPLEX_CST
case|:
name|new_l
operator|=
name|find_lattice_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|op1_l
operator|=
name|find_lattice_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op2_l
operator|=
name|find_lattice_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We've set up the lattice values such that IOR neatly 	 models addition.  */
name|new_l
operator|=
name|op1_l
operator||
name|op2_l
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
name|op1_l
operator|=
name|find_lattice_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op2_l
operator|=
name|find_lattice_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Obviously, if either varies, so does the result.  */
if|if
condition|(
name|op1_l
operator|==
name|VARYING
operator|||
name|op2_l
operator|==
name|VARYING
condition|)
name|new_l
operator|=
name|VARYING
expr_stmt|;
comment|/* Don't prematurely promote variables if we've not yet seen 	 their inputs.  */
elseif|else
if|if
condition|(
name|op1_l
operator|==
name|UNINITIALIZED
condition|)
name|new_l
operator|=
name|op2_l
expr_stmt|;
elseif|else
if|if
condition|(
name|op2_l
operator|==
name|UNINITIALIZED
condition|)
name|new_l
operator|=
name|op1_l
expr_stmt|;
else|else
block|{
comment|/* At this point both numbers have only one component. If the 	     numbers are of opposite kind, the result is imaginary, 	     otherwise the result is real. The add/subtract translates 	     the real/imag from/to 0/1; the ^ performs the comparison.  */
name|new_l
operator|=
operator|(
operator|(
name|op1_l
operator|-
name|ONLY_REAL
operator|)
operator|^
operator|(
name|op2_l
operator|-
name|ONLY_REAL
operator|)
operator|)
operator|+
name|ONLY_REAL
expr_stmt|;
comment|/* Don't allow the lattice value to flip-flop indefinitely.  */
name|new_l
operator||=
name|old_l
expr_stmt|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
name|new_l
operator|=
name|find_lattice_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_l
operator|=
name|VARYING
expr_stmt|;
break|break;
block|}
comment|/* If nothing changed this round, let the propagator know.  */
if|if
condition|(
name|new_l
operator|==
name|old_l
condition|)
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
name|VEC_replace
argument_list|(
name|complex_lattice_t
argument_list|,
name|complex_lattice_values
argument_list|,
name|ver
argument_list|,
name|new_l
argument_list|)
expr_stmt|;
return|return
name|new_l
operator|==
name|VARYING
condition|?
name|SSA_PROP_VARYING
else|:
name|SSA_PROP_INTERESTING
return|;
block|}
end_function

begin_comment
comment|/* Evaluate a PHI node against the complex lattice defined above.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|complex_visit_phi
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|complex_lattice_t
name|new_l
decl_stmt|,
name|old_l
decl_stmt|;
name|unsigned
name|int
name|ver
decl_stmt|;
name|tree
name|lhs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lhs
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
comment|/* This condition should be satisfied due to the initial filter      set up in init_dont_simulate_again.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
comment|/* We've set up the lattice values such that IOR neatly models PHI meet.  */
name|new_l
operator|=
name|UNINITIALIZED
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|new_l
operator||=
name|find_lattice_value
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ver
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|old_l
operator|=
name|VEC_index
argument_list|(
name|complex_lattice_t
argument_list|,
name|complex_lattice_values
argument_list|,
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_l
operator|==
name|old_l
condition|)
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
name|VEC_replace
argument_list|(
name|complex_lattice_t
argument_list|,
name|complex_lattice_values
argument_list|,
name|ver
argument_list|,
name|new_l
argument_list|)
expr_stmt|;
return|return
name|new_l
operator|==
name|VARYING
condition|?
name|SSA_PROP_VARYING
else|:
name|SSA_PROP_INTERESTING
return|;
block|}
end_function

begin_comment
comment|/* Create one backing variable for a complex component of ORIG.  */
end_comment

begin_function
specifier|static
name|tree
name|create_one_component_var
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|orig
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|r
init|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|add_referenced_var
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|orig
argument_list|)
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|orig
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inner_type
decl_stmt|;
name|DECL_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|ACONCAT
argument_list|(
operator|(
name|name
operator|,
name|suffix
operator|,
name|NULL
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_DEBUG_EXPR
argument_list|(
name|r
argument_list|,
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_NO_WARNING
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DECL_IGNORED_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a value for a complex component of VAR.  */
end_comment

begin_function
specifier|static
name|tree
name|get_component_var
parameter_list|(
name|tree
name|var
parameter_list|,
name|bool
name|imag_p
parameter_list|)
block|{
name|size_t
name|decl_index
init|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
operator|*
literal|2
operator|+
name|imag_p
decl_stmt|;
name|tree
name|ret
init|=
name|cvc_lookup
argument_list|(
name|decl_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|create_one_component_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|var
argument_list|,
name|imag_p
condition|?
literal|"CI"
else|:
literal|"CR"
argument_list|,
name|imag_p
condition|?
literal|"$imag"
else|:
literal|"$real"
argument_list|,
name|imag_p
condition|?
name|IMAGPART_EXPR
else|:
name|REALPART_EXPR
argument_list|)
expr_stmt|;
name|cvc_insert
argument_list|(
name|decl_index
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a value for a complex component of SSA_NAME.  */
end_comment

begin_function
specifier|static
name|tree
name|get_component_ssa_name
parameter_list|(
name|tree
name|ssa_name
parameter_list|,
name|bool
name|imag_p
parameter_list|)
block|{
name|complex_lattice_t
name|lattice
init|=
name|find_lattice_value
argument_list|(
name|ssa_name
argument_list|)
decl_stmt|;
name|size_t
name|ssa_name_index
decl_stmt|;
name|tree
name|ret
decl_stmt|;
if|if
condition|(
name|lattice
operator|==
operator|(
name|imag_p
condition|?
name|ONLY_REAL
else|:
name|ONLY_IMAG
operator|)
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|inner_type
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|inner_type
argument_list|,
name|dconst0
argument_list|)
return|;
else|else
return|return
name|build_int_cst
argument_list|(
name|inner_type
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|ssa_name_index
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|ssa_name
argument_list|)
operator|*
literal|2
operator|+
name|imag_p
expr_stmt|;
name|ret
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|complex_ssa_name_components
argument_list|,
name|ssa_name_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|get_component_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|,
name|imag_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|make_ssa_name
argument_list|(
name|ret
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy some properties from the original.  In particular, whether it 	 is used in an abnormal phi, and whether it's uninitialized.  */
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|ret
argument_list|)
operator|=
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|ssa_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|IS_EMPTY_STMT
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
condition|)
block|{
name|SSA_NAME_DEF_STMT
argument_list|(
name|ret
argument_list|)
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|ssa_name
argument_list|)
expr_stmt|;
name|set_default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ret
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|complex_ssa_name_components
argument_list|,
name|ssa_name_index
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Set a value for a complex component of SSA_NAME, return a STMT_LIST of    stuff that needs doing.  */
end_comment

begin_function
specifier|static
name|tree
name|set_component_ssa_name
parameter_list|(
name|tree
name|ssa_name
parameter_list|,
name|bool
name|imag_p
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|complex_lattice_t
name|lattice
init|=
name|find_lattice_value
argument_list|(
name|ssa_name
argument_list|)
decl_stmt|;
name|size_t
name|ssa_name_index
decl_stmt|;
name|tree
name|comp
decl_stmt|,
name|list
decl_stmt|,
name|last
decl_stmt|;
comment|/* We know the value must be zero, else there's a bug in our lattice      analysis.  But the value may well be a variable known to contain      zero.  We should be safe ignoring it.  */
if|if
condition|(
name|lattice
operator|==
operator|(
name|imag_p
condition|?
name|ONLY_REAL
else|:
name|ONLY_IMAG
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* If we've already assigned an SSA_NAME to this component, then this      means that our walk of the basic blocks found a use before the set.      This is fine.  Now we should create an initialization for the value      we created earlier.  */
name|ssa_name_index
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|ssa_name
argument_list|)
operator|*
literal|2
operator|+
name|imag_p
expr_stmt|;
name|comp
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|complex_ssa_name_components
argument_list|,
name|ssa_name_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
condition|)
empty_stmt|;
comment|/* If we've nothing assigned, and the value we're given is already stable,      then install that as the value for this SSA_NAME.  This preemptively      copy-propagates the value, which avoids unnecessary memory allocation.  */
elseif|else
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|complex_ssa_name_components
argument_list|,
name|ssa_name_index
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|ssa_name
argument_list|)
condition|)
block|{
comment|/* Replace an anonymous base value with the variable from cvc_lookup. 	 This should result in better debug info.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
condition|)
block|{
name|comp
operator|=
name|get_component_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|,
name|imag_p
argument_list|)
expr_stmt|;
name|replace_ssa_name_symbol
argument_list|(
name|value
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|complex_ssa_name_components
argument_list|,
name|ssa_name_index
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Finally, we need to stabilize the result by installing the value into      a new ssa name.  */
else|else
name|comp
operator|=
name|get_component_ssa_name
argument_list|(
name|ssa_name
argument_list|,
name|imag_p
argument_list|)
expr_stmt|;
comment|/* Do all the work to assign VALUE to COMP.  */
name|value
operator|=
name|force_gimple_operand
argument_list|(
name|value
argument_list|,
operator|&
name|list
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|last
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|comp
argument_list|)
argument_list|,
name|comp
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|last
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|comp
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|comp
argument_list|)
operator|=
name|last
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Extract the real or imaginary part of a complex variable or constant.    Make sure that it's a proper gimple_val and gimplify it if not.    Emit any new code before BSI.  */
end_comment

begin_function
specifier|static
name|tree
name|extract_component
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|t
parameter_list|,
name|bool
name|imagpart_p
parameter_list|,
name|bool
name|gimple_p
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|COMPLEX_CST
case|:
return|return
name|imagpart_p
condition|?
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
else|:
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
return|;
case|case
name|COMPLEX_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|imagpart_p
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|=
name|build1
argument_list|(
operator|(
name|imagpart_p
condition|?
name|IMAGPART_EXPR
else|:
name|REALPART_EXPR
operator|)
argument_list|,
name|inner_type
argument_list|,
name|unshare_expr
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimple_p
condition|)
name|t
operator|=
name|gimplify_val
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|SSA_NAME
case|:
return|return
name|get_component_ssa_name
argument_list|(
name|t
argument_list|,
name|imagpart_p
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the complex components of the ssa name on the lhs of STMT.  */
end_comment

begin_function
specifier|static
name|void
name|update_complex_components
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|r
parameter_list|,
name|tree
name|i
parameter_list|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|list
operator|=
name|set_component_ssa_name
argument_list|(
name|lhs
argument_list|,
name|false
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|bsi_insert_after
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|list
operator|=
name|set_component_ssa_name
argument_list|(
name|lhs
argument_list|,
name|true
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|bsi_insert_after
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_complex_components_on_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|r
parameter_list|,
name|tree
name|i
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
name|list
operator|=
name|set_component_ssa_name
argument_list|(
name|lhs
argument_list|,
name|false
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|set_component_ssa_name
argument_list|(
name|lhs
argument_list|,
name|true
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update an assignment to a complex variable in place.  */
end_comment

begin_function
specifier|static
name|void
name|update_complex_assignment
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|r
parameter_list|,
name|tree
name|i
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|mod
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mod
operator|=
name|stmt
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
name|mod
operator|=
name|TREE_OPERAND
argument_list|(
name|mod
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_ssa_p
condition|)
name|update_complex_components
argument_list|(
name|bsi
argument_list|,
name|stmt
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|mod
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|mod
argument_list|,
literal|1
argument_list|)
operator|=
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code at the entry point of the function to initialize the    component variables for a complex parameter.  */
end_comment

begin_function
specifier|static
name|void
name|update_parameter_components
parameter_list|(
name|void
parameter_list|)
block|{
name|edge
name|entry_edge
init|=
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
decl_stmt|;
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|ssa_name
decl_stmt|,
name|r
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|COMPLEX_TYPE
operator|||
operator|!
name|is_gimple_reg
argument_list|(
name|parm
argument_list|)
condition|)
continue|continue;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|ssa_name
operator|=
name|default_def
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssa_name
condition|)
continue|continue;
name|r
operator|=
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|ssa_name
argument_list|)
expr_stmt|;
name|i
operator|=
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|ssa_name
argument_list|)
expr_stmt|;
name|update_complex_components_on_edge
argument_list|(
name|entry_edge
argument_list|,
name|ssa_name
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to set the component variables of a complex variable    to match the PHI statements in block BB.  */
end_comment

begin_function
specifier|static
name|void
name|update_phi_components
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|is_complex_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|lr
decl_stmt|,
name|li
decl_stmt|,
name|pr
init|=
name|NULL
decl_stmt|,
name|pi
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|lr
operator|=
name|get_component_ssa_name
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|pr
operator|=
name|create_phi_node
argument_list|(
name|lr
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|lr
argument_list|)
operator|=
name|pr
expr_stmt|;
block|}
name|li
operator|=
name|get_component_ssa_name
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|li
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|pi
operator|=
name|create_phi_node
argument_list|(
name|li
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|li
argument_list|)
operator|=
name|pi
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|comp
decl_stmt|,
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pr
condition|)
block|{
name|comp
operator|=
name|extract_component
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|pr
argument_list|,
name|i
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
condition|)
block|{
name|comp
operator|=
name|extract_component
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|pi
argument_list|,
name|i
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark each virtual op in STMT for ssa update.  */
end_comment

begin_function
specifier|static
name|void
name|update_all_vops
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|sym
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|sym
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_VIRTUALS
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|sym
operator|=
name|SSA_NAME_VAR
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a complex move to scalars.  */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_move
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|r
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|is_ctrl_altering_stmt
argument_list|(
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
argument_list|)
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* The value is not assigned on the exception edges, so we need not 	     concern ourselves there.  We do need to update on the fallthru 	     edge.  Find it.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bsi->bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
goto|goto
name|found_fallthru
goto|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|found_fallthru
label|:
name|r
operator|=
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|inner_type
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|i
operator|=
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|inner_type
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|update_complex_components_on_edge
argument_list|(
name|e
argument_list|,
name|lhs
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|r
operator|=
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|inner_type
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|i
operator|=
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|inner_type
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|update_complex_components
argument_list|(
name|bsi
argument_list|,
name|stmt
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|update_all_vops
argument_list|(
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|i
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|tree
name|x
decl_stmt|;
name|r
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|i
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|inner_type
argument_list|,
name|unshare_expr
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|inner_type
argument_list|,
name|x
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|x
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|==
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|inner_type
argument_list|,
name|unshare_expr
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|i
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|inner_type
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|inner_type
argument_list|,
name|unshare_expr
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|inner_type
argument_list|,
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|x
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|lhs
expr_stmt|;
block|}
name|update_all_vops
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand complex addition to scalars: 	a + b = (ar + br) + i(ai + bi) 	a - b = (ar - br) + i(ai + bi) */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_addition
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|,
name|tree
name|br
parameter_list|,
name|tree
name|bi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|complex_lattice_t
name|al
parameter_list|,
name|complex_lattice_t
name|bl
parameter_list|)
block|{
name|tree
name|rr
decl_stmt|,
name|ri
decl_stmt|;
switch|switch
condition|(
name|PAIR
argument_list|(
name|al
argument_list|,
name|bl
argument_list|)
condition|)
block|{
case|case
name|PAIR
argument_list|(
name|ONLY_REAL
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|ai
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_REAL
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|ar
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MINUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
else|else
name|ri
operator|=
name|bi
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MINUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
else|else
name|rr
operator|=
name|br
expr_stmt|;
name|ri
operator|=
name|ai
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|ar
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|ai
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|ar
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_REAL
argument_list|,
name|VARYING
argument_list|)
case|:
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
goto|goto
name|general
goto|;
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|bi
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|VARYING
argument_list|)
case|:
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
goto|goto
name|general
goto|;
name|rr
operator|=
name|br
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|VARYING
argument_list|)
case|:
name|general
label|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|rr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a complex multiplication or division to a libcall to the c99    compliant routines.  */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_libcall
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|,
name|tree
name|br
parameter_list|,
name|tree
name|bi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|built_in_function
name|bcode
decl_stmt|;
name|tree
name|args
decl_stmt|,
name|fn
decl_stmt|,
name|stmt
decl_stmt|,
name|type
decl_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|bi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|br
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|ai
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|ar
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
condition|)
name|bcode
operator|=
name|BUILT_IN_COMPLEX_MUL_MIN
operator|+
name|mode
operator|-
name|MIN_MODE_COMPLEX_FLOAT
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|RDIV_EXPR
condition|)
name|bcode
operator|=
name|BUILT_IN_COMPLEX_DIV_MIN
operator|+
name|mode
operator|-
name|MIN_MODE_COMPLEX_FLOAT
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|fn
operator|=
name|built_in_decls
index|[
name|bcode
index|]
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|type
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_ssa_p
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|update_complex_components
argument_list|(
name|bsi
argument_list|,
name|stmt
argument_list|,
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|)
argument_list|,
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand complex multiplication to scalars: 	a * b = (ar*br - ai*bi) + i(ar*bi + br*ai) */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_multiplication
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|,
name|tree
name|br
parameter_list|,
name|tree
name|bi
parameter_list|,
name|complex_lattice_t
name|al
parameter_list|,
name|complex_lattice_t
name|bl
parameter_list|)
block|{
name|tree
name|rr
decl_stmt|,
name|ri
decl_stmt|;
if|if
condition|(
name|al
operator|<
name|bl
condition|)
block|{
name|complex_lattice_t
name|tl
decl_stmt|;
name|rr
operator|=
name|ar
operator|,
name|ar
operator|=
name|br
operator|,
name|br
operator|=
name|rr
expr_stmt|;
name|ri
operator|=
name|ai
operator|,
name|ai
operator|=
name|bi
operator|,
name|bi
operator|=
name|ri
expr_stmt|;
name|tl
operator|=
name|al
operator|,
name|al
operator|=
name|bl
operator|,
name|bl
operator|=
name|tl
expr_stmt|;
block|}
switch|switch
condition|(
name|PAIR
argument_list|(
name|al
argument_list|,
name|bl
argument_list|)
condition|)
block|{
case|case
name|PAIR
argument_list|(
name|ONLY_REAL
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|ai
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|ar
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ai
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|ai
argument_list|)
argument_list|,
name|dconst1
argument_list|)
condition|)
name|ri
operator|=
name|br
expr_stmt|;
else|else
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|br
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|rr
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|NEGATE_EXPR
argument_list|,
name|inner_type
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|ri
operator|=
name|ar
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|br
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|rr
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|NEGATE_EXPR
argument_list|,
name|inner_type
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|bi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|VARYING
argument_list|)
case|:
if|if
condition|(
name|flag_complex_method
operator|==
literal|2
operator|&&
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|inner_type
argument_list|)
condition|)
block|{
name|expand_complex_libcall
argument_list|(
name|bsi
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|MULT_EXPR
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|t3
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|bi
argument_list|)
expr_stmt|;
comment|/* Avoid expanding redundant multiplication for the common 	     case of squaring a complex number.  */
if|if
condition|(
name|ar
operator|==
name|br
operator|&&
name|ai
operator|==
name|bi
condition|)
name|t4
operator|=
name|t3
expr_stmt|;
else|else
name|t4
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MINUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|PLUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t3
argument_list|,
name|t4
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|rr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand complex division to scalars, straightforward algorithm. 	a / b = ((ar*br + ai*bi)/t) + i((ai*br - ar*bi)/t) 	    t = br*br + bi*bi */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_div_straight
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|,
name|tree
name|br
parameter_list|,
name|tree
name|bi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|rr
decl_stmt|,
name|ri
decl_stmt|,
name|div
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|br
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|bi
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|div
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|PLUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|t3
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|PLUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|t3
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|t3
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MINUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|t3
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|rr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand complex division to scalars, modified algorithm to minimize    overflow with wide input ranges.  */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_div_wide
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|,
name|tree
name|br
parameter_list|,
name|tree
name|bi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|rr
decl_stmt|,
name|ri
decl_stmt|,
name|ratio
decl_stmt|,
name|div
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|tr
decl_stmt|,
name|ti
decl_stmt|,
name|cond
decl_stmt|;
name|basic_block
name|bb_cond
decl_stmt|,
name|bb_true
decl_stmt|,
name|bb_false
decl_stmt|,
name|bb_join
decl_stmt|;
comment|/* Examine |br|< |bi|, and branch.  */
name|t1
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|ABS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|ABS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold_build2
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|bb_cond
operator|=
name|bb_true
operator|=
name|bb_false
operator|=
name|bb_join
operator|=
name|NULL
expr_stmt|;
name|rr
operator|=
name|ri
operator|=
name|tr
operator|=
name|ti
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|cond
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|cond
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Split the original block, and create the TRUE and FALSE blocks.  */
name|e
operator|=
name|split_block
argument_list|(
name|bsi
operator|->
name|bb
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|bb_cond
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|bb_join
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|bb_true
operator|=
name|create_empty_bb
argument_list|(
name|bb_cond
argument_list|)
expr_stmt|;
name|bb_false
operator|=
name|create_empty_bb
argument_list|(
name|bb_true
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|bb_true
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|bb_false
argument_list|)
argument_list|)
expr_stmt|;
name|COND_EXPR_THEN
argument_list|(
name|cond
argument_list|)
operator|=
name|t1
expr_stmt|;
name|COND_EXPR_ELSE
argument_list|(
name|cond
argument_list|)
operator|=
name|t2
expr_stmt|;
comment|/* Wire the blocks together.  */
name|e
operator|->
name|flags
operator|=
name|EDGE_TRUE_VALUE
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|bb_true
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bb_cond
argument_list|,
name|bb_false
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bb_true
argument_list|,
name|bb_join
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bb_false
argument_list|,
name|bb_join
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
comment|/* Update dominance info.  Note that bb_join's data was          updated by split_block.  */
if|if
condition|(
name|dom_info_available_p
argument_list|(
name|CDI_DOMINATORS
argument_list|)
condition|)
block|{
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb_true
argument_list|,
name|bb_cond
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb_false
argument_list|,
name|bb_cond
argument_list|)
expr_stmt|;
block|}
name|rr
operator|=
name|make_rename_temp
argument_list|(
name|inner_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ri
operator|=
name|make_rename_temp
argument_list|(
name|inner_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* In the TRUE branch, we compute       ratio = br/bi;       div = (br * ratio) + bi;       tr = (ar * ratio) + ai;       ti = (ai * ratio) - ar;       tr = tr / div;       ti = ti / div;  */
if|if
condition|(
name|bb_true
operator|||
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
if|if
condition|(
name|bb_true
condition|)
block|{
operator|*
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb_true
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
name|bsi
argument_list|,
name|build_empty_stmt
argument_list|()
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
name|ratio
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|br
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|br
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|div
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|PLUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|tr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|PLUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|ti
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MINUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|ar
argument_list|)
expr_stmt|;
name|tr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|tr
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|ti
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ti
argument_list|,
name|div
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_true
condition|)
block|{
name|t1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|inner_type
argument_list|,
name|rr
argument_list|,
name|tr
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|t1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ri
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|t1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In the FALSE branch, we compute       ratio = d/c;       divisor = (d * ratio) + c;       tr = (b * ratio) + a;       ti = b - (a * ratio);       tr = tr / div;       ti = ti / div;  */
if|if
condition|(
name|bb_false
operator|||
name|integer_zerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
if|if
condition|(
name|bb_false
condition|)
block|{
operator|*
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb_false
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
name|bsi
argument_list|,
name|build_empty_stmt
argument_list|()
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
name|ratio
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|bi
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|bi
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|div
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|PLUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|tr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|PLUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|t1
argument_list|,
name|ar
argument_list|)
expr_stmt|;
name|t1
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MULT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|ti
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MINUS_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|tr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|tr
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|ti
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ti
argument_list|,
name|div
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_false
condition|)
block|{
name|t1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|inner_type
argument_list|,
name|rr
argument_list|,
name|tr
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|t1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ri
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|t1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bb_join
condition|)
operator|*
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb_join
argument_list|)
expr_stmt|;
else|else
name|rr
operator|=
name|tr
operator|,
name|ri
operator|=
name|ti
expr_stmt|;
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|rr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand complex division to scalars.  */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_division
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|,
name|tree
name|br
parameter_list|,
name|tree
name|bi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|complex_lattice_t
name|al
parameter_list|,
name|complex_lattice_t
name|bl
parameter_list|)
block|{
name|tree
name|rr
decl_stmt|,
name|ri
decl_stmt|;
switch|switch
condition|(
name|PAIR
argument_list|(
name|al
argument_list|,
name|bl
argument_list|)
condition|)
block|{
case|case
name|PAIR
argument_list|(
name|ONLY_REAL
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|ai
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_REAL
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|ai
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|NEGATE_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ri
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|ar
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|br
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|ri
operator|=
name|ar
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|ONLY_REAL
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|br
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|ONLY_IMAG
argument_list|)
case|:
name|rr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|NEGATE_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ri
argument_list|)
expr_stmt|;
case|case
name|PAIR
argument_list|(
name|ONLY_REAL
argument_list|,
name|VARYING
argument_list|)
case|:
case|case
name|PAIR
argument_list|(
name|ONLY_IMAG
argument_list|,
name|VARYING
argument_list|)
case|:
case|case
name|PAIR
argument_list|(
name|VARYING
argument_list|,
name|VARYING
argument_list|)
case|:
switch|switch
condition|(
name|flag_complex_method
condition|)
block|{
case|case
literal|0
case|:
comment|/* straightforward implementation of complex divide acceptable.  */
name|expand_complex_div_straight
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|inner_type
argument_list|)
condition|)
block|{
name|expand_complex_libcall
argument_list|(
name|bsi
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
literal|1
case|:
comment|/* wide ranges of inputs must work for complex divide.  */
name|expand_complex_div_wide
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|rr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand complex negation to scalars: 	-a = (-ar) + i(-ai) */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_negation
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|)
block|{
name|tree
name|rr
decl_stmt|,
name|ri
decl_stmt|;
name|rr
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|NEGATE_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|)
expr_stmt|;
name|ri
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|NEGATE_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|rr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand complex conjugate to scalars: 	~a = (ar) + i(-ai) */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_conjugate
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|)
block|{
name|tree
name|ri
decl_stmt|;
name|ri
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|NEGATE_EXPR
argument_list|,
name|inner_type
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|update_complex_assignment
argument_list|(
name|bsi
argument_list|,
name|ar
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand complex comparison (EQ or NE only).  */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_comparison
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|ar
parameter_list|,
name|tree
name|ai
parameter_list|,
name|tree
name|br
parameter_list|,
name|tree
name|bi
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|cr
decl_stmt|,
name|ci
decl_stmt|,
name|cc
decl_stmt|,
name|stmt
decl_stmt|,
name|expr
decl_stmt|,
name|type
decl_stmt|;
name|cr
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|boolean_type_node
argument_list|,
name|ar
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|ci
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|boolean_type_node
argument_list|,
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|cc
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
operator|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
operator|)
argument_list|,
name|boolean_type_node
argument_list|,
name|cr
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|expr
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|MODIFY_EXPR
case|:
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|cc
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process one statement.  If we identify a complex operation, expand it.  */
end_comment

begin_function
specifier|static
name|void
name|expand_complex_operations_1
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
decl_stmt|;
name|tree
name|rhs
decl_stmt|,
name|type
decl_stmt|,
name|inner_type
decl_stmt|;
name|tree
name|ac
decl_stmt|,
name|ar
decl_stmt|,
name|ai
decl_stmt|,
name|bc
decl_stmt|,
name|br
decl_stmt|,
name|bi
decl_stmt|;
name|complex_lattice_t
name|al
decl_stmt|,
name|bl
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return;
comment|/* FALLTHRU */
case|case
name|MODIFY_EXPR
case|:
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Initial filter for operations we handle.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return;
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return;
break|break;
default|default:
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|expand_complex_move
argument_list|(
name|bsi
argument_list|,
name|stmt
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|IMAGPART_EXPR
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* Extract the components of the two complex values.  Make sure and      handle the common case of the same value used twice specially.  */
name|ac
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|ac
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ai
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|ac
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
condition|)
name|bc
operator|=
name|br
operator|=
name|bi
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|bc
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|bc
condition|)
name|br
operator|=
name|ar
operator|,
name|bi
operator|=
name|ai
expr_stmt|;
else|else
block|{
name|br
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|bc
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|bi
operator|=
name|extract_component
argument_list|(
name|bsi
argument_list|,
name|bc
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_ssa_p
condition|)
block|{
name|al
operator|=
name|find_lattice_value
argument_list|(
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
name|UNINITIALIZED
condition|)
name|al
operator|=
name|VARYING
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
condition|)
name|bl
operator|=
name|UNINITIALIZED
expr_stmt|;
elseif|else
if|if
condition|(
name|ac
operator|==
name|bc
condition|)
name|bl
operator|=
name|al
expr_stmt|;
else|else
block|{
name|bl
operator|=
name|find_lattice_value
argument_list|(
name|bc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|==
name|UNINITIALIZED
condition|)
name|bl
operator|=
name|VARYING
expr_stmt|;
block|}
block|}
else|else
name|al
operator|=
name|bl
operator|=
name|VARYING
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|expand_complex_addition
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|code
argument_list|,
name|al
argument_list|,
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|expand_complex_multiplication
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|al
argument_list|,
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
name|expand_complex_division
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|code
argument_list|,
name|al
argument_list|,
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
name|expand_complex_negation
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
name|expand_complex_conjugate
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|expand_complex_comparison
argument_list|(
name|bsi
argument_list|,
name|ar
argument_list|,
name|ai
argument_list|,
name|br
argument_list|,
name|bi
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point for complex operation lowering during optimization.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_lower_complex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|old_last_basic_block
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|init_dont_simulate_again
argument_list|()
condition|)
return|return
literal|0
return|;
name|complex_lattice_values
operator|=
name|VEC_alloc
argument_list|(
name|complex_lattice_t
argument_list|,
name|heap
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|complex_lattice_t
argument_list|,
name|heap
argument_list|,
name|complex_lattice_values
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|VEC_address
argument_list|(
name|complex_lattice_t
argument_list|,
name|complex_lattice_values
argument_list|)
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
name|complex_lattice_t
argument_list|)
argument_list|)
expr_stmt|;
name|init_parameter_lattice_values
argument_list|()
expr_stmt|;
name|ssa_propagate
argument_list|(
name|complex_visit_stmt
argument_list|,
name|complex_visit_phi
argument_list|)
expr_stmt|;
name|complex_variable_components
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|int_tree_map_hash
argument_list|,
name|int_tree_map_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|complex_ssa_name_components
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|2
operator|*
name|num_ssa_names
argument_list|)
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|complex_ssa_name_components
argument_list|,
literal|2
operator|*
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|complex_ssa_name_components
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|update_parameter_components
argument_list|()
expr_stmt|;
comment|/* ??? Ideally we'd traverse the blocks in breadth-first order.  */
name|old_last_basic_block
operator|=
name|last_basic_block
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
name|old_last_basic_block
condition|)
continue|continue;
name|update_phi_components
argument_list|(
name|bb
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|expand_complex_operations_1
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
name|htab_delete
argument_list|(
name|complex_variable_components
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|complex_ssa_name_components
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|complex_lattice_t
argument_list|,
name|heap
argument_list|,
name|complex_lattice_values
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_lower_complex
init|=
block|{
literal|"cplxlower"
block|,
comment|/* name */
literal|0
block|,
comment|/* gate */
name|tree_lower_complex
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_ssa
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_update_smt_usage
operator||
name|TODO_update_ssa
operator||
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Entry point for complex operation lowering without optimization.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_lower_complex_O0
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|old_last_basic_block
init|=
name|last_basic_block
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|bb
operator|->
name|index
operator|>=
name|old_last_basic_block
condition|)
continue|continue;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|expand_complex_operations_1
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_no_optimization
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* With errors, normal optimization passes are not run.  If we don't      lower complex operations at all, rtl expansion will abort.  */
return|return
name|optimize
operator|==
literal|0
operator|||
name|sorrycount
operator|||
name|errorcount
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_lower_complex_O0
init|=
block|{
literal|"cplxlower0"
block|,
comment|/* name */
name|gate_no_optimization
block|,
comment|/* gate */
name|tree_lower_complex_O0
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

