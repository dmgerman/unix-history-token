begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Register to Stack convert for GNU compiler.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This pass converts stack-like registers from the "flat register    file" model that gcc uses, to a stack convention that the 387 uses.     * The form of the input:     On input, the function consists of insn that have had their    registers fully allocated to a set of "virtual" registers.  Note that    the word "virtual" is used differently here than elsewhere in gcc: for    each virtual stack reg, there is a hard reg, but the mapping between    them is not known until this pass is run.  On output, hard register    numbers have been substituted, and various pop and exchange insns have    been emitted.  The hard register numbers and the virtual register    numbers completely overlap - before this pass, all stack register    numbers are virtual, and afterward they are all hard.     The virtual registers can be manipulated normally by gcc, and their    semantics are the same as for normal registers.  After the hard    register numbers are substituted, the semantics of an insn containing    stack-like regs are not the same as for an insn with normal regs: for    instance, it is not safe to delete an insn that appears to be a no-op    move.  In general, no insn containing hard regs should be changed    after this pass is done.     * The form of the output:     After this pass, hard register numbers represent the distance from    the current top of stack to the desired register.  A reference to    FIRST_STACK_REG references the top of stack, FIRST_STACK_REG + 1,    represents the register just below that, and so forth.  Also, REG_DEAD    notes indicate whether or not a stack register should be popped.     A "swap" insn looks like a parallel of two patterns, where each    pattern is a SET: one sets A to B, the other B to A.     A "push" or "load" insn is a SET whose SET_DEST is FIRST_STACK_REG    and whose SET_DEST is REG or MEM.  Any other SET_DEST, such as PLUS,    will replace the existing stack top, not push a new value.     A store insn is a SET whose SET_DEST is FIRST_STACK_REG, and whose    SET_SRC is REG or MEM.     The case where the SET_SRC and SET_DEST are both FIRST_STACK_REG    appears ambiguous.  As a special case, the presence of a REG_DEAD note    for FIRST_STACK_REG differentiates between a load insn and a pop.     If a REG_DEAD is present, the insn represents a "pop" that discards    the top of the register stack.  If there is no REG_DEAD note, then the    insn represents a "dup" or a push of the current top of stack onto the    stack.     * Methodology:     Existing REG_DEAD and REG_UNUSED notes for stack registers are    deleted and recreated from scratch.  REG_DEAD is never created for a    SET_DEST, only REG_UNUSED.     * asm_operands:     There are several rules on the usage of stack-like regs in    asm_operands insns.  These rules apply only to the operands that are    stack-like regs:     1. Given a set of input regs that die in an asm_operands, it is       necessary to know which are implicitly popped by the asm, and       which must be explicitly popped by gcc.  	An input reg that is implicitly popped by the asm must be 	explicitly clobbered, unless it is constrained to match an 	output operand.     2. For any input reg that is implicitly popped by an asm, it is       necessary to know how to adjust the stack to compensate for the pop.       If any non-popped input is closer to the top of the reg-stack than       the implicitly popped reg, it would not be possible to know what the       stack looked like - it's not clear how the rest of the stack "slides       up".  	All implicitly popped input regs must be closer to the top of 	the reg-stack than any input that is not implicitly popped.     3. It is possible that if an input dies in an insn, reload might       use the input reg for an output reload.  Consider this example:  		asm ("foo" : "=t" (a) : "f" (b));        This asm says that input B is not popped by the asm, and that       the asm pushes a result onto the reg-stack, ie, the stack is one       deeper after the asm than it was before.  But, it is possible that       reload will think that it can use the same reg for both the input and       the output, if input B dies in this insn.  	If any input operand uses the "f" constraint, all output reg 	constraints must use the "&" earlyclobber.        The asm above would be written as  		asm ("foo" : "=&t" (a) : "f" (b));     4. Some operands need to be in particular places on the stack.  All       output operands fall in this category - there is no other way to       know which regs the outputs appear in unless the user indicates       this in the constraints.  	Output operands must specifically indicate which reg an output 	appears in after an asm.  "=f" is not allowed: the operand 	constraints must select a class with a single reg.     5. Output operands may not be "inserted" between existing stack regs.       Since no 387 opcode uses a read/write operand, all output operands       are dead before the asm_operands, and are pushed by the asm_operands.       It makes no sense to push anywhere but the top of the reg-stack.  	Output operands must start at the top of the reg-stack: output 	operands may not "skip" a reg.     6. Some asm statements may need extra stack space for internal       calculations.  This can be guaranteed by clobbering stack registers       unrelated to the inputs and outputs.     Here are a couple of reasonable asms to want to write.  This asm    takes one input, which is internally popped, and produces two outputs.  	asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));     This asm takes two inputs, which are popped by the fyl2xp1 opcode,    and replaces them with one output.  The user must code the "st(1)"    clobber for reg-stack.c to know that fyl2xp1 pops both inputs.  	asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_REGS
end_ifdef

begin_define
define|#
directive|define
name|REG_STACK_SIZE
value|(LAST_STACK_REG - FIRST_STACK_REG + 1)
end_define

begin_comment
comment|/* This is the basic stack record.  TOP is an index into REG[] such    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.     If TOP is -2, REG[] is not yet initialized.  Stack initialization    consists of placing each live reg in array `reg' and setting `top'    appropriately.     REG_SET indicates which registers are live.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|stack_def
block|{
name|int
name|top
decl_stmt|;
comment|/* index to top stack element */
name|HARD_REG_SET
name|reg_set
decl_stmt|;
comment|/* set of live registers */
name|unsigned
name|char
name|reg
index|[
name|REG_STACK_SIZE
index|]
decl_stmt|;
comment|/* register - stack mapping */
block|}
typedef|*
name|stack
typedef|;
end_typedef

begin_comment
comment|/* This is used to carry information about basic blocks.  It is     attached to the AUX field of the standard CFG block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|block_info_def
block|{
name|struct
name|stack_def
name|stack_in
decl_stmt|;
comment|/* Input stack configuration.  */
name|struct
name|stack_def
name|stack_out
decl_stmt|;
comment|/* Output stack configuration.  */
name|HARD_REG_SET
name|out_reg_set
decl_stmt|;
comment|/* Stack regs live on output.  */
name|int
name|done
decl_stmt|;
comment|/* True if block already converted.  */
name|int
name|predecessors
decl_stmt|;
comment|/* Number of predecessors that needs 				   to be visited.  */
block|}
typedef|*
name|block_info
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BLOCK_INFO
parameter_list|(
name|B
parameter_list|)
value|((block_info) (B)->aux)
end_define

begin_comment
comment|/* Passed to change_stack to indicate where to emit insns.  */
end_comment

begin_enum
enum|enum
name|emit_where
block|{
name|EMIT_AFTER
block|,
name|EMIT_BEFORE
block|}
enum|;
end_enum

begin_comment
comment|/* We use this array to cache info about insns, because otherwise we    spend too much time in stack_regs_mentioned_p.      Indexed by insn UIDs.  A value of zero is uninitialized, one indicates    the insn uses stack registers, two indicates the insn does not use    stack registers.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|stack_regs_mentioned_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The block we're currently working on.  */
end_comment

begin_decl_stmt
specifier|static
name|basic_block
name|current_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the register file for all register after conversion */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|FP_mode_reg
index|[
name|LAST_STACK_REG
operator|+
literal|1
operator|-
name|FIRST_STACK_REG
index|]
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FP_MODE_REG
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
define|\
value|(FP_mode_reg[(regno)-FIRST_STACK_REG][(int) (mode)])
end_define

begin_comment
comment|/* Used to initialize uninitialized registers.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|nan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stack_regs_mentioned_p
name|PARAMS
argument_list|(
operator|(
name|rtx
name|pat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|straighten_stack
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_stack
name|PARAMS
argument_list|(
operator|(
name|stack
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|get_true_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_asm_stack_operands
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_asm_operand_n_inputs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|stack_result
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_regno_note
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|reg_note
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_hard_regnum
name|PARAMS
argument_list|(
operator|(
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|emit_pop_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|,
expr|enum
name|emit_where
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_swap_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_for_stack_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_rtx_condition_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_rtx_condition
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compare_for_stack_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_stack_regs_pat
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_asm_stack_regs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_stack_regs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|change_stack
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|stack
operator|,
expr|enum
name|emit_where
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|convert_regs_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_regs_exit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|convert_regs_1
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|convert_regs_2
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|convert_regs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_stack
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|next_flags_user
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_label_references
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|compensate_edge
name|PARAMS
argument_list|(
operator|(
name|edge
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if any stack register is mentioned somewhere within PAT.  */
end_comment

begin_function
specifier|static
name|int
name|stack_regs_mentioned_p
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|stack_regs_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN mentions stacked registers, else return zero.  */
end_comment

begin_function
name|int
name|stack_regs_mentioned
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|,
name|max
decl_stmt|;
name|int
name|test
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|stack_regs_mentioned_data
condition|)
return|return
literal|0
return|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|max
operator|=
name|VARRAY_SIZE
argument_list|(
name|stack_regs_mentioned_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
name|max
condition|)
block|{
comment|/* Allocate some extra size to avoid too many reallocs, but 	 do not grow too quickly.  */
name|max
operator|=
name|uid
operator|+
name|uid
operator|/
literal|20
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
name|test
operator|=
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|==
literal|0
condition|)
block|{
comment|/* This insn has yet to be examined.  Do so now.  */
name|test
operator|=
name|stack_regs_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|uid
argument_list|)
operator|=
name|test
expr_stmt|;
block|}
return|return
name|test
operator|==
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|rtx
name|ix86_flags_rtx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|next_flags_user
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Search forward looking for the first use of this value.       Stop at block boundaries.  */
while|while
condition|(
name|insn
operator|!=
name|current_block
operator|->
name|end
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|ix86_flags_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|insn
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
name|NULL_RTX
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reorganise the stack into ascending numbers,    after this insn.  */
end_comment

begin_function
specifier|static
name|void
name|straighten_stack
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|struct
name|stack_def
name|temp_stack
decl_stmt|;
name|int
name|top
decl_stmt|;
comment|/* If there is only a single register on the stack, then the stack is      already in increasing order and no reorganization is needed.       Similarly if the stack is empty.  */
if|if
condition|(
name|regstack
operator|->
name|top
operator|<=
literal|0
condition|)
return|return;
name|COPY_HARD_REG_SET
argument_list|(
name|temp_stack
operator|.
name|reg_set
argument_list|,
name|regstack
operator|->
name|reg_set
argument_list|)
expr_stmt|;
for|for
control|(
name|top
operator|=
name|temp_stack
operator|.
name|top
operator|=
name|regstack
operator|->
name|top
init|;
name|top
operator|>=
literal|0
condition|;
name|top
operator|--
control|)
name|temp_stack
operator|.
name|reg
index|[
name|top
index|]
operator|=
name|FIRST_STACK_REG
operator|+
name|temp_stack
operator|.
name|top
operator|-
name|top
expr_stmt|;
name|change_stack
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|&
name|temp_stack
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a register from the stack */
end_comment

begin_function
specifier|static
name|void
name|pop_stack
parameter_list|(
name|regstack
parameter_list|,
name|regno
parameter_list|)
name|stack
name|regstack
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|top
init|=
name|regstack
operator|->
name|top
decl_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
comment|/* If regno was not at the top of stack then adjust stack */
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|top
index|]
operator|!=
name|regno
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|regno
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|top
condition|;
name|j
operator|++
control|)
name|regstack
operator|->
name|reg
index|[
name|j
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert register usage from "flat" register file usage to a "stack    register file.  FIRST is the first insn in the function, FILE is the    dump file, if used.     Construct a CFG and run life analysis.  Then convert each insn one    by one.  Run a last cleanup_cfg pass, if optimizing, to eliminate    code duplication created when the converter inserts pop insns on    the edges.  */
end_comment

begin_function
name|void
name|reg_to_stack
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
comment|/* Clean up previous run.  */
if|if
condition|(
name|stack_regs_mentioned_data
condition|)
block|{
name|VARRAY_FREE
argument_list|(
name|stack_regs_mentioned_data
argument_list|)
expr_stmt|;
name|stack_regs_mentioned_data
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|optimize
condition|)
name|split_all_insns
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* See if there is something to do.  Flow analysis is quite      expensive so we might save some compilation time.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|>
name|LAST_STACK_REG
condition|)
return|return;
comment|/* Ok, floating point instructions exist.  If not optimizing,       build the CFG and run life analysis.  */
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
name|find_basic_blocks
argument_list|(
name|first
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|life_analysis
argument_list|(
name|first
argument_list|,
name|file
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
block|}
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
comment|/* Set up block info for each basic block.  */
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|block_info_def
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|predecessors
operator|++
expr_stmt|;
block|}
comment|/* Create the replacement registers up front.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|FP_MODE_REG
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_COMPLEX_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|FP_MODE_REG
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|ix86_flags_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
comment|/* A QNaN for initializing uninitialized variables.         ??? We can't load from constant memory in PIC mode, because      we're insertting these instructions before the prologue and      the PIC register hasn't been set up.  In that case, fall back      on zero, which we can get from `ldz'.  */
if|if
condition|(
name|flag_pic
condition|)
name|nan
operator|=
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
else|else
block|{
name|nan
operator|=
name|gen_lowpart
argument_list|(
name|SFmode
argument_list|,
name|GEN_INT
argument_list|(
literal|0x7fc00000
argument_list|)
argument_list|)
expr_stmt|;
name|nan
operator|=
name|force_const_mem
argument_list|(
name|SFmode
argument_list|,
name|nan
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate a cache for stack_regs_mentioned.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|VARRAY_CHAR_INIT
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|max_uid
operator|+
literal|1
argument_list|,
literal|"stack_regs_mentioned cache"
argument_list|)
expr_stmt|;
name|convert_regs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the    label's chain of references, and note which insn contains each    reference.  */
end_comment

begin_function
specifier|static
name|void
name|record_label_references
parameter_list|(
name|insn
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is an undefined label, LABEL_REFS (label) contains          garbage.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Don't make a duplicate in the code_label's chain.  */
for|for
control|(
name|ref
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
name|ref
operator|&&
name|ref
operator|!=
name|label
condition|;
name|ref
operator|=
name|LABEL_NEXTREF
argument_list|(
name|ref
argument_list|)
control|)
if|if
condition|(
name|CONTAINING_INSN
argument_list|(
name|ref
argument_list|)
operator|==
name|insn
condition|)
return|return;
name|CONTAINING_INSN
argument_list|(
name|pat
argument_list|)
operator|=
name|insn
expr_stmt|;
name|LABEL_NEXTREF
argument_list|(
name|pat
argument_list|)
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
operator|=
name|pat
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a pointer to the REG expression within PAT.  If PAT is not a    REG, possible enclosed by a conversion rtx, return the inner part of    PAT that stopped the search.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|get_true_reg
parameter_list|(
name|pat
parameter_list|)
name|rtx
modifier|*
name|pat
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* Eliminate FP subregister accesses in favour of the 	   actual FP register in use.  */
block|{
name|rtx
name|subreg
decl_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|subreg
operator|=
name|SUBREG_REG
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno_off
init|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|subreg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|pat
operator|=
name|FP_MODE_REG
argument_list|(
name|REGNO
argument_list|(
name|subreg
argument_list|)
operator|+
name|regno_off
argument_list|,
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
argument_list|)
expr_stmt|;
default|default:
return|return
name|pat
return|;
block|}
block|}
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|FLOAT_EXTEND
case|:
name|pat
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* There are many rules that an asm statement for stack-like regs must    follow.  Those rules are explained at the top of this file: the rule    numbers below refer to that explanation.  */
end_comment

begin_function
specifier|static
name|int
name|check_asm_stack_operands
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_clobbers
decl_stmt|;
name|int
name|malformed_asm
init|=
literal|0
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|char
name|reg_used_as_output
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|char
name|implicitly_dies
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|alt
decl_stmt|;
name|rtx
modifier|*
name|clobber_reg
init|=
literal|0
decl_stmt|;
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
comment|/* Find out what the constraints require.  If no constraint      alternative matches, this asm is malformed.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alt
operator|=
name|which_alternative
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
name|n_inputs
operator|=
name|get_asm_operand_n_inputs
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|n_outputs
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
name|n_inputs
expr_stmt|;
if|if
condition|(
name|alt
operator|<
literal|0
condition|)
block|{
name|malformed_asm
operator|=
literal|1
expr_stmt|;
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Strip SUBREGs here to make the following code simpler.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set up CLOBBER_REG.  */
name|n_clobbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|clobber_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobber
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|clobber_reg
index|[
name|n_clobbers
index|]
operator|=
name|reg
expr_stmt|;
name|n_clobbers
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Enforce rule #4: Output operands must specifically indicate which      reg an output appears in after an asm.  "=f" is not allowed: the      operand constraints must select a class with a single reg.       Also enforce rule #5: Output operands must start at the top of      the reg-stack: output operands may not "skip" a reg.  */
name|memset
argument_list|(
name|reg_used_as_output
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_used_as_output
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
index|]
operator|!=
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"output constraint %d must specify a single register"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_clobbers
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"output constraint %d cannot be specified together with \"%s\" clobber"
argument_list|,
name|i
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|n_clobbers
condition|)
name|reg_used_as_output
index|[
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Search for first non-popped reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|reg_used_as_output
index|[
name|i
index|]
condition|)
break|break;
comment|/* If there are any other popped regs, that's an error.  */
for|for
control|(
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_used_as_output
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|LAST_STACK_REG
operator|+
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"output regs must be grouped at top of stack"
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Enforce rule #2: All implicitly popped input regs must be closer      to the top of the reg-stack than any input that is not implicitly      popped.  */
name|memset
argument_list|(
name|implicitly_dies
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|implicitly_dies
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* An input reg is implicitly popped if it is tied to an 	   output, or if there is a CLOBBER for it.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_clobbers
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|n_clobbers
operator|||
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
operator|>=
literal|0
condition|)
name|implicitly_dies
index|[
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Search for first non-popped reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|implicitly_dies
index|[
name|i
index|]
condition|)
break|break;
comment|/* If there are any other popped regs, that's an error.  */
for|for
control|(
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|implicitly_dies
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|LAST_STACK_REG
operator|+
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"implicitly popped regs must be grouped at top of stack"
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Enfore rule #3: If any input operand uses the "f" constraint, all      output constraints must use the "&" earlyclobber.       ??? Detect this more deterministically by having constrain_asm_operands      record any earlyclobber.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_outputs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"output operand %d must use `&' constraint"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|malformed_asm
condition|)
block|{
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the number of inputs and outputs in BODY, an    asm_operands.  N_OPERANDS is the total number of operands, and    N_INPUTS and N_OUTPUTS are pointers to ints into which the results are    placed.  */
end_comment

begin_function
specifier|static
name|int
name|get_asm_operand_n_inputs
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If current function returns its result in an fp stack register,    return the REG.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|stack_result
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|result
decl_stmt|;
comment|/* If the value is supposed to be returned in memory, then clearly      it is not returned in a stack register.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|result
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|result
operator|!=
literal|0
operator|&&
name|STACK_REG_P
argument_list|(
name|result
argument_list|)
condition|?
name|result
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This section deals with stack register substitution, and forms the second  * pass over the RTL.  */
end_comment

begin_comment
comment|/* Replace REG, which is a pointer to a stack reg RTX, with an RTX for    the desired hard REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|replace_reg
parameter_list|(
name|reg
parameter_list|,
name|regno
parameter_list|)
name|rtx
modifier|*
name|reg
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_STACK_REG
operator|||
name|regno
operator|>
name|LAST_STACK_REG
operator|||
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
empty_stmt|;
block|}
operator|*
name|reg
operator|=
name|FP_MODE_REG
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a note of type NOTE, which must be found, for register    number REGNO from INSN.  Remove only one such note.  */
end_comment

begin_function
specifier|static
name|void
name|remove_regno_note
parameter_list|(
name|insn
parameter_list|,
name|note
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|note
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
modifier|*
name|note_link
decl_stmt|,
name|this
decl_stmt|;
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|this
operator|=
operator|*
name|note_link
init|;
name|this
condition|;
name|this
operator|=
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|this
argument_list|)
operator|==
name|note
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the hard register number of virtual register REG in REGSTACK.    The hard register number is relative to the top of the stack.  -1 is    returned if the register is not found.  */
end_comment

begin_function
specifier|static
name|int
name|get_hard_regnum
parameter_list|(
name|regstack
parameter_list|,
name|reg
parameter_list|)
name|stack
name|regstack
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
break|break;
return|return
name|i
operator|>=
literal|0
condition|?
operator|(
name|FIRST_STACK_REG
operator|+
name|regstack
operator|->
name|top
operator|-
name|i
operator|)
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn to pop virtual register REG before or after INSN.    REGSTACK is the stack state after INSN and is updated to reflect this    pop.  WHEN is either emit_insn_before or emit_insn_after.  A pop insn    is represented as a SET whose destination is the register to be popped    and source is the top of stack.  A death note for the top of stack    cases the movdf pattern to pop.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_pop_insn
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|reg
parameter_list|,
name|where
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|enum
name|emit_where
name|where
decl_stmt|;
block|{
name|rtx
name|pop_insn
decl_stmt|,
name|pop_rtx
decl_stmt|;
name|int
name|hard_regno
decl_stmt|;
comment|/* For complex types take care to pop both halves.  These may survive in      CLOBBER and USE expressions.  */
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|reg1
init|=
name|FP_MODE_REG
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|DFmode
argument_list|)
decl_stmt|;
name|rtx
name|reg2
init|=
name|FP_MODE_REG
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
literal|1
argument_list|,
name|DFmode
argument_list|)
decl_stmt|;
name|pop_insn
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg1
argument_list|)
operator|>=
literal|0
condition|)
name|pop_insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|reg1
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg2
argument_list|)
operator|>=
literal|0
condition|)
name|pop_insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|reg2
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pop_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|pop_insn
return|;
block|}
name|hard_regno
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|<
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pop_rtx
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|hard_regno
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|EMIT_AFTER
condition|)
name|pop_insn
operator|=
name|emit_insn_after
argument_list|(
name|pop_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|pop_insn
operator|=
name|emit_insn_before
argument_list|(
name|pop_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|pop_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|pop_insn
argument_list|)
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|hard_regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
name|regstack
operator|->
name|top
operator|-=
literal|1
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pop_insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn before or after INSN to swap virtual register REG with    the top of stack.  REGSTACK is the stack state before the swap, and    is updated to reflect the swap.  A swap insn is represented as a    PARALLEL of two patterns: each pattern moves one reg to the other.     If REG is already at the top of the stack, no insn is emitted.  */
end_comment

begin_function
specifier|static
name|void
name|emit_swap_insn
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|hard_regno
decl_stmt|;
name|rtx
name|swap_rtx
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|other_reg
decl_stmt|;
comment|/* swap regno temps */
name|rtx
name|i1
decl_stmt|;
comment|/* the stack-reg insn prior to INSN */
name|rtx
name|i1set
init|=
name|NULL_RTX
decl_stmt|;
comment|/* the SET rtx within I1 */
name|hard_regno
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|<
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|==
name|FIRST_STACK_REG
condition|)
return|return;
name|other_reg
operator|=
name|regstack
operator|->
name|top
operator|-
operator|(
name|hard_regno
operator|-
name|FIRST_STACK_REG
operator|)
expr_stmt|;
name|tmp
operator|=
name|regstack
operator|->
name|reg
index|[
name|other_reg
index|]
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|other_reg
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* Find the previous insn involving stack regs, but don't pass a      block boundary.  */
name|i1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|current_block
operator|&&
name|insn
operator|!=
name|current_block
operator|->
name|head
condition|)
block|{
name|rtx
name|tmp
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|limit
init|=
name|PREV_INSN
argument_list|(
name|current_block
operator|->
name|head
argument_list|)
decl_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|limit
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|tmp
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|INSN
operator|&&
name|stack_regs_mentioned
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|i1
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i1
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|i1set
operator|=
name|single_set
argument_list|(
name|i1
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|i1src
init|=
operator|*
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|i1set
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|i1dest
init|=
operator|*
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|i1set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the previous register stack push was from the reg we are to 	 swap with, omit the swap.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1dest
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1src
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|hard_regno
operator|-
literal|1
operator|&&
name|find_regno_note
argument_list|(
name|i1
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return;
comment|/* If the previous insn wrote to the reg we are to swap with, 	 omit the swap.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1dest
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|hard_regno
operator|&&
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1src
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|find_regno_note
argument_list|(
name|i1
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return;
block|}
name|swap_rtx
operator|=
name|gen_swapxf
argument_list|(
name|FP_MODE_REG
argument_list|(
name|hard_regno
argument_list|,
name|XFmode
argument_list|)
argument_list|,
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|XFmode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
condition|)
name|emit_insn_after
argument_list|(
name|swap_rtx
argument_list|,
name|i1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_block
condition|)
name|emit_insn_before
argument_list|(
name|swap_rtx
argument_list|,
name|current_block
operator|->
name|head
argument_list|)
expr_stmt|;
else|else
name|emit_insn_before
argument_list|(
name|swap_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle a move to or from a stack register in PAT, which is in INSN.    REGSTACK is the current stack.  */
end_comment

begin_function
specifier|static
name|void
name|move_for_stack_reg
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|psrc
init|=
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|pdest
init|=
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|src
operator|=
operator|*
name|psrc
expr_stmt|;
name|dest
operator|=
operator|*
name|pdest
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|STACK_REG_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Write from one stack reg to another.  If SRC dies here, then 	 just change the register mapping and delete the insn.  */
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If this is a no-op move, there must not be a REG_DEAD note.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|REGNO
argument_list|(
name|src
argument_list|)
condition|)
break|break;
comment|/* The source must be live, and the dest must be dead.  */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* It is possible that the dest is unused after this insn. 	     If so, just pop the src.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|src
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The source reg does not die.  */
comment|/* If this appears to be a no-op move, delete it, or else it 	 will confuse the machine description output patterns. But if 	 it is REG_UNUSED, we must pop the reg now, as per-insn processing 	 for REG_UNUSED will not work for deleted insns.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|dest
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The destination ought to be dead */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|psrc
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|pdest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Save from a stack reg to MEM, or possibly integer reg.  Since 	 only top of stack may be saved, emit an exchange first if 	 needs be.  */
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|XFmode
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|TFmode
operator|)
operator|&&
name|regstack
operator|->
name|top
operator|<
name|REG_STACK_SIZE
operator|-
literal|1
condition|)
block|{
comment|/* A 387 cannot write an XFmode value to a MEM without 	     clobbering the source reg.  The output code can handle 	     this by reading back the value from the MEM. 	     But it is more efficient to use a temp register if one is 	     available.  Push the source value here if the register 	     stack is not full, and then write the value to memory via 	     a pop.  */
name|rtx
name|push_rtx
decl_stmt|,
name|push_insn
decl_stmt|;
name|rtx
name|top_stack_reg
init|=
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|TFmode
condition|)
name|push_rtx
operator|=
name|gen_movtf
argument_list|(
name|top_stack_reg
argument_list|,
name|top_stack_reg
argument_list|)
expr_stmt|;
else|else
name|push_rtx
operator|=
name|gen_movxf
argument_list|(
name|top_stack_reg
argument_list|,
name|top_stack_reg
argument_list|)
expr_stmt|;
name|push_insn
operator|=
name|emit_insn_before
argument_list|(
name|push_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|top_stack_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|psrc
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Load from MEM, or possibly integer REG or constant, into the 	 stack regs.  The actual target is always the top of the 	 stack. The stack mapping is changed to reflect that DEST is 	 now at top of stack.  */
comment|/* The destination ought to be dead */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|regstack
operator|->
name|top
operator|>=
name|REG_STACK_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|pdest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Swap the condition on a branch, if there is one.  Return true if we    found a condition to swap.  False if the condition was not used as    such.  */
end_comment

begin_function
specifier|static
name|int
name|swap_rtx_condition_1
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|PUT_CODE
argument_list|(
name|pat
argument_list|,
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|r
operator||=
name|swap_rtx_condition_1
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|r
operator||=
name|swap_rtx_condition_1
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swap_rtx_condition
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We're looking for a single set to cc0 or an HImode temporary.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|FLAGS_REG
condition|)
block|{
name|insn
operator|=
name|next_flags_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* See if this is, or ends in, a fnstsw, aka unspec 9.  If so, we're      not doing anything with the cc value right now.  We may be able to      search for one though.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|9
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
comment|/* Search forward looking for the first use of this value.  	 Stop at block boundaries.  */
while|while
condition|(
name|insn
operator|!=
name|current_block
operator|->
name|end
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
block|}
comment|/* So we've found the insn using this value.  If it is anything 	 other than sahf, aka unspec 10, or the value does not die 	 (meaning we'd have to search further), then we must give up.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
literal|10
operator|||
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now we are prepared to handle this as a normal cc0 setter.  */
name|insn
operator|=
name|next_flags_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_rtx_condition_1
argument_list|(
name|pat
argument_list|)
condition|)
block|{
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* In case the flags don't die here, recurse to try fix          following user too.  */
elseif|else
if|if
condition|(
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|ix86_flags_rtx
argument_list|)
condition|)
block|{
name|insn
operator|=
name|next_flags_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|swap_rtx_condition
argument_list|(
name|insn
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|swap_rtx_condition_1
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle a comparison.  Special care needs to be taken to avoid    causing comparisons that a 387 cannot do correctly, such as EQ.     Also, a pop insn may need to be emitted.  The 387 does have an    `fcompp' insn that can pop two regs, but it is sometimes too expensive    to do this - a `fcomp' followed by a `fstpl %st(0)' may be easier to    set up.  */
end_comment

begin_function
specifier|static
name|void
name|compare_for_stack_reg
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat_src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat_src
decl_stmt|;
block|{
name|rtx
modifier|*
name|src1
decl_stmt|,
modifier|*
name|src2
decl_stmt|;
name|rtx
name|src1_note
decl_stmt|,
name|src2_note
decl_stmt|;
name|rtx
name|flags_user
decl_stmt|;
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|flags_user
operator|=
name|next_flags_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? If fxch turns out to be cheaper than fstp, give priority to      registers that die in this insn - move those to stack top first.  */
if|if
condition|(
operator|(
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|||
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
operator|&&
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|)
operator|)
operator|&&
name|swap_rtx_condition
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We will fix any death note later.  */
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src2_note
operator|=
name|NULL_RTX
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|pop_stack
argument_list|(
name|regstack
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
comment|/* If the second operand dies, handle that.  But if the operands are      the same stack register, don't bother, because only one death is      needed, and it was just handled.  */
if|if
condition|(
name|src2_note
operator|&&
operator|!
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|&&
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
operator|&&
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
operator|==
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
operator|)
condition|)
block|{
comment|/* As a special case, two regs may die in this insn if src2 is 	 next to top of stack and the top of stack also dies.  Since 	 we have already popped src1, "next to top of stack" is really 	 at top (FIRST_STACK_REG) now.  */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|src1_note
condition|)
block|{
name|pop_stack
argument_list|(
name|regstack
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The 386 can only represent death of the first operand in 	     the case handled above.  In all other cases, emit a separate 	     pop and remove the death note from here.  */
comment|/* link_cc0_insns (insn); */
name|remove_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute new registers in PAT, which is part of INSN.  REGSTACK    is the current register layout.  */
end_comment

begin_function
specifier|static
name|void
name|subst_stack_regs_pat
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|dest
decl_stmt|,
modifier|*
name|src
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
comment|/* Deaths in USE insns can happen in non optimizing compilation. 	 Handle them by popping the dying register.  */
name|src
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src
argument_list|)
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
condition|)
block|{
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ??? Uninitialized USE should not happen.  */
elseif|else
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
block|{
name|rtx
name|note
decl_stmt|;
name|dest
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
name|PATTERN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* The fix_truncdi_1 pattern wants to be able to allocate 		   it's own scratch register.  It does this by clobbering 		   an fp reg so that it is assured of an empty reg-stack 		   register.  If the register is live, kill it now.  		   Remove the DEAD/UNUSED note so we don't try to kill it 		   later too.  */
if|if
condition|(
name|note
condition|)
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|,
name|EMIT_BEFORE
argument_list|)
expr_stmt|;
else|else
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|LAST_STACK_REG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A top-level clobber with no REG_DEAD, and no hard-regnum 		   indicates an uninitialized value.  Because reload removed 		   all other clobbers, this must be due to a function  		   returning without a value.  Load up a NaN.  */
if|if
condition|(
operator|!
name|note
operator|&&
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|,
name|SFmode
argument_list|)
argument_list|,
name|nan
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
expr_stmt|;
name|move_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|note
operator|&&
name|COMPLEX_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
operator|&&
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|FP_MODE_REG
argument_list|(
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|,
name|DFmode
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|+
literal|1
argument_list|,
name|SFmode
argument_list|)
argument_list|,
name|nan
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
expr_stmt|;
name|move_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|SET
case|:
block|{
name|rtx
modifier|*
name|src1
init|=
operator|(
name|rtx
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|src2
decl_stmt|;
name|rtx
name|src1_note
decl_stmt|,
name|src2_note
decl_stmt|;
name|rtx
name|pat_src
decl_stmt|;
name|dest
operator|=
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|pat_src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* See if this is a `movM' pattern, and handle elsewhere if so.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src
argument_list|)
operator|||
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|)
condition|)
block|{
name|move_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat_src
argument_list|)
condition|)
block|{
case|case
name|COMPARE
case|:
name|compare_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat_src
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
init|;
operator|--
name|count
operator|>=
literal|0
condition|;
control|)
block|{
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|+
name|count
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
comment|/* This is a `tstM2' case.  */
if|if
condition|(
operator|*
name|dest
operator|!=
name|cc0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src1
operator|=
name|src
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|SQRT
case|:
case|case
name|ABS
case|:
case|case
name|NEG
case|:
comment|/* These insns only operate on the top of the stack. DEST might 	       be cc0_rtx if we're processing a tstM pattern. Also, it's 	       possible that the tstM case results in a REG_DEAD note on the 	       source.  */
if|if
condition|(
name|src1
operator|==
literal|0
condition|)
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
comment|/* On i386, reversed forms of subM3 and divM3 exist for 	       MODE_FLOAT, so the same code that works for addM3 and mulM3 	       can be used.  */
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
comment|/* These insns can accept the top of stack as a destination 	       from a stack reg or mem, or can use the top of stack as a 	       source and some other stack register (possibly top of stack) 	       as a destination.  */
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We will fix any death note later.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src1_note
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src2_note
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If either operand is not a stack register, then the dest 	       must be top of stack.  */
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|||
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Both operands are REG.  If neither operand is already 		   at the top of stack, choose to make the one that is the dest 		   the new top of stack.  */
name|int
name|src1_hard_regnum
decl_stmt|,
name|src2_hard_regnum
decl_stmt|;
name|src1_hard_regnum
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src2_hard_regnum
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_hard_regnum
operator|==
operator|-
literal|1
operator|||
name|src2_hard_regnum
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|src1_hard_regnum
operator|!=
name|FIRST_STACK_REG
operator|&&
name|src2_hard_regnum
operator|!=
name|FIRST_STACK_REG
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|rtx
name|src1_reg
init|=
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If the register that dies is at the top of stack, then 		   the destination is somewhere else - merely substitute it. 		   But if the reg that dies is not at top of stack, then 		   move the top of stack to the dead reg, as though we had 		   done the insn and then a store-with-pop.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src1_reg
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|src1_reg
argument_list|)
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
block|}
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2_note
condition|)
block|{
name|rtx
name|src2_reg
init|=
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|src2_reg
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|src2_reg
argument_list|)
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
block|}
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Keep operand 1 maching with destination.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|pat_src
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|&&
name|REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|&&
name|REG_P
argument_list|(
operator|*
name|src2
argument_list|)
operator|&&
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
operator|!=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
block|{
name|int
name|tmp
init|=
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
decl_stmt|;
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* sin */
case|case
literal|2
case|:
comment|/* cos */
comment|/* These insns only operate on the top of the stack.  */
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* (unspec [(unspec [(compare ..)] 9)] 10) 		   Unspec 9 is fnstsw; unspec 10 is sahf.  The combination 		   matches the PPRO fcomi instruction.  */
name|pat_src
operator|=
name|XVECEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat_src
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
operator|!=
literal|9
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|9
case|:
comment|/* (unspec [(compare ..)] 9) */
comment|/* Combined fcomp+fnstsw generated for doing well with 		   CSE.  When optimizing this would have been broken 		   up before now.  */
name|pat_src
operator|=
name|XVECEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat_src
argument_list|)
operator|!=
name|COMPARE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|compare_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat_src
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
comment|/* This insn requires the top of stack to be the destination.  */
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the comparison operator is an FP comparison operator, 	       it is handled correctly by compare_for_stack_reg () who 	       will move the destination to the top of stack. But if the 	       comparison operator is not an FP comparison operator, we 	       have to handle it here.  */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
operator|&&
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|!=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
comment|/* In case one of operands is the top of stack and the operands 		   dies, it is safe to make it the destination operand by reversing 		   the direction of cmove and avoid fxch.  */
if|if
condition|(
operator|(
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
operator|&&
name|src1_note
operator|)
operator|||
operator|(
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
operator|&&
name|src2_note
operator|)
condition|)
block|{
name|int
name|idx1
init|=
operator|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
operator|-
name|FIRST_STACK_REG
operator|)
decl_stmt|;
name|int
name|idx2
init|=
operator|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
operator|-
name|FIRST_STACK_REG
operator|)
decl_stmt|;
comment|/* Make reg-stack believe that the operands are already 		       swapped on the stack */
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
name|idx1
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
name|idx2
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
expr_stmt|;
comment|/* Reverse condition to compensate the operand swap. 		       i386 do have comparison always reversible.  */
name|PUT_CODE
argument_list|(
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_comparison_code
argument_list|(
name|XEXP
argument_list|(
name|pat_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
block|}
block|{
name|rtx
name|src_note
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|src_note
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|src_note
index|[
literal|1
index|]
operator|=
name|src1_note
expr_stmt|;
name|src_note
index|[
literal|2
index|]
operator|=
name|src2_note
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|src_note
index|[
name|i
index|]
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src_note
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the register that dies is not at the top of 		       stack, then move the top of stack to the dead reg */
if|if
condition|(
name|regno
operator|!=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|remove_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src_note
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Top of stack never dies, as it is the 			 destination.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Make dest the top of stack.  Add dest to regstack if 	       not present.  */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|<
name|FIRST_STACK_REG
condition|)
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute hard regnums for any stack regs in INSN, which has    N_INPUTS inputs and N_OUTPUTS outputs.  REGSTACK is the stack info    before the insn, and is updated with changes made here.     There are several requirements and assumptions about the use of    stack-like regs in asm statements.  These rules are enforced by    record_asm_stack_regs; see comments there for details.  Any    asm_operands left in the RTL at this point may be assume to meet the    requirements, since record_asm_stack_regs removes any problem asm.  */
end_comment

begin_function
specifier|static
name|void
name|subst_asm_stack_regs
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|alt
decl_stmt|;
name|rtx
modifier|*
name|note_reg
decl_stmt|;
comment|/* Array of note contents */
name|rtx
modifier|*
modifier|*
name|note_loc
decl_stmt|;
comment|/* Address of REG field of each note */
name|enum
name|reg_note
modifier|*
name|note_kind
decl_stmt|;
comment|/* The type of each note */
name|rtx
modifier|*
name|clobber_reg
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|clobber_loc
init|=
literal|0
decl_stmt|;
name|struct
name|stack_def
name|temp_stack
decl_stmt|;
name|int
name|n_notes
decl_stmt|;
name|int
name|n_clobbers
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
if|if
condition|(
operator|!
name|check_asm_stack_operands
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* Find out what the constraints required.  If no constraint      alternative matches, that is a compiler bug: we should have caught      such an insn in check_asm_stack_operands.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alt
operator|=
name|which_alternative
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
name|n_inputs
operator|=
name|get_asm_operand_n_inputs
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|n_outputs
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
name|n_inputs
expr_stmt|;
if|if
condition|(
name|alt
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Strip SUBREGs here to make the following code simpler.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Set up NOTE_REG, NOTE_LOC and NOTE_KIND.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
name|note_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|note_loc
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|note_kind
operator|=
operator|(
expr|enum
name|reg_note
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_note
argument_list|)
argument_list|)
expr_stmt|;
name|n_notes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
condition|)
block|{
name|note_reg
index|[
name|n_notes
index|]
operator|=
name|reg
expr_stmt|;
name|note_loc
index|[
name|n_notes
index|]
operator|=
name|loc
expr_stmt|;
name|note_kind
index|[
name|n_notes
index|]
operator|=
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|n_notes
operator|++
expr_stmt|;
block|}
block|}
comment|/* Set up CLOBBER_REG and CLOBBER_LOC.  */
name|n_clobbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|clobber_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|clobber_loc
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobber
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|&
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|clobber_reg
index|[
name|n_clobbers
index|]
operator|=
name|reg
expr_stmt|;
name|clobber_loc
index|[
name|n_clobbers
index|]
operator|=
name|loc
expr_stmt|;
name|n_clobbers
operator|++
expr_stmt|;
block|}
block|}
block|}
name|temp_stack
operator|=
operator|*
name|regstack
expr_stmt|;
comment|/* Put the input regs into the desired place in TEMP_STACK.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|&&
name|reg_class_subset_p
argument_list|(
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
argument_list|,
name|FLOAT_REGS
argument_list|)
operator|&&
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
operator|!=
name|FLOAT_REGS
condition|)
block|{
comment|/* If an operand needs to be in a particular reg in 	   FLOAT_REGS, the constraint was either 't' or 'u'.  Since 	   these constraints are for single register classes, and 	   reload guaranteed that operand[i] is already in that class, 	   we can just use REGNO (recog_data.operand[i]) to know which 	   actual reg this operand needs to be in.  */
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
operator|&
name|temp_stack
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|regno
operator|!=
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* recog_data.operand[i] is not in the right place.  Find 	       it and swap it with whatever is already in I's place. 	       K is where recog_data.operand[i] is now.  J is where it 	       should be.  */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|temp
decl_stmt|;
name|k
operator|=
name|temp_stack
operator|.
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
expr_stmt|;
name|j
operator|=
operator|(
name|temp_stack
operator|.
name|top
operator|-
operator|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|-
name|FIRST_STACK_REG
operator|)
operator|)
expr_stmt|;
name|temp
operator|=
name|temp_stack
operator|.
name|reg
index|[
name|k
index|]
expr_stmt|;
name|temp_stack
operator|.
name|reg
index|[
name|k
index|]
operator|=
name|temp_stack
operator|.
name|reg
index|[
name|j
index|]
expr_stmt|;
name|temp_stack
operator|.
name|reg
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Emit insns before INSN to make sure the reg-stack is in the right      order.  */
name|change_stack
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|&
name|temp_stack
argument_list|,
name|EMIT_BEFORE
argument_list|)
expr_stmt|;
comment|/* Make the needed input register substitutions.  Do death notes and      clobbers too, because these are for inputs, not outputs.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_notes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|note_kind
index|[
name|i
index|]
operator|==
name|REG_DEAD
condition|)
block|{
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|note_reg
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|note_loc
index|[
name|i
index|]
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_clobbers
condition|;
name|i
operator|++
control|)
block|{
comment|/* It's OK for a CLOBBER to reference a reg that is not live.          Don't try to replace it in that case.  */
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|clobber_reg
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
condition|)
block|{
comment|/* Sigh - clobbers always have QImode.  But replace_reg knows 	     that these regs can't be MODE_INT and will abort.  Just put 	     the right reg there without calling replace_reg.  */
operator|*
name|clobber_loc
index|[
name|i
index|]
operator|=
name|FP_MODE_REG
argument_list|(
name|regnum
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now remove from REGSTACK any inputs that the asm implicitly popped.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* An input reg is implicitly popped if it is tied to an 	   output, or if there is a CLOBBER for it.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_clobbers
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|n_clobbers
operator|||
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
operator|>=
literal|0
condition|)
block|{
comment|/* recog_data.operand[i] might not be at the top of stack. 	       But that's OK, because all we need to do is pop the 	       right number of regs off of the top of the reg-stack. 	       record_asm_stack_regs guaranteed that all implicitly 	       popped regs were grouped at the top of the reg-stack.  */
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
block|}
comment|/* Now add to REGSTACK any outputs that the asm implicitly pushed.      Note that there isn't any need to substitute register numbers.      ???  Explain why this is true.  */
for|for
control|(
name|i
operator|=
name|LAST_STACK_REG
init|;
name|i
operator|>=
name|FIRST_STACK_REG
condition|;
name|i
operator|--
control|)
block|{
comment|/* See if there is an output for this hard reg.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_outputs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|i
condition|)
block|{
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|i
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now emit a pop insn for any REG_UNUSED output, or any REG_DEAD      input that the asm didn't implicitly pop.  If the asm didn't      implicitly pop an input reg, that reg will still be live.       Note that we can't use find_regno_note here: the register numbers      in the death notes have already been substituted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_notes
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|note_reg
index|[
name|j
index|]
argument_list|)
operator|&&
name|note_kind
index|[
name|j
index|]
operator|==
name|REG_UNUSED
condition|)
block|{
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_notes
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|note_reg
index|[
name|j
index|]
argument_list|)
operator|&&
name|note_kind
index|[
name|j
index|]
operator|==
name|REG_DEAD
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute stack hard reg numbers for stack virtual registers in    INSN.  Non-stack register numbers are not changed.  REGSTACK is the    current stack content.  Insns may be emitted as needed to arrange the    stack for the 387 based on the contents of the insn.  */
end_comment

begin_function
specifier|static
name|void
name|subst_stack_regs
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|rtx
modifier|*
name|note_link
decl_stmt|,
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|top
init|=
name|regstack
operator|->
name|top
decl_stmt|;
comment|/* If there are any floating point parameters to be passed in 	 registers for this call, make sure they are in the right 	 order.  */
if|if
condition|(
name|top
operator|>=
literal|0
condition|)
block|{
name|straighten_stack
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regstack
argument_list|)
expr_stmt|;
comment|/* Now mark the arguments as dead after the call.  */
while|while
condition|(
name|regstack
operator|->
name|top
operator|>=
literal|0
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|FIRST_STACK_REG
operator|+
name|regstack
operator|->
name|top
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Do the actual substitution if any stack regs are mentioned.      Since we only record whether entire insn mentions stack regs, and      subst_stack_regs_pat only works for patterns that contain stack regs,      we must check each pattern in a parallel here.  A call_value_pop could      fail otherwise.  */
if|if
condition|(
name|stack_regs_mentioned
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|n_operands
init|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_operands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  Decode the operands, 	     decide how many are inputs, and do register substitution. 	     Any REG_UNUSED notes will be handled by subst_asm_stack_regs.  */
name|subst_asm_stack_regs
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|subst_stack_regs_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|subst_stack_regs_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* subst_stack_regs_pat may have deleted a no-op insn.  If so, any      REG_UNUSED will already have been dealt with, so just return.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* If there is a REG_UNUSED note on a stack register on this insn,      the indicated reg must be popped.  The REG_UNUSED note is removed,      since the form of the newly emitted pop insn references the reg,      making it no longer `unset'.  */
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
operator|*
name|note_link
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
block|}
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the organization of the stack so that it fits a new basic    block.  Some registers might have to be popped, but there can never be    a register live in the new block that is not now live.     Insert any needed insns before or after INSN, as indicated by    WHERE.  OLD is the original stack layout, and NEW is the desired    form.  OLD is updated to reflect the code emitted, ie, it will be    the same as NEW upon return.     This function will not preserve block_end[].  But that information    is no longer needed once this has executed.  */
end_comment

begin_function
specifier|static
name|void
name|change_stack
parameter_list|(
name|insn
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|,
name|where
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|old
decl_stmt|;
name|stack
name|new
decl_stmt|;
name|enum
name|emit_where
name|where
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|int
name|update_end
init|=
literal|0
decl_stmt|;
comment|/* We will be inserting new insns "backwards".  If we are to insert      after INSN, find the next insn, and insert before it.  */
if|if
condition|(
name|where
operator|==
name|EMIT_AFTER
condition|)
block|{
if|if
condition|(
name|current_block
operator|&&
name|current_block
operator|->
name|end
operator|==
name|insn
condition|)
name|update_end
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Pop any registers that are not needed in the new block.  */
for|for
control|(
name|reg
operator|=
name|old
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|new
operator|->
name|reg_set
argument_list|,
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|)
condition|)
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_MODE_REG
argument_list|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|EMIT_BEFORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* If the new block has never been processed, then it can inherit 	 the old stack order.  */
name|new
operator|->
name|top
operator|=
name|old
operator|->
name|top
expr_stmt|;
name|memcpy
argument_list|(
name|new
operator|->
name|reg
argument_list|,
name|old
operator|->
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This block has been entered before, and we must match the 	 previously selected stack order.  */
comment|/* By now, the only difference should be the order of the stack, 	 not their depth or liveliness.  */
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|old
operator|->
name|reg_set
argument_list|,
name|new
operator|->
name|reg_set
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|win
label|:
if|if
condition|(
name|old
operator|->
name|top
operator|!=
name|new
operator|->
name|top
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the stack is not empty (new->top != -1), loop here emitting 	 swaps until the stack is correct.   	 The worst case number of swaps emitted is N + 2, where N is the 	 depth of the stack.  In some cases, the reg at the top of 	 stack may be correct, but swapped anyway in order to fix 	 other regs.  But since we never swap any other reg away from 	 its correct slot, this algorithm will converge.  */
if|if
condition|(
name|new
operator|->
name|top
operator|!=
operator|-
literal|1
condition|)
do|do
block|{
comment|/* Swap the reg at top of stack into the position it is 	       supposed to be in, until the correct top of stack appears.  */
while|while
condition|(
name|old
operator|->
name|reg
index|[
name|old
operator|->
name|top
index|]
operator|!=
name|new
operator|->
name|reg
index|[
name|new
operator|->
name|top
index|]
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|new
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|new
operator|->
name|reg
index|[
name|reg
index|]
operator|==
name|old
operator|->
name|reg
index|[
name|old
operator|->
name|top
index|]
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_MODE_REG
argument_list|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* See if any regs remain incorrect.  If so, bring an 	     incorrect reg to the top of stack, and let the while loop 	     above fix it.  */
for|for
control|(
name|reg
operator|=
name|new
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|new
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|old
operator|->
name|reg
index|[
name|reg
index|]
condition|)
block|{
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_MODE_REG
argument_list|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|reg
operator|>=
literal|0
condition|)
do|;
comment|/* At this point there must be no differences.  */
for|for
control|(
name|reg
operator|=
name|old
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|new
operator|->
name|reg
index|[
name|reg
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|update_end
condition|)
name|current_block
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print stack configuration.  */
end_comment

begin_function
specifier|static
name|void
name|print_stack
parameter_list|(
name|file
parameter_list|,
name|s
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|stack
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|file
condition|)
return|return;
if|if
condition|(
name|s
operator|->
name|top
operator|==
operator|-
literal|2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"uninitialized\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|top
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"empty\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|fputs
argument_list|(
literal|"[ "
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|s
operator|->
name|top
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|s
operator|->
name|reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"]\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function was doing life analysis.  We now let the regular live    code do it's job, so we only need to check some extra invariants     that reg-stack expects.  Primary among these being that all registers    are initialized before use.     The function returns true when code was emitted to CFG edges and    commit_edge_insertions needs to be called.  */
end_comment

begin_function
specifier|static
name|int
name|convert_regs_entry
parameter_list|()
block|{
name|int
name|inserted
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|block
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|block_info
name|bi
init|=
name|BLOCK_INFO
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* Set current register status at last instruction `uninitialized'.  */
name|bi
operator|->
name|stack_in
operator|.
name|top
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Copy live_at_end and live_at_start into temporaries.  */
for|for
control|(
name|reg
operator|=
name|FIRST_STACK_REG
init|;
name|reg
operator|<=
name|LAST_STACK_REG
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|block
operator|->
name|global_live_at_end
argument_list|,
name|reg
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|bi
operator|->
name|out_reg_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|block
operator|->
name|global_live_at_start
argument_list|,
name|reg
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|bi
operator|->
name|stack_in
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load something into each stack register live at function entry.       Such live registers can be caused by uninitialized variables or      functions not returning values on all paths.  In order to keep       the push/pop code happy, and to not scrog the register stack, we      must put something in these registers.  Use a QNaN.         Note that we are insertting converted code here.  This code is      never seen by the convert_regs pass.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|block
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|block_info
name|bi
init|=
name|BLOCK_INFO
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|top
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_STACK_REG
init|;
name|reg
operator|>=
name|FIRST_STACK_REG
condition|;
operator|--
name|reg
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|bi
operator|->
name|stack_in
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|init
decl_stmt|;
name|bi
operator|->
name|stack_in
operator|.
name|reg
index|[
operator|++
name|top
index|]
operator|=
name|reg
expr_stmt|;
name|init
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|SFmode
argument_list|)
argument_list|,
name|nan
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|init
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
name|bi
operator|->
name|stack_in
operator|.
name|top
operator|=
name|top
expr_stmt|;
block|}
return|return
name|inserted
return|;
block|}
end_function

begin_comment
comment|/* Construct the desired stack for function exit.  This will either    be `empty', or the function return value at top-of-stack.  */
end_comment

begin_function
specifier|static
name|void
name|convert_regs_exit
parameter_list|()
block|{
name|int
name|value_reg_low
decl_stmt|,
name|value_reg_high
decl_stmt|;
name|stack
name|output_stack
decl_stmt|;
name|rtx
name|retvalue
decl_stmt|;
name|retvalue
operator|=
name|stack_result
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|value_reg_low
operator|=
name|value_reg_high
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|retvalue
condition|)
block|{
name|value_reg_low
operator|=
name|REGNO
argument_list|(
name|retvalue
argument_list|)
expr_stmt|;
name|value_reg_high
operator|=
name|value_reg_low
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|value_reg_low
argument_list|,
name|GET_MODE
argument_list|(
name|retvalue
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|output_stack
operator|=
operator|&
name|BLOCK_INFO
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
operator|->
name|stack_in
expr_stmt|;
if|if
condition|(
name|value_reg_low
operator|==
operator|-
literal|1
condition|)
name|output_stack
operator|->
name|top
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|int
name|reg
decl_stmt|;
name|output_stack
operator|->
name|top
operator|=
name|value_reg_high
operator|-
name|value_reg_low
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|value_reg_low
init|;
name|reg
operator|<=
name|value_reg_high
condition|;
operator|++
name|reg
control|)
block|{
name|output_stack
operator|->
name|reg
index|[
name|reg
operator|-
name|value_reg_low
index|]
operator|=
name|reg
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|output_stack
operator|->
name|reg_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Adjust the stack of this block on exit to match the stack of the    target block, or copy stack info into the stack of the successor    of the successor hasn't been processed yet.  */
end_comment

begin_function
specifier|static
name|bool
name|compensate_edge
parameter_list|(
name|e
parameter_list|,
name|file
parameter_list|)
name|edge
name|e
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|basic_block
name|block
init|=
name|e
operator|->
name|src
decl_stmt|,
name|target
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|block_info
name|bi
init|=
name|BLOCK_INFO
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|struct
name|stack_def
name|regstack
decl_stmt|,
name|tmpstack
decl_stmt|;
name|stack
name|target_stack
init|=
operator|&
name|BLOCK_INFO
argument_list|(
name|target
argument_list|)
operator|->
name|stack_in
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|current_block
operator|=
name|block
expr_stmt|;
name|regstack
operator|=
name|bi
operator|->
name|stack_out
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Edge %d->%d: "
argument_list|,
name|block
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_stack
operator|->
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* The target block hasn't had a stack order selected.          We need merely ensure that no pops are needed.  */
for|for
control|(
name|reg
operator|=
name|regstack
operator|.
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
operator|--
name|reg
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|target_stack
operator|->
name|reg_set
argument_list|,
name|regstack
operator|.
name|reg
index|[
name|reg
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"new block; copying stack position\n"
argument_list|)
expr_stmt|;
comment|/* change_stack kills values in regstack.  */
name|tmpstack
operator|=
name|regstack
expr_stmt|;
name|change_stack
argument_list|(
name|block
operator|->
name|end
argument_list|,
operator|&
name|tmpstack
argument_list|,
name|target_stack
argument_list|,
name|EMIT_AFTER
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"new block; pops needed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target_stack
operator|->
name|top
operator|==
name|regstack
operator|.
name|top
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|target_stack
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
operator|--
name|reg
control|)
if|if
condition|(
name|target_stack
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|regstack
operator|.
name|reg
index|[
name|reg
index|]
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"no changes needed\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"correcting stack to "
argument_list|)
expr_stmt|;
name|print_stack
argument_list|(
name|file
argument_list|,
name|target_stack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Care for non-call EH edges specially.  The normal return path have      values in registers.  These will be popped en masse by the unwind      library.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_EH
operator||
name|EDGE_ABNORMAL_CALL
operator|)
operator|)
operator|==
name|EDGE_EH
condition|)
name|target_stack
operator|->
name|top
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Other calls may appear to have values live in st(0), but the      abnormal return path will not have actually loaded the values.  */
elseif|else
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL_CALL
condition|)
block|{
comment|/* Assert that the lifetimes are as we expect -- one value          live at st(0) on the end of the source block, and no          values live at the beginning of the destination block.  */
name|HARD_REG_SET
name|tmp
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|target_stack
operator|->
name|reg_set
argument_list|,
name|tmp
argument_list|,
name|eh1
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|eh1
label|:
name|SET_HARD_REG_BIT
argument_list|(
name|tmp
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|regstack
operator|.
name|reg_set
argument_list|,
name|tmp
argument_list|,
name|eh2
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|eh2
label|:
name|target_stack
operator|->
name|top
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* It is better to output directly to the end of the block      instead of to the edge, because emit_swap can do minimal      insn scheduling.  We can do this when there is only one      edge out, and it is not abnormal.  */
elseif|else
if|if
condition|(
name|block
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
block|{
comment|/* change_stack kills values in regstack.  */
name|tmpstack
operator|=
name|regstack
expr_stmt|;
name|change_stack
argument_list|(
name|block
operator|->
name|end
argument_list|,
operator|&
name|tmpstack
argument_list|,
name|target_stack
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|block
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|EMIT_BEFORE
else|:
name|EMIT_AFTER
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|seq
decl_stmt|,
name|after
decl_stmt|;
comment|/* We don't support abnormal edges.  Global takes care to          avoid any live register across them, so we should never          have to insert instructions on such edges.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_block
operator|=
name|NULL
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* ??? change_stack needs some point to emit insns after.           Also needed to keep gen_sequence from returning a           pattern as opposed to a sequence, which would lose          REG_DEAD notes.  */
name|after
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|tmpstack
operator|=
name|regstack
expr_stmt|;
name|change_stack
argument_list|(
name|after
argument_list|,
operator|&
name|tmpstack
argument_list|,
name|target_stack
argument_list|,
name|EMIT_BEFORE
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|seq
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Convert stack register references in one block.  */
end_comment

begin_function
specifier|static
name|int
name|convert_regs_1
parameter_list|(
name|file
parameter_list|,
name|block
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
block|{
name|struct
name|stack_def
name|regstack
decl_stmt|;
name|block_info
name|bi
init|=
name|BLOCK_INFO
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|inserted
decl_stmt|,
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|beste
init|=
name|NULL
decl_stmt|;
name|inserted
operator|=
literal|0
expr_stmt|;
comment|/* Find the edge we will copy stack from.  It should be the most frequent      one as it will get cheapest after compensation code is generated,      if multiple such exists, take one with largest count, prefer critical      one (as splitting critical edges is more expensive), or one with lowest      index, to avoid random changes with different orders of the edges.  */
for|for
control|(
name|e
operator|=
name|block
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|beste
condition|)
name|beste
operator|=
name|e
expr_stmt|;
elseif|else
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|beste
argument_list|)
operator|<
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
condition|)
name|beste
operator|=
name|e
expr_stmt|;
elseif|else
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|beste
argument_list|)
operator|>
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|beste
operator|->
name|count
operator|<
name|e
operator|->
name|count
condition|)
name|beste
operator|=
name|e
expr_stmt|;
elseif|else
if|if
condition|(
name|beste
operator|->
name|count
operator|>
name|e
operator|->
name|count
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|EDGE_CRITICAL_P
argument_list|(
name|beste
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|)
name|beste
operator|=
name|e
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|<
name|beste
operator|->
name|src
operator|->
name|index
condition|)
name|beste
operator|=
name|e
expr_stmt|;
block|}
comment|/* Entry block does have stack already initialized.  */
if|if
condition|(
name|bi
operator|->
name|stack_in
operator|.
name|top
operator|==
operator|-
literal|2
condition|)
name|inserted
operator||=
name|compensate_edge
argument_list|(
name|beste
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|beste
operator|=
name|NULL
expr_stmt|;
name|current_block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nBasic block %d\nInput stack: "
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_stack
argument_list|(
name|file
argument_list|,
operator|&
name|bi
operator|->
name|stack_in
argument_list|)
expr_stmt|;
block|}
comment|/* Process all insns in this block.  Keep track of NEXT so that we      don't process insns emitted while substituting in INSN.  */
name|next
operator|=
name|block
operator|->
name|head
expr_stmt|;
name|regstack
operator|=
name|bi
operator|->
name|stack_in
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Ensure we have not missed a block boundary.  */
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|block
operator|->
name|end
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Don't bother processing unless there is a stack reg 	 mentioned or if it's a CALL_INSN.  */
if|if
condition|(
name|stack_regs_mentioned
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  insn %d input stack: "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_stack
argument_list|(
name|file
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
name|subst_stack_regs
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next
condition|)
do|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Expected live registers ["
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_STACK_REG
init|;
name|reg
operator|<=
name|LAST_STACK_REG
condition|;
operator|++
name|reg
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|bi
operator|->
name|out_reg_set
argument_list|,
name|reg
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ]\nOutput stack: "
argument_list|)
expr_stmt|;
name|print_stack
argument_list|(
name|file
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|block
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the function is declared to return a value, but it returns one      in only some cases, some registers might come live here.  Emit      necessary moves for them.  */
for|for
control|(
name|reg
operator|=
name|FIRST_STACK_REG
init|;
name|reg
operator|<=
name|LAST_STACK_REG
condition|;
operator|++
name|reg
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|bi
operator|->
name|out_reg_set
argument_list|,
name|reg
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Emitting insn initializing reg %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|reg
argument_list|,
name|SFmode
argument_list|)
argument_list|,
name|nan
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|set
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|subst_stack_regs
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Something failed if the stack lives don't match.  */
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|regstack
operator|.
name|reg_set
argument_list|,
name|bi
operator|->
name|out_reg_set
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|win
label|:
name|bi
operator|->
name|stack_out
operator|=
name|regstack
expr_stmt|;
comment|/* Compensate the back edges, as those wasn't visited yet.  */
for|for
control|(
name|e
operator|=
name|block
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|||
operator|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|done
operator|&&
name|e
operator|->
name|dest
operator|!=
name|block
condition|)
name|abort
argument_list|()
expr_stmt|;
name|inserted
operator||=
name|compensate_edge
argument_list|(
name|e
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|e
operator|=
name|block
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|!=
name|beste
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
if|if
condition|(
operator|!
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|done
condition|)
name|abort
argument_list|()
expr_stmt|;
name|inserted
operator||=
name|compensate_edge
argument_list|(
name|e
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|inserted
return|;
block|}
end_function

begin_comment
comment|/* Convert registers in all blocks reachable from BLOCK.  */
end_comment

begin_function
specifier|static
name|int
name|convert_regs_2
parameter_list|(
name|file
parameter_list|,
name|block
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
block|{
name|basic_block
modifier|*
name|stack
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
name|inserted
decl_stmt|;
name|stack
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|block
expr_stmt|;
name|inserted
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|edge
name|e
decl_stmt|;
name|block
operator|=
operator|*
operator|--
name|sp
expr_stmt|;
name|inserted
operator||=
name|convert_regs_1
argument_list|(
name|file
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|block
argument_list|)
operator|->
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|e
operator|=
name|block
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
block|{
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|predecessors
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|predecessors
condition|)
operator|*
name|sp
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
block|}
do|while
condition|(
name|sp
operator|!=
name|stack
condition|)
do|;
return|return
name|inserted
return|;
block|}
end_function

begin_comment
comment|/* Traverse all basic blocks in a function, converting the register    references in each insn from the "flat" register file that gcc uses,    to the stack-like registers the 387 uses.  */
end_comment

begin_function
specifier|static
name|int
name|convert_regs
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|inserted
decl_stmt|,
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Initialize uninitialized registers on function entry.  */
name|inserted
operator|=
name|convert_regs_entry
argument_list|()
expr_stmt|;
comment|/* Construct the desired stack for function exit.  */
name|convert_regs_exit
argument_list|()
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* ??? Future: process inner loops first, and give them arbitrary      initial stacks which emit_swap_insn can modify.  This ought to      prevent double fxch that aften appears at the head of a loop.  */
comment|/* Process all blocks reachable from all entry points.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|inserted
operator||=
name|convert_regs_2
argument_list|(
name|file
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* ??? Process all unreachable blocks.  Though there's no excuse       for keeping these even when not optimizing.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|block_info
name|bi
init|=
name|BLOCK_INFO
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|done
condition|)
block|{
name|int
name|reg
decl_stmt|;
comment|/* Create an arbitrary input stack.  */
name|bi
operator|->
name|stack_in
operator|.
name|top
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_STACK_REG
init|;
name|reg
operator|>=
name|FIRST_STACK_REG
condition|;
operator|--
name|reg
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|bi
operator|->
name|stack_in
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
name|bi
operator|->
name|stack_in
operator|.
name|reg
index|[
operator|++
name|bi
operator|->
name|stack_in
operator|.
name|top
index|]
operator|=
name|reg
expr_stmt|;
name|inserted
operator||=
name|convert_regs_2
argument_list|(
name|file
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inserted
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|inserted
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STACK_REGS */
end_comment

end_unit

