begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Register to Stack convert for GNU compiler.    Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This pass converts stack-like registers from the "flat register    file" model that gcc uses, to a stack convention that the 387 uses.     * The form of the input:     On input, the function consists of insn that have had their    registers fully allocated to a set of "virtual" registers.  Note that    the word "virtual" is used differently here than elsewhere in gcc: for    each virtual stack reg, there is a hard reg, but the mapping between    them is not known until this pass is run.  On output, hard register    numbers have been substituted, and various pop and exchange insns have    been emitted.  The hard register numbers and the virtual register    numbers completely overlap - before this pass, all stack register    numbers are virtual, and afterward they are all hard.     The virtual registers can be manipulated normally by gcc, and their    semantics are the same as for normal registers.  After the hard    register numbers are substituted, the semantics of an insn containing    stack-like regs are not the same as for an insn with normal regs: for    instance, it is not safe to delete an insn that appears to be a no-op    move.  In general, no insn containing hard regs should be changed    after this pass is done.     * The form of the output:     After this pass, hard register numbers represent the distance from    the current top of stack to the desired register.  A reference to    FIRST_STACK_REG references the top of stack, FIRST_STACK_REG + 1,    represents the register just below that, and so forth.  Also, REG_DEAD    notes indicate whether or not a stack register should be popped.     A "swap" insn looks like a parallel of two patterns, where each    pattern is a SET: one sets A to B, the other B to A.     A "push" or "load" insn is a SET whose SET_DEST is FIRST_STACK_REG    and whose SET_DEST is REG or MEM.  Any other SET_DEST, such as PLUS,    will replace the existing stack top, not push a new value.     A store insn is a SET whose SET_DEST is FIRST_STACK_REG, and whose    SET_SRC is REG or MEM.     The case where the SET_SRC and SET_DEST are both FIRST_STACK_REG    appears ambiguous.  As a special case, the presence of a REG_DEAD note    for FIRST_STACK_REG differentiates between a load insn and a pop.     If a REG_DEAD is present, the insn represents a "pop" that discards    the top of the register stack.  If there is no REG_DEAD note, then the    insn represents a "dup" or a push of the current top of stack onto the    stack.     * Methodology:     Existing REG_DEAD and REG_UNUSED notes for stack registers are    deleted and recreated from scratch.  REG_DEAD is never created for a    SET_DEST, only REG_UNUSED.     * asm_operands:     There are several rules on the usage of stack-like regs in    asm_operands insns.  These rules apply only to the operands that are    stack-like regs:     1. Given a set of input regs that die in an asm_operands, it is       necessary to know which are implicitly popped by the asm, and       which must be explicitly popped by gcc.  	An input reg that is implicitly popped by the asm must be 	explicitly clobbered, unless it is constrained to match an 	output operand.     2. For any input reg that is implicitly popped by an asm, it is       necessary to know how to adjust the stack to compensate for the pop.       If any non-popped input is closer to the top of the reg-stack than       the implicitly popped reg, it would not be possible to know what the       stack looked like - it's not clear how the rest of the stack "slides       up".  	All implicitly popped input regs must be closer to the top of 	the reg-stack than any input that is not implicitly popped.     3. It is possible that if an input dies in an insn, reload might       use the input reg for an output reload.  Consider this example:  		asm ("foo" : "=t" (a) : "f" (b));        This asm says that input B is not popped by the asm, and that       the asm pushes a result onto the reg-stack, ie, the stack is one       deeper after the asm than it was before.  But, it is possible that       reload will think that it can use the same reg for both the input and       the output, if input B dies in this insn.  	If any input operand uses the "f" constraint, all output reg 	constraints must use the "&" earlyclobber.        The asm above would be written as  		asm ("foo" : "=&t" (a) : "f" (b));     4. Some operands need to be in particular places on the stack.  All       output operands fall in this category - there is no other way to       know which regs the outputs appear in unless the user indicates       this in the constraints.  	Output operands must specifically indicate which reg an output 	appears in after an asm.  "=f" is not allowed: the operand 	constraints must select a class with a single reg.     5. Output operands may not be "inserted" between existing stack regs.       Since no 387 opcode uses a read/write operand, all output operands       are dead before the asm_operands, and are pushed by the asm_operands.       It makes no sense to push anywhere but the top of the reg-stack.  	Output operands must start at the top of the reg-stack: output 	operands may not "skip" a reg.     6. Some asm statements may need extra stack space for internal       calculations.  This can be guaranteed by clobbering stack registers       unrelated to the inputs and outputs.     Here are a couple of reasonable asms to want to write.  This asm    takes one input, which is internally popped, and produces two outputs.  	asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));     This asm takes two inputs, which are popped by the fyl2xp1 opcode,    and replaces them with one output.  The user must code the "st(1)"    clobber for reg-stack.c to know that fyl2xp1 pops both inputs.  	asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");     */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_REGS
end_ifdef

begin_define
define|#
directive|define
name|REG_STACK_SIZE
value|(LAST_STACK_REG - FIRST_STACK_REG + 1)
end_define

begin_comment
comment|/* This is the basic stack record.  TOP is an index into REG[] such    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.     If TOP is -2, REG[] is not yet initialized.  Stack initialization    consists of placing each live reg in array `reg' and setting `top'    appropriately.     REG_SET indicates which registers are live.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|stack_def
block|{
name|int
name|top
decl_stmt|;
comment|/* index to top stack element */
name|HARD_REG_SET
name|reg_set
decl_stmt|;
comment|/* set of live registers */
name|char
name|reg
index|[
name|REG_STACK_SIZE
index|]
decl_stmt|;
comment|/* register - stack mapping */
block|}
typedef|*
name|stack
typedef|;
end_typedef

begin_comment
comment|/* highest instruction uid */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks in the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is first insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|block_begin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is last insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is nonzero if control can drop into basic block N */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|block_drops_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N says all about the stack at entry block N */
end_comment

begin_decl_stmt
specifier|static
name|stack
name|block_stack_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N says all about the stack life at the end of block N */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|block_out_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is where the BLOCK_NUM values are really stored.  This is set    up by find_blocks and used there and in life_analysis.  It can be used    later, but only to look up an insn that is the head or tail of some    block.  life_analysis and the stack register conversion process can    add insns within a block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|block_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use this array to cache info about insns, because otherwise we    spend too much time in stack_regs_mentioned_p.      Indexed by insn UIDs.  A value of zero is uninitialized, one indicates    the insn uses stack registers, two indicates the insn does not use    stack registers.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|stack_regs_mentioned_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the register file for all register after conversion */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|FP_mode_reg
index|[
name|LAST_STACK_REG
operator|+
literal|1
operator|-
name|FIRST_STACK_REG
index|]
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FP_MODE_REG
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
define|\
value|(FP_mode_reg[(regno)-FIRST_STACK_REG][(int)(mode)])
end_define

begin_comment
comment|/* Get the basic block number of an insn.  See note at block_number    definition are validity of this information.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|BLOCK_NUM
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline__
endif|#
directive|endif
specifier|static
name|int
name|BLOCK_NUM
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|tmp
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
name|max_uid
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|block_number
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mark_regs_pat
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|straighten_stack
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_stack
name|PROTO
argument_list|(
operator|(
name|stack
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_label_references
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|get_true_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_asm_reg_life
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_reg_life_pat
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|HARD_REG_SET
operator|*
operator|,
name|HARD_REG_SET
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_asm_operand_n_inputs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_reg_life
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_blocks
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|stack_result
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stack_reg_life_analysis
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_regno_note
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|reg_note
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_hard_regnum
name|PROTO
argument_list|(
operator|(
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_insn_for_stacker
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|emit_pop_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|,
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_swap_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_for_stack_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_rtx_condition
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compare_for_stack_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_stack_regs_pat
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_asm_stack_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_stack_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|change_stack
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|stack
operator|,
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|goto_block_pat
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|stack
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_regs
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_blocks
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_stack_info
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_stack_regs_mentioned
name|PROTO
argument_list|(
operator|(
name|rtx
name|insn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize stack_regs_mentioned_data for INSN (growing the virtual array    if needed.  Return nonzero if INSN mentions stacked registers.  */
end_comment

begin_function
specifier|static
name|int
name|check_stack_regs_mentioned
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|>=
name|VARRAY_SIZE
argument_list|(
name|stack_regs_mentioned_data
argument_list|)
condition|)
comment|/* Allocate some extra size to avoid too many reallocs, but        do not grow exponentially.  */
name|VARRAY_GROW
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|uid
operator|+
name|uid
operator|/
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|uid
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|uid
argument_list|)
operator|=
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN mentions stacked registers, else return    zero.  */
end_comment

begin_function
name|int
name|stack_regs_mentioned
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
literal|0
return|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
name|VARRAY_SIZE
argument_list|(
name|stack_regs_mentioned_data
argument_list|)
operator|||
operator|!
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|uid
argument_list|)
condition|)
return|return
operator|(
name|check_stack_regs_mentioned
argument_list|(
name|insn
argument_list|)
operator|)
return|;
return|return
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|uid
argument_list|)
operator|==
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark all registers needed for this pattern.  */
end_comment

begin_function
specifier|static
name|void
name|mark_regs_pat
parameter_list|(
name|pat
parameter_list|,
name|set
parameter_list|)
name|rtx
name|pat
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|set
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|regno
operator|=
name|SUBREG_WORD
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|regno
operator|+=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|regno
operator|=
name|REGNO
argument_list|(
name|pat
argument_list|)
operator|,
name|mode
operator|=
name|GET_MODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
init|;
name|count
condition|;
name|count
operator|--
operator|,
name|regno
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reorganise the stack into ascending numbers,    after this insn.  */
end_comment

begin_function
specifier|static
name|void
name|straighten_stack
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|struct
name|stack_def
name|temp_stack
decl_stmt|;
name|int
name|top
decl_stmt|;
comment|/* If there is only a single register on the stack, then the stack is      already in increasing order and no reorganization is needed.       Similarly if the stack is empty.  */
if|if
condition|(
name|regstack
operator|->
name|top
operator|<=
literal|0
condition|)
return|return;
name|temp_stack
operator|.
name|reg_set
operator|=
name|regstack
operator|->
name|reg_set
expr_stmt|;
for|for
control|(
name|top
operator|=
name|temp_stack
operator|.
name|top
operator|=
name|regstack
operator|->
name|top
init|;
name|top
operator|>=
literal|0
condition|;
name|top
operator|--
control|)
name|temp_stack
operator|.
name|reg
index|[
name|top
index|]
operator|=
name|FIRST_STACK_REG
operator|+
name|temp_stack
operator|.
name|top
operator|-
name|top
expr_stmt|;
name|change_stack
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|&
name|temp_stack
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a register from the stack */
end_comment

begin_function
specifier|static
name|void
name|pop_stack
parameter_list|(
name|regstack
parameter_list|,
name|regno
parameter_list|)
name|stack
name|regstack
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|top
init|=
name|regstack
operator|->
name|top
decl_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
comment|/* If regno was not at the top of stack then adjust stack */
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|top
index|]
operator|!=
name|regno
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|regno
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|top
condition|;
name|j
operator|++
control|)
name|regstack
operator|->
name|reg
index|[
name|j
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if any stack register is mentioned somewhere within PAT.  */
end_comment

begin_function
name|int
name|stack_regs_mentioned_p
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|stack_regs_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert register usage from "flat" register file usage to a "stack    register file.  FIRST is the first insn in the function, FILE is the    dump file, if used.     First compute the beginning and end of each basic block.  Do a    register life analysis on the stack registers, recording the result    for the head and tail of each basic block.  The convert each insn one    by one.  Run a last jump_optimize() pass, if optimizing, to eliminate    any cross-jumping created when the converter inserts pop insns.*/
end_comment

begin_function
name|void
name|reg_to_stack
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|stack_reg_seen
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HARD_REG_SET
name|stackentry
decl_stmt|;
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|VARRAY_CHAR_INIT
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|max_uid
operator|+
literal|1
argument_list|,
literal|"stack_regs_mentioned cache"
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|stackentry
argument_list|)
expr_stmt|;
block|{
specifier|static
name|int
name|initialised
decl_stmt|;
if|if
condition|(
operator|!
name|initialised
condition|)
block|{
if|#
directive|if
literal|0
block|initialised = 1;
comment|/* This array can not have been previously 				   initialised, because the rtx's are 				   thrown away between compilations of 				   functions.  */
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|FP_MODE_REG
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_COMPLEX_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
name|FP_MODE_REG
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Count the basic blocks.  Also find maximum insn uid.  */
block|{
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|BARRIER
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|before_function_beg
init|=
literal|1
decl_stmt|;
name|max_uid
operator|=
literal|0
expr_stmt|;
name|blocks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Note that this loop must select the same block boundaries 	   as code in find_blocks.  Also note that this code is not the 	   same as that used in flow.c.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|prev_code
operator|!=
name|INSN
operator|&&
name|prev_code
operator|!=
name|CALL_INSN
operator|&&
name|prev_code
operator|!=
name|CODE_LABEL
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|)
condition|)
name|blocks
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
name|before_function_beg
operator|=
literal|0
expr_stmt|;
comment|/* Remember whether or not this insn mentions an FP regs. 	   Check JUMP_INSNs too, in case someone creates a funny PARALLEL.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|&&
name|stack_regs_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|stack_reg_seen
operator|=
literal|1
expr_stmt|;
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Note any register passing parameters.  */
if|if
condition|(
name|before_function_beg
operator|&&
name|code
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|record_reg_life_pat
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|HARD_REG_SET
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|stackentry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* delete old chain */
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
block|}
comment|/* If no stack register reference exists in this insn, there isn't      anything to convert.  */
if|if
condition|(
operator|!
name|stack_reg_seen
condition|)
block|{
name|VARRAY_FREE
argument_list|(
name|stack_regs_mentioned_data
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there are stack registers, there must be at least one block.  */
if|if
condition|(
operator|!
name|blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Allocate some tables that last till end of compiling this function      and some needed only in find_blocks and life_analysis.  */
name|block_begin
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|block_end
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|block_drops_in
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|block_stack_in
operator|=
operator|(
name|stack
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stack_def
argument_list|)
argument_list|)
expr_stmt|;
name|block_out_reg_set
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|block_stack_in
argument_list|,
name|blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stack_def
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|block_out_reg_set
argument_list|,
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|block_number
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|block_number
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|find_blocks
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|stack_reg_life_analysis
argument_list|(
name|first
argument_list|,
operator|&
name|stackentry
argument_list|)
expr_stmt|;
comment|/* Dump the life analysis debug information before jump      optimization, as that will destroy the LABEL_REFS we keep the      information in.  */
if|if
condition|(
name|file
condition|)
name|dump_stack_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|convert_regs
argument_list|()
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|jump_optimize
argument_list|(
name|first
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|stack_regs_mentioned_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the    label's chain of references, and note which insn contains each    reference.  */
end_comment

begin_function
specifier|static
name|void
name|record_label_references
parameter_list|(
name|insn
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|ref
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is an undefined label, LABEL_REFS (label) contains          garbage.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Don't make a duplicate in the code_label's chain.  */
for|for
control|(
name|ref
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
name|ref
operator|&&
name|ref
operator|!=
name|label
condition|;
name|ref
operator|=
name|LABEL_NEXTREF
argument_list|(
name|ref
argument_list|)
control|)
if|if
condition|(
name|CONTAINING_INSN
argument_list|(
name|ref
argument_list|)
operator|==
name|insn
condition|)
return|return;
name|CONTAINING_INSN
argument_list|(
name|pat
argument_list|)
operator|=
name|insn
expr_stmt|;
name|LABEL_NEXTREF
argument_list|(
name|pat
argument_list|)
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
operator|=
name|pat
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a pointer to the REG expression within PAT.  If PAT is not a    REG, possible enclosed by a conversion rtx, return the inner part of    PAT that stopped the search.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|get_true_reg
parameter_list|(
name|pat
parameter_list|)
name|rtx
modifier|*
name|pat
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* eliminate FP subregister accesses in favour of the 		   actual FP register in use.  */
block|{
name|rtx
name|subreg
decl_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|subreg
operator|=
name|SUBREG_REG
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|pat
operator|=
name|FP_MODE_REG
argument_list|(
name|REGNO
argument_list|(
name|subreg
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
argument_list|)
expr_stmt|;
default|default:
return|return
name|pat
return|;
block|}
block|}
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|FLOAT_EXTEND
case|:
name|pat
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the life info of each stack reg in INSN, updating REGSTACK.    N_INPUTS is the number of inputs; N_OUTPUTS the outputs.    OPERANDS is an array of all operands for the insn, and is assumed to    contain all output operands, then all inputs operands.     There are many rules that an asm statement for stack-like regs must    follow.  Those rules are explained at the top of this file: the rule    numbers below refer to that explanation.  */
end_comment

begin_function
specifier|static
name|void
name|record_asm_reg_life
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_clobbers
decl_stmt|;
name|int
name|malformed_asm
init|=
literal|0
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|reg_used_as_output
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|implicitly_dies
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|alt
decl_stmt|;
name|rtx
modifier|*
name|clobber_reg
decl_stmt|;
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
comment|/* Find out what the constraints require.  If no constraint      alternative matches, this asm is malformed.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alt
operator|=
name|which_alternative
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
name|n_inputs
operator|=
name|get_asm_operand_n_inputs
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|n_outputs
operator|=
name|recog_n_operands
operator|-
name|n_inputs
expr_stmt|;
if|if
condition|(
name|alt
operator|<
literal|0
condition|)
block|{
name|malformed_asm
operator|=
literal|1
expr_stmt|;
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
literal|2
expr_stmt|;
return|return;
block|}
comment|/* Strip SUBREGs here to make the following code simpler.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set up CLOBBER_REG.  */
name|n_clobbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|clobber_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobber
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|clobber_reg
index|[
name|n_clobbers
index|]
operator|=
name|reg
expr_stmt|;
name|n_clobbers
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Enforce rule #4: Output operands must specifically indicate which      reg an output appears in after an asm.  "=f" is not allowed: the      operand constraints must select a class with a single reg.       Also enforce rule #5: Output operands must start at the top of      the reg-stack: output operands may not "skip" a reg.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_used_as_output
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_used_as_output
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
index|]
operator|!=
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Output constraint %d must specify a single register"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reg_used_as_output
index|[
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Search for first non-popped reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|reg_used_as_output
index|[
name|i
index|]
condition|)
break|break;
comment|/* If there are any other popped regs, that's an error.  */
for|for
control|(
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_used_as_output
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|LAST_STACK_REG
operator|+
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Output regs must be grouped at top of stack"
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Enforce rule #2: All implicitly popped input regs must be closer      to the top of the reg-stack than any input that is not implicitly      popped.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|implicitly_dies
argument_list|,
sizeof|sizeof
argument_list|(
name|implicitly_dies
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* An input reg is implicitly popped if it is tied to an 	   output, or if there is a CLOBBER for it.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_clobbers
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|n_clobbers
operator|||
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
operator|>=
literal|0
condition|)
name|implicitly_dies
index|[
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Search for first non-popped reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|implicitly_dies
index|[
name|i
index|]
condition|)
break|break;
comment|/* If there are any other popped regs, that's an error.  */
for|for
control|(
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|implicitly_dies
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|LAST_STACK_REG
operator|+
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Implicitly popped regs must be grouped at top of stack"
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Enfore rule #3: If any input operand uses the "f" constraint, all      output constraints must use the "&" earlyclobber.       ???  Detect this more deterministically by having constraint_asm_operands      record any earlyclobber.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_outputs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|j
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Output operand %d must use `&' constraint"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|malformed_asm
condition|)
block|{
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|VARRAY_CHAR
argument_list|(
name|stack_regs_mentioned_data
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
literal|2
expr_stmt|;
return|return;
block|}
comment|/* Process all outputs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|op
init|=
name|recog_operand
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|op
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
continue|continue;
block|}
comment|/* Each destination is dead before this insn.  If the 	 destination is not used after this insn, record this with 	 REG_UNUSED.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|op
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process all inputs */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|op
init|=
name|recog_operand
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|op
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
continue|continue;
block|}
comment|/* If an input is dead after the insn, record a death note. 	 But don't record a death note if there is already a death note, 	 or if the input is also an output.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
operator|==
operator|-
literal|1
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|NULL_RTX
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|op
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan PAT, which is part of INSN, and record registers appearing in    a SET_DEST in DEST, and other registers in SRC.     This function does not know about SET_DESTs that are both input and    output (such as ZERO_EXTRACT) - this cannot happen on a 387.  */
end_comment

begin_function
specifier|static
name|void
name|record_reg_life_pat
parameter_list|(
name|pat
parameter_list|,
name|src
parameter_list|,
name|dest
parameter_list|,
name|douse
parameter_list|)
name|rtx
name|pat
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|src
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|douse
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|pat
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SUBREG
operator|&&
name|STACK_REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|src
condition|)
name|mark_regs_pat
argument_list|(
name|pat
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
condition|)
name|mark_regs_pat
argument_list|(
name|pat
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|record_reg_life_pat
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_reg_life_pat
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
argument_list|,
name|src
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We don't need to consider either of these cases.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|&&
operator|!
name|douse
operator|)
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|record_reg_life_pat
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_reg_life_pat
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Calculate the number of inputs and outputs in BODY, an    asm_operands.  N_OPERANDS is the total number of operands, and    N_INPUTS and N_OUTPUTS are pointers to ints into which the results are    placed.  */
end_comment

begin_function
specifier|static
name|int
name|get_asm_operand_n_inputs
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan INSN, which is in BLOCK, and record the life& death of stack    registers in REGSTACK.  This function is called to process insns from    the last insn in a block to the first.  The actual scanning is done in    record_reg_life_pat.     If a register is live after a CALL_INSN, but is not a value return    register for that CALL_INSN, then code is emitted to initialize that    register.  The block_end[] data is kept accurate.     Existing death and unset notes for stack registers are deleted    before processing the insn.  */
end_comment

begin_function
specifier|static
name|void
name|record_reg_life
parameter_list|(
name|insn
parameter_list|,
name|block
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|block
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|,
modifier|*
name|note_link
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|)
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* Strip death notes for stack regs from this insn */
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
operator|*
name|note_link
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
condition|)
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Process all patterns in the insn.  */
name|n_operands
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_operands
operator|>=
literal|0
condition|)
block|{
name|record_asm_reg_life
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|HARD_REG_SET
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|record_reg_life_pat
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
operator|&
name|src
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_reg_life_pat
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_STACK_REG
init|;
name|regno
operator|<=
name|LAST_STACK_REG
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|src
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|FP_MODE_REG
argument_list|(
name|regno
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|FP_MODE_REG
argument_list|(
name|regno
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|reg
decl_stmt|;
comment|/* There might be a reg that is live after a function call.              Initialize it to zero so that the program does not crash.  See 	     comment towards the end of stack_reg_life_analysis().  */
for|for
control|(
name|reg
operator|=
name|FIRST_STACK_REG
init|;
name|reg
operator|<=
name|LAST_STACK_REG
condition|;
name|reg
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|dest
argument_list|,
name|reg
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|init
decl_stmt|,
name|pat
decl_stmt|;
comment|/* The insn will use virtual register numbers, and so 	           convert_regs is expected to process these.  But BLOCK_NUM 	           cannot be used on these insns, because they do not appear in 	           block_number[].  */
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|reg
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* If the CALL_INSN was the end of a block, move the 	           block_end to point to the new insn.  */
if|if
condition|(
name|block_end
index|[
name|block
index|]
operator|==
name|insn
condition|)
name|block_end
index|[
name|block
index|]
operator|=
name|init
expr_stmt|;
block|}
comment|/* Some regs do not survive a CALL */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
block|}
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all basic blocks of the function, which starts with FIRST.    For each JUMP_INSN, build the chain of LABEL_REFS on each CODE_LABEL.  */
end_comment

begin_function
specifier|static
name|void
name|find_blocks
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|block
decl_stmt|;
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|BARRIER
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|label_value_list
init|=
literal|0
decl_stmt|;
comment|/* Record where all the blocks start and end.      Record which basic blocks control can drop in to.  */
name|block
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Note that this loop must select the same block boundaries 	 as code in reg_to_stack, but that these are not the same 	 as those selected in flow.c.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|prev_code
operator|!=
name|INSN
operator|&&
name|prev_code
operator|!=
name|CALL_INSN
operator|&&
name|prev_code
operator|!=
name|CODE_LABEL
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|)
condition|)
block|{
name|block_begin
index|[
operator|++
name|block
index|]
operator|=
name|insn
expr_stmt|;
name|block_end
index|[
name|block
index|]
operator|=
name|insn
expr_stmt|;
name|block_drops_in
index|[
name|block
index|]
operator|=
name|prev_code
operator|!=
name|BARRIER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
name|block_end
index|[
name|block
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Make a list of all labels referred to other than by jumps.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|label_value_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_value_list
argument_list|)
expr_stmt|;
block|}
name|block_number
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|+
literal|1
operator|!=
name|blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* generate all label references to the corresponding jump insn */
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|blocks
condition|;
name|block
operator|++
control|)
block|{
name|insn
operator|=
name|block_end
index|[
name|block
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If current function returns its result in an fp stack register,    return the REG.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|stack_result
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|result
decl_stmt|;
comment|/* If the value is supposed to be returned in memory, then clearly      it is not returned in a stack register.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|result
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ?!?  What is this code supposed to do?  Can this code actually      trigger if we kick out aggregates above?  */
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|result
operator|!=
literal|0
operator|&&
name|STACK_REG_P
argument_list|(
name|result
argument_list|)
condition|?
name|result
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine the which registers are live at the start of each basic    block of the function whose first insn is FIRST.     First, if the function returns a real_type, mark the function    return type as live at each return point, as the RTL may not give any    hint that the register is live.     Then, start with the last block and work back to the first block.    Similarly, work backwards within each block, insn by insn, recording    which regs are dead and which are used (and therefore live) in the    hard reg set of block_stack_in[].     After processing each basic block, if there is a label at the start    of the block, propagate the live registers to all jumps to this block.     As a special case, if there are regs live in this block, that are    not live in a block containing a jump to this label, and the block    containing the jump has already been processed, we must propagate this    block's entry register life back to the block containing the jump, and    restart life analysis from there.     In the worst case, this function may traverse the insns    REG_STACK_SIZE times.  This is necessary, since a jump towards the end    of the insns may not know that a reg is live at a target that is early    in the insns.  So we back up and start over with the new reg live.     If there are registers that are live at the start of the function,    insns are emitted to initialize these registers.  Something similar is    done after CALL_INSNs in record_reg_life.  */
end_comment

begin_function
specifier|static
name|void
name|stack_reg_life_analysis
parameter_list|(
name|first
parameter_list|,
name|stackentry
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|stackentry
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|,
name|block
decl_stmt|;
name|struct
name|stack_def
name|regstack
decl_stmt|;
block|{
name|rtx
name|retvalue
decl_stmt|;
if|if
condition|(
operator|(
name|retvalue
operator|=
name|stack_result
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
block|{
comment|/* Find all RETURN insns and mark them.  */
for|for
control|(
name|block
operator|=
name|blocks
operator|-
literal|1
init|;
operator|--
name|block
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|block_end
index|[
name|block
index|]
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|returnjump_p
argument_list|(
name|block_end
index|[
name|block
index|]
argument_list|)
condition|)
name|mark_regs_pat
argument_list|(
name|retvalue
argument_list|,
name|block_out_reg_set
operator|+
name|block
argument_list|)
expr_stmt|;
comment|/* Mark off the end of last block if we "fall off" the end of the 	   function into the epilogue.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|block_end
index|[
name|blocks
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|returnjump_p
argument_list|(
name|block_end
index|[
name|blocks
operator|-
literal|1
index|]
argument_list|)
condition|)
name|mark_regs_pat
argument_list|(
name|retvalue
argument_list|,
name|block_out_reg_set
operator|+
name|blocks
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now scan all blocks backward for stack register use */
name|block
operator|=
name|blocks
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|block
operator|>=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
comment|/* current register status at last instruction */
name|COPY_HARD_REG_SET
argument_list|(
name|regstack
operator|.
name|reg_set
argument_list|,
name|block_out_reg_set
index|[
name|block
index|]
argument_list|)
expr_stmt|;
name|prev
operator|=
name|block_end
index|[
name|block
index|]
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the insn is a CALL_INSN, we need to ensure that 	     everything dies.  But otherwise don't process unless there 	     are some stack regs present.  */
if|if
condition|(
name|stack_regs_mentioned
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|record_reg_life
argument_list|(
name|insn
argument_list|,
name|block
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|block_begin
index|[
name|block
index|]
condition|)
do|;
comment|/* Set the state at the start of the block.  Mark that no 	 register mapping information known yet.  */
name|COPY_HARD_REG_SET
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|regstack
operator|.
name|reg_set
argument_list|)
expr_stmt|;
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* If there is a label, propagate our register life to all jumps 	 to this label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
specifier|register
name|rtx
name|label
decl_stmt|;
name|int
name|must_restart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|label
operator|=
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
init|;
name|label
operator|!=
name|insn
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
block|{
name|int
name|jump_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|jump_block
operator|<
name|block
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|block_out_reg_set
index|[
name|jump_block
index|]
argument_list|,
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The block containing the jump has already been 		     processed.  If there are registers that were not known 		     to be live then, but are live now, we must back up 		     and restart life analysis from that point with the new 		     life information.  */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|block_out_reg_set
index|[
name|jump_block
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|block_out_reg_set
index|[
name|jump_block
index|]
argument_list|,
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|)
expr_stmt|;
name|block
operator|=
name|jump_block
expr_stmt|;
name|must_restart
operator|=
literal|1
expr_stmt|;
break|break;
name|win
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|must_restart
condition|)
continue|continue;
block|}
if|if
condition|(
name|block_drops_in
index|[
name|block
index|]
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|block_out_reg_set
index|[
name|block
operator|-
literal|1
index|]
argument_list|,
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|)
expr_stmt|;
name|block
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* If any reg is live at the start of the first block of a        function, then we must guarantee that the reg holds some value by        generating our own "load" of that register.  Otherwise a 387 would        fault trying to access an empty register.  */
comment|/* Load zero into each live register.  The fact that a register      appears live at the function start necessarily implies an error      in the user program: it means that (unless the offending code is *never*      executed) this program is using uninitialised floating point      variables.  In order to keep broken code like this happy, we initialise      those variables with zero.       Note that we are inserting virtual register references here:      these insns must be processed by convert_regs later.  Also, these      insns will not be in block_number, so BLOCK_NUM() will fail for them.  */
for|for
control|(
name|reg
operator|=
name|LAST_STACK_REG
init|;
name|reg
operator|>=
name|FIRST_STACK_REG
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
literal|0
index|]
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|stackentry
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|init_rtx
decl_stmt|;
name|init_rtx
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|reg
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|block_begin
index|[
literal|0
index|]
operator|=
name|emit_insn_after
argument_list|(
name|init_rtx
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
literal|0
index|]
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************    This section deals with stack register substitution, and forms the second    pass over the RTL.  *****************************************************************************/
end_comment

begin_comment
comment|/* Replace REG, which is a pointer to a stack reg RTX, with an RTX for    the desired hard REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|replace_reg
parameter_list|(
name|reg
parameter_list|,
name|regno
parameter_list|)
name|rtx
modifier|*
name|reg
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_STACK_REG
operator|||
name|regno
operator|>
name|LAST_STACK_REG
operator|||
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
empty_stmt|;
block|}
operator|*
name|reg
operator|=
name|FP_MODE_REG
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a note of type NOTE, which must be found, for register    number REGNO from INSN.  Remove only one such note.  */
end_comment

begin_function
specifier|static
name|void
name|remove_regno_note
parameter_list|(
name|insn
parameter_list|,
name|note
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|note
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|note_link
decl_stmt|,
name|this
decl_stmt|;
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|this
operator|=
operator|*
name|note_link
init|;
name|this
condition|;
name|this
operator|=
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|this
argument_list|)
operator|==
name|note
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the hard register number of virtual register REG in REGSTACK.    The hard register number is relative to the top of the stack.  -1 is    returned if the register is not found.  */
end_comment

begin_function
specifier|static
name|int
name|get_hard_regnum
parameter_list|(
name|regstack
parameter_list|,
name|reg
parameter_list|)
name|stack
name|regstack
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
break|break;
return|return
name|i
operator|>=
literal|0
condition|?
operator|(
name|FIRST_STACK_REG
operator|+
name|regstack
operator|->
name|top
operator|-
name|i
operator|)
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete INSN from the RTL.  Mark the insn, but don't remove it from    the chain of insns.  Doing so could confuse block_begin and block_end    if this were the only insn in the block.  */
end_comment

begin_function
specifier|static
name|void
name|delete_insn_for_stacker
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Ensure that the side effects were clobbers when deleting a PARALLEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn to pop virtual register REG before or after INSN.    REGSTACK is the stack state after INSN and is updated to reflect this    pop.  WHEN is either emit_insn_before, emit_insn_after or NULL.     in case WHEN is NULL we don't really emit the insn, just modify stack     information.  Caller is expected to emit insn himself.     A pop insn is represented as a SET whose destination is the register to    be popped and source is the top of stack.  A death note for the top of stack    cases the movdf pattern to pop.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|reg
argument_list|,
name|when
argument_list|)
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
name|regstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reg
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|when
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|rtx
name|pop_insn
decl_stmt|,
name|pop_rtx
decl_stmt|;
name|int
name|hard_regno
decl_stmt|;
name|hard_regno
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|<
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|when
condition|)
block|{
name|pop_rtx
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|FP_MODE_REG
argument_list|(
name|hard_regno
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|pop_insn
operator|=
call|(
modifier|*
name|when
call|)
argument_list|(
name|pop_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|pop_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|pop_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|hard_regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
name|regstack
operator|->
name|top
operator|-=
literal|1
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pop_insn
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Emit an insn before or after INSN to swap virtual register REG with the    top of stack.  WHEN should be `emit_insn_before' or `emit_insn_before'    REGSTACK is the stack state before the swap, and is updated to reflect    the swap.  A swap insn is represented as a PARALLEL of two patterns:    each pattern moves one reg to the other.     If REG is already at the top of the stack, no insn is emitted.  */
end_comment

begin_function
specifier|static
name|void
name|emit_swap_insn
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|hard_regno
decl_stmt|;
name|rtx
name|gen_swapdf
parameter_list|()
function_decl|;
name|rtx
name|swap_rtx
decl_stmt|,
name|swap_insn
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|other_reg
decl_stmt|;
comment|/* swap regno temps */
name|rtx
name|i1
decl_stmt|;
comment|/* the stack-reg insn prior to INSN */
name|rtx
name|i1set
init|=
name|NULL_RTX
decl_stmt|;
comment|/* the SET rtx within I1 */
name|hard_regno
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|<
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|==
name|FIRST_STACK_REG
condition|)
return|return;
name|other_reg
operator|=
name|regstack
operator|->
name|top
operator|-
operator|(
name|hard_regno
operator|-
name|FIRST_STACK_REG
operator|)
expr_stmt|;
name|tmp
operator|=
name|regstack
operator|->
name|reg
index|[
name|other_reg
index|]
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|other_reg
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* Find the previous insn involving stack regs, but don't go past      any labels, calls or jumps.  */
name|i1
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|i1
operator|&&
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|&&
operator|!
name|stack_regs_mentioned
argument_list|(
name|i1
argument_list|)
condition|)
name|i1
operator|=
name|prev_nonnote_insn
argument_list|(
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
condition|)
name|i1set
operator|=
name|single_set
argument_list|(
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1set
condition|)
block|{
name|rtx
name|i1src
init|=
operator|*
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|i1set
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|i1dest
init|=
operator|*
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|i1set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the previous register stack push was from the reg we are to 	 swap with, omit the swap.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1dest
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1src
argument_list|)
operator|==
name|hard_regno
operator|-
literal|1
operator|&&
name|find_regno_note
argument_list|(
name|i1
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return;
comment|/* If the previous insn wrote to the reg we are to swap with, 	 omit the swap.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1dest
argument_list|)
operator|==
name|hard_regno
operator|&&
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1src
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|find_regno_note
argument_list|(
name|i1
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
condition|)
block|{
name|i1
operator|=
name|next_nonnote_insn
argument_list|(
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
name|insn
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|swap_rtx
operator|=
name|gen_swapdf
argument_list|(
name|FP_MODE_REG
argument_list|(
name|hard_regno
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|swap_insn
operator|=
name|emit_insn_after
argument_list|(
name|swap_rtx
argument_list|,
name|i1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle a move to or from a stack register in PAT, which is in INSN.    REGSTACK is the current stack.  */
end_comment

begin_function
specifier|static
name|void
name|move_for_stack_reg
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|psrc
init|=
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|pdest
init|=
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|src
operator|=
operator|*
name|psrc
expr_stmt|;
name|dest
operator|=
operator|*
name|pdest
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|STACK_REG_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Write from one stack reg to another.  If SRC dies here, then 	 just change the register mapping and delete the insn.  */
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If this is a no-op move, there must not be a REG_DEAD note.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|REGNO
argument_list|(
name|src
argument_list|)
condition|)
break|break;
comment|/* The source must be live, and the dest must be dead.  */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* It is possible that the dest is unused after this insn. 	     If so, just pop the src.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|src
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
name|delete_insn_for_stacker
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn_for_stacker
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The source reg does not die.  */
comment|/* If this appears to be a no-op move, delete it, or else it 	 will confuse the machine description output patterns. But if 	 it is REG_UNUSED, we must pop the reg now, as per-insn processing 	 for REG_UNUSED will not work for deleted insns.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|dest
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
name|delete_insn_for_stacker
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The destination ought to be dead */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|psrc
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|pdest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Save from a stack reg to MEM, or possibly integer reg.  Since 	 only top of stack may be saved, emit an exchange first if 	 needs be.  */
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|XFmode
operator|&&
name|regstack
operator|->
name|top
operator|<
name|REG_STACK_SIZE
operator|-
literal|1
condition|)
block|{
comment|/* A 387 cannot write an XFmode value to a MEM without 	     clobbering the source reg.  The output code can handle 	     this by reading back the value from the MEM. 	     But it is more efficient to use a temp register if one is 	     available.  Push the source value here if the register 	     stack is not full, and then write the value to memory via 	     a pop.  */
name|rtx
name|push_rtx
decl_stmt|,
name|push_insn
decl_stmt|;
name|rtx
name|top_stack_reg
init|=
name|FP_MODE_REG
argument_list|(
name|FIRST_STACK_REG
argument_list|,
name|XFmode
argument_list|)
decl_stmt|;
name|push_rtx
operator|=
name|gen_movxf
argument_list|(
name|top_stack_reg
argument_list|,
name|top_stack_reg
argument_list|)
expr_stmt|;
name|push_insn
operator|=
name|emit_insn_before
argument_list|(
name|push_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|top_stack_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|psrc
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Load from MEM, or possibly integer REG or constant, into the 	 stack regs.  The actual target is always the top of the 	 stack. The stack mapping is changed to reflect that DEST is 	 now at top of stack.  */
comment|/* The destination ought to be dead */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|regstack
operator|->
name|top
operator|>=
name|REG_STACK_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|pdest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|swap_rtx_condition
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|PUT_CODE
argument_list|(
name|pat
argument_list|,
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|swap_rtx_condition
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|swap_rtx_condition
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a comparison.  Special care needs to be taken to avoid    causing comparisons that a 387 cannot do correctly, such as EQ.     Also, a fstp instruction may need to be emitted.  The 387 does have an    `fcompp' insn that can pop two regs, but it is sometimes too expensive    to do this - a `fcomp' followed by a `fstpl %st(0)' may be easier to    set up.       We can not handle this by emiting fpop instruction after compare, because    it appears between cc0 setter and user.  So we emit only    REG_DEAD note and handle it as a special case in machine description.      This code used trick with delay_slot filling to emit pop insn after    comparsion but it didn't worked because it caused confusion with cc_status    in final pass. */
end_comment

begin_function
specifier|static
name|void
name|compare_for_stack_reg
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|src1
decl_stmt|,
modifier|*
name|src2
decl_stmt|;
name|rtx
name|src1_note
decl_stmt|,
name|src2_note
decl_stmt|;
name|rtx
name|cc0_user
decl_stmt|;
name|int
name|have_cmove
decl_stmt|;
name|int
name|hard_regno
decl_stmt|;
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cc0_user
operator|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the insn that uses cc0 is an FP-conditional move, then the destination      must be the top of stack */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|cc0_user
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|cc0_user
argument_list|)
argument_list|)
operator|!=
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|cc0_user
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|cc0_user
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|)
condition|)
block|{
name|rtx
modifier|*
name|dest
decl_stmt|;
name|dest
operator|=
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|cc0_user
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|have_cmove
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
operator|&&
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|!=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|have_cmove
operator|=
literal|0
expr_stmt|;
comment|/* ??? If fxch turns out to be cheaper than fstp, give priority to      registers that die in this insn - move those to stack top first.  */
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|||
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
operator|&&
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|,
name|next
decl_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|swap_rtx_condition
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|next
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We will fix any death note later.  */
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src2_note
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|have_cmove
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
block|{
name|hard_regno
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|hard_regno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src1_note
condition|)
block|{
name|pop_stack
argument_list|(
name|regstack
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
comment|/* If the second operand dies, handle that.  But if the operands are      the same stack register, don't bother, because only one death is      needed, and it was just handled.  */
if|if
condition|(
name|src2_note
operator|&&
operator|!
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|&&
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
operator|&&
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
operator|==
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
operator|)
condition|)
block|{
comment|/* As a special case, two regs may die in this insn if src2 is 	 next to top of stack and the top of stack also dies.  Since 	 we have already popped src1, "next to top of stack" is really 	 at top (FIRST_STACK_REG) now.  */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|src1_note
condition|)
block|{
name|pop_stack
argument_list|(
name|regstack
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pop of second operand is handled using special REG_DEAD note 	     because we can't emit pop insn after cc0 setter.  */
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|hard_regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute new registers in PAT, which is part of INSN.  REGSTACK    is the current register layout.  */
end_comment

begin_function
specifier|static
name|void
name|subst_stack_regs_pat
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|dest
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|rtx
modifier|*
name|src1
init|=
operator|(
name|rtx
operator|*
operator|)
name|NULL_PTR
decl_stmt|,
modifier|*
name|src2
decl_stmt|;
name|rtx
name|src1_note
decl_stmt|,
name|src2_note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
return|return;
name|dest
operator|=
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this is a `movM' pattern, and handle elsewhere if so.  */
if|if
condition|(
operator|*
name|dest
operator|!=
name|cc0_rtx
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src
argument_list|)
operator|||
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|)
operator|)
condition|)
name|move_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|COMPARE
case|:
name|compare_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
init|;
operator|--
name|count
operator|>=
literal|0
condition|;
control|)
block|{
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|+
name|count
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
comment|/* This is a `tstM2' case.  */
if|if
condition|(
operator|*
name|dest
operator|!=
name|cc0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src1
operator|=
name|src
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|SQRT
case|:
case|case
name|ABS
case|:
case|case
name|NEG
case|:
comment|/* These insns only operate on the top of the stack. DEST might 	   be cc0_rtx if we're processing a tstM pattern. Also, it's 	   possible that the tstM case results in a REG_DEAD note on the 	   source.  */
if|if
condition|(
name|src1
operator|==
literal|0
condition|)
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
comment|/* On i386, reversed forms of subM3 and divM3 exist for 	   MODE_FLOAT, so the same code that works for addM3 and mulM3 	   can be used.  */
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
comment|/* These insns can accept the top of stack as a destination 	   from a stack reg or mem, or can use the top of stack as a 	   source and some other stack register (possibly top of stack) 	   as a destination.  */
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We will fix any death note later.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src1_note
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src2_note
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If either operand is not a stack register, then the dest 	   must be top of stack.  */
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|||
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Both operands are REG.  If neither operand is already 	       at the top of stack, choose to make the one that is the dest 	       the new top of stack.  */
name|int
name|src1_hard_regnum
decl_stmt|,
name|src2_hard_regnum
decl_stmt|;
name|src1_hard_regnum
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src2_hard_regnum
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_hard_regnum
operator|==
operator|-
literal|1
operator|||
name|src2_hard_regnum
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|src1_hard_regnum
operator|!=
name|FIRST_STACK_REG
operator|&&
name|src2_hard_regnum
operator|!=
name|FIRST_STACK_REG
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
comment|/* If the register that dies is at the top of stack, then 	       the destination is somewhere else - merely substitute it. 	       But if the reg that dies is not at top of stack, then 	       move the top of stack to the dead reg, as though we had 	       done the insn and then a store-with-pop.  */
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
block|}
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2_note
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
block|}
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* sin */
case|case
literal|2
case|:
comment|/* cos */
comment|/* These insns only operate on the top of the stack.  */
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
comment|/* dest has to be on stack. */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|<
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This insn requires the top of stack to be the destination. */
comment|/* If the comparison operator is an FP comparison operator, 	   it is handled correctly by compare_for_stack_reg () who 	   will move the destination to the top of stack. But if the 	   comparison operator is not an FP comparison operator, we 	   have to handle it here. */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
operator|&&
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
operator|!=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|rtx
name|src_note
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|src_note
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|src_note
index|[
literal|1
index|]
operator|=
name|src1_note
expr_stmt|;
name|src_note
index|[
literal|2
index|]
operator|=
name|src2_note
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|src_note
index|[
name|i
index|]
condition|)
block|{
comment|/* If the register that dies is not at the top of stack, then 		   move the top of stack to the dead reg */
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src_note
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|remove_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src_note
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src_note
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src_note
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src_note
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Make dest the top of stack. */
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute hard regnums for any stack regs in INSN, which has    N_INPUTS inputs and N_OUTPUTS outputs.  REGSTACK is the stack info    before the insn, and is updated with changes made here.     There are several requirements and assumptions about the use of    stack-like regs in asm statements.  These rules are enforced by    record_asm_stack_regs; see comments there for details.  Any    asm_operands left in the RTL at this point may be assume to meet the    requirements, since record_asm_stack_regs removes any problem asm.  */
end_comment

begin_function
specifier|static
name|void
name|subst_asm_stack_regs
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|alt
decl_stmt|;
name|rtx
modifier|*
name|note_reg
decl_stmt|;
comment|/* Array of note contents */
name|rtx
modifier|*
modifier|*
name|note_loc
decl_stmt|;
comment|/* Address of REG field of each note */
name|enum
name|reg_note
modifier|*
name|note_kind
decl_stmt|;
comment|/* The type of each note */
name|rtx
modifier|*
name|clobber_reg
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|clobber_loc
decl_stmt|;
name|struct
name|stack_def
name|temp_stack
decl_stmt|;
name|int
name|n_notes
decl_stmt|;
name|int
name|n_clobbers
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
comment|/* Find out what the constraints required.  If no constraint      alternative matches, that is a compiler bug: we should have caught      such an insn during the life analysis pass (and reload should have      caught it regardless).  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alt
operator|=
name|which_alternative
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
name|n_inputs
operator|=
name|get_asm_operand_n_inputs
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|n_outputs
operator|=
name|recog_n_operands
operator|-
name|n_inputs
expr_stmt|;
if|if
condition|(
name|alt
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Strip SUBREGs here to make the following code simpler.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|recog_operand_loc
index|[
name|i
index|]
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|recog_operand
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Set up NOTE_REG, NOTE_LOC and NOTE_KIND.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
name|note_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|note_loc
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|note_kind
operator|=
operator|(
expr|enum
name|reg_note
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_note
argument_list|)
argument_list|)
expr_stmt|;
name|n_notes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
condition|)
block|{
name|note_reg
index|[
name|n_notes
index|]
operator|=
name|reg
expr_stmt|;
name|note_loc
index|[
name|n_notes
index|]
operator|=
name|loc
expr_stmt|;
name|note_kind
index|[
name|n_notes
index|]
operator|=
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|n_notes
operator|++
expr_stmt|;
block|}
block|}
comment|/* Set up CLOBBER_REG and CLOBBER_LOC.  */
name|n_clobbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|clobber_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|clobber_loc
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobber
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|&
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|clobber_reg
index|[
name|n_clobbers
index|]
operator|=
name|reg
expr_stmt|;
name|clobber_loc
index|[
name|n_clobbers
index|]
operator|=
name|loc
expr_stmt|;
name|n_clobbers
operator|++
expr_stmt|;
block|}
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|temp_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the input regs into the desired place in TEMP_STACK.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|&&
name|reg_class_subset_p
argument_list|(
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
argument_list|,
name|FLOAT_REGS
argument_list|)
operator|&&
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
operator|!=
name|FLOAT_REGS
condition|)
block|{
comment|/* If an operand needs to be in a particular reg in 	   FLOAT_REGS, the constraint was either 't' or 'u'.  Since 	   these constraints are for single register classes, and reload 	   guaranteed that operand[i] is already in that class, we can 	   just use REGNO (recog_operand[i]) to know which actual reg this 	   operand needs to be in.  */
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
operator|&
name|temp_stack
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* recog_operand[i] is not in the right place.  Find it 	       and swap it with whatever is already in I's place. 	       K is where recog_operand[i] is now.  J is where it should 	       be.  */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|temp
decl_stmt|;
name|k
operator|=
name|temp_stack
operator|.
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
expr_stmt|;
name|j
operator|=
operator|(
name|temp_stack
operator|.
name|top
operator|-
operator|(
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|-
name|FIRST_STACK_REG
operator|)
operator|)
expr_stmt|;
name|temp
operator|=
name|temp_stack
operator|.
name|reg
index|[
name|k
index|]
expr_stmt|;
name|temp_stack
operator|.
name|reg
index|[
name|k
index|]
operator|=
name|temp_stack
operator|.
name|reg
index|[
name|j
index|]
expr_stmt|;
name|temp_stack
operator|.
name|reg
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* emit insns before INSN to make sure the reg-stack is in the right      order.  */
name|change_stack
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|&
name|temp_stack
argument_list|,
name|emit_insn_before
argument_list|)
expr_stmt|;
comment|/* Make the needed input register substitutions.  Do death notes and      clobbers too, because these are for inputs, not outputs.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_notes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|note_kind
index|[
name|i
index|]
operator|==
name|REG_DEAD
condition|)
block|{
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|note_reg
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|note_loc
index|[
name|i
index|]
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_clobbers
condition|;
name|i
operator|++
control|)
block|{
comment|/* It's OK for a CLOBBER to reference a reg that is not live.          Don't try to replace it in that case.  */
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|clobber_reg
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
condition|)
block|{
comment|/* Sigh - clobbers always have QImode.  But replace_reg knows 	     that these regs can't be MODE_INT and will abort.  Just put 	     the right reg there without calling replace_reg.  */
operator|*
name|clobber_loc
index|[
name|i
index|]
operator|=
name|FP_MODE_REG
argument_list|(
name|regnum
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now remove from REGSTACK any inputs that the asm implicitly popped.  */
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* An input reg is implicitly popped if it is tied to an 	   output, or if there is a CLOBBER for it.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_clobbers
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|n_clobbers
operator|||
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
operator|>=
literal|0
condition|)
block|{
comment|/* recog_operand[i] might not be at the top of stack.  But that's 	       OK, because all we need to do is pop the right number of regs 	       off of the top of the reg-stack.  record_asm_stack_regs 	       guaranteed that all implicitly popped regs were grouped 	       at the top of the reg-stack.  */
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
block|}
comment|/* Now add to REGSTACK any outputs that the asm implicitly pushed.      Note that there isn't any need to substitute register numbers.      ???  Explain why this is true.  */
for|for
control|(
name|i
operator|=
name|LAST_STACK_REG
init|;
name|i
operator|>=
name|FIRST_STACK_REG
condition|;
name|i
operator|--
control|)
block|{
comment|/* See if there is an output for this hard reg.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_outputs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|j
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|recog_operand
index|[
name|j
index|]
argument_list|)
operator|==
name|i
condition|)
block|{
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|i
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now emit a pop insn for any REG_UNUSED output, or any REG_DEAD      input that the asm didn't implicitly pop.  If the asm didn't      implicitly pop an input reg, that reg will still be live.       Note that we can't use find_regno_note here: the register numbers      in the death notes have already been substituted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_notes
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|note_reg
index|[
name|j
index|]
argument_list|)
operator|&&
name|note_kind
index|[
name|j
index|]
operator|==
name|REG_UNUSED
condition|)
block|{
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
name|n_outputs
init|;
name|i
operator|<
name|n_outputs
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_notes
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|note_reg
index|[
name|j
index|]
argument_list|)
operator|&&
name|note_kind
index|[
name|j
index|]
operator|==
name|REG_DEAD
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute stack hard reg numbers for stack virtual registers in    INSN.  Non-stack register numbers are not changed.  REGSTACK is the    current stack content.  Insns may be emitted as needed to arrange the    stack for the 387 based on the contents of the insn.  */
end_comment

begin_function
specifier|static
name|void
name|subst_stack_regs
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|note_link
decl_stmt|,
name|note
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|top
init|=
name|regstack
operator|->
name|top
decl_stmt|;
comment|/* If there are any floating point parameters to be passed in 	registers for this call, make sure they are in the right 	order.  */
if|if
condition|(
name|top
operator|>=
literal|0
condition|)
block|{
name|straighten_stack
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regstack
argument_list|)
expr_stmt|;
comment|/* Now mark the arguments as dead after the call.  */
while|while
condition|(
name|regstack
operator|->
name|top
operator|>=
literal|0
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|FIRST_STACK_REG
operator|+
name|regstack
operator|->
name|top
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Do the actual substitution if any stack regs are mentioned.      Since we only record whether entire insn mentions stack regs, and      subst_stack_regs_pat only works for patterns that contain stack regs,      we must check each pattern in a parallel here.  A call_value_pop could      fail otherwise.  */
if|if
condition|(
name|stack_regs_mentioned
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|n_operands
init|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_operands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  Decode the operands, 	     decide how many are inputs, and do register substitution. 	     Any REG_UNUSED notes will be handled by subst_asm_stack_regs.  */
name|subst_asm_stack_regs
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|subst_stack_regs_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* subst_stack_regs_pat may have deleted a no-op insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
break|break;
block|}
block|}
else|else
name|subst_stack_regs_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* subst_stack_regs_pat may have deleted a no-op insn.  If so, any      REG_UNUSED will already have been dealt with, so just return.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
return|return;
comment|/* If there is a REG_UNUSED note on a stack register on this insn,      the indicated reg must be popped.  The REG_UNUSED note is removed,      since the form of the newly emitted pop insn references the reg,      making it no longer `unset'.  */
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
operator|*
name|note_link
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the organization of the stack so that it fits a new basic    block.  Some registers might have to be popped, but there can never be    a register live in the new block that is not now live.     Insert any needed insns before or after INSN.  WHEN is emit_insn_before    or emit_insn_after. OLD is the original stack layout, and NEW is    the desired form.  OLD is updated to reflect the code emitted, ie, it    will be the same as NEW upon return.     This function will not preserve block_end[].  But that information    is no longer needed once this has executed.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|change_stack
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|when
argument_list|)
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
name|new
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|when
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|reg
decl_stmt|;
comment|/* We will be inserting new insns "backwards", by calling emit_insn_before.      If we are to insert after INSN, find the next insn, and insert before      it.  */
if|if
condition|(
name|when
operator|==
name|emit_insn_after
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Pop any registers that are not needed in the new block.  */
for|for
control|(
name|reg
operator|=
name|old
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|new
operator|->
name|reg_set
argument_list|,
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|)
condition|)
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_MODE_REG
argument_list|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|emit_insn_before
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* If the new block has never been processed, then it can inherit 	 the old stack order.  */
name|new
operator|->
name|top
operator|=
name|old
operator|->
name|top
expr_stmt|;
name|bcopy
argument_list|(
name|old
operator|->
name|reg
argument_list|,
name|new
operator|->
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This block has been entered before, and we must match the 	 previously selected stack order.  */
comment|/* By now, the only difference should be the order of the stack, 	 not their depth or liveliness.  */
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|old
operator|->
name|reg_set
argument_list|,
name|new
operator|->
name|reg_set
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|win
label|:
if|if
condition|(
name|old
operator|->
name|top
operator|!=
name|new
operator|->
name|top
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the stack is not empty (new->top != -1), loop here emitting 	 swaps until the stack is correct.   	 The worst case number of swaps emitted is N + 2, where N is the 	 depth of the stack.  In some cases, the reg at the top of 	 stack may be correct, but swapped anyway in order to fix 	 other regs.  But since we never swap any other reg away from 	 its correct slot, this algorithm will converge.  */
if|if
condition|(
name|new
operator|->
name|top
operator|!=
operator|-
literal|1
condition|)
do|do
block|{
comment|/* Swap the reg at top of stack into the position it is 	       supposed to be in, until the correct top of stack appears.  */
while|while
condition|(
name|old
operator|->
name|reg
index|[
name|old
operator|->
name|top
index|]
operator|!=
name|new
operator|->
name|reg
index|[
name|new
operator|->
name|top
index|]
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|new
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|new
operator|->
name|reg
index|[
name|reg
index|]
operator|==
name|old
operator|->
name|reg
index|[
name|old
operator|->
name|top
index|]
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_MODE_REG
argument_list|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* See if any regs remain incorrect.  If so, bring an 	     incorrect reg to the top of stack, and let the while loop 	     above fix it.  */
for|for
control|(
name|reg
operator|=
name|new
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|new
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|old
operator|->
name|reg
index|[
name|reg
index|]
condition|)
block|{
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_MODE_REG
argument_list|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|reg
operator|>=
literal|0
condition|)
do|;
comment|/* At this point there must be no differences.  */
for|for
control|(
name|reg
operator|=
name|old
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|new
operator|->
name|reg
index|[
name|reg
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Check PAT, which points to RTL in INSN, for a LABEL_REF.  If it is    found, ensure that a jump from INSN to the code_label to which the    label_ref points ends up with the same stack as that at the    code_label.  Do this by inserting insns just before the code_label to    pop and rotate the stack until it is in the correct order.  REGSTACK    is the order of the register stack in INSN.     Any code that is emitted here must not be later processed as part    of any block, as it will already contain hard register numbers.  */
end_comment

begin_function
specifier|static
name|void
name|goto_block_pat
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
name|rtx
name|new_jump
decl_stmt|,
name|new_label
decl_stmt|,
name|new_barrier
decl_stmt|;
name|rtx
modifier|*
name|ref
decl_stmt|;
name|stack
name|label_stack
decl_stmt|;
name|struct
name|stack_def
name|temp_stack
decl_stmt|;
name|int
name|reg
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|RETURN
case|:
name|straighten_stack
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regstack
argument_list|)
expr_stmt|;
return|return;
default|default:
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|goto_block_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|goto_block_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|LABEL_REF
case|:
empty_stmt|;
block|}
name|label
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* First, see if in fact anything needs to be done to the stack at all.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|<=
literal|0
condition|)
return|return;
name|label_stack
operator|=
operator|&
name|block_stack_in
index|[
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|label_stack
operator|->
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* If the target block hasn't had a stack order selected, then 	 we need merely ensure that no pops are needed.  */
for|for
control|(
name|reg
operator|=
name|regstack
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|label_stack
operator|->
name|reg_set
argument_list|,
name|regstack
operator|->
name|reg
index|[
name|reg
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* change_stack will not emit any code in this case.  */
name|change_stack
argument_list|(
name|label
argument_list|,
name|regstack
argument_list|,
name|label_stack
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|label_stack
operator|->
name|top
operator|==
name|regstack
operator|->
name|top
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|label_stack
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|label_stack
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|regstack
operator|->
name|reg
index|[
name|reg
index|]
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
comment|/* At least one insn will need to be inserted before label.  Insert      a jump around the code we are about to emit.  Emit a label for the new      code, and point the original insn at this new label. We can't use      redirect_jump here, because we're using fld[4] of the code labels as      LABEL_REF chains, no NUSES counters.  */
name|new_jump
operator|=
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|record_label_references
argument_list|(
name|new_jump
argument_list|,
name|PATTERN
argument_list|(
name|new_jump
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|new_barrier
operator|=
name|emit_barrier_after
argument_list|(
name|new_jump
argument_list|)
expr_stmt|;
name|new_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|new_label
argument_list|,
name|new_barrier
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|new_label
argument_list|)
operator|=
name|new_label
expr_stmt|;
comment|/* The old label_ref will no longer point to the code_label if now uses,      so strip the label_ref from the code_label's chain of references.  */
for|for
control|(
name|ref
operator|=
operator|&
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
operator|*
name|ref
operator|!=
name|label
condition|;
name|ref
operator|=
operator|&
name|LABEL_NEXTREF
argument_list|(
operator|*
name|ref
argument_list|)
control|)
if|if
condition|(
operator|*
name|ref
operator|==
name|pat
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|==
name|label
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|ref
operator|=
name|LABEL_NEXTREF
argument_list|(
operator|*
name|ref
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|=
name|new_label
expr_stmt|;
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|new_label
expr_stmt|;
comment|/* Now emit the needed code.  */
name|temp_stack
operator|=
operator|*
name|regstack
expr_stmt|;
name|change_stack
argument_list|(
name|new_label
argument_list|,
operator|&
name|temp_stack
argument_list|,
name|label_stack
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Traverse all basic blocks in a function, converting the register    references in each insn from the "flat" register file that gcc uses, to    the stack-like registers the 387 uses.  */
end_comment

begin_function
specifier|static
name|void
name|convert_regs
parameter_list|()
block|{
specifier|register
name|int
name|block
decl_stmt|,
name|reg
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|struct
name|stack_def
name|regstack
decl_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|blocks
condition|;
name|block
operator|++
control|)
block|{
if|if
condition|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* This block has not been previously encountered.  Choose a 	     default mapping for any stack regs live on entry */
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_STACK_REG
init|;
name|reg
operator|>=
name|FIRST_STACK_REG
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg
index|[
operator|++
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
index|]
operator|=
name|reg
expr_stmt|;
block|}
comment|/* Process all insns in this block.  Keep track of `next' here, 	 so that we don't process any insns emitted while making 	 substitutions in INSN.  */
name|next
operator|=
name|block_begin
index|[
name|block
index|]
expr_stmt|;
name|regstack
operator|=
name|block_stack_in
index|[
name|block
index|]
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't bother processing unless there is a stack reg 	     mentioned or if it's a CALL_INSN (register passing of 	     floating point values).  */
if|if
condition|(
name|stack_regs_mentioned
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|subst_stack_regs
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|block_end
index|[
name|block
index|]
condition|)
do|;
comment|/* For all further actions, INSN needs to be the last insn in          this basic block.  If subst_stack_regs inserted additional          instructions after INSN, it is no longer the last one at          this point.  */
name|next
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* If subst_stack_regs inserted something after a JUMP_INSN, that          is almost certainly a bug.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|insn
operator|!=
name|next
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
comment|/* Something failed if the stack life doesn't match.  */
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|regstack
operator|.
name|reg_set
argument_list|,
name|block_out_reg_set
index|[
name|block
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|win
label|:
comment|/* Adjust the stack of this block on exit to match the stack of 	 the target block, or copy stack information into stack of 	 jump target if the target block's stack order hasn't been set 	 yet.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|goto_block_pat
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Likewise handle the case where we fall into the next block.  */
if|if
condition|(
operator|(
name|block
operator|<
name|blocks
operator|-
literal|1
operator|)
operator|&&
name|block_drops_in
index|[
name|block
operator|+
literal|1
index|]
condition|)
name|change_stack
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|,
operator|&
name|block_stack_in
index|[
name|block
operator|+
literal|1
index|]
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
comment|/* If the last basic block is the end of a loop, and that loop has      regs live at its start, then the last basic block will have regs live      at its end that need to be popped before the function returns.  */
block|{
name|int
name|value_reg_low
decl_stmt|,
name|value_reg_high
decl_stmt|;
name|value_reg_low
operator|=
name|value_reg_high
operator|=
operator|-
literal|1
expr_stmt|;
block|{
name|rtx
name|retvalue
decl_stmt|;
if|if
condition|(
operator|(
name|retvalue
operator|=
name|stack_result
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
block|{
name|value_reg_low
operator|=
name|REGNO
argument_list|(
name|retvalue
argument_list|)
expr_stmt|;
name|value_reg_high
operator|=
name|value_reg_low
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|value_reg_low
argument_list|,
name|GET_MODE
argument_list|(
name|retvalue
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|reg
operator|=
name|regstack
operator|.
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regstack
operator|.
name|reg
index|[
name|reg
index|]
operator|<
name|value_reg_low
operator|||
name|regstack
operator|.
name|reg
index|[
name|reg
index|]
operator|>
name|value_reg_high
condition|)
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|,
name|FP_MODE_REG
argument_list|(
name|regstack
operator|.
name|reg
index|[
name|reg
index|]
argument_list|,
name|DFmode
argument_list|)
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
name|straighten_stack
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check expression PAT, which is in INSN, for label references.  if    one is found, print the block number of destination to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|print_blocks
parameter_list|(
name|file
parameter_list|,
name|insn
parameter_list|,
name|pat
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|print_blocks
argument_list|(
name|file
argument_list|,
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|print_blocks
argument_list|(
name|file
argument_list|,
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write information about stack registers and stack blocks into FILE.    This is part of making a debugging dump.  */
end_comment

begin_function
specifier|static
name|void
name|dump_stack_info
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|block
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d stack blocks.\n"
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|blocks
condition|;
name|block
operator|++
control|)
block|{
specifier|register
name|rtx
name|head
decl_stmt|,
name|jump
decl_stmt|,
name|end
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nStack block %d: first insn %d, last %d.\n"
argument_list|,
name|block
argument_list|,
name|INSN_UID
argument_list|(
name|block_begin
index|[
name|block
index|]
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|block_end
index|[
name|block
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|block_begin
index|[
name|block
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reached from blocks: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|from_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block_drops_in
index|[
name|block
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" previous"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nlive stack registers on block entry: "
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_STACK_REG
init|;
name|regno
operator|<=
name|LAST_STACK_REG
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nlive stack registers on block exit: "
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_STACK_REG
init|;
name|regno
operator|<=
name|LAST_STACK_REG
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_out_reg_set
index|[
name|block
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|block_end
index|[
name|block
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nJumps to blocks: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|print_blocks
argument_list|(
name|file
argument_list|,
name|end
argument_list|,
name|PATTERN
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|+
literal|1
operator|<
name|blocks
operator|&&
name|block_drops_in
index|[
name|block
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" next"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|block
operator|+
literal|1
operator|==
name|blocks
operator|||
operator|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|end
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" return"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STACK_REGS */
end_comment

end_unit

