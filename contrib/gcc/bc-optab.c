begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Bytecode conversion definitions for GNU C-compiler.    Copyright (C) 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bytecode.h"
end_include

begin_include
include|#
directive|include
file|"bc-typecd.h"
end_include

begin_include
include|#
directive|include
file|"bc-opcode.h"
end_include

begin_include
include|#
directive|include
file|"bc-optab.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Table relating interpreter typecodes to machine modes.  */
end_comment

begin_define
define|#
directive|define
name|GET_TYPECODE_MODE
parameter_list|(
name|CODE
parameter_list|)
value|(typecode_mode[((int) CODE)])
end_define

begin_decl_stmt
name|enum
name|machine_mode
name|typecode_mode
index|[]
init|=
block|{
define|#
directive|define
name|DEFTYPECODE
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|MODE
parameter_list|,
name|TYPE
parameter_list|)
value|MODE,
include|#
directive|include
file|"bc-typecd.def"
undef|#
directive|undef
name|DEFTYPECODE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machine mode to type code map */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|typecode
name|signed_mode_to_code_map
index|[
name|MAX_MACHINE_MODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|typecode
name|unsigned_mode_to_code_map
index|[
name|MAX_MACHINE_MODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GET_TYPECODE_SIZE
parameter_list|(
name|CODE
parameter_list|)
value|GET_MODE_SIZE (GET_TYPECODE_MODE (CODE))
end_define

begin_define
define|#
directive|define
name|BIG_ARBITRARY_NUMBER
value|100000
end_define

begin_comment
comment|/* Table of recipes for conversions among scalar types, to be filled    in as needed at run time.  */
end_comment

begin_struct
specifier|static
struct|struct
name|conversion_recipe
block|{
name|unsigned
name|char
modifier|*
name|opcodes
decl_stmt|;
comment|/* Bytecodes to emit in order.  */
name|int
name|nopcodes
decl_stmt|;
comment|/* Count of bytecodes. */
name|int
name|cost
decl_stmt|;
comment|/* A rather arbitrary cost function. */
block|}
name|conversion_recipe
index|[
name|NUM_TYPECODES
index|]
index|[
name|NUM_TYPECODES
index|]
struct|;
end_struct

begin_comment
comment|/* Binary operator tables.  */
end_comment

begin_decl_stmt
name|struct
name|binary_operator
name|optab_plus_expr
index|[]
init|=
block|{
block|{
name|addSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|addDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|addSF
block|,
name|SFcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|addDF
block|,
name|DFcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|addXF
block|,
name|XFcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|addPSI
block|,
name|Pcode
block|,
name|Pcode
block|,
name|SIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_minus_expr
index|[]
init|=
block|{
block|{
name|subSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|subDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|subSF
block|,
name|SFcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|subDF
block|,
name|DFcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|subXF
block|,
name|XFcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|subPP
block|,
name|SIcode
block|,
name|Pcode
block|,
name|Pcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The ordering of the tables for multiplicative operators    is such that unsigned operations will be preferred to signed    operations when one argument is unsigned.  */
end_comment

begin_decl_stmt
name|struct
name|binary_operator
name|optab_mult_expr
index|[]
init|=
block|{
block|{
name|mulSU
block|,
name|SUcode
block|,
name|SUcode
block|,
name|SUcode
block|}
block|,
block|{
name|mulDU
block|,
name|DUcode
block|,
name|DUcode
block|,
name|DUcode
block|}
block|,
block|{
name|mulSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|mulDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|mulSF
block|,
name|SFcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|mulDF
block|,
name|DFcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|mulXF
block|,
name|XFcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_trunc_div_expr
index|[]
init|=
block|{
block|{
name|divSU
block|,
name|SUcode
block|,
name|SUcode
block|,
name|SUcode
block|}
block|,
block|{
name|divDU
block|,
name|DUcode
block|,
name|DUcode
block|,
name|DUcode
block|}
block|,
block|{
name|divSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|divDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_trunc_mod_expr
index|[]
init|=
block|{
block|{
name|modSU
block|,
name|SUcode
block|,
name|SUcode
block|,
name|SUcode
block|}
block|,
block|{
name|modDU
block|,
name|DUcode
block|,
name|DUcode
block|,
name|DUcode
block|}
block|,
block|{
name|modSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|modDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_rdiv_expr
index|[]
init|=
block|{
block|{
name|divSF
block|,
name|SFcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|divDF
block|,
name|DFcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|divXF
block|,
name|XFcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_bit_and_expr
index|[]
init|=
block|{
block|{
name|andSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|andDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_bit_ior_expr
index|[]
init|=
block|{
block|{
name|iorSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|iorDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_bit_xor_expr
index|[]
init|=
block|{
block|{
name|xorSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|xorDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_lshift_expr
index|[]
init|=
block|{
block|{
name|lshiftSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|lshiftSU
block|,
name|SUcode
block|,
name|SUcode
block|,
name|SIcode
block|}
block|,
block|{
name|lshiftDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|SIcode
block|}
block|,
block|{
name|lshiftDU
block|,
name|DUcode
block|,
name|DUcode
block|,
name|SIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_rshift_expr
index|[]
init|=
block|{
block|{
name|rshiftSI
block|,
name|SIcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|rshiftSU
block|,
name|SUcode
block|,
name|SUcode
block|,
name|SIcode
block|}
block|,
block|{
name|rshiftDI
block|,
name|DIcode
block|,
name|DIcode
block|,
name|SIcode
block|}
block|,
block|{
name|rshiftDU
block|,
name|DUcode
block|,
name|DUcode
block|,
name|SIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_truth_and_expr
index|[]
init|=
block|{
block|{
name|andSI
block|,
name|SIcode
block|,
name|Tcode
block|,
name|Tcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_truth_or_expr
index|[]
init|=
block|{
block|{
name|iorSI
block|,
name|SIcode
block|,
name|Tcode
block|,
name|Tcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_lt_expr
index|[]
init|=
block|{
block|{
name|ltSI
block|,
name|Tcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|ltSU
block|,
name|Tcode
block|,
name|SUcode
block|,
name|SUcode
block|}
block|,
block|{
name|ltDI
block|,
name|Tcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|ltDU
block|,
name|Tcode
block|,
name|DUcode
block|,
name|DUcode
block|}
block|,
block|{
name|ltSF
block|,
name|Tcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|ltDF
block|,
name|Tcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|ltXF
block|,
name|Tcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|ltP
block|,
name|Tcode
block|,
name|Pcode
block|,
name|Pcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_le_expr
index|[]
init|=
block|{
block|{
name|leSI
block|,
name|Tcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|leSU
block|,
name|Tcode
block|,
name|SUcode
block|,
name|SUcode
block|}
block|,
block|{
name|leDI
block|,
name|Tcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|leDU
block|,
name|Tcode
block|,
name|DUcode
block|,
name|DUcode
block|}
block|,
block|{
name|leSF
block|,
name|Tcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|leDF
block|,
name|Tcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|leXF
block|,
name|Tcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|leP
block|,
name|Tcode
block|,
name|Pcode
block|,
name|Pcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_ge_expr
index|[]
init|=
block|{
block|{
name|geSI
block|,
name|Tcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|geSU
block|,
name|Tcode
block|,
name|SUcode
block|,
name|SUcode
block|}
block|,
block|{
name|geDI
block|,
name|Tcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|geDU
block|,
name|Tcode
block|,
name|DUcode
block|,
name|DUcode
block|}
block|,
block|{
name|geSF
block|,
name|Tcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|geDF
block|,
name|Tcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|geXF
block|,
name|Tcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|geP
block|,
name|Tcode
block|,
name|Pcode
block|,
name|Pcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_gt_expr
index|[]
init|=
block|{
block|{
name|gtSI
block|,
name|Tcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|gtSU
block|,
name|Tcode
block|,
name|SUcode
block|,
name|SUcode
block|}
block|,
block|{
name|gtDI
block|,
name|Tcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|gtDU
block|,
name|Tcode
block|,
name|DUcode
block|,
name|DUcode
block|}
block|,
block|{
name|gtSF
block|,
name|Tcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|gtDF
block|,
name|Tcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|gtXF
block|,
name|Tcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|gtP
block|,
name|Tcode
block|,
name|Pcode
block|,
name|Pcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_eq_expr
index|[]
init|=
block|{
block|{
name|eqSI
block|,
name|Tcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|eqDI
block|,
name|Tcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|eqSF
block|,
name|Tcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|eqDF
block|,
name|Tcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|eqXF
block|,
name|Tcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|eqP
block|,
name|Tcode
block|,
name|Pcode
block|,
name|Pcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|binary_operator
name|optab_ne_expr
index|[]
init|=
block|{
block|{
name|neSI
block|,
name|Tcode
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|neDI
block|,
name|Tcode
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|neSF
block|,
name|Tcode
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|neDF
block|,
name|Tcode
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|neXF
block|,
name|Tcode
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
name|neP
block|,
name|Tcode
block|,
name|Pcode
block|,
name|Pcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unary operator tables.  */
end_comment

begin_decl_stmt
name|struct
name|unary_operator
name|optab_negate_expr
index|[]
init|=
block|{
block|{
name|negSI
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|negDI
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
name|negSF
block|,
name|SFcode
block|,
name|SFcode
block|}
block|,
block|{
name|negDF
block|,
name|DFcode
block|,
name|DFcode
block|}
block|,
block|{
name|negXF
block|,
name|XFcode
block|,
name|XFcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|unary_operator
name|optab_bit_not_expr
index|[]
init|=
block|{
block|{
name|notSI
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
name|notDI
block|,
name|DIcode
block|,
name|DIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|unary_operator
name|optab_truth_not_expr
index|[]
init|=
block|{
block|{
name|notT
block|,
name|SIcode
block|,
name|SIcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Increment operator tables.  */
end_comment

begin_decl_stmt
name|struct
name|increment_operator
name|optab_predecrement_expr
index|[]
init|=
block|{
block|{
name|predecQI
block|,
name|QIcode
block|}
block|,
block|{
name|predecQI
block|,
name|QUcode
block|}
block|,
block|{
name|predecHI
block|,
name|HIcode
block|}
block|,
block|{
name|predecHI
block|,
name|HUcode
block|}
block|,
block|{
name|predecSI
block|,
name|SIcode
block|}
block|,
block|{
name|predecSI
block|,
name|SUcode
block|}
block|,
block|{
name|predecDI
block|,
name|DIcode
block|}
block|,
block|{
name|predecDI
block|,
name|DUcode
block|}
block|,
block|{
name|predecP
block|,
name|Pcode
block|}
block|,
block|{
name|predecSF
block|,
name|SFcode
block|}
block|,
block|{
name|predecDF
block|,
name|DFcode
block|}
block|,
block|{
name|predecXF
block|,
name|XFcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|increment_operator
name|optab_preincrement_expr
index|[]
init|=
block|{
block|{
name|preincQI
block|,
name|QIcode
block|}
block|,
block|{
name|preincQI
block|,
name|QUcode
block|}
block|,
block|{
name|preincHI
block|,
name|HIcode
block|}
block|,
block|{
name|preincHI
block|,
name|HUcode
block|}
block|,
block|{
name|preincSI
block|,
name|SIcode
block|}
block|,
block|{
name|preincSI
block|,
name|SUcode
block|}
block|,
block|{
name|preincDI
block|,
name|DIcode
block|}
block|,
block|{
name|preincDI
block|,
name|DUcode
block|}
block|,
block|{
name|preincP
block|,
name|Pcode
block|}
block|,
block|{
name|preincSF
block|,
name|SFcode
block|}
block|,
block|{
name|preincDF
block|,
name|DFcode
block|}
block|,
block|{
name|preincXF
block|,
name|XFcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|increment_operator
name|optab_postdecrement_expr
index|[]
init|=
block|{
block|{
name|postdecQI
block|,
name|QIcode
block|}
block|,
block|{
name|postdecQI
block|,
name|QUcode
block|}
block|,
block|{
name|postdecHI
block|,
name|HIcode
block|}
block|,
block|{
name|postdecHI
block|,
name|HUcode
block|}
block|,
block|{
name|postdecSI
block|,
name|SIcode
block|}
block|,
block|{
name|postdecSI
block|,
name|SUcode
block|}
block|,
block|{
name|postdecDI
block|,
name|DIcode
block|}
block|,
block|{
name|postdecDI
block|,
name|DUcode
block|}
block|,
block|{
name|postdecP
block|,
name|Pcode
block|}
block|,
block|{
name|postdecSF
block|,
name|SFcode
block|}
block|,
block|{
name|postdecDF
block|,
name|DFcode
block|}
block|,
block|{
name|postdecXF
block|,
name|XFcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|increment_operator
name|optab_postincrement_expr
index|[]
init|=
block|{
block|{
name|postincQI
block|,
name|QIcode
block|}
block|,
block|{
name|postincQI
block|,
name|QUcode
block|}
block|,
block|{
name|postincHI
block|,
name|HIcode
block|}
block|,
block|{
name|postincHI
block|,
name|HUcode
block|}
block|,
block|{
name|postincSI
block|,
name|SIcode
block|}
block|,
block|{
name|postincSI
block|,
name|SUcode
block|}
block|,
block|{
name|postincDI
block|,
name|DIcode
block|}
block|,
block|{
name|postincDI
block|,
name|DUcode
block|}
block|,
block|{
name|postincP
block|,
name|Pcode
block|}
block|,
block|{
name|postincSF
block|,
name|SFcode
block|}
block|,
block|{
name|postincDF
block|,
name|DFcode
block|}
block|,
block|{
name|postincXF
block|,
name|XFcode
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of conversions supported by the interpreter.  */
end_comment

begin_struct
specifier|static
struct|struct
name|conversion_info
block|{
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
comment|/*  here indicates the conversion needs no opcode.  */
name|enum
name|typecode
name|from
decl_stmt|;
name|enum
name|typecode
name|to
decl_stmt|;
name|int
name|cost
decl_stmt|;
comment|/* 1 for no-op conversions, 2 for widening conversions, 				   4 for int/float conversions, 8 for narrowing conversions.  */
block|}
name|conversion_info
index|[]
init|=
block|{
block|{
operator|-
literal|1
block|,
name|QIcode
block|,
name|QUcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|HIcode
block|,
name|HUcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|SIcode
block|,
name|SUcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|DIcode
block|,
name|DUcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|QUcode
block|,
name|QIcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|HUcode
block|,
name|HIcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|SUcode
block|,
name|SIcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|DUcode
block|,
name|DIcode
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|Tcode
block|,
name|SIcode
block|,
literal|1
block|}
block|,
block|{
name|convertQIHI
block|,
name|QIcode
block|,
name|HIcode
block|,
literal|2
block|}
block|,
block|{
name|convertQUHU
block|,
name|QUcode
block|,
name|HUcode
block|,
literal|2
block|}
block|,
block|{
name|convertQUSU
block|,
name|QUcode
block|,
name|SUcode
block|,
literal|2
block|}
block|,
block|{
name|convertHISI
block|,
name|HIcode
block|,
name|SIcode
block|,
literal|2
block|}
block|,
block|{
name|convertHUSU
block|,
name|HUcode
block|,
name|SUcode
block|,
literal|2
block|}
block|,
block|{
name|convertSIDI
block|,
name|SIcode
block|,
name|DIcode
block|,
literal|2
block|}
block|,
block|{
name|convertSUDU
block|,
name|SUcode
block|,
name|DUcode
block|,
literal|2
block|}
block|,
block|{
name|convertSFDF
block|,
name|SFcode
block|,
name|DFcode
block|,
literal|2
block|}
block|,
block|{
name|convertDFXF
block|,
name|DFcode
block|,
name|XFcode
block|,
literal|2
block|}
block|,
block|{
name|convertHIQI
block|,
name|HIcode
block|,
name|QIcode
block|,
literal|8
block|}
block|,
block|{
name|convertSIQI
block|,
name|SIcode
block|,
name|QIcode
block|,
literal|8
block|}
block|,
block|{
name|convertSIHI
block|,
name|SIcode
block|,
name|HIcode
block|,
literal|8
block|}
block|,
block|{
name|convertSUQU
block|,
name|SUcode
block|,
name|QUcode
block|,
literal|8
block|}
block|,
block|{
name|convertDISI
block|,
name|DIcode
block|,
name|SIcode
block|,
literal|8
block|}
block|,
block|{
name|convertDFSF
block|,
name|DFcode
block|,
name|SFcode
block|,
literal|8
block|}
block|,
block|{
name|convertXFDF
block|,
name|XFcode
block|,
name|DFcode
block|,
literal|8
block|}
block|,
block|{
name|convertPSI
block|,
name|Pcode
block|,
name|SIcode
block|,
literal|2
block|}
block|,
block|{
name|convertSIP
block|,
name|SIcode
block|,
name|Pcode
block|,
literal|2
block|}
block|,
block|{
name|convertSIT
block|,
name|SIcode
block|,
name|Tcode
block|,
literal|2
block|}
block|,
block|{
name|convertDIT
block|,
name|DIcode
block|,
name|Tcode
block|,
literal|2
block|}
block|,
block|{
name|convertSFT
block|,
name|SFcode
block|,
name|Tcode
block|,
literal|2
block|}
block|,
block|{
name|convertDFT
block|,
name|DFcode
block|,
name|Tcode
block|,
literal|2
block|}
block|,
block|{
name|convertXFT
block|,
name|XFcode
block|,
name|Tcode
block|,
literal|2
block|}
block|,
block|{
name|convertQISI
block|,
name|QIcode
block|,
name|SIcode
block|,
literal|2
block|}
block|,
block|{
name|convertPT
block|,
name|Pcode
block|,
name|Tcode
block|,
literal|2
block|}
block|,
block|{
name|convertSISF
block|,
name|SIcode
block|,
name|SFcode
block|,
literal|4
block|}
block|,
block|{
name|convertSIDF
block|,
name|SIcode
block|,
name|DFcode
block|,
literal|4
block|}
block|,
block|{
name|convertSIXF
block|,
name|SIcode
block|,
name|XFcode
block|,
literal|4
block|}
block|,
block|{
name|convertSUSF
block|,
name|SUcode
block|,
name|SFcode
block|,
literal|4
block|}
block|,
block|{
name|convertSUDF
block|,
name|SUcode
block|,
name|DFcode
block|,
literal|4
block|}
block|,
block|{
name|convertSUXF
block|,
name|SUcode
block|,
name|XFcode
block|,
literal|4
block|}
block|,
block|{
name|convertDISF
block|,
name|DIcode
block|,
name|SFcode
block|,
literal|4
block|}
block|,
block|{
name|convertDIDF
block|,
name|DIcode
block|,
name|DFcode
block|,
literal|4
block|}
block|,
block|{
name|convertDIXF
block|,
name|DIcode
block|,
name|XFcode
block|,
literal|4
block|}
block|,
block|{
name|convertDUSF
block|,
name|DUcode
block|,
name|SFcode
block|,
literal|4
block|}
block|,
block|{
name|convertDUDF
block|,
name|DUcode
block|,
name|DFcode
block|,
literal|4
block|}
block|,
block|{
name|convertDUXF
block|,
name|DUcode
block|,
name|XFcode
block|,
literal|4
block|}
block|,
block|{
name|convertSFSI
block|,
name|SFcode
block|,
name|SIcode
block|,
literal|4
block|}
block|,
block|{
name|convertDFSI
block|,
name|DFcode
block|,
name|SIcode
block|,
literal|4
block|}
block|,
block|{
name|convertXFSI
block|,
name|XFcode
block|,
name|SIcode
block|,
literal|4
block|}
block|,
block|{
name|convertSFSU
block|,
name|SFcode
block|,
name|SUcode
block|,
literal|4
block|}
block|,
block|{
name|convertDFSU
block|,
name|DFcode
block|,
name|SUcode
block|,
literal|4
block|}
block|,
block|{
name|convertXFSU
block|,
name|XFcode
block|,
name|SUcode
block|,
literal|4
block|}
block|,
block|{
name|convertSFDI
block|,
name|SFcode
block|,
name|DIcode
block|,
literal|4
block|}
block|,
block|{
name|convertDFDI
block|,
name|DFcode
block|,
name|DIcode
block|,
literal|4
block|}
block|,
block|{
name|convertXFDI
block|,
name|XFcode
block|,
name|DIcode
block|,
literal|4
block|}
block|,
block|{
name|convertSFDU
block|,
name|SFcode
block|,
name|DUcode
block|,
literal|4
block|}
block|,
block|{
name|convertDFDU
block|,
name|DFcode
block|,
name|DUcode
block|,
literal|4
block|}
block|,
block|{
name|convertXFDU
block|,
name|XFcode
block|,
name|DUcode
block|,
literal|4
block|}
block|,
block|{
name|convertSIQI
block|,
name|SIcode
block|,
name|QIcode
block|,
literal|8
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_CONVERSIONS
value|(sizeof conversion_info / sizeof (struct conversion_info))
end_define

begin_comment
comment|/* List form of a conversion recipe.  */
end_comment

begin_struct
struct|struct
name|conversion_list
block|{
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
name|enum
name|typecode
name|to
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|struct
name|conversion_list
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Determine if it is "reasonable" to add a given conversion to    a given list of conversions.  The following criteria define    "reasonable" conversion lists:    * No typecode appears more than once in the sequence (no loops).    * At most one conversion from integer to float or vice versa is present.    * Either sign extensions or zero extensions may be present, but not both.    * No widening conversions occur after a signed/unsigned conversion.    * The sequence of sizes must be strict nonincreasing or nondecreasing.  */
end_comment

begin_function
specifier|static
name|int
name|conversion_reasonable_p
parameter_list|(
name|conversion
parameter_list|,
name|list
parameter_list|)
name|struct
name|conversion_info
modifier|*
name|conversion
decl_stmt|;
name|struct
name|conversion_list
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|conversion_list
modifier|*
name|curr
decl_stmt|;
name|int
name|curr_size
decl_stmt|,
name|prev_size
decl_stmt|;
name|int
name|has_int_float
decl_stmt|,
name|has_float_int
decl_stmt|;
name|int
name|has_sign_extend
decl_stmt|,
name|has_zero_extend
decl_stmt|;
name|int
name|has_signed_unsigned
decl_stmt|,
name|has_unsigned_signed
decl_stmt|;
name|has_int_float
operator|=
literal|0
expr_stmt|;
name|has_float_int
operator|=
literal|0
expr_stmt|;
name|has_sign_extend
operator|=
literal|0
expr_stmt|;
name|has_zero_extend
operator|=
literal|0
expr_stmt|;
name|has_signed_unsigned
operator|=
literal|0
expr_stmt|;
name|has_unsigned_signed
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the destination typecode doesn't already appear in      the list.  */
for|for
control|(
name|curr
operator|=
name|list
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|prev
control|)
if|if
condition|(
name|conversion
operator|->
name|to
operator|==
name|curr
operator|->
name|to
condition|)
return|return
literal|0
return|;
comment|/* Check for certain kinds of conversions.  */
if|if
condition|(
name|TYPECODE_INTEGER_P
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|&&
name|TYPECODE_FLOAT_P
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
condition|)
name|has_int_float
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_FLOAT_P
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|&&
name|TYPECODE_INTEGER_P
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
condition|)
name|has_float_int
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_SIGNED_P
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|&&
name|TYPECODE_SIGNED_P
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
operator|&&
name|GET_TYPECODE_SIZE
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|<
name|GET_TYPECODE_SIZE
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
condition|)
name|has_sign_extend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_UNSIGNED_P
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|&&
name|TYPECODE_UNSIGNED_P
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
operator|&&
name|GET_TYPECODE_SIZE
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|<
name|GET_TYPECODE_SIZE
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
condition|)
name|has_zero_extend
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|curr
operator|=
name|list
init|;
name|curr
operator|&&
name|curr
operator|->
name|prev
condition|;
name|curr
operator|=
name|curr
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|TYPECODE_INTEGER_P
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|&&
name|TYPECODE_FLOAT_P
argument_list|(
name|curr
operator|->
name|to
argument_list|)
condition|)
name|has_int_float
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_FLOAT_P
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|&&
name|TYPECODE_INTEGER_P
argument_list|(
name|curr
operator|->
name|to
argument_list|)
condition|)
name|has_float_int
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_SIGNED_P
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|&&
name|TYPECODE_SIGNED_P
argument_list|(
name|curr
operator|->
name|to
argument_list|)
operator|&&
name|GET_TYPECODE_SIZE
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|<
name|GET_TYPECODE_SIZE
argument_list|(
name|curr
operator|->
name|to
argument_list|)
condition|)
name|has_sign_extend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_UNSIGNED_P
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|&&
name|TYPECODE_UNSIGNED_P
argument_list|(
name|curr
operator|->
name|to
argument_list|)
operator|&&
name|GET_TYPECODE_SIZE
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|<
name|GET_TYPECODE_SIZE
argument_list|(
name|curr
operator|->
name|to
argument_list|)
condition|)
name|has_zero_extend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_SIGNED_P
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|&&
name|TYPECODE_UNSIGNED_P
argument_list|(
name|curr
operator|->
name|to
argument_list|)
condition|)
name|has_signed_unsigned
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPECODE_UNSIGNED_P
argument_list|(
name|curr
operator|->
name|prev
operator|->
name|to
argument_list|)
operator|&&
name|TYPECODE_SIGNED_P
argument_list|(
name|curr
operator|->
name|to
argument_list|)
condition|)
name|has_unsigned_signed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPECODE_INTEGER_P
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|&&
name|TYPECODE_INTEGER_P
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
operator|&&
name|GET_TYPECODE_SIZE
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
operator|>
name|GET_TYPECODE_SIZE
argument_list|(
name|conversion
operator|->
name|from
argument_list|)
operator|&&
operator|(
name|has_signed_unsigned
operator|||
name|has_unsigned_signed
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|has_float_int
operator|&&
name|has_int_float
operator|||
name|has_sign_extend
operator|&&
name|has_zero_extend
condition|)
return|return
literal|0
return|;
comment|/* Make sure the sequence of destination typecode sizes is      strictly nondecreasing or strictly nonincreasing.  */
name|prev_size
operator|=
name|GET_TYPECODE_SIZE
argument_list|(
name|conversion
operator|->
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|curr
operator|=
name|list
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|prev
control|)
block|{
name|curr_size
operator|=
name|GET_TYPECODE_SIZE
argument_list|(
name|curr
operator|->
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_size
operator|!=
name|prev_size
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|curr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|curr_size
operator|<
name|prev_size
condition|)
for|for
control|(
name|prev_size
operator|=
name|curr_size
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|prev
control|)
block|{
name|curr_size
operator|=
name|GET_TYPECODE_SIZE
argument_list|(
name|curr
operator|->
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_size
operator|>
name|prev_size
condition|)
return|return
literal|0
return|;
name|prev_size
operator|=
name|curr_size
expr_stmt|;
block|}
else|else
for|for
control|(
name|prev_size
operator|=
name|curr_size
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|prev
control|)
block|{
name|curr_size
operator|=
name|GET_TYPECODE_SIZE
argument_list|(
name|curr
operator|->
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_size
operator|<
name|prev_size
condition|)
return|return
literal|0
return|;
name|prev_size
operator|=
name|curr_size
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Exhaustively search all reasonable conversions to find one to    convert the given types.  */
end_comment

begin_function
specifier|static
name|struct
name|conversion_recipe
name|deduce_conversion
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|enum
name|typecode
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
struct|struct
name|rl
block|{
name|struct
name|conversion_list
modifier|*
name|list
decl_stmt|;
name|struct
name|rl
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|prev
struct|,
name|curr
struct|,
modifier|*
name|good
struct|,
modifier|*
name|temp
struct|;
name|struct
name|conversion_list
modifier|*
name|conv
decl_stmt|,
modifier|*
name|best
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cost
decl_stmt|,
name|bestcost
decl_stmt|;
name|struct
name|conversion_recipe
name|result
decl_stmt|;
name|struct
name|obstack
name|recipe_obstack
decl_stmt|;
name|obstack_init
argument_list|(
operator|&
name|recipe_obstack
argument_list|)
expr_stmt|;
name|curr
operator|.
name|next
operator|=
operator|(
expr|struct
name|rl
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|recipe_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|.
name|next
operator|->
name|list
operator|=
operator|(
expr|struct
name|conversion_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|recipe_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|conversion_list
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|.
name|next
operator|->
name|list
operator|->
name|opcode
operator|=
operator|-
literal|1
expr_stmt|;
name|curr
operator|.
name|next
operator|->
name|list
operator|->
name|to
operator|=
name|from
expr_stmt|;
name|curr
operator|.
name|next
operator|->
name|list
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
name|curr
operator|.
name|next
operator|->
name|list
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|curr
operator|.
name|next
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|good
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|curr
operator|.
name|next
condition|)
block|{
comment|/* Remove successful conversions from further consideration.  */
for|for
control|(
name|prev
operator|=
operator|&
name|curr
init|;
name|prev
condition|;
name|prev
operator|=
name|prev
operator|->
name|next
control|)
if|if
condition|(
name|prev
operator|->
name|next
operator|&&
name|prev
operator|->
name|next
operator|->
name|list
operator|->
name|to
operator|==
name|to
condition|)
block|{
name|temp
operator|=
name|prev
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|->
name|next
operator|=
name|good
expr_stmt|;
name|good
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Go through each of the pending conversion chains, trying 	 all possible candidate conversions on them.  */
for|for
control|(
name|prev
operator|=
name|curr
operator|.
name|next
operator|,
name|curr
operator|.
name|next
operator|=
literal|0
init|;
name|prev
condition|;
name|prev
operator|=
name|prev
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CONVERSIONS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|conversion_info
index|[
name|i
index|]
operator|.
name|from
operator|==
name|prev
operator|->
name|list
operator|->
name|to
operator|&&
name|conversion_reasonable_p
argument_list|(
operator|&
name|conversion_info
index|[
name|i
index|]
argument_list|,
name|prev
operator|->
name|list
argument_list|)
condition|)
block|{
name|temp
operator|=
operator|(
expr|struct
name|rl
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|recipe_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|list
operator|=
operator|(
expr|struct
name|conversion_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|recipe_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|conversion_list
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|list
operator|->
name|opcode
operator|=
name|conversion_info
index|[
name|i
index|]
operator|.
name|opcode
expr_stmt|;
name|temp
operator|->
name|list
operator|->
name|to
operator|=
name|conversion_info
index|[
name|i
index|]
operator|.
name|to
expr_stmt|;
name|temp
operator|->
name|list
operator|->
name|cost
operator|=
name|conversion_info
index|[
name|i
index|]
operator|.
name|cost
expr_stmt|;
name|temp
operator|->
name|list
operator|->
name|prev
operator|=
name|prev
operator|->
name|list
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|curr
operator|.
name|next
expr_stmt|;
name|curr
operator|.
name|next
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|bestcost
operator|=
name|BIG_ARBITRARY_NUMBER
expr_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|good
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
for|for
control|(
name|conv
operator|=
name|temp
operator|->
name|list
operator|,
name|cost
operator|=
literal|0
init|;
name|conv
condition|;
name|conv
operator|=
name|conv
operator|->
name|prev
control|)
name|cost
operator|+=
name|conv
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|bestcost
condition|)
block|{
name|bestcost
operator|=
name|cost
expr_stmt|;
name|best
operator|=
name|temp
operator|->
name|list
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|best
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|conv
operator|=
name|best
init|;
name|conv
condition|;
name|conv
operator|=
name|conv
operator|->
name|prev
control|)
if|if
condition|(
name|conv
operator|->
name|opcode
operator|!=
operator|-
literal|1
condition|)
operator|++
name|i
expr_stmt|;
name|result
operator|.
name|opcodes
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|result
operator|.
name|nopcodes
operator|=
name|i
expr_stmt|;
for|for
control|(
name|conv
operator|=
name|best
init|;
name|conv
condition|;
name|conv
operator|=
name|conv
operator|->
name|prev
control|)
if|if
condition|(
name|conv
operator|->
name|opcode
operator|!=
operator|-
literal|1
condition|)
name|result
operator|.
name|opcodes
index|[
operator|--
name|i
index|]
operator|=
name|conv
operator|->
name|opcode
expr_stmt|;
name|result
operator|.
name|cost
operator|=
name|bestcost
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|recipe_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DEDUCE_CONVERSION
parameter_list|(
name|FROM
parameter_list|,
name|TO
parameter_list|)
define|\
value|(conversion_recipe[(int) FROM][(int) TO].opcodes ? 0		\    : (conversion_recipe[(int) FROM][(int) TO]			\        = deduce_conversion (FROM, TO), 0))
end_define

begin_comment
comment|/* Emit a conversion between the given scalar types.  */
end_comment

begin_function
name|void
name|emit_typecode_conversion
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|enum
name|typecode
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|DEDUCE_CONVERSION
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conversion_recipe
index|[
operator|(
name|int
operator|)
name|from
index|]
index|[
operator|(
name|int
operator|)
name|to
index|]
operator|.
name|nopcodes
condition|;
operator|++
name|i
control|)
name|bc_emit_instruction
argument_list|(
name|conversion_recipe
index|[
operator|(
name|int
operator|)
name|from
index|]
index|[
operator|(
name|int
operator|)
name|to
index|]
operator|.
name|opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize mode_to_code_map[] */
end_comment

begin_function
name|void
name|bc_init_mode_to_code_map
parameter_list|()
block|{
name|int
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
literal|0
init|;
name|mode
operator|<
name|MAX_MACHINE_MODE
operator|+
literal|1
condition|;
name|mode
operator|++
control|)
block|{
name|signed_mode_to_code_map
index|[
name|mode
index|]
operator|=
name|unsigned_mode_to_code_map
index|[
name|mode
index|]
operator|=
name|LAST_AND_UNUSED_TYPECODE
expr_stmt|;
block|}
define|#
directive|define
name|DEF_MODEMAP
parameter_list|(
name|SYM
parameter_list|,
name|CODE
parameter_list|,
name|UCODE
parameter_list|,
name|CONST
parameter_list|,
name|LOAD
parameter_list|,
name|STORE
parameter_list|)
define|\
value|{ signed_mode_to_code_map[(int) SYM] = CODE; \     unsigned_mode_to_code_map[(int) SYM] = UCODE; }
include|#
directive|include
file|"modemap.def"
undef|#
directive|undef
name|DEF_MODEMAP
comment|/* Initialize opcode maps for const, load, and store */
name|bc_init_mode_to_opcode_maps
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a machine mode return the preferred typecode.  */
end_comment

begin_function
name|enum
name|typecode
name|preferred_typecode
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|typecode
name|code
init|=
operator|(
name|unsignedp
condition|?
name|unsigned_mode_to_code_map
else|:
name|signed_mode_to_code_map
operator|)
index|[
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|mode
argument_list|,
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LAST_AND_UNUSED_TYPECODE
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Expand a conversion between the given types.  */
end_comment

begin_function
name|void
name|bc_expand_conversion
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|tree
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|enum
name|typecode
name|fcode
decl_stmt|,
name|tcode
decl_stmt|;
name|fcode
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|tcode
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|emit_typecode_conversion
argument_list|(
name|fcode
argument_list|,
name|tcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a conversion of the given type to a truth value.  */
end_comment

begin_function
name|void
name|bc_expand_truth_conversion
parameter_list|(
name|from
parameter_list|)
name|tree
name|from
decl_stmt|;
block|{
name|enum
name|typecode
name|fcode
decl_stmt|;
name|fcode
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|emit_typecode_conversion
argument_list|(
name|fcode
argument_list|,
name|Tcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an appropriate binary operation.  */
end_comment

begin_function
name|void
name|bc_expand_binary_operation
parameter_list|(
name|optab
parameter_list|,
name|resulttype
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|struct
name|binary_operator
name|optab
index|[]
decl_stmt|;
name|tree
name|resulttype
decl_stmt|,
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|besti
decl_stmt|,
name|cost
decl_stmt|,
name|bestcost
decl_stmt|;
name|enum
name|typecode
name|resultcode
decl_stmt|,
name|arg0code
decl_stmt|,
name|arg1code
decl_stmt|;
name|resultcode
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|resulttype
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|resulttype
argument_list|)
argument_list|)
expr_stmt|;
name|arg0code
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|resulttype
argument_list|)
argument_list|)
expr_stmt|;
name|arg1code
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|resulttype
argument_list|)
argument_list|)
expr_stmt|;
name|besti
operator|=
operator|-
literal|1
expr_stmt|;
name|bestcost
operator|=
name|BIG_ARBITRARY_NUMBER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|optab
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|cost
operator|=
literal|0
expr_stmt|;
name|DEDUCE_CONVERSION
argument_list|(
name|arg0code
argument_list|,
name|optab
index|[
name|i
index|]
operator|.
name|arg0
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|conversion_recipe
index|[
operator|(
name|int
operator|)
name|arg0code
index|]
index|[
operator|(
name|int
operator|)
name|optab
index|[
name|i
index|]
operator|.
name|arg0
index|]
operator|.
name|cost
expr_stmt|;
name|DEDUCE_CONVERSION
argument_list|(
name|arg1code
argument_list|,
name|optab
index|[
name|i
index|]
operator|.
name|arg1
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|conversion_recipe
index|[
operator|(
name|int
operator|)
name|arg1code
index|]
index|[
operator|(
name|int
operator|)
name|optab
index|[
name|i
index|]
operator|.
name|arg1
index|]
operator|.
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|bestcost
condition|)
block|{
name|besti
operator|=
name|i
expr_stmt|;
name|bestcost
operator|=
name|cost
expr_stmt|;
block|}
block|}
if|if
condition|(
name|besti
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_typecode_conversion
argument_list|(
name|arg1code
argument_list|,
name|optab
index|[
name|besti
index|]
operator|.
name|arg1
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_typecode_conversion
argument_list|(
name|arg0code
argument_list|,
name|optab
index|[
name|besti
index|]
operator|.
name|arg0
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|optab
index|[
name|besti
index|]
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|emit_typecode_conversion
argument_list|(
name|optab
index|[
name|besti
index|]
operator|.
name|result
argument_list|,
name|resultcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an appropriate unary operation.  */
end_comment

begin_function
name|void
name|bc_expand_unary_operation
parameter_list|(
name|optab
parameter_list|,
name|resulttype
parameter_list|,
name|arg0
parameter_list|)
name|struct
name|unary_operator
name|optab
index|[]
decl_stmt|;
name|tree
name|resulttype
decl_stmt|,
name|arg0
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|besti
decl_stmt|,
name|cost
decl_stmt|,
name|bestcost
decl_stmt|;
name|enum
name|typecode
name|resultcode
decl_stmt|,
name|arg0code
decl_stmt|;
name|resultcode
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|resulttype
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|resulttype
argument_list|)
argument_list|)
expr_stmt|;
name|arg0code
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|besti
operator|=
operator|-
literal|1
expr_stmt|;
name|bestcost
operator|=
name|BIG_ARBITRARY_NUMBER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|optab
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|DEDUCE_CONVERSION
argument_list|(
name|arg0code
argument_list|,
name|optab
index|[
name|i
index|]
operator|.
name|arg0
argument_list|)
expr_stmt|;
name|cost
operator|=
name|conversion_recipe
index|[
operator|(
name|int
operator|)
name|arg0code
index|]
index|[
operator|(
name|int
operator|)
name|optab
index|[
name|i
index|]
operator|.
name|arg0
index|]
operator|.
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|bestcost
condition|)
block|{
name|besti
operator|=
name|i
expr_stmt|;
name|bestcost
operator|=
name|cost
expr_stmt|;
block|}
block|}
if|if
condition|(
name|besti
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_typecode_conversion
argument_list|(
name|arg0code
argument_list|,
name|optab
index|[
name|besti
index|]
operator|.
name|arg0
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|optab
index|[
name|besti
index|]
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|emit_typecode_conversion
argument_list|(
name|optab
index|[
name|besti
index|]
operator|.
name|result
argument_list|,
name|resultcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an appropriate increment.  */
end_comment

begin_function
name|void
name|bc_expand_increment
parameter_list|(
name|optab
parameter_list|,
name|type
parameter_list|)
name|struct
name|increment_operator
name|optab
index|[]
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|typecode
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
name|code
operator|=
name|preferred_typecode
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|optab
index|[
name|i
index|]
operator|.
name|opcode
operator|>=
literal|0
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|code
operator|==
name|optab
index|[
name|i
index|]
operator|.
name|arg
condition|)
block|{
name|bc_emit_instruction
argument_list|(
name|optab
index|[
name|i
index|]
operator|.
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

