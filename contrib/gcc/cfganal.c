begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph analysis code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains various simple utilities to analyze the CFG.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Store the data structures necessary for depth-first search.  */
end_comment

begin_struct
struct|struct
name|depth_first_search_dsS
block|{
comment|/* stack for backtracking during the algorithm */
name|basic_block
modifier|*
name|stack
decl_stmt|;
comment|/* number of edges in the stack.  That is, positions 0, ..., sp-1      have edges.  */
name|unsigned
name|int
name|sp
decl_stmt|;
comment|/* record of basic blocks already seen by depth-first search */
name|sbitmap
name|visited_blocks
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|depth_first_search_dsS
modifier|*
name|depth_first_search_ds
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|flow_dfs_compute_reverse_init
name|PARAMS
argument_list|(
operator|(
name|depth_first_search_ds
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flow_dfs_compute_reverse_add_bb
name|PARAMS
argument_list|(
operator|(
name|depth_first_search_ds
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|flow_dfs_compute_reverse_execute
name|PARAMS
argument_list|(
operator|(
name|depth_first_search_ds
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flow_dfs_compute_reverse_finish
name|PARAMS
argument_list|(
operator|(
name|depth_first_search_ds
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_fake_successors
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|need_fake_edge_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return true if the block has no effect and only forwards control flow to    its single destination.  */
end_comment

begin_function
name|bool
name|forwarder_block_p
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|bb
operator|==
name|ENTRY_BLOCK_PTR
operator|||
operator|!
name|bb
operator|->
name|succ
operator|||
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
return|return
name|false
return|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|!=
name|bb
operator|->
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|!
name|active_insn_p
argument_list|(
name|insn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if we can reach target from src by falling through.  */
end_comment

begin_function
name|bool
name|can_fallthru
parameter_list|(
name|src
parameter_list|,
name|target
parameter_list|)
name|basic_block
name|src
decl_stmt|,
name|target
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|src
operator|->
name|end
decl_stmt|;
name|rtx
name|insn2
init|=
name|target
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|index
operator|+
literal|1
operator|==
name|target
operator|->
name|index
operator|&&
operator|!
name|active_insn_p
argument_list|(
name|insn2
argument_list|)
condition|)
name|insn2
operator|=
name|next_active_insn
argument_list|(
name|insn2
argument_list|)
expr_stmt|;
comment|/* ??? Later we may add code to move jump tables offline.  */
return|return
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|==
name|insn2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark the back edges in DFS traversal.    Return non-zero if a loop (natural or otherwise) is present.    Inspired by Depth_First_Search_PP described in:       Advanced Compiler Design and Implementation      Steven Muchnick      Morgan Kaufmann, 1997     and heavily borrowed from flow_depth_first_order_compute.  */
end_comment

begin_function
name|bool
name|mark_dfs_back_edges
parameter_list|()
block|{
name|edge
modifier|*
name|stack
decl_stmt|;
name|int
modifier|*
name|pre
decl_stmt|;
name|int
modifier|*
name|post
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|prenum
init|=
literal|1
decl_stmt|;
name|int
name|postnum
init|=
literal|1
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
comment|/* Allocate the preorder and postorder number arrays.  */
name|pre
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|post
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_DFS_BACK
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Mark that we have visited the destination.  */
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|pre
index|[
name|dest
operator|->
name|index
index|]
operator|=
name|prenum
operator|++
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|succ
condition|)
block|{
comment|/* Since the DEST node has been visited for the first 		 time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|dest
operator|->
name|succ
expr_stmt|;
block|}
else|else
name|post
index|[
name|dest
operator|->
name|index
index|]
operator|=
name|postnum
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|pre
index|[
name|src
operator|->
name|index
index|]
operator|>=
name|pre
index|[
name|dest
operator|->
name|index
index|]
operator|&&
name|post
index|[
name|dest
operator|->
name|index
index|]
operator|==
literal|0
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_DFS_BACK
operator|,
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|succ_next
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|post
index|[
name|src
operator|->
name|index
index|]
operator|=
name|postnum
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|succ_next
condition|)
name|stack
index|[
name|sp
operator|-
literal|1
index|]
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|post
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Return true if we need to add fake edge to exit.    Helper function for the flow_call_edges_add.  */
end_comment

begin_function
specifier|static
name|bool
name|need_fake_edge_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_ALWAYS_RETURN
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|asm_noperands
argument_list|(
name|insn
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add fake edges to the function exit for any non constant and non noreturn    calls, volatile inline assembly in the bitmap of blocks specified by    BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks    that were split.     The goal is to expose cases in which entering a basic block does not imply    that all subsequent instructions must be executed.  */
end_comment

begin_function
name|int
name|flow_call_edges_add
parameter_list|(
name|blocks
parameter_list|)
name|sbitmap
name|blocks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|blocks_split
init|=
literal|0
decl_stmt|;
name|int
name|bb_num
init|=
literal|0
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|bool
name|check_last_block
init|=
name|false
decl_stmt|;
comment|/* Map bb indices into basic block pointers since split_block      will renumber the basic blocks.  */
name|bbs
operator|=
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bbs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blocks
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|bbs
index|[
name|bb_num
operator|++
index|]
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|check_last_block
operator|=
name|true
expr_stmt|;
block|}
else|else
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 				 bbs[bb_num++] = BASIC_BLOCK (i); 				 if (i == n_basic_blocks -
literal|1
argument|) 				   check_last_block = true; 			       }
argument_list|)
empty_stmt|;
comment|/* In the last basic block, before epilogue generation, there will be      a fallthru edge to EXIT.  Special care is required if the last insn      of the last basic block is a call because make_edge folds duplicate      edges, which would result in the fallthru edge also being marked      fake, which would result in the fallthru edge being removed by      remove_fake_edges, which would result in an invalid CFG.       Moreover, we can't elide the outgoing fake edge, since the block      profiler needs to take this into account in order to solve the minimal      spanning tree in the case that the call doesn't return.       Handle this by adding a dummy instruction in a new last basic block.  */
if|if
condition|(
name|check_last_block
operator|&&
name|need_fake_edge_p
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
operator|->
name|end
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
break|break;
name|insert_insn_on_edge
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|commit_edge_insertions
argument_list|()
expr_stmt|;
block|}
comment|/* Now add fake edges to the function exit for any non constant      calls since there is no way that we can determine if they will      return or not...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bb_num
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|bbs
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
condition|;
name|insn
operator|=
name|prev_insn
control|)
block|{
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fake_edge_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* The above condition should be enough to verify that there is 		 no edge to the exit block in CFG already.  Calling make_edge 		 in such case would make us to mark that edge as fake and 		 remove it later.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Note that the following may create a new basic block 		 and renumber the existing basic blocks.  */
name|e
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|blocks_split
operator|++
expr_stmt|;
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|head
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|blocks_split
condition|)
name|verify_flow_info
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|blocks_split
return|;
block|}
end_function

begin_comment
comment|/* Find unreachable blocks.  An unreachable block will have 0 in    the reachable bit in block->flags.  A non-zero value indicates the    block is reachable.  */
end_comment

begin_function
name|void
name|find_unreachable_blocks
parameter_list|()
block|{
name|edge
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
modifier|*
name|tos
decl_stmt|,
modifier|*
name|worklist
decl_stmt|;
name|n
operator|=
name|n_basic_blocks
expr_stmt|;
name|tos
operator|=
name|worklist
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* Clear all the reachability flags.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|BB_REACHABLE
expr_stmt|;
comment|/* Add our starting points to the worklist.  Almost always there will      be only one.  It isn't inconceivable that we might one day directly      support Fortran alternate entry points.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Mark the block reachable.  */
name|e
operator|->
name|dest
operator|->
name|flags
operator||=
name|BB_REACHABLE
expr_stmt|;
block|}
comment|/* Iterate: find everything reachable from what we've already seen.  */
while|while
condition|(
name|tos
operator|!=
name|worklist
condition|)
block|{
name|basic_block
name|b
init|=
operator|*
operator|--
name|tos
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|dest
operator|->
name|flags
operator|&
name|BB_REACHABLE
operator|)
condition|)
block|{
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|e
operator|->
name|dest
operator|->
name|flags
operator||=
name|BB_REACHABLE
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to access an edge list with a vector representation.    Enough data is kept such that given an index number, the    pred and succ that edge represents can be determined, or    given a pred and a succ, its index number can be returned.    This allows algorithms which consume a lot of memory to    represent the normally full matrix of edge (pred,succ) with a    single indexed vector,  edge (EDGE_INDEX (pred, succ)), with no    wasted space in the client code due to sparse flow graphs.  */
end_comment

begin_comment
comment|/* This functions initializes the edge list. Basically the entire    flowgraph is processed, and all edges are assigned a number,    and the data structure is filled in.  */
end_comment

begin_function
name|struct
name|edge_list
modifier|*
name|create_edge_list
parameter_list|()
block|{
name|struct
name|edge_list
modifier|*
name|elist
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|num_edges
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|block_count
decl_stmt|;
name|block_count
operator|=
name|n_basic_blocks
operator|+
literal|2
expr_stmt|;
comment|/* Include the entry and exit blocks.  */
name|num_edges
operator|=
literal|0
expr_stmt|;
comment|/* Determine the number of edges in the flow graph by counting successor      edges on each basic block.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|num_edges
operator|++
expr_stmt|;
block|}
comment|/* Don't forget successors of the entry block.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|num_edges
operator|++
expr_stmt|;
name|elist
operator|=
operator|(
expr|struct
name|edge_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_list
argument_list|)
argument_list|)
expr_stmt|;
name|elist
operator|->
name|num_blocks
operator|=
name|block_count
expr_stmt|;
name|elist
operator|->
name|num_edges
operator|=
name|num_edges
expr_stmt|;
name|elist
operator|->
name|index_to_edge
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
operator|*
name|num_edges
argument_list|)
expr_stmt|;
name|num_edges
operator|=
literal|0
expr_stmt|;
comment|/* Follow successors of the entry block, and register these edges.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|elist
operator|->
name|index_to_edge
index|[
name|num_edges
operator|++
index|]
operator|=
name|e
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Follow all successors of blocks, and register these edges.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|elist
operator|->
name|index_to_edge
index|[
name|num_edges
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
return|return
name|elist
return|;
block|}
end_function

begin_comment
comment|/* This function free's memory associated with an edge list.  */
end_comment

begin_function
name|void
name|free_edge_list
parameter_list|(
name|elist
parameter_list|)
name|struct
name|edge_list
modifier|*
name|elist
decl_stmt|;
block|{
if|if
condition|(
name|elist
condition|)
block|{
name|free
argument_list|(
name|elist
operator|->
name|index_to_edge
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function provides debug output showing an edge list.  */
end_comment

begin_function
name|void
name|print_edge_list
parameter_list|(
name|f
parameter_list|,
name|elist
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|elist
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Compressed edge list, %d BBs + entry& exit, and %d edges\n"
argument_list|,
name|elist
operator|->
name|num_blocks
operator|-
literal|2
argument_list|,
name|elist
operator|->
name|num_edges
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|elist
operator|->
name|num_edges
condition|;
name|x
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %-4d - edge("
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"entry,"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d,"
argument_list|,
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"exit)\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d)\n"
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function provides an internal consistency check of an edge list,    verifying that all edges are present, and that there are no    extra edges.  */
end_comment

begin_function
name|void
name|verify_edge_list
parameter_list|(
name|f
parameter_list|,
name|elist
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|elist
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|pred
decl_stmt|,
name|succ
decl_stmt|,
name|index
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|pred
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
name|succ
operator|=
name|e
operator|->
name|dest
operator|->
name|index
expr_stmt|;
name|index
operator|=
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|EDGE_INDEX_NO_EDGE
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* No index for edge from %d to %d\n"
argument_list|,
name|pred
argument_list|,
name|succ
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
operator|!=
name|pred
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* Pred for index %d should be %d not %d\n"
argument_list|,
name|index
argument_list|,
name|pred
argument_list|,
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
operator|!=
name|succ
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* Succ for index %d should be %d not %d\n"
argument_list|,
name|index
argument_list|,
name|succ
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|pred
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
name|succ
operator|=
name|e
operator|->
name|dest
operator|->
name|index
expr_stmt|;
name|index
operator|=
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|EDGE_INDEX_NO_EDGE
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* No index for edge from %d to %d\n"
argument_list|,
name|pred
argument_list|,
name|succ
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
operator|!=
name|pred
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* Pred for index %d should be %d not %d\n"
argument_list|,
name|index
argument_list|,
name|pred
argument_list|,
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
operator|!=
name|succ
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* Succ for index %d should be %d not %d\n"
argument_list|,
name|index
argument_list|,
name|succ
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* We've verified that all the edges are in the list, no lets make sure      there are no spurious edges in the list.  */
for|for
control|(
name|pred
operator|=
literal|0
init|;
name|pred
operator|<
name|n_basic_blocks
condition|;
name|pred
operator|++
control|)
for|for
control|(
name|succ
operator|=
literal|0
init|;
name|succ
operator|<
name|n_basic_blocks
condition|;
name|succ
operator|++
control|)
block|{
name|basic_block
name|p
init|=
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
decl_stmt|;
name|basic_block
name|s
init|=
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
decl_stmt|;
name|int
name|found_edge
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|p
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|s
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|e
operator|=
name|s
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|p
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
argument_list|)
operator|==
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (%d, %d) appears to not have an index\n"
argument_list|,
name|pred
argument_list|,
name|succ
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
argument_list|)
operator|!=
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (%d, %d) has index %d, but there is no edge\n"
argument_list|,
name|pred
argument_list|,
name|succ
argument_list|,
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|succ
operator|=
literal|0
init|;
name|succ
operator|<
name|n_basic_blocks
condition|;
name|succ
operator|++
control|)
block|{
name|basic_block
name|p
init|=
name|ENTRY_BLOCK_PTR
decl_stmt|;
name|basic_block
name|s
init|=
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
decl_stmt|;
name|int
name|found_edge
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|p
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|s
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|e
operator|=
name|s
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|p
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
argument_list|)
operator|==
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (entry, %d) appears to not have an index\n"
argument_list|,
name|succ
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
argument_list|)
operator|!=
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (entry, %d) has index %d, but no edge exists\n"
argument_list|,
name|succ
argument_list|,
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|succ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pred
operator|=
literal|0
init|;
name|pred
operator|<
name|n_basic_blocks
condition|;
name|pred
operator|++
control|)
block|{
name|basic_block
name|p
init|=
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
decl_stmt|;
name|basic_block
name|s
init|=
name|EXIT_BLOCK_PTR
decl_stmt|;
name|int
name|found_edge
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|p
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|s
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|e
operator|=
name|s
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|p
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
operator|==
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (%d, exit) appears to not have an index\n"
argument_list|,
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
operator|!=
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (%d, exit) has index %d, but no edge exists\n"
argument_list|,
name|pred
argument_list|,
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|pred
argument_list|)
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will determine what, if any, edge there is between    a specified predecessor and successor.  */
end_comment

begin_function
name|int
name|find_edge_index
parameter_list|(
name|edge_list
parameter_list|,
name|pred
parameter_list|,
name|succ
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|basic_block
name|pred
decl_stmt|,
name|succ
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
operator|==
name|pred
operator|&&
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
operator|==
name|succ
condition|)
return|return
name|x
return|;
return|return
operator|(
name|EDGE_INDEX_NO_EDGE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Dump the list of basic blocks in the bitmap NODES.  */
end_comment

begin_function
name|void
name|flow_nodes_print
parameter_list|(
name|str
parameter_list|,
name|nodes
parameter_list|,
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|sbitmap
name|nodes
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s { "
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|node
argument_list|,
argument|{fprintf (file,
literal|"%d "
argument|, node);}
argument_list|)
empty_stmt|;
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the list of edges in the array EDGE_LIST.  */
end_comment

begin_function
name|void
name|flow_edge_list_print
parameter_list|(
name|str
parameter_list|,
name|edge_list
parameter_list|,
name|num_edges
parameter_list|,
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|edge
modifier|*
name|edge_list
decl_stmt|;
name|int
name|num_edges
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|edge_list
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s { "
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d->%d "
argument_list|,
name|edge_list
index|[
name|i
index|]
operator|->
name|src
operator|->
name|index
argument_list|,
name|edge_list
index|[
name|i
index|]
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine will remove any fake successor edges for a basic block.    When the edge is removed, it is also removed from whatever predecessor    list it is in.  */
end_comment

begin_function
specifier|static
name|void
name|remove_fake_successors
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
control|)
block|{
name|edge
name|tmp
init|=
name|e
decl_stmt|;
name|e
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|==
name|EDGE_FAKE
condition|)
name|remove_edge
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will remove all fake edges from the flow graph.  If    we remove all fake successors, it will automatically remove all    fake predecessors.  */
end_comment

begin_function
name|void
name|remove_fake_edges
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
name|remove_fake_successors
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We've handled all successors except the entry block's.  */
name|remove_fake_successors
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will add a fake edge between any block which has no    successors, and the exit block. Some data flow equations require these    edges to exist.  */
end_comment

begin_function
name|void
name|add_noreturn_fake_exit_edges
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|BASIC_BLOCK
argument_list|(
name|x
argument_list|)
operator|->
name|succ
operator|==
name|NULL
condition|)
name|make_single_succ_edge
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|x
argument_list|)
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function adds a fake edge between any infinite loops to the    exit block.  Some optimizations require a path from each node to    the exit node.     See also Morgan, Figure 3.10, pp. 82-83.     The current implementation is ugly, not attempting to minimize the    number of inserted fake edges.  To reduce the number of fake edges    to insert, add fake edges from _innermost_ loops containing only    nodes not reachable from the exit block.  */
end_comment

begin_function
name|void
name|connect_infinite_loops_to_exit
parameter_list|()
block|{
name|basic_block
name|unvisited_block
decl_stmt|;
name|struct
name|depth_first_search_dsS
name|dfs_ds
decl_stmt|;
comment|/* Perform depth-first search in the reverse graph to find nodes      reachable from the exit block.  */
name|flow_dfs_compute_reverse_init
argument_list|(
operator|&
name|dfs_ds
argument_list|)
expr_stmt|;
name|flow_dfs_compute_reverse_add_bb
argument_list|(
operator|&
name|dfs_ds
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Repeatedly add fake edges, updating the unreachable nodes.  */
while|while
condition|(
literal|1
condition|)
block|{
name|unvisited_block
operator|=
name|flow_dfs_compute_reverse_execute
argument_list|(
operator|&
name|dfs_ds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unvisited_block
condition|)
break|break;
name|make_edge
argument_list|(
name|unvisited_block
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
name|flow_dfs_compute_reverse_add_bb
argument_list|(
operator|&
name|dfs_ds
argument_list|,
name|unvisited_block
argument_list|)
expr_stmt|;
block|}
name|flow_dfs_compute_reverse_finish
argument_list|(
operator|&
name|dfs_ds
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute reverse top sort order */
end_comment

begin_function
name|void
name|flow_reverse_top_sort_order_compute
parameter_list|(
name|rts_order
parameter_list|)
name|int
modifier|*
name|rts_order
decl_stmt|;
block|{
name|edge
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|postnum
init|=
literal|0
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Mark that we have visited the destination.  */
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|succ
condition|)
comment|/* Since the DEST node has been visited for the first 	       time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|dest
operator|->
name|succ
expr_stmt|;
else|else
name|rts_order
index|[
name|postnum
operator|++
index|]
operator|=
name|dest
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|succ_next
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|rts_order
index|[
name|postnum
operator|++
index|]
operator|=
name|src
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|succ_next
condition|)
name|stack
index|[
name|sp
operator|-
literal|1
index|]
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the depth first search order and store in the array   DFS_ORDER if non-zero, marking the nodes visited in VISITED.  If   RC_ORDER is non-zero, return the reverse completion number for each   node.  Returns the number of nodes visited.  A depth first search   tries to get as far away from the starting point as quickly as   possible.  */
end_comment

begin_function
name|int
name|flow_depth_first_order_compute
parameter_list|(
name|dfs_order
parameter_list|,
name|rc_order
parameter_list|)
name|int
modifier|*
name|dfs_order
decl_stmt|;
name|int
modifier|*
name|rc_order
decl_stmt|;
block|{
name|edge
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|dfsnum
init|=
literal|0
decl_stmt|;
name|int
name|rcnum
init|=
name|n_basic_blocks
operator|-
literal|1
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Mark that we have visited the destination.  */
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfs_order
condition|)
name|dfs_order
index|[
name|dfsnum
index|]
operator|=
name|dest
operator|->
name|index
expr_stmt|;
name|dfsnum
operator|++
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|succ
condition|)
comment|/* Since the DEST node has been visited for the first 	       time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|dest
operator|->
name|succ
expr_stmt|;
elseif|else
if|if
condition|(
name|rc_order
condition|)
comment|/* There are no successors for the DEST node so assign 	       its reverse completion number.  */
name|rc_order
index|[
name|rcnum
operator|--
index|]
operator|=
name|dest
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|succ_next
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|rc_order
condition|)
comment|/* There are no more successors for the SRC node 	       so assign its reverse completion number.  */
name|rc_order
index|[
name|rcnum
operator|--
index|]
operator|=
name|src
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|succ_next
condition|)
name|stack
index|[
name|sp
operator|-
literal|1
index|]
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* The number of nodes visited should not be greater than      n_basic_blocks.  */
if|if
condition|(
name|dfsnum
operator|>
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* There are some nodes left in the CFG that are unreachable.  */
if|if
condition|(
name|dfsnum
operator|<
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|dfsnum
return|;
block|}
end_function

begin_struct
struct|struct
name|dfst_node
block|{
name|unsigned
name|nnodes
decl_stmt|;
name|struct
name|dfst_node
modifier|*
modifier|*
name|node
decl_stmt|;
name|struct
name|dfst_node
modifier|*
name|up
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compute a preorder transversal ordering such that a sub-tree which    is the source of a cross edge appears before the sub-tree which is    the destination of the cross edge.  This allows for easy detection    of all the entry blocks for a loop.     The ordering is compute by:       1) Generating a depth first spanning tree.       2) Walking the resulting tree from right to left.  */
end_comment

begin_function
name|void
name|flow_preorder_transversal_compute
parameter_list|(
name|pot_order
parameter_list|)
name|int
modifier|*
name|pot_order
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|edge
modifier|*
name|stack
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|max_successors
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
name|struct
name|dfst_node
modifier|*
name|node
decl_stmt|;
name|struct
name|dfst_node
modifier|*
name|dfst
decl_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the tree.  */
name|dfst
operator|=
operator|(
expr|struct
name|dfst_node
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dfst_node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|max_successors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|max_successors
operator|++
expr_stmt|;
name|dfst
index|[
name|i
index|]
operator|.
name|node
operator|=
operator|(
name|max_successors
condition|?
operator|(
expr|struct
name|dfst_node
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_successors
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dfst_node
operator|*
argument_list|)
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
block|}
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Mark that we have visited the destination.  */
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Add the destination to the preorder tree.  */
if|if
condition|(
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|dfst
index|[
name|src
operator|->
name|index
index|]
operator|.
name|node
index|[
name|dfst
index|[
name|src
operator|->
name|index
index|]
operator|.
name|nnodes
operator|++
index|]
operator|=
operator|&
name|dfst
index|[
name|dest
operator|->
name|index
index|]
expr_stmt|;
name|dfst
index|[
name|dest
operator|->
name|index
index|]
operator|.
name|up
operator|=
operator|&
name|dfst
index|[
name|src
operator|->
name|index
index|]
expr_stmt|;
block|}
if|if
condition|(
name|dest
operator|->
name|succ
condition|)
comment|/* Since the DEST node has been visited for the first 	       time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|dest
operator|->
name|succ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|succ_next
condition|)
name|stack
index|[
name|sp
operator|-
literal|1
index|]
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Record the preorder transversal order by      walking the tree from right to left.  */
name|i
operator|=
literal|0
expr_stmt|;
name|node
operator|=
operator|&
name|dfst
index|[
literal|0
index|]
expr_stmt|;
name|pot_order
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|nnodes
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|node
index|[
operator|--
name|node
operator|->
name|nnodes
index|]
expr_stmt|;
name|pot_order
index|[
name|i
operator|++
index|]
operator|=
name|node
operator|-
name|dfst
expr_stmt|;
block|}
else|else
name|node
operator|=
name|node
operator|->
name|up
expr_stmt|;
block|}
comment|/* Free the tree.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dfst
index|[
name|i
index|]
operator|.
name|node
condition|)
name|free
argument_list|(
name|dfst
index|[
name|i
index|]
operator|.
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dfst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the depth first search order on the _reverse_ graph and    store in the array DFS_ORDER, marking the nodes visited in VISITED.    Returns the number of nodes visited.     The computation is split into three pieces:     flow_dfs_compute_reverse_init () creates the necessary data    structures.     flow_dfs_compute_reverse_add_bb () adds a basic block to the data    structures.  The block will start the search.     flow_dfs_compute_reverse_execute () continues (or starts) the    search using the block on the top of the stack, stopping when the    stack is empty.     flow_dfs_compute_reverse_finish () destroys the necessary data    structures.     Thus, the user will probably call ..._init(), call ..._add_bb() to    add a beginning basic block to the stack, call ..._execute(),    possibly add another bb to the stack and again call ..._execute(),    ..., and finally call _finish().  */
end_comment

begin_comment
comment|/* Initialize the data structures used for depth-first search on the    reverse graph.  If INITIALIZE_STACK is nonzero, the exit block is    added to the basic block stack.  DATA is the current depth-first    search context.  If INITIALIZE_STACK is non-zero, there is an    element on the stack.  */
end_comment

begin_function
specifier|static
name|void
name|flow_dfs_compute_reverse_init
parameter_list|(
name|data
parameter_list|)
name|depth_first_search_ds
name|data
decl_stmt|;
block|{
comment|/* Allocate stack for back-tracking up CFG.  */
name|data
operator|->
name|stack
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|data
operator|->
name|visited_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Add the specified basic block to the top of the dfs data    structures.  When the search continues, it will start at the    block.  */
end_comment

begin_function
specifier|static
name|void
name|flow_dfs_compute_reverse_add_bb
parameter_list|(
name|data
parameter_list|,
name|bb
parameter_list|)
name|depth_first_search_ds
name|data
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|data
operator|->
name|stack
index|[
name|data
operator|->
name|sp
operator|++
index|]
operator|=
name|bb
expr_stmt|;
name|SET_BIT
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|,
name|bb
operator|->
name|index
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Continue the depth-first search through the reverse graph starting with the    block at the stack's top and ending when the stack is empty.  Visited nodes    are marked.  Returns an unvisited basic block, or NULL if there is none    available.  */
end_comment

begin_function
specifier|static
name|basic_block
name|flow_dfs_compute_reverse_execute
parameter_list|(
name|data
parameter_list|)
name|depth_first_search_ds
name|data
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|sp
operator|>
literal|0
condition|)
block|{
name|bb
operator|=
name|data
operator|->
name|stack
index|[
operator|--
name|data
operator|->
name|sp
index|]
expr_stmt|;
comment|/* Perform depth-first search on adjacent vertices.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
argument_list|)
condition|)
name|flow_dfs_compute_reverse_add_bb
argument_list|(
name|data
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Determine if there are unvisited basic blocks.  */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|BASIC_BLOCK
argument_list|(
name|i
operator|+
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Destroy the data structures needed for depth-first search on the    reverse graph.  */
end_comment

begin_function
specifier|static
name|void
name|flow_dfs_compute_reverse_finish
parameter_list|(
name|data
parameter_list|)
name|depth_first_search_ds
name|data
decl_stmt|;
block|{
name|free
argument_list|(
name|data
operator|->
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

