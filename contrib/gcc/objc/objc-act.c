begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implement classes and message passing for Objective C.    Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000,    2001, 2002, 2003 Free Software Foundation, Inc.    Contributed by Steve Naroff.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Purpose: This module implements the Objective-C 4.0 language.     compatibility issues (with the Stepstone translator):     - does not recognize the following 3.3 constructs.      @requires, @classes, @messages, = (...)    - methods with variable arguments must conform to ANSI standard.    - tagged structure definitions that appear in BOTH the interface      and implementation are not allowed.    - public/private: all instance variables are public within the      context of the implementation...I consider this to be a bug in      the translator.    - statically allocated objects are not supported. the user will      receive an error if this service is requested.     code generation `options':     */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"objc-act.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_define
define|#
directive|define
name|OBJC_VOID_AT_END
value|build_tree_list (NULL_TREE, void_type_node)
end_define

begin_comment
comment|/* This is the default way of generating a method name.  */
end_comment

begin_comment
comment|/* I am not sure it is really correct.    Perhaps there's a danger that it will make name conflicts    if method names contain underscores. -- rms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_GEN_METHOD_LABEL
end_ifndef

begin_define
define|#
directive|define
name|OBJC_GEN_METHOD_LABEL
parameter_list|(
name|BUF
parameter_list|,
name|IS_INST
parameter_list|,
name|CLASS_NAME
parameter_list|,
name|CAT_NAME
parameter_list|,
name|SEL_NAME
parameter_list|,
name|NUM
parameter_list|)
define|\
value|do {					    \     char *temp;				    \     sprintf ((BUF), "_%s_%s_%s_%s",	    \ 	     ((IS_INST) ? "i" : "c"),	    \ 	     (CLASS_NAME),		    \ 	     ((CAT_NAME)? (CAT_NAME) : ""), \ 	     (SEL_NAME));		    \     for (temp = (BUF); *temp; temp++)	    \       if (*temp == ':') *temp = '_';	    \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These need specifying.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_FORWARDING_STACK_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|OBJC_FORWARDING_STACK_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_FORWARDING_MIN_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|OBJC_FORWARDING_MIN_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Set up for use of obstacks.  */
end_comment

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* This obstack is used to accumulate the encoding of a data type.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|util_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the beginning of obstack contents, so we can free    the whole contents.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|util_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The version identifies which language generation and runtime    the module (file) was compiled for, and is recorded in the    module descriptor.  */
end_comment

begin_define
define|#
directive|define
name|OBJC_VERSION
value|(flag_next_runtime ? 5 : 8)
end_define

begin_define
define|#
directive|define
name|PROTOCOL_VERSION
value|2
end_define

begin_comment
comment|/* (Decide if these can ever be validly changed.) */
end_comment

begin_define
define|#
directive|define
name|OBJC_ENCODE_INLINE_DEFS
value|0
end_define

begin_define
define|#
directive|define
name|OBJC_ENCODE_DONT_INLINE_DEFS
value|1
end_define

begin_comment
comment|/*** Private Interface (procedures) ***/
end_comment

begin_comment
comment|/* Used by compile_file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_objc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_objc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Code generation.  */
end_comment

begin_function_decl
specifier|static
name|void
name|synth_module_prologue
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_build_constructor
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|build_module_descriptor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|init_module_descriptor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_objc_method_call
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_strings
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_proto_encoding
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_selector_translation_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_add_static_instance
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_objc_exception_stuff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_declare_variable
parameter_list|(
name|enum
name|rid
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_enter_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_exit_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|objc_build_try_enter_fragment
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|objc_build_try_exit_fragment
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|objc_build_extract_fragment
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_build_extract_expr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ivar_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_method_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_private_template
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_class_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_selector_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_category_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_method_in_hash_lists
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_super_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_category_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_protocol_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|synth_forward_declarations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ivar_list_length
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_class_ivars
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_ivar_lists
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_dispatch_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_shared_structures
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|generate_protocol_list
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_forward_declaration_to_string_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_protocol_reference
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_keyword_selector
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|synth_id_with_class_suffix
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_static_references
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_methods_accessible
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_aggregate_within
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|objc_demangle
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|objc_expand_function_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hash tables to manage the global pool of method prototypes.  */
end_comment

begin_decl_stmt
name|hash
modifier|*
name|nst_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hash
modifier|*
name|cls_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|size_t
name|hash_func
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_enter
parameter_list|(
name|hash
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hash
name|hash_lookup
parameter_list|(
name|hash
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_add_attr
parameter_list|(
name|hash
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_method
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_method_static
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_method_to_hash_list
parameter_list|(
name|hash
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|add_class
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_category
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|tree
name|lookup_category
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|string_section
block|{
name|class_names
block|,
comment|/* class, category, protocol, module names */
name|meth_var_names
block|,
comment|/* method and variable names */
name|meth_var_types
comment|/* method and variable type descriptors */
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|tree
name|add_objc_string
parameter_list|(
name|tree
parameter_list|,
name|enum
name|string_section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_objc_string_decl
parameter_list|(
name|tree
parameter_list|,
name|enum
name|string_section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_objc_string_decl
parameter_list|(
name|enum
name|string_section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_selector_reference_decl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Protocol additions.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|add_protocol
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_protocol
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_protocol_recursively
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_and_install_protocols
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Type encoding.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_type_qualifiers
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_pointer
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_array
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_aggregate
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_next_bitfield
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_gnu_bitfield
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_type
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_field_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|really_start_method
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_method_with_proto
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|objc_types_are_equivalent
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_proto_with_proto
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_arg_type_list
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_expr_last
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|synth_self_and_ucmd_args
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utilities for debugging and error diagnostics.  */
end_comment

begin_function_decl
specifier|static
name|void
name|warn_with_method
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error_with_ivar
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_method_decl
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_declaration
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_declaration_1
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_declarator
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_complex_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adorn_decl
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_interface
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Everything else.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|define_decl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_method_in_protocol_list
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_protocol_in_reflist
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|create_builtin_decl
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_string_decl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_string_class_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_objc_symtab_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|init_def_list
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|init_objc_symtab
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_metadata_decl
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|forward_declare_categories
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_objc_symtab_decl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_selector
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_typed_selector_reference
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_selector_reference
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_class_reference_decl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_class_reference
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_protocol_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_descriptor_table_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_method_prototype_list_template
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_method_prototype_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_method_parm_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|objc_encoded_type_size
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|encode_method_prototype
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|generate_descriptor_table
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_method_descriptors
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_protocol_references
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_protocols
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_ivars
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ivar_list_template
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_method_list_template
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ivar_list_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|generate_ivars_list
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_dispatch_table_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|generate_dispatch_table
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_shared_structure_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_category
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_objc_type_qualifier
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|adjust_type_for_id_default
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|check_duplicates
parameter_list|(
name|hash
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|receiver_is_class_object
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_methods
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|conforms_to_protocol
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_protocol
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_protocols
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_declspecs
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_classref_translation_entry
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_class_ref
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|generate_struct_by_value_array
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mark_referenced_methods
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_objc_image_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*** Private Interface (data) ***/
end_comment

begin_comment
comment|/* Reserved tag definitions.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_ID
value|"id"
end_define

begin_define
define|#
directive|define
name|TAG_OBJECT
value|"objc_object"
end_define

begin_define
define|#
directive|define
name|TAG_CLASS
value|"objc_class"
end_define

begin_define
define|#
directive|define
name|TAG_SUPER
value|"objc_super"
end_define

begin_define
define|#
directive|define
name|TAG_SELECTOR
value|"objc_selector"
end_define

begin_define
define|#
directive|define
name|UTAG_CLASS
value|"_objc_class"
end_define

begin_define
define|#
directive|define
name|UTAG_IVAR
value|"_objc_ivar"
end_define

begin_define
define|#
directive|define
name|UTAG_IVAR_LIST
value|"_objc_ivar_list"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD
value|"_objc_method"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_LIST
value|"_objc_method_list"
end_define

begin_define
define|#
directive|define
name|UTAG_CATEGORY
value|"_objc_category"
end_define

begin_define
define|#
directive|define
name|UTAG_MODULE
value|"_objc_module"
end_define

begin_define
define|#
directive|define
name|UTAG_SYMTAB
value|"_objc_symtab"
end_define

begin_define
define|#
directive|define
name|UTAG_SUPER
value|"_objc_super"
end_define

begin_define
define|#
directive|define
name|UTAG_SELECTOR
value|"_objc_selector"
end_define

begin_define
define|#
directive|define
name|UTAG_PROTOCOL
value|"_objc_protocol"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_PROTOTYPE
value|"_objc_method_prototype"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_PROTOTYPE_LIST
value|"_objc__method_prototype_list"
end_define

begin_comment
comment|/* Note that the string object global name is only needed for the    NeXT runtime.  */
end_comment

begin_define
define|#
directive|define
name|STRING_OBJECT_GLOBAL_FORMAT
value|"_%sClassReference"
end_define

begin_define
define|#
directive|define
name|PROTOCOL_OBJECT_CLASS_NAME
value|"Protocol"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_GETCLASS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_GETMETACLASS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSEND
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSENDSUPER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The NeXT Objective-C messenger may have two extra entry points, for use    when returning a structure. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSEND_STRET
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSENDSUPER_STRET
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_EXECCLASS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_constant_string_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Runtime metadata flags.  */
end_comment

begin_define
define|#
directive|define
name|CLS_FACTORY
value|0x0001L
end_define

begin_define
define|#
directive|define
name|CLS_META
value|0x0002L
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_STATIC
value|0x00000001
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_FINAL
value|0x00000002
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_PUBLIC
value|0x00000004
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_PRIVATE
value|0x00000008
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_PROTECTED
value|0x00000010
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_NATIVE
value|0x00000020
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_SYNCHRONIZED
value|0x00000040
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_ABSTRACT
value|0x00000080
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_VOLATILE
value|0x00000100
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_TRANSIENT
value|0x00000200
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_NONE_SPECIFIED
value|0x80000000
end_define

begin_define
define|#
directive|define
name|TAG_MSGSEND_NONNIL
value|"objc_msgSendNonNil"
end_define

begin_define
define|#
directive|define
name|TAG_MSGSEND_NONNIL_STRET
value|"objc_msgSendNonNil_stret"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONEXTRACT
value|"objc_exception_extract"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONTRYENTER
value|"objc_exception_try_enter"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONTRYEXIT
value|"objc_exception_try_exit"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONMATCH
value|"objc_exception_match"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONTHROW
value|"objc_exception_throw"
end_define

begin_define
define|#
directive|define
name|TAG_SYNCENTER
value|"objc_sync_enter"
end_define

begin_define
define|#
directive|define
name|TAG_SYNCEXIT
value|"objc_sync_exit"
end_define

begin_define
define|#
directive|define
name|TAG_SETJMP
value|"_setjmp"
end_define

begin_define
define|#
directive|define
name|TAG_RETURN_STRUCT
value|"objc_return_struct"
end_define

begin_define
define|#
directive|define
name|UTAG_EXCDATA
value|"_objc_exception_data"
end_define

begin_define
define|#
directive|define
name|UTAG_EXCDATA_VAR
value|"_stackExceptionData"
end_define

begin_define
define|#
directive|define
name|UTAG_CAUGHTEXC_VAR
value|"_caughtException"
end_define

begin_define
define|#
directive|define
name|UTAG_RETHROWEXC_VAR
value|"_rethrowException"
end_define

begin_define
define|#
directive|define
name|UTAG_EVALONCE_VAR
value|"_eval_once"
end_define

begin_struct
struct|struct
name|val_stack
block|{
name|long
name|val
decl_stmt|;
name|struct
name|val_stack
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|val_stack
modifier|*
name|catch_count_stack
decl_stmt|,
modifier|*
name|exc_binding_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* useful for debugging */
end_comment

begin_decl_stmt
specifier|static
name|int
name|if_nesting_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blk_nesting_count
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|val_stack_push
parameter_list|(
name|struct
name|val_stack
modifier|*
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|val_stack_pop
parameter_list|(
name|struct
name|val_stack
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The OCTI_... enumeration itself is in objc/objc-act.h.  */
end_comment

begin_decl_stmt
name|tree
name|objc_global_trees
index|[
name|OCTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|handle_impent
parameter_list|(
name|struct
name|imp_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|imp_entry
modifier|*
name|imp_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|imp_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@implementation' */
end_comment

begin_decl_stmt
name|int
name|cat_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@category' */
end_comment

begin_comment
comment|/* Use to generate method labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|method_slot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for error diagnostics */
end_comment

begin_comment
comment|/* Data imported from tree.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|debug_info_type
name|write_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data imported from toplev.c.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|flag_typed_selectors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|gen_declaration_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tells "encode_pointer/encode_aggregate" whether we are generating    type descriptors for instance variables (as opposed to methods).    Type descriptors for instance variables contain more information    than methods (for static typing and embedded structures).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|generating_instance_variables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some platforms pass small structures through registers versus    through an invisible pointer.  Determine at what size structure is    the transition point between the two possibilities.  */
end_comment

begin_function
specifier|static
name|void
name|generate_struct_by_value_array
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|aggregate_in_mem
index|[
literal|32
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Presumably no platform passes 32 byte structures in a register.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buffer
index|[
literal|5
index|]
decl_stmt|;
comment|/* Create an unnamed struct that has `i' character components */
name|type
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"c1"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|char_type_node
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"c%d"
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|char_type_node
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
name|finish_struct
argument_list|(
name|type
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|aggregate_in_mem
index|[
name|i
index|]
operator|=
name|aggregate_value_p
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aggregate_in_mem
index|[
name|i
index|]
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We found some structures that are returned in registers instead of memory      so output the necessary data.  */
if|if
condition|(
name|found
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|aggregate_in_mem
index|[
name|i
index|]
condition|)
break|break;
name|printf
argument_list|(
literal|"#define OBJC_MAX_STRUCT_BY_VALUE %d\n\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The first member of the structure is always 0 because we don't handle 	 structures with 0 members */
name|printf
argument_list|(
literal|"static int struct_forward_array[] = {\n  0"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|", %d"
argument_list|,
name|aggregate_in_mem
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|objc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|c_objc_common_init
argument_list|()
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Force the line number back to 0; check_newline will have      raised it to 1, which will make the builtin functions appear      not to be built in.  */
name|input_line
operator|=
literal|0
expr_stmt|;
comment|/* If gen_declaration desired, open the output file.  */
if|if
condition|(
name|flag_gen_declaration
condition|)
block|{
specifier|register
name|char
modifier|*
specifier|const
name|dumpname
init|=
name|concat
argument_list|(
name|dump_base_name
argument_list|,
literal|".decl"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gen_declaration_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_declaration_file
operator|==
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't open %s: %m"
argument_list|,
name|dumpname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|TAG_GETCLASS
operator|=
literal|"objc_getClass"
expr_stmt|;
name|TAG_GETMETACLASS
operator|=
literal|"objc_getMetaClass"
expr_stmt|;
name|TAG_MSGSEND
operator|=
literal|"objc_msgSend"
expr_stmt|;
name|TAG_MSGSENDSUPER
operator|=
literal|"objc_msgSendSuper"
expr_stmt|;
name|TAG_MSGSEND_STRET
operator|=
literal|"objc_msgSend_stret"
expr_stmt|;
name|TAG_MSGSENDSUPER_STRET
operator|=
literal|"objc_msgSendSuper_stret"
expr_stmt|;
name|TAG_EXECCLASS
operator|=
literal|"__objc_execClass"
expr_stmt|;
name|default_constant_string_class_name
operator|=
literal|"NSConstantString"
expr_stmt|;
block|}
else|else
block|{
name|TAG_GETCLASS
operator|=
literal|"objc_get_class"
expr_stmt|;
name|TAG_GETMETACLASS
operator|=
literal|"objc_get_meta_class"
expr_stmt|;
name|TAG_MSGSEND
operator|=
literal|"objc_msg_lookup"
expr_stmt|;
name|TAG_MSGSENDSUPER
operator|=
literal|"objc_msg_lookup_super"
expr_stmt|;
comment|/* GNU runtime does not provide special functions to support 	 structure-returning methods.  */
name|TAG_EXECCLASS
operator|=
literal|"__objc_exec_class"
expr_stmt|;
name|default_constant_string_class_name
operator|=
literal|"NXConstantString"
expr_stmt|;
name|flag_typed_selectors
operator|=
literal|1
expr_stmt|;
block|}
name|objc_ellipsis_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|init_objc
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_struct_values
condition|)
name|generate_struct_by_value_array
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|finish_file
parameter_list|(
name|void
parameter_list|)
block|{
name|mark_referenced_methods
argument_list|()
expr_stmt|;
name|c_objc_common_finish_file
argument_list|()
expr_stmt|;
comment|/* Finalize Objective-C runtime data.  No need to generate tables      and code if only checking syntax.  */
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
name|finish_objc
argument_list|()
expr_stmt|;
if|if
condition|(
name|gen_declaration_file
condition|)
name|fclose
argument_list|(
name|gen_declaration_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|define_decl
parameter_list|(
name|tree
name|declarator
parameter_list|,
name|tree
name|declspecs
parameter_list|)
block|{
name|tree
name|decl
init|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_method_in_protocol_list
parameter_list|(
name|tree
name|rproto_list
parameter_list|,
name|tree
name|sel_name
parameter_list|,
name|int
name|class_meth
parameter_list|)
block|{
name|tree
name|rproto
decl_stmt|,
name|p
decl_stmt|;
name|tree
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
operator|(
name|fnd
operator|=
name|lookup_method
argument_list|(
name|class_meth
condition|?
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
else|:
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|sel_name
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|fnd
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|,
name|sel_name
argument_list|,
name|class_meth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
empty_stmt|;
comment|/* An identifier...if we could not find a protocol.  */
block|}
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_protocol_in_reflist
parameter_list|(
name|tree
name|rproto_list
parameter_list|,
name|tree
name|lproto
parameter_list|)
block|{
name|tree
name|rproto
decl_stmt|,
name|p
decl_stmt|;
comment|/* Make sure the protocol is supported by the object on the rhs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lproto
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|tree
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
name|lproto
operator|==
name|p
condition|)
name|fnd
operator|=
name|lproto
expr_stmt|;
elseif|else
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|fnd
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|,
name|lproto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
block|}
else|else
block|{
empty_stmt|;
comment|/* An identifier...if we could not find a protocol.  */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if LHS and RHS are compatible types for assignment or    various other operations.  Return 0 if they are incompatible, and    return -1 if we choose to not decide (because the types are really    just C types, not ObjC specific ones).  When the operation is    REFLEXIVE (typically comparisons), check for compatibility in    either direction; when it's not (typically assignments), don't.     This function is called in two cases: when both lhs and rhs are    pointers to records (in which case we check protocols too), and    when both lhs and rhs are records (in which case we check class    inheritance only).     Warnings about classes/protocols not implementing a protocol are    emitted here (multiple of those warnings might be emitted for a    single line!); generic warnings about incompatible assignments and    lacks of casts in comparisons are/must be emitted by the caller if    we return 0. */
end_comment

begin_function
name|int
name|objc_comptypes
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|int
name|reflexive
parameter_list|)
block|{
comment|/* New clause for protocols.  */
comment|/* Here we manage the case of a POINTER_TYPE = POINTER_TYPE.  We only      manage the ObjC ones, and leave the rest to the C code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|lhs_is_proto
init|=
name|IS_PROTOCOL_QUALIFIED_ID
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|int
name|rhs_is_proto
init|=
name|IS_PROTOCOL_QUALIFIED_ID
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|lhs_is_proto
condition|)
block|{
name|tree
name|lproto
decl_stmt|,
name|lproto_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|rproto
decl_stmt|,
name|rproto_list
decl_stmt|;
name|tree
name|p
decl_stmt|;
comment|/*<Protocol> =<Protocol>  */
if|if
condition|(
name|rhs_is_proto
condition|)
block|{
name|rproto_list
operator|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reflexive
condition|)
block|{
comment|/* An assignment between objects of type 'id<Protocol>'; make sure the protocol on the lhs is 		     supported by the object on the rhs.  */
for|for
control|(
name|lproto
operator|=
name|lproto_list
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rproto
condition|)
name|warning
argument_list|(
literal|"object does not conform to the `%s' protocol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Obscure case - a comparison between two objects 		     of type 'id<Protocol>'.  Check that either the 		     protocol on the lhs is supported by the object on 		     the rhs, or viceversa.  */
comment|/* Check if the protocol on the lhs is supported by the 		     object on the rhs.  */
for|for
control|(
name|lproto
operator|=
name|lproto_list
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rproto
condition|)
block|{
comment|/* Check failed - check if the protocol on the rhs 			     is supported by the object on the lhs.  */
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
expr_stmt|;
name|lproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|lproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lproto
condition|)
block|{
comment|/* This check failed too: incompatible  */
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
comment|/*<Protocol> =<class> *  */
elseif|else
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|rname
init|=
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rinter
decl_stmt|;
comment|/* Make sure the protocol is supported by the object on 		 the rhs.  */
for|for
control|(
name|lproto
operator|=
name|lproto_list
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
expr_stmt|;
name|rproto
operator|=
literal|0
expr_stmt|;
name|rinter
operator|=
name|lookup_interface
argument_list|(
name|rname
argument_list|)
expr_stmt|;
while|while
condition|(
name|rinter
operator|&&
operator|!
name|rproto
condition|)
block|{
name|tree
name|cat
decl_stmt|;
name|rproto_list
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|rinter
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If the underlying ObjC class does not have 			 the protocol we're looking for, check for "one-off" 			 protocols (e.g., `NSObject<MyProt> *foo;') attached 			 to the rhs.  */
if|if
condition|(
operator|!
name|rproto
condition|)
block|{
name|rproto_list
operator|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Check for protocols adopted by categories.  */
name|cat
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|rinter
argument_list|)
expr_stmt|;
while|while
condition|(
name|cat
operator|&&
operator|!
name|rproto
condition|)
block|{
name|rproto_list
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|cat
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|cat
argument_list|)
expr_stmt|;
block|}
name|rinter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|rinter
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rproto
condition|)
name|warning
argument_list|(
literal|"class `%s' does not implement the `%s' protocol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/*<Protocol> = id */
elseif|else
if|if
condition|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|objc_object_id
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/*<Protocol> = Class */
elseif|else
if|if
condition|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|objc_class_id
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*<Protocol> = ?? : let comptypes decide.  */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rhs_is_proto
condition|)
block|{
comment|/*<class> * =<Protocol> */
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|reflexive
condition|)
block|{
name|tree
name|rname
init|=
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rinter
decl_stmt|;
name|tree
name|rproto
decl_stmt|,
name|rproto_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
comment|/* Make sure the protocol is supported by the object on 		     the lhs.  */
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
decl_stmt|;
name|tree
name|lproto
init|=
literal|0
decl_stmt|;
name|rinter
operator|=
name|lookup_interface
argument_list|(
name|rname
argument_list|)
expr_stmt|;
while|while
condition|(
name|rinter
operator|&&
operator|!
name|lproto
condition|)
block|{
name|tree
name|cat
decl_stmt|;
name|tree
name|lproto_list
init|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|rinter
argument_list|)
decl_stmt|;
name|lproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|lproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If the underlying ObjC class does not 			     have the protocol we're looking for, 			     check for "one-off" protocols (e.g., 			     `NSObject<MyProt> *foo;') attached to the 			     lhs.  */
if|if
condition|(
operator|!
name|lproto
condition|)
block|{
name|lproto_list
operator|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|lproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|lproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Check for protocols adopted by categories.  */
name|cat
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|rinter
argument_list|)
expr_stmt|;
while|while
condition|(
name|cat
operator|&&
operator|!
name|lproto
condition|)
block|{
name|lproto_list
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|lproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|lproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|cat
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|cat
argument_list|)
expr_stmt|;
block|}
name|rinter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|rinter
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lproto
condition|)
name|warning
argument_list|(
literal|"class `%s' does not implement the `%s' protocol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* id =<Protocol> */
elseif|else
if|if
condition|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|objc_object_id
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Class =<Protocol> */
elseif|else
if|if
condition|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|objc_class_id
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* ??? =<Protocol> : let comptypes decide */
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* Attention: we shouldn't defer to comptypes here.  One bad 	     side effect would be that we might loose the REFLEXIVE 	     information. 	  */
name|lhs
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
comment|/* Nothing to do with ObjC - let immediately comptypes take 	 responsibility for checking.  */
return|return
operator|-
literal|1
return|;
block|}
comment|/* `id' = `<class> *' `<class> *' = `id': always allow it.      Please note that      'Object *o = [[Object alloc] init]; falls      in the case<class> * = `id'.   */
if|if
condition|(
operator|(
name|OBJC_TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|TYPED_OBJECT
argument_list|(
name|rhs
argument_list|)
operator|)
operator|||
operator|(
name|OBJC_TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|TYPED_OBJECT
argument_list|(
name|lhs
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* `id' = `Class', `Class' = `id' */
elseif|else
if|if
condition|(
operator|(
name|OBJC_TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|OBJC_TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_class_id
operator|)
operator|||
operator|(
name|OBJC_TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_class_id
operator|&&
name|OBJC_TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_object_id
operator|)
condition|)
return|return
literal|1
return|;
comment|/* `<class> *' = `<class> *' */
elseif|else
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|lhs
argument_list|)
operator|&&
name|TYPED_OBJECT
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|tree
name|lname
init|=
name|OBJC_TYPE_NAME
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|rname
init|=
name|OBJC_TYPE_NAME
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|tree
name|inter
decl_stmt|;
if|if
condition|(
name|lname
operator|==
name|rname
condition|)
return|return
literal|1
return|;
comment|/* If the left hand side is a super class of the right hand side, 	 allow it.  */
for|for
control|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|rname
argument_list|)
init|;
name|inter
condition|;
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
control|)
if|if
condition|(
name|lname
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Allow the reverse when reflexive.  */
if|if
condition|(
name|reflexive
condition|)
for|for
control|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|lname
argument_list|)
init|;
name|inter
condition|;
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
control|)
if|if
condition|(
name|rname
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
comment|/* Not an ObjC type - let comptypes do the check.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called from finish_decl.  */
end_comment

begin_function
name|void
name|objc_check_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|type
operator|=
name|is_class_name
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"statically allocated instance of Objective-C class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement static typing.  At this point, we know we have an interface.  */
end_comment

begin_function
name|tree
name|get_static_reference
parameter_list|(
name|tree
name|interface
parameter_list|,
name|tree
name|protocols
parameter_list|)
block|{
name|tree
name|type
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|interface
argument_list|)
decl_stmt|;
if|if
condition|(
name|protocols
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Look up protocols and install in lang specific list.  Note 	 that the protocol list can have a different lifetime than T!  */
name|SET_TYPE_PROTOCOL_LIST
argument_list|(
name|t
argument_list|,
name|lookup_and_install_protocols
argument_list|(
name|protocols
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This forces a new pointer type to be created later 	 (in build_pointer_type)...so that the new template 	 we just created will actually be used...what a hack!  */
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|type
operator|=
name|t
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|get_object_reference
parameter_list|(
name|tree
name|protocols
parameter_list|)
block|{
name|tree
name|type_decl
init|=
name|lookup_name
argument_list|(
name|objc_id_id
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|type_decl
operator|&&
name|TREE_CODE
argument_list|(
name|type_decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|id_type
condition|)
name|warning
argument_list|(
literal|"unexpected type for `id' (%s)"
argument_list|,
name|gen_declaration
argument_list|(
name|type
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"undefined type `id', please import<objc/objc.h>"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* This clause creates a new pointer type that is qualified with      the protocol specification...this info is used later to do more      elaborate type checking.  */
if|if
condition|(
name|protocols
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Look up protocols...and install in lang specific list */
name|SET_TYPE_PROTOCOL_LIST
argument_list|(
name|t
argument_list|,
name|lookup_and_install_protocols
argument_list|(
name|protocols
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This forces a new pointer type to be created later 	 (in build_pointer_type)...so that the new template 	 we just created will actually be used...what a hack!  */
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|type
operator|=
name|t
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Check for circular dependencies in protocols.  The arguments are    PROTO, the protocol to check, and LIST, a list of protocol it    conforms to.  */
end_comment

begin_function
specifier|static
name|void
name|check_protocol_recursively
parameter_list|(
name|tree
name|proto
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|pp
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pp
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|pp
operator|=
name|lookup_protocol
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|proto
condition|)
name|fatal_error
argument_list|(
literal|"protocol `%s' has circular dependency"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|pp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
name|check_protocol_recursively
argument_list|(
name|proto
argument_list|,
name|PROTOCOL_LIST
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look up PROTOCOLS, and return a list of those that are found.    If none are found, return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_and_install_protocols
parameter_list|(
name|tree
name|protocols
parameter_list|)
block|{
name|tree
name|proto
decl_stmt|;
name|tree
name|return_value
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|proto
operator|=
name|protocols
init|;
name|proto
condition|;
name|proto
operator|=
name|TREE_CHAIN
argument_list|(
name|proto
argument_list|)
control|)
block|{
name|tree
name|ident
init|=
name|TREE_VALUE
argument_list|(
name|proto
argument_list|)
decl_stmt|;
name|tree
name|p
init|=
name|lookup_protocol
argument_list|(
name|ident
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
literal|"cannot find protocol declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|return_value
operator|=
name|chainon
argument_list|(
name|return_value
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* Create and push a decl for a built-in external variable or field NAME.    CODE says which.    TYPE is its data type.  */
end_comment

begin_function
specifier|static
name|tree
name|create_builtin_decl
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VAR_DECL
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Find the decl for the constant string class.  */
end_comment

begin_function
specifier|static
name|void
name|setup_string_decl
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|string_class_decl
condition|)
block|{
if|if
condition|(
operator|!
name|constant_string_global_id
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* %s in format will provide room for terminating null */
name|length
operator|=
name|strlen
argument_list|(
name|STRING_OBJECT_GLOBAL_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|constant_string_class_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|STRING_OBJECT_GLOBAL_FORMAT
argument_list|,
name|constant_string_class_name
argument_list|)
expr_stmt|;
name|constant_string_global_id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|string_class_decl
operator|=
name|lookup_name
argument_list|(
name|constant_string_global_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Purpose: "play" parser, creating/installing representations    of the declarations that are required by Objective-C.     Model:  	type_spec--------->sc_spec 	(tree_list)        (tree_list) 	    |                  | 	    |                  | 	identifier_node    identifier_node  */
end_comment

begin_function
specifier|static
name|void
name|synth_module_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|temp_type
decl_stmt|;
comment|/* Defined in `objc.h' */
name|objc_object_id
operator|=
name|get_identifier
argument_list|(
name|TAG_OBJECT
argument_list|)
expr_stmt|;
name|objc_object_reference
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_object_id
argument_list|)
expr_stmt|;
name|id_type
operator|=
name|build_pointer_type
argument_list|(
name|objc_object_reference
argument_list|)
expr_stmt|;
name|objc_id_id
operator|=
name|get_identifier
argument_list|(
name|TYPE_ID
argument_list|)
expr_stmt|;
name|objc_class_id
operator|=
name|get_identifier
argument_list|(
name|TAG_CLASS
argument_list|)
expr_stmt|;
name|objc_class_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_class_id
argument_list|)
argument_list|)
expr_stmt|;
name|temp_type
operator|=
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
expr_stmt|;
name|objc_declare_class
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|temp_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|temp_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Declare type of selector-objects that represent an operation name.  */
comment|/* `struct objc_selector *' */
name|selector_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Forward declare type, or else the prototype for msgSendSuper will      complain.  */
comment|/* `struct objc_super *' */
name|super_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SUPER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* id objc_msgSend (id, SEL, ...); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
name|umsg_decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|TAG_MSGSEND
argument_list|)
argument_list|,
name|temp_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|umsg_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|umsg_decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umsg_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* id objc_msgSendNonNil (id, SEL, ...); */
name|umsg_nonnil_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND_NONNIL
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* id objc_msgSendSuper (struct objc_super *, SEL, ...); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|super_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_super_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSENDSUPER
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The NeXT runtime defines the following additional entry points,      used for dispatching calls to methods returning structs:       #if defined(__cplusplus)        id objc_msgSend_stret(id self, SEL op, ...);        id objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...);      #else        void objc_msgSend_stret(void * stretAddr, id self, SEL op, ...);        void objc_msgSendSuper_stret(void * stretAddr, struct objc_super *super, 				    SEL op, ...);      #endif       struct objc_return_struct objc_msgSendNonNil_stret(id self, SEL op, ...);       These prototypes appear in<objc/objc-runtime.h>; however, they      CANNOT BE USED DIRECTLY.  In order to call one of the ..._stret      functions, the function must first be cast to a signature that      corresponds to the actual ObjC method being invoked.  This is      what is done by the build_objc_method_call() routine below.  */
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|tree
name|objc_return_struct_type
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_RETURN_STRUCT
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|stret_temp_type
init|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|umsg_stret_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND_STRET
argument_list|,
name|stret_temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|stret_temp_type
operator|=
name|build_function_type
argument_list|(
name|objc_return_struct_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_nonnil_stret_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND_NONNIL_STRET
argument_list|,
name|stret_temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|stret_temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|super_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_super_stret_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSENDSUPER_STRET
argument_list|,
name|stret_temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* id objc_getClass (const char *); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_get_class_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_GETCLASS
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* id objc_getMetaClass (const char *); */
name|objc_get_meta_class_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_GETMETACLASS
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|build_super_template
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
name|build_objc_exception_stuff
argument_list|()
expr_stmt|;
comment|/* static SEL _OBJC_SELECTOR_TABLE[]; */
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
if|if
condition|(
name|flag_typed_selectors
condition|)
block|{
comment|/* Suppress outputting debug symbols, because 	     dbxout_init hasn'r been called yet.  */
name|enum
name|debug_info_type
name|save_write_symbols
init|=
name|write_symbols
decl_stmt|;
specifier|const
name|struct
name|gcc_debug_hooks
modifier|*
specifier|const
name|save_hooks
init|=
name|debug_hooks
decl_stmt|;
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
name|build_selector_template
argument_list|()
expr_stmt|;
name|temp_type
operator|=
name|build_array_type
argument_list|(
name|objc_selector_template
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|save_write_symbols
expr_stmt|;
name|debug_hooks
operator|=
name|save_hooks
expr_stmt|;
block|}
else|else
name|temp_type
operator|=
name|build_array_type
argument_list|(
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|temp_type
argument_list|)
expr_stmt|;
name|UOBJC_SELECTOR_TABLE_decl
operator|=
name|create_builtin_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|temp_type
argument_list|,
literal|"_OBJC_SELECTOR_TABLE"
argument_list|)
expr_stmt|;
comment|/* Avoid warning when not sending messages.  */
name|TREE_USED
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|generate_forward_declaration_to_string_table
argument_list|()
expr_stmt|;
comment|/* Forward declare constant_string_id and constant_string_type.  */
if|if
condition|(
operator|!
name|constant_string_class_name
condition|)
name|constant_string_class_name
operator|=
name|default_constant_string_class_name
expr_stmt|;
name|constant_string_id
operator|=
name|get_identifier
argument_list|(
name|constant_string_class_name
argument_list|)
expr_stmt|;
name|objc_declare_class
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|constant_string_id
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pre-build the following entities - for speed/convenience.  */
name|self_id
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
name|ucmd_id
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJCPLUS
comment|/* The C++ front-end does not appear to grok __attribute__((__unused__)).  */
name|unused_list
operator|=
name|build_tree_list
argument_list|(
name|get_identifier
argument_list|(
literal|"__unused__"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Ensure that the ivar list for NSConstantString/NXConstantString    (or whatever was specified via `-fconstant-string-class')    contains fields at least as large as the following three, so that    the runtime can stomp on them with confidence:     struct STRING_OBJECT_CLASS_NAME    {      Object isa;      char *cString;      unsigned int length;    }; */
end_comment

begin_function
specifier|static
name|int
name|check_string_class_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
init|=
name|TYPE_FIELDS
argument_list|(
name|constant_string_type
argument_list|)
decl_stmt|;
define|#
directive|define
name|AT_LEAST_AS_LARGE_AS
parameter_list|(
name|F
parameter_list|,
name|T
parameter_list|)
define|\
value|(F&& TREE_CODE (F) == FIELD_DECL \&& (TREE_INT_CST_LOW (DECL_SIZE (F)) \>= TREE_INT_CST_LOW (TYPE_SIZE (T))))
if|if
condition|(
operator|!
name|AT_LEAST_AS_LARGE_AS
argument_list|(
name|field_decl
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AT_LEAST_AS_LARGE_AS
argument_list|(
name|field_decl
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
return|return
name|AT_LEAST_AS_LARGE_AS
argument_list|(
name|field_decl
argument_list|,
name|unsigned_type_node
argument_list|)
return|;
undef|#
directive|undef
name|AT_LEAST_AS_LARGE_AS
block|}
end_function

begin_comment
comment|/* Avoid calling `check_string_class_template ()' more than once.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|string_layout_checked
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Custom build_string which sets TREE_TYPE!  */
end_comment

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|fix_string_type
argument_list|(
name|build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of STRING_CST's, build a static instance of    NXConstantString which points at the concatenation of those    strings.  We place the string object in the __string_objects    section of the __OBJC segment.  The Objective-C runtime will    initialize the isa pointers of the string objects to point at the    NXConstantString class object.  */
end_comment

begin_function
name|tree
name|build_objc_string_object
parameter_list|(
name|tree
name|string
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|constructor
decl_stmt|,
name|constant_string_class
decl_stmt|;
name|int
name|length
decl_stmt|;
name|string
operator|=
name|fix_string_type
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|constant_string_class
operator|=
name|lookup_interface
argument_list|(
name|constant_string_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constant_string_class
operator|||
operator|!
operator|(
name|constant_string_type
operator|=
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|constant_string_class
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constant_string_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Call to 'combine_strings' has been moved above.  */
name|TREE_SET_CODE
argument_list|(
name|string
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|string_layout_checked
condition|)
block|{
comment|/* The NSConstantString/NXConstantString ivar layout is now 	 known.  */
if|if
condition|(
operator|!
name|check_string_class_template
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"interface `%s' does not have valid constant string layout"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constant_string_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|add_class_reference
argument_list|(
name|constant_string_id
argument_list|)
expr_stmt|;
block|}
comment|/*& ((NXConstantString) { NULL, string, length })  */
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* For the NeXT runtime, we can generate a literal reference 	 to the string class, don't need to run a constructor.  */
name|setup_string_decl
argument_list|()
expr_stmt|;
if|if
condition|(
name|string_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"cannot find reference tag for class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constant_string_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|copy_node
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_class_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|copy_node
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|length
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|objc_build_constructor
argument_list|(
name|constant_string_type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
name|constructor
operator|=
name|objc_add_static_instance
argument_list|(
name|constructor
argument_list|,
name|constant_string_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|constructor
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Declare a static instance of CLASS_DECL initialized by CONSTRUCTOR.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|num_static_inst
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|objc_add_static_instance
parameter_list|(
name|tree
name|constructor
parameter_list|,
name|tree
name|class_decl
parameter_list|)
block|{
name|tree
modifier|*
name|chain
decl_stmt|,
name|decl
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* Find the list of static instances for the CLASS_DECL.  Create one if      not found.  */
for|for
control|(
name|chain
operator|=
operator|&
name|objc_static_instances
init|;
operator|*
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|!=
name|class_decl
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|chain
condition|)
block|{
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_objc_string
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|class_decl
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_INSTANCE_%d"
argument_list|,
name|num_static_inst
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|class_decl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|constructor
expr_stmt|;
comment|/* We may be writing something else just now.      Postpone till end of input.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add the DECL to the head of this CLASS' list.  */
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Build a static constant CONSTRUCTOR    with type TYPE and elements ELTS.  */
end_comment

begin_function
specifier|static
name|tree
name|objc_build_constructor
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|elts
parameter_list|)
block|{
name|tree
name|constructor
decl_stmt|,
name|f
decl_stmt|,
name|e
decl_stmt|;
comment|/* ??? Most of the places that we build constructors, we don't fill in      the type of integers properly.  Convert them all en masse.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|f
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
for|for
control|(
name|e
operator|=
name|elts
init|;
name|e
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
operator|=
name|convert
argument_list|(
name|f
argument_list|,
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|elts
init|;
name|e
operator|&&
name|f
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
operator|,
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|constructor
operator|=
name|build_constructor
argument_list|(
name|type
argument_list|,
name|elts
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* zlaski 2001-Apr-02: mark this as a call to a constructor, as required by      build_unary_op (wasn't true in 2.7.2.1 days) */
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|constructor
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take care of defining and initializing _OBJC_SYMBOLS.  */
end_comment

begin_comment
comment|/* Predefine the following data type:     struct _objc_symtab    {      long sel_ref_cnt;      SEL *refs;      short cls_def_cnt;      short cat_def_cnt;      void *defs[cls_def_cnt + cat_def_cnt];    }; */
end_comment

begin_function
specifier|static
name|void
name|build_objc_symtab_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_symtab_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SYMTAB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long sel_ref_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|long_integer_type_node
argument_list|,
literal|"sel_ref_cnt"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* SEL *refs; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_pointer_type
argument_list|(
name|selector_type
argument_list|)
argument_list|,
literal|"refs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cls_def_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|short_integer_type_node
argument_list|,
literal|"cls_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cat_def_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|short_integer_type_node
argument_list|,
literal|"cat_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp_count
operator|||
name|cat_count
operator|||
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* void *defs[imp_count + cat_count (+ 1)]; */
comment|/* NB: The index is one less than the size of the array.  */
name|int
name|index
init|=
name|imp_count
operator|+
name|cat_count
operator|+
operator|(
name|flag_next_runtime
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"defs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
name|finish_struct
argument_list|(
name|objc_symtab_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the initial value for the `defs' field of _objc_symtab.    This is a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|tree
name|init_def_list
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|,
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
if|if
condition|(
name|imp_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cat_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* statics = { ..., _OBJC_STATIC_INSTANCES, ... }  */
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|static_instances_decl
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|static_instances_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct the initial value for all of _objc_symtab.  */
end_comment

begin_function
specifier|static
name|tree
name|init_objc_symtab
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|;
comment|/* sel_ref_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */
if|if
condition|(
name|flag_next_runtime
operator|||
operator|!
name|sel_ref_chain
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cls_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|imp_count
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cat_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|cat_count
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cls_def = { ..., {&Foo,&Bar, ...}, ... } */
if|if
condition|(
name|imp_count
operator|||
name|cat_count
operator|||
operator|!
name|flag_next_runtime
condition|)
block|{
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init_def_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate forward declarations for metadata such as   'OBJC_CLASS_...'.  */
end_comment

begin_function
specifier|static
name|tree
name|build_metadata_decl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|decl_specs
decl_stmt|;
comment|/* extern struct TYPE NAME_<name>; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|decl
operator|=
name|define_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Push forward-declarations of all the categories so that    init_def_list can use them in a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|void
name|forward_declare_categories
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|sav
init|=
name|objc_implementation_context
decl_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* Set an invisible arg to synth_id_with_class_suffix.  */
name|objc_implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
comment|/* extern struct objc_category _OBJC_CATEGORY_<name>; */
name|impent
operator|->
name|class_decl
operator|=
name|build_metadata_decl
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|,
name|objc_category_template
argument_list|)
expr_stmt|;
block|}
block|}
name|objc_implementation_context
operator|=
name|sav
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the declaration of _OBJC_SYMBOLS, with type `struct _objc_symtab'    and initialized appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|generate_objc_symtab_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|;
if|if
condition|(
operator|!
name|objc_category_template
condition|)
name|build_category_template
argument_list|()
expr_stmt|;
comment|/* forward declare categories */
if|if
condition|(
name|cat_count
condition|)
name|forward_declare_categories
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|objc_symtab_template
condition|)
name|build_objc_symtab_template
argument_list|()
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
name|UOBJC_SYMBOLS_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
literal|"_OBJC_SYMBOLS"
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_symtab_template
argument_list|,
name|sc_spec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|,
name|init_objc_symtab
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|init_module_descriptor
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|expr
decl_stmt|;
comment|/* version = { 1, ... } */
name|expr
operator|=
name|build_int_2
argument_list|(
name|OBJC_VERSION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* size = { ..., sizeof (struct objc_module), ... } */
name|expr
operator|=
name|size_in_bytes
argument_list|(
name|objc_module_template
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* name = { ..., "foo.m", ... } */
name|expr
operator|=
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* symtab = { ..., _OBJC_SYMBOLS, ... } */
if|if
condition|(
name|UOBJC_SYMBOLS_decl
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_SYMBOLS_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the data structures to describe Objective C classes defined.    If appropriate, compile and output a setup function to initialize them.    Return a symbol_ref to the function to call to initialize the Objective C    data structures for this file (and perhaps for other files also).     struct objc_module { ... } _OBJC_MODULE = { ... };   */
end_comment

begin_function
specifier|static
name|rtx
name|build_module_descriptor
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_module_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_MODULE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Long version; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"version"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* long  size; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char  *name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_symtab *symtab; */
name|decl_specs
operator|=
name|get_identifier
argument_list|(
name|UTAG_SYMTAB
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|decl_specs
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"symtab"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_module_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Create an instance of "objc_module".  */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_module_template
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|UOBJC_MODULES_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
literal|"_OBJC_MODULES"
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_decl
argument_list|(
name|UOBJC_MODULES_decl
argument_list|,
name|init_module_descriptor
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Mark the decl to avoid "defined but not used" warning.  */
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Generate a constructor call for the module descriptor.      This code was generated by reading the grammar rules      of c-parse.in;  Therefore, it may not be the most efficient      way of generating the requisite code.  */
if|if
condition|(
name|flag_next_runtime
condition|)
return|return
name|NULL_RTX
return|;
block|{
name|tree
name|parms
decl_stmt|,
name|execclass_decl
decl_stmt|,
name|decelerator
decl_stmt|,
name|void_list_node_1
decl_stmt|;
name|tree
name|init_function_name
decl_stmt|,
name|init_function_decl
decl_stmt|;
comment|/* Declare void __objc_execClass (void *); */
name|void_list_node_1
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|execclass_decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|TAG_EXECCLASS
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|execclass_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|execclass_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|execclass_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|execclass_decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|execclass_decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|execclass_decl
argument_list|)
expr_stmt|;
comment|/* void _GLOBAL_$I$<gnyf> () {objc_execClass (&L_OBJC_MODULES);}  */
name|init_function_name
operator|=
name|get_file_function_name
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|void_list_node_1
argument_list|,
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|init_function_name
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|init_function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|init_function_decl
argument_list|)
operator|=
operator|!
name|targetm
operator|.
name|have_ctors_dtors
expr_stmt|;
name|TREE_USED
argument_list|(
name|init_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't let this one be deferred.  */
name|DECL_INLINE
argument_list|(
name|init_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|init_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_function_cannot_inline
operator|=
literal|"static constructors and destructors cannot be inlined"
expr_stmt|;
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_MODULES_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|decelerator
operator|=
name|build_function_call
argument_list|(
name|execclass_decl
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|decelerator
argument_list|)
expr_stmt|;
name|finish_function
argument_list|()
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|init_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* extern const char _OBJC_STRINGS[]; */
end_comment

begin_function
specifier|static
name|void
name|generate_forward_declaration_to_string_table
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"_OBJC_STRINGS"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|UOBJC_STRINGS_decl
operator|=
name|define_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the DECL of the string IDENT in the SECTION.  */
end_comment

begin_function
specifier|static
name|tree
name|get_objc_string_decl
parameter_list|(
name|tree
name|ident
parameter_list|,
name|enum
name|string_section
name|section
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|chain
operator|=
name|class_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|chain
operator|=
name|meth_var_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|chain
operator|=
name|meth_var_types_chain
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
operator|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
operator|)
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Output references to all statically allocated objects.  Return the DECL    for the array built.  */
end_comment

begin_function
specifier|static
name|void
name|generate_static_references
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|,
name|ident
decl_stmt|,
name|decl_spec
decl_stmt|,
name|expr_decl
decl_stmt|,
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|class_name
decl_stmt|,
name|class
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|tree
name|cl_chain
decl_stmt|,
name|in_chain
decl_stmt|,
name|type
decl_stmt|;
name|int
name|num_inst
decl_stmt|,
name|num_class
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|cl_chain
operator|=
name|objc_static_instances
operator|,
name|num_class
operator|=
literal|0
init|;
name|cl_chain
condition|;
name|cl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|cl_chain
argument_list|)
operator|,
name|num_class
operator|++
control|)
block|{
for|for
control|(
name|num_inst
operator|=
literal|0
operator|,
name|in_chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|cl_chain
argument_list|)
init|;
name|in_chain
condition|;
name|num_inst
operator|++
operator|,
name|in_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|in_chain
argument_list|)
control|)
empty_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_STATIC_INSTANCES_%d"
argument_list|,
name|num_class
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_spec
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output {class_name, ...}.  */
name|class
operator|=
name|TREE_VALUE
argument_list|(
name|cl_chain
argument_list|)
expr_stmt|;
name|class_name
operator|=
name|get_objc_string_decl
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|class
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output {..., instance, ...}.  */
for|for
control|(
name|in_chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|cl_chain
argument_list|)
init|;
name|in_chain
condition|;
name|in_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|in_chain
argument_list|)
control|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|in_chain
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* Output {..., NULL}.  */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decls
argument_list|)
expr_stmt|;
block|}
name|decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decls
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
literal|"_OBJC_STATIC_INSTANCES"
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|static_instances_decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_spec
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|static_instances_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|static_instances_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|static_instances_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expr
operator|=
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|static_instances_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|decls
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|static_instances_decl
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all strings.  */
end_comment

begin_function
specifier|static
name|void
name|generate_strings
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|string_expr
decl_stmt|;
name|tree
name|string
decl_stmt|,
name|decl
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|class_names_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|string
operator|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|string_expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|chain
operator|=
name|meth_var_names_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|string
operator|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|string_expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|chain
operator|=
name|meth_var_types_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|string
operator|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|string_expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|selector_reference_idx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|build_selector_reference_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES_%d"
argument_list|,
name|selector_reference_idx
operator|++
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|selector_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Just a handy wrapper for add_objc_string.  */
end_comment

begin_function
specifier|static
name|tree
name|build_selector
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|expr
init|=
name|add_objc_string
argument_list|(
name|ident
argument_list|,
name|meth_var_names
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_typed_selectors
condition|)
return|return
name|expr
return|;
else|else
return|return
name|build_c_cast
argument_list|(
name|selector_type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* cast! */
block|}
end_function

begin_function
specifier|static
name|void
name|build_selector_translation_table
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|,
name|var_decl
decl_stmt|,
name|name
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|sel_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|warn_selector
operator|&&
name|objc_implementation_context
condition|)
block|{
name|tree
name|method_chain
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
for|for
control|(
name|method_chain
operator|=
name|meth_var_names_chain
init|;
name|method_chain
condition|;
name|method_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|method_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|method_chain
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* Adjust line number for warning message.  */
name|int
name|save_lineno
init|=
name|input_line
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
operator|&&
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
condition|)
name|input_line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"creating selector for non existant method %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|input_line
operator|=
name|save_lineno
expr_stmt|;
block|}
block|}
name|expr
operator|=
name|build_selector
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
comment|/* static SEL _OBJC_SELECTOR_REFERENCES_n = ...; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|var_decl
operator|=
name|name
expr_stmt|;
comment|/* The `decl' that is returned from start_decl is the one that we 	     forward declared in `build_selector_reference'  */
name|decl
operator|=
name|start_decl
argument_list|(
name|var_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* add one for the '\0' character */
name|offset
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag_typed_selectors
condition|)
block|{
name|tree
name|eltlist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|encoding
init|=
name|get_proto_encoding
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|encoding
argument_list|,
name|eltlist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|objc_build_constructor
argument_list|(
name|objc_selector_template
argument_list|,
name|nreverse
argument_list|(
name|eltlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* Cause the variable and its initial value to be actually output.  */
name|DECL_EXTERNAL
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* NULL terminate the list and fix the decl for output.  */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
name|objc_ellipsis_node
expr_stmt|;
name|initlist
operator|=
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|get_proto_encoding
parameter_list|(
name|tree
name|proto
parameter_list|)
block|{
name|tree
name|encoding
decl_stmt|;
if|if
condition|(
name|proto
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
else|else
name|encoding
operator|=
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
expr_stmt|;
return|return
name|add_objc_string
argument_list|(
name|encoding
argument_list|,
name|meth_var_types
argument_list|)
return|;
block|}
else|else
return|return
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* sel_ref_chain is a list whose "value" fields will be instances of    identifier_node that represent the selector.  */
end_comment

begin_function
specifier|static
name|tree
name|build_typed_selector_reference
parameter_list|(
name|tree
name|ident
parameter_list|,
name|tree
name|prototype
parameter_list|)
block|{
name|tree
modifier|*
name|chain
init|=
operator|&
name|sel_ref_chain
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|prototype
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
goto|goto
name|return_at_index
goto|;
name|index
operator|++
expr_stmt|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|prototype
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|return_at_index
label|:
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_2
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build_c_cast
argument_list|(
name|selector_type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_selector_reference
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
modifier|*
name|chain
init|=
operator|&
name|sel_ref_chain
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
operator|(
name|flag_next_runtime
condition|?
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
else|:
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_2
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
name|index
operator|++
expr_stmt|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build_selector_reference_decl
argument_list|()
expr_stmt|;
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|expr
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
operator|(
name|flag_next_runtime
condition|?
name|expr
else|:
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_2
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|class_reference_idx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|build_class_reference_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_CLASS_REFERENCES_%d"
argument_list|,
name|class_reference_idx
operator|++
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|objc_class_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a class reference, but don't create a variable to reference    it.  */
end_comment

begin_function
specifier|static
name|void
name|add_class_reference
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
operator|(
name|chain
operator|=
name|cls_ref_chain
operator|)
condition|)
block|{
name|tree
name|tail
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return;
name|tail
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
comment|/* Append to the end of the list */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|cls_ref_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a class reference, creating it if necessary.  Also create the    reference variable.  */
end_comment

begin_function
name|tree
name|get_class_reference
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|orig_ident
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Must wait until template instantiation time.  */
return|return
name|build_min_nt
argument_list|(
name|CLASS_REFERENCE_EXPR
argument_list|,
name|ident
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ident
operator|=
name|DECL_NAME
argument_list|(
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|orig_ident
operator|=
name|ident
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ident
operator|=
name|is_class_name
argument_list|(
name|ident
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is not an Objective-C class name or alias"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|orig_ident
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|flag_next_runtime
operator|&&
operator|!
name|flag_zero_link
condition|)
block|{
name|tree
modifier|*
name|chain
decl_stmt|;
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|chain
operator|=
operator|&
name|cls_ref_chain
init|;
operator|*
name|chain
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|build_class_reference_decl
argument_list|()
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
return|;
block|}
name|decl
operator|=
name|build_class_reference_decl
argument_list|()
expr_stmt|;
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
block|{
name|tree
name|params
decl_stmt|;
name|add_class_reference
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|params
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|ident
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_get_class_decl
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|objc_get_class_decl
argument_list|,
name|params
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* For each string section we have a chain which maps identifier nodes    to decls for the strings.  */
end_comment

begin_function
specifier|static
name|tree
name|add_objc_string
parameter_list|(
name|tree
name|ident
parameter_list|,
name|enum
name|string_section
name|section
parameter_list|)
block|{
name|tree
modifier|*
name|chain
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|chain
operator|=
operator|&
name|class_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|chain
operator|=
operator|&
name|meth_var_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|chain
operator|=
operator|&
name|meth_var_types_chain
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_objc_string_decl
argument_list|(
name|section
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|class_names_idx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|meth_var_names_idx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|meth_var_types_idx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|build_objc_string_decl
parameter_list|(
name|enum
name|string_section
name|section
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_CLASS_NAME_%d"
argument_list|,
name|class_names_idx
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_METH_VAR_NAME_%d"
argument_list|,
name|meth_var_names_idx
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_METH_VAR_TYPE_%d"
argument_list|,
name|meth_var_types_idx
operator|++
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
name|void
name|objc_declare_alias
parameter_list|(
name|tree
name|alias_ident
parameter_list|,
name|tree
name|class_ident
parameter_list|)
block|{
name|tree
name|underlying_class
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
block|{
name|error
argument_list|(
literal|"Objective-C declarations may only appear in global scope"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJCPLUS */
if|if
condition|(
operator|!
operator|(
name|underlying_class
operator|=
name|is_class_name
argument_list|(
name|class_ident
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"cannot find class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_ident
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_class_name
argument_list|(
name|alias_ident
argument_list|)
condition|)
name|warning
argument_list|(
literal|"class `%s' already exists"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|alias_ident
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|alias_chain
operator|=
name|tree_cons
argument_list|(
name|underlying_class
argument_list|,
name|alias_ident
argument_list|,
name|alias_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_declare_class
parameter_list|(
name|tree
name|ident_list
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
block|{
name|error
argument_list|(
literal|"Objective-C declarations may only appear in global scope"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJCPLUS */
for|for
control|(
name|list
operator|=
name|ident_list
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
name|tree
name|ident
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_class_name
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|tree
name|record
init|=
name|lookup_name
argument_list|(
name|ident
argument_list|)
decl_stmt|;
if|if
condition|(
name|record
operator|&&
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|record
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' redeclared as different kind of symbol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jprevious declaration of '%D'"
argument_list|,
name|record
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
name|record
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|TREE_STATIC_TEMPLATE
argument_list|(
name|record
argument_list|)
operator|=
literal|1
expr_stmt|;
name|class_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|class_chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|tree
name|is_class_name
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|identifier_global_value
argument_list|(
name|ident
argument_list|)
condition|)
name|ident
operator|=
name|identifier_global_value
argument_list|(
name|ident
argument_list|)
expr_stmt|;
while|while
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|ident
argument_list|)
condition|)
name|ident
operator|=
name|TYPE_NAME
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|ident
operator|=
name|TYPE_NAME
argument_list|(
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ident
operator|=
name|DECL_NAME
argument_list|(
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ident
operator|||
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|lookup_interface
argument_list|(
name|ident
argument_list|)
condition|)
return|return
name|ident
return|;
for|for
control|(
name|chain
operator|=
name|class_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|ident
return|;
block|}
for|for
control|(
name|chain
operator|=
name|alias_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is either 'id', 'Class', or a pointer to an ObjC    class instance.  This is needed by other parts of the compiler to    handle ObjC types gracefully.  */
end_comment

begin_function
name|tree
name|objc_is_object_ptr
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
comment|/* NB: This function may be called before the ObjC front-end has      been initialized, in which case ID_TYPE will be NULL.  */
if|if
condition|(
name|id_type
operator|&&
name|type
operator|&&
name|TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|IS_ID
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|objc_class_type
argument_list|)
operator|)
condition|)
return|return
name|type
return|;
return|return
name|is_class_name
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_interface
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ident
operator|=
name|DECL_NAME
argument_list|(
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|chain
operator|=
name|interface_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|CLASS_NAME
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|chain
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Implement @defs (<classname>) within struct bodies.  */
end_comment

begin_function
name|tree
name|get_class_ivars_from_name
parameter_list|(
name|tree
name|class_name
parameter_list|)
block|{
name|tree
name|interface
init|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|fields
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|interface
condition|)
block|{
name|tree
name|raw_ivar
init|=
name|get_class_ivars
argument_list|(
name|interface
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Regenerate the FIELD_DECLs for the enclosing struct.  */
for|for
control|(
init|;
name|raw_ivar
condition|;
name|raw_ivar
operator|=
name|TREE_CHAIN
argument_list|(
name|raw_ivar
argument_list|)
control|)
block|{
name|field
operator|=
name|grokfield
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_VALUE
argument_list|(
name|raw_ivar
argument_list|)
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|raw_ivar
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|raw_ivar
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|finish_member_declaration
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|#
directive|else
name|fields
operator|=
name|chainon
argument_list|(
name|fields
argument_list|,
name|field
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
name|error
argument_list|(
literal|"cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
end_function

begin_comment
comment|/* Used by: build_private_template, continue_class,    and for @defs constructs.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_ivars
parameter_list|(
name|tree
name|interface
parameter_list|,
name|int
name|raw
parameter_list|)
block|{
name|tree
name|my_name
decl_stmt|,
name|super_name
decl_stmt|,
name|ivar_chain
decl_stmt|;
name|my_name
operator|=
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|super_name
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw
condition|)
name|ivar_chain
operator|=
name|CLASS_RAW_IVARS
argument_list|(
name|interface
argument_list|)
expr_stmt|;
else|else
block|{
name|ivar_chain
operator|=
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
expr_stmt|;
comment|/* Save off a pristine copy of the leaf ivars (i.e, those not 	 inherited from a super class).  */
if|if
condition|(
operator|!
name|CLASS_OWN_IVARS
argument_list|(
name|interface
argument_list|)
condition|)
name|CLASS_OWN_IVARS
argument_list|(
name|interface
argument_list|)
operator|=
name|copy_list
argument_list|(
name|ivar_chain
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|super_name
condition|)
block|{
name|tree
name|op1
decl_stmt|;
name|tree
name|super_interface
init|=
name|lookup_interface
argument_list|(
name|super_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|super_interface
condition|)
block|{
comment|/* fatal did not work with 2 args...should fix */
name|error
argument_list|(
literal|"cannot find interface declaration for `%s', superclass of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|my_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|super_interface
operator|==
name|interface
condition|)
name|fatal_error
argument_list|(
literal|"circular inheritance in interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
expr_stmt|;
name|interface
operator|=
name|super_interface
expr_stmt|;
name|my_name
operator|=
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|super_name
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|op1
operator|=
operator|(
name|raw
condition|?
name|CLASS_RAW_IVARS
argument_list|(
name|interface
argument_list|)
else|:
name|CLASS_OWN_IVARS
argument_list|(
name|interface
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
block|{
name|tree
name|head
init|=
name|copy_list
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* Prepend super class ivars...make a copy of the list, we 	     do not want to alter the original.  */
name|chainon
argument_list|(
name|head
argument_list|,
name|ivar_chain
argument_list|)
expr_stmt|;
name|ivar_chain
operator|=
name|head
expr_stmt|;
block|}
block|}
return|return
name|ivar_chain
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_enter_block
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|block
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|block
operator|=
name|begin_compound_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|block
operator|=
name|c_begin_compound_stmt
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|1
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|objc_exception_block_stack
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block
argument_list|,
name|objc_exception_block_stack
argument_list|)
expr_stmt|;
name|blk_nesting_count
operator|++
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_exit_block
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|block
init|=
name|TREE_VALUE
argument_list|(
name|objc_exception_block_stack
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|OBJCPLUS
name|tree
name|scope_stmt
decl_stmt|,
name|inner
decl_stmt|;
endif|#
directive|endif
name|objc_clear_super_receiver
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|finish_compound_stmt
argument_list|(
literal|0
argument_list|,
name|block
argument_list|)
expr_stmt|;
else|#
directive|else
name|scope_stmt
operator|=
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|0
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
name|inner
operator|=
name|poplevel
argument_list|(
name|KEEP_MAYBE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|scope_stmt
argument_list|)
argument_list|)
operator|=
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_VALUE
argument_list|(
name|scope_stmt
argument_list|)
argument_list|)
operator|=
name|inner
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|block
argument_list|,
name|COMPOUND_BODY
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
name|objc_exception_block_stack
operator|=
name|TREE_CHAIN
argument_list|(
name|objc_exception_block_stack
argument_list|)
expr_stmt|;
name|blk_nesting_count
operator|--
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_declare_variable
parameter_list|(
name|enum
name|rid
name|scspec
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|scspec
index|]
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
operator|(
name|init
operator|!=
name|NULL_TREE
operator|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* This prevents `unused variable' warnings when compiling with -Wall.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
name|tree
name|objc_build_throw_stmt
parameter_list|(
name|tree
name|throw_expr
parameter_list|)
block|{
name|tree
name|func_params
decl_stmt|;
if|if
condition|(
operator|!
name|flag_objc_exceptions
condition|)
name|fatal_error
argument_list|(
literal|"Use `-fobjc-exceptions' to enable Objective-C exception syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|throw_expr
operator|&&
name|objc_caught_exception
condition|)
name|throw_expr
operator|=
name|TREE_VALUE
argument_list|(
name|objc_caught_exception
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|throw_expr
condition|)
block|{
name|error
argument_list|(
literal|"`@throw;' (rethrow) used outside of a `@catch' block"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|func_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|throw_expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_exception_throw_decl
argument_list|)
expr_stmt|;
return|return
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|objc_exception_throw_decl
argument_list|,
name|func_params
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|val_stack_push
parameter_list|(
name|struct
name|val_stack
modifier|*
modifier|*
name|nc
parameter_list|,
name|long
name|val
parameter_list|)
block|{
name|struct
name|val_stack
modifier|*
name|new_elem
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|val_stack
argument_list|)
argument_list|)
decl_stmt|;
name|new_elem
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|new_elem
operator|->
name|next
operator|=
operator|*
name|nc
expr_stmt|;
operator|*
name|nc
operator|=
name|new_elem
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|val_stack_pop
parameter_list|(
name|struct
name|val_stack
modifier|*
modifier|*
name|nc
parameter_list|)
block|{
name|struct
name|val_stack
modifier|*
name|old_elem
init|=
operator|*
name|nc
decl_stmt|;
operator|*
name|nc
operator|=
name|old_elem
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old_elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|objc_build_try_enter_fragment
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* objc_exception_try_enter(&_stackExceptionData);      if (!_setjmp(&_stackExceptionData.buf)) {  */
name|tree
name|func_params
decl_stmt|,
name|if_stmt
decl_stmt|,
name|cond
decl_stmt|;
name|func_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_stack_exception_data
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_exception_try_enter_decl
argument_list|)
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|objc_exception_try_enter_decl
argument_list|,
name|func_params
argument_list|)
argument_list|)
expr_stmt|;
name|if_stmt
operator|=
name|c_begin_if_stmt
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|++
expr_stmt|;
comment|/* If<setjmp.h> has been included, the _setjmp prototype has      acquired a real, breathing type for its parameter.  Cast our      argument to that type.  */
name|func_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_c_cast
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|objc_setjmp_decl
argument_list|)
argument_list|)
condition|?
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|objc_setjmp_decl
argument_list|)
argument_list|)
argument_list|)
else|:
name|ptr_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|objc_stack_exception_data
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"buf"
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_setjmp_decl
argument_list|)
expr_stmt|;
name|cond
operator|=
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|build_function_call
argument_list|(
name|objc_setjmp_decl
argument_list|,
name|func_params
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c_expand_start_cond
argument_list|(
name|c_common_truthvalue_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
literal|0
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_build_extract_expr
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*	... = objc_exception_extract(&_stackExceptionData);  */
name|tree
name|func_params
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_stack_exception_data
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|assemble_external
argument_list|(
name|objc_exception_extract_decl
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|objc_exception_extract_decl
argument_list|,
name|func_params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|objc_build_try_exit_fragment
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* objc_exception_try_exit(&_stackExceptionData); */
name|tree
name|func_params
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_stack_exception_data
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|assemble_external
argument_list|(
name|objc_exception_try_exit_decl
argument_list|)
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|objc_exception_try_exit_decl
argument_list|,
name|func_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|objc_build_extract_fragment
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* } else {       _rethrowException = objc_exception_extract(&_stackExceptionData);      }  */
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_then
argument_list|()
expr_stmt|;
name|c_expand_start_else
argument_list|()
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|objc_rethrow_exception
argument_list|)
argument_list|,
name|NOP_EXPR
argument_list|,
name|objc_build_extract_expr
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_else
argument_list|()
expr_stmt|;
name|c_expand_end_cond
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|objc_build_try_prologue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* { // new scope        struct _objc_exception_data _stackExceptionData;        volatile id _rethrowException = nil;        { // begin TRY-CATCH scope          objc_exception_try_enter(&_stackExceptionData); 	 if (!_setjmp(&_stackExceptionData.buf)) {  */
name|tree
name|try_catch_block
decl_stmt|;
if|if
condition|(
operator|!
name|flag_objc_exceptions
condition|)
name|fatal_error
argument_list|(
literal|"Use `-fobjc-exceptions' to enable Objective-C exception syntax"
argument_list|)
expr_stmt|;
name|objc_mark_locals_volatile
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|exc_binding_stack
condition|?
name|exc_binding_stack
operator|->
name|val
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|objc_stack_exception_data
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_declare_variable
argument_list|(
name|RID_AUTO
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_EXCDATA_VAR
argument_list|)
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_EXCDATA
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|objc_stack_exception_data
argument_list|)
expr_stmt|;
name|objc_rethrow_exception
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_declare_variable
argument_list|(
name|RID_VOLATILE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_RETHROWEXC_VAR
argument_list|)
argument_list|,
name|id_type
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|objc_rethrow_exception
argument_list|)
expr_stmt|;
name|try_catch_block
operator|=
name|objc_enter_block
argument_list|()
expr_stmt|;
name|val_stack_push
argument_list|(
operator|&
name|exc_binding_stack
argument_list|,
operator|(
name|long
operator|)
name|get_current_scope
argument_list|()
argument_list|)
expr_stmt|;
name|objc_build_try_enter_fragment
argument_list|()
expr_stmt|;
return|return
name|try_catch_block
return|;
block|}
end_function

begin_function
name|void
name|objc_build_try_epilogue
parameter_list|(
name|int
name|also_catch_prologue
parameter_list|)
block|{
if|if
condition|(
name|also_catch_prologue
condition|)
block|{
comment|/* } else { 	   register id _caughtException = objc_exception_extract(&_stackExceptionData); 	   objc_exception_try_enter(&_stackExceptionData); 	   if(!_setjmp(&_stackExceptionData.buf)) { 	     if (0) {  */
name|tree
name|if_stmt
decl_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_then
argument_list|()
expr_stmt|;
name|c_expand_start_else
argument_list|()
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|objc_caught_exception
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_declare_variable
argument_list|(
name|RID_REGISTER
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CAUGHTEXC_VAR
argument_list|)
argument_list|,
name|id_type
argument_list|,
name|objc_build_extract_expr
argument_list|()
argument_list|)
argument_list|,
name|objc_caught_exception
argument_list|)
expr_stmt|;
name|objc_build_try_enter_fragment
argument_list|()
expr_stmt|;
name|val_stack_push
argument_list|(
operator|&
name|catch_count_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|if_stmt
operator|=
name|c_begin_if_stmt
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|++
expr_stmt|;
name|c_expand_start_cond
argument_list|(
name|c_common_truthvalue_conversion
argument_list|(
name|boolean_false_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
comment|/* Start a new chain of @catch statements for this @try.  */
name|objc_catch_type
operator|=
name|tree_cons
argument_list|(
name|objc_catch_type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* !also_catch_prologue */
comment|/* } else { 	   _rethrowException = objc_exception_extract(&_stackExceptionData); 	 }        }  */
name|objc_build_extract_fragment
argument_list|()
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|objc_build_catch_stmt
parameter_list|(
name|tree
name|catch_expr
parameter_list|)
block|{
comment|/* } else if (objc_exception_match(objc_get_class("SomeClass"), _caughtException)) {        register SomeClass *e = _caughtException;  */
name|tree
name|if_stmt
decl_stmt|,
name|cond
decl_stmt|,
name|func_params
decl_stmt|,
name|prev_catch
decl_stmt|,
name|var_name
decl_stmt|,
name|var_type
decl_stmt|;
name|int
name|catch_id
decl_stmt|;
ifndef|#
directive|ifndef
name|OBJCPLUS
comment|/* Yet another C/C++ impedance mismatch.  */
name|catch_expr
operator|=
name|TREE_PURPOSE
argument_list|(
name|catch_expr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|var_name
operator|=
name|TREE_VALUE
argument_list|(
name|catch_expr
argument_list|)
expr_stmt|;
name|var_type
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|catch_expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var_name
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|var_name
operator|=
name|TREE_OPERAND
argument_list|(
name|var_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var_type
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|var_type
operator|=
name|TREE_TYPE
argument_list|(
name|var_type
argument_list|)
expr_stmt|;
name|catch_id
operator|=
operator|(
name|var_type
operator|==
name|TREE_TYPE
argument_list|(
name|id_type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_objc_exceptions
condition|)
name|fatal_error
argument_list|(
literal|"Use `-fobjc-exceptions' to enable Objective-C exception syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|catch_id
operator|||
name|TYPED_OBJECT
argument_list|(
name|var_type
argument_list|)
operator|)
condition|)
name|fatal_error
argument_list|(
literal|"`@catch' parameter is not a known Objective-C class type"
argument_list|)
expr_stmt|;
comment|/* Examine previous @catch clauses for the current @try block for      superclasses of the 'var_type' class.  */
for|for
control|(
name|prev_catch
operator|=
name|objc_catch_type
init|;
name|TREE_VALUE
argument_list|(
name|prev_catch
argument_list|)
condition|;
name|prev_catch
operator|=
name|TREE_CHAIN
argument_list|(
name|prev_catch
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|prev_catch
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|id_type
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Exception already handled by preceding `@catch(id)'"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|catch_id
operator|&&
name|objc_comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|prev_catch
argument_list|)
argument_list|,
name|var_type
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"Exception of type `%s *' already handled by `@catch (%s *)'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|var_type
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|prev_catch
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|objc_catch_type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|var_type
argument_list|,
name|objc_catch_type
argument_list|)
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_then
argument_list|()
expr_stmt|;
name|c_expand_start_else
argument_list|()
expr_stmt|;
name|catch_count_stack
operator|->
name|val
operator|++
expr_stmt|;
name|if_stmt
operator|=
name|c_begin_if_stmt
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|++
expr_stmt|;
if|if
condition|(
name|catch_id
condition|)
name|cond
operator|=
name|integer_one_node
expr_stmt|;
else|else
block|{
name|cond
operator|=
name|get_class_reference
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|var_type
argument_list|)
argument_list|)
expr_stmt|;
name|func_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cond
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_caught_exception
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_exception_match_decl
argument_list|)
expr_stmt|;
name|cond
operator|=
name|build_function_call
argument_list|(
name|objc_exception_match_decl
argument_list|,
name|func_params
argument_list|)
expr_stmt|;
block|}
name|c_expand_start_cond
argument_list|(
name|c_common_truthvalue_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
literal|0
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|objc_declare_variable
argument_list|(
name|RID_REGISTER
argument_list|,
name|var_name
argument_list|,
name|build_pointer_type
argument_list|(
name|var_type
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_caught_exception
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_build_catch_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*     } else {            _rethrowException = _caughtException;            objc_exception_try_exit(&_stackExceptionData);          }        } else {          _rethrowException = objc_exception_extract(&_stackExceptionData);        }      }    } // end TRY-CATCH scope   */
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_then
argument_list|()
expr_stmt|;
name|c_expand_start_else
argument_list|()
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|objc_rethrow_exception
argument_list|)
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_caught_exception
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_build_try_exit_fragment
argument_list|()
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
while|while
condition|(
name|catch_count_stack
operator|->
name|val
operator|--
condition|)
block|{
name|c_finish_else
argument_list|()
expr_stmt|;
comment|/* close off all the nested ifs ! */
name|c_expand_end_cond
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|--
expr_stmt|;
block|}
name|val_stack_pop
argument_list|(
operator|&
name|catch_count_stack
argument_list|)
expr_stmt|;
name|objc_caught_exception
operator|=
name|TREE_CHAIN
argument_list|(
name|objc_caught_exception
argument_list|)
expr_stmt|;
name|objc_build_extract_fragment
argument_list|()
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_else
argument_list|()
expr_stmt|;
name|c_expand_end_cond
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|--
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
comment|/* Return to enclosing chain of @catch statements (if any).  */
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|objc_catch_type
argument_list|)
condition|)
name|objc_catch_type
operator|=
name|TREE_CHAIN
argument_list|(
name|objc_catch_type
argument_list|)
expr_stmt|;
name|objc_catch_type
operator|=
name|TREE_PURPOSE
argument_list|(
name|objc_catch_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|objc_build_finally_prologue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* { // begin FINALLY scope        if (!_rethrowException) {          objc_exception_try_exit(&_stackExceptionData);        }  */
name|tree
name|blk
init|=
name|objc_enter_block
argument_list|()
decl_stmt|;
name|tree
name|if_stmt
init|=
name|c_begin_if_stmt
argument_list|()
decl_stmt|;
name|if_nesting_count
operator|++
expr_stmt|;
name|c_expand_start_cond
argument_list|(
name|c_common_truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_rethrow_exception
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|objc_build_try_exit_fragment
argument_list|()
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_then
argument_list|()
expr_stmt|;
name|c_expand_end_cond
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|--
expr_stmt|;
return|return
name|blk
return|;
block|}
end_function

begin_function
name|tree
name|objc_build_finally_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    if (_rethrowException) { 	  objc_exception_throw(_rethrowException); 	}       } // end FINALLY scope     } */
name|tree
name|if_stmt
init|=
name|c_begin_if_stmt
argument_list|()
decl_stmt|;
name|if_nesting_count
operator|++
expr_stmt|;
name|c_expand_start_cond
argument_list|(
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|objc_rethrow_exception
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|objc_build_throw_stmt
argument_list|(
name|TREE_VALUE
argument_list|(
name|objc_rethrow_exception
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|c_finish_then
argument_list|()
expr_stmt|;
name|c_expand_end_cond
argument_list|()
expr_stmt|;
name|if_nesting_count
operator|--
expr_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|objc_rethrow_exception
operator|=
name|TREE_CHAIN
argument_list|(
name|objc_rethrow_exception
argument_list|)
expr_stmt|;
name|objc_stack_exception_data
operator|=
name|TREE_CHAIN
argument_list|(
name|objc_stack_exception_data
argument_list|)
expr_stmt|;
name|val_stack_pop
argument_list|(
operator|&
name|exc_binding_stack
argument_list|)
expr_stmt|;
return|return
name|objc_exit_block
argument_list|()
return|;
block|}
end_function

begin_function
name|tree
name|objc_build_try_catch_finally_stmt
parameter_list|(
name|int
name|has_catch
parameter_list|,
name|int
name|has_finally
parameter_list|)
block|{
comment|/* NB: The operative assumption here is that TRY_FINALLY_EXPR will      deal with all exits from 'try_catch_blk' and route them through      'finally_blk'.  */
name|tree
name|outer_blk
init|=
name|objc_build_finally_epilogue
argument_list|()
decl_stmt|;
name|tree
name|prec_stmt
init|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|outer_blk
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|try_catch_blk
init|=
name|TREE_CHAIN
argument_list|(
name|prec_stmt
argument_list|)
decl_stmt|,
name|try_catch_expr
decl_stmt|;
name|tree
name|finally_blk
init|=
name|TREE_CHAIN
argument_list|(
name|try_catch_blk
argument_list|)
decl_stmt|,
name|finally_expr
decl_stmt|;
name|tree
name|succ_stmt
init|=
name|TREE_CHAIN
argument_list|(
name|finally_blk
argument_list|)
decl_stmt|;
name|tree
name|try_finally_stmt
decl_stmt|,
name|try_finally_expr
decl_stmt|;
if|if
condition|(
operator|!
name|flag_objc_exceptions
condition|)
name|fatal_error
argument_list|(
literal|"Use `-fobjc-exceptions' to enable Objective-C exception syntax"
argument_list|)
expr_stmt|;
comment|/* It is an error to have a @try block without a @catch and/or @finally      (even though sensible code can be generated nonetheless).  */
if|if
condition|(
operator|!
name|has_catch
operator|&&
operator|!
name|has_finally
condition|)
name|error
argument_list|(
literal|"`@try' without `@catch' or `@finally'"
argument_list|)
expr_stmt|;
comment|/* We shall now do something truly disgusting.  We shall remove the      'try_catch_blk' and 'finally_blk' from the 'outer_blk' statement      chain, and replace them with a TRY_FINALLY_EXPR statement!  If      this doesn't work, we will have to learn (from Per/gcj) how to      construct the 'outer_blk' lazily.  */
name|TREE_CHAIN
argument_list|(
name|try_catch_blk
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|finally_blk
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|try_catch_expr
operator|=
name|build1
argument_list|(
name|STMT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|try_catch_blk
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|try_catch_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finally_expr
operator|=
name|build1
argument_list|(
name|STMT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_blk
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|finally_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|try_finally_expr
operator|=
name|build
argument_list|(
name|TRY_FINALLY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|try_catch_expr
argument_list|,
name|finally_expr
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|try_finally_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|try_finally_stmt
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|try_finally_expr
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|prec_stmt
argument_list|)
operator|=
name|try_finally_stmt
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|try_finally_stmt
argument_list|)
operator|=
name|succ_stmt
expr_stmt|;
return|return
name|outer_blk
return|;
comment|/* the whole enchilada */
block|}
end_function

begin_function
name|void
name|objc_build_synchronized_prologue
parameter_list|(
name|tree
name|sync_expr
parameter_list|)
block|{
comment|/* {        id _eval_once =<sync_expr>;        @try {               objc_sync_enter( _eval_once );  */
name|tree
name|func_params
decl_stmt|;
if|if
condition|(
operator|!
name|flag_objc_exceptions
condition|)
name|fatal_error
argument_list|(
literal|"Use `-fobjc-exceptions' to enable Objective-C exception syntax"
argument_list|)
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|objc_eval_once
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_declare_variable
argument_list|(
name|RID_AUTO
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_EVALONCE_VAR
argument_list|)
argument_list|,
name|id_type
argument_list|,
name|sync_expr
argument_list|)
argument_list|,
name|objc_eval_once
argument_list|)
expr_stmt|;
name|objc_build_try_prologue
argument_list|()
expr_stmt|;
name|objc_enter_block
argument_list|()
expr_stmt|;
name|func_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_eval_once
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_sync_enter_decl
argument_list|)
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|objc_sync_enter_decl
argument_list|,
name|func_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|objc_build_synchronized_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* }        @finally {          objc_sync_exit( _eval_once );        }      }  */
name|tree
name|func_params
decl_stmt|;
name|objc_exit_block
argument_list|()
expr_stmt|;
name|objc_build_try_epilogue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|objc_build_finally_prologue
argument_list|()
expr_stmt|;
name|func_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|objc_eval_once
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_sync_exit_decl
argument_list|)
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|objc_sync_exit_decl
argument_list|,
name|func_params
argument_list|)
argument_list|)
expr_stmt|;
name|objc_build_try_catch_finally_stmt
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|objc_exit_block
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Predefine the following data type:     struct _objc_exception_data    {      int buf[_JBLEN];      void *pointers[4];    }; */
end_comment

begin_comment
comment|/* The following yuckiness should prevent users from having to #include<setjmp.h> in their code... */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_POWERPC
end_ifdef

begin_comment
comment|/* snarfed from /usr/include/ppc/setjmp.h */
end_comment

begin_define
define|#
directive|define
name|_JBLEN
value|(26 + 36 + 129 + 1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* snarfed from /usr/include/i386/{setjmp,signal}.h */
end_comment

begin_define
define|#
directive|define
name|_JBLEN
value|18
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|build_objc_exception_stuff
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|,
name|index
decl_stmt|,
name|temp_type
decl_stmt|;
comment|/* Suppress outputting debug symbols, because      dbxout_init hasn't been called yet.  */
name|enum
name|debug_info_type
name|save_write_symbols
init|=
name|write_symbols
decl_stmt|;
specifier|const
name|struct
name|gcc_debug_hooks
modifier|*
name|save_hooks
init|=
name|debug_hooks
decl_stmt|;
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
name|objc_exception_data_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_EXCDATA
argument_list|)
argument_list|)
expr_stmt|;
comment|/* int buf[_JBLEN]; */
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|_JBLEN
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|index
argument_list|)
argument_list|,
literal|"buf"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* void *pointers[4]; */
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
literal|4
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|index
argument_list|)
argument_list|,
literal|"pointers"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_exception_data_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int _setjmp(...); */
comment|/* If the user includes<setjmp.h>, this shall be superceded by      'int _setjmp(jmp_buf);' */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_setjmp_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_SETJMP
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* id objc_exception_extract(struct _objc_exception_data *); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|objc_exception_data_template
argument_list|)
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_extract_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONEXTRACT
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* void objc_exception_try_enter(struct _objc_exception_data *); */
comment|/* void objc_exception_try_exit(struct _objc_exception_data *); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|objc_exception_data_template
argument_list|)
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_try_enter_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONTRYENTER
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_exception_try_exit_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONTRYEXIT
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* void objc_exception_throw(id) __attribute__((noreturn)); */
comment|/* void objc_sync_enter(id); */
comment|/* void objc_sync_exit(id); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_throw_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONTHROW
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_ATTRIBUTES
argument_list|(
name|objc_exception_throw_decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"noreturn"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_sync_enter_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_SYNCENTER
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_sync_exit_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_SYNCEXIT
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int objc_exception_match(id, id); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_match_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONMATCH
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|save_write_symbols
expr_stmt|;
name|debug_hooks
operator|=
name|save_hooks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct<classname> {      struct objc_class *isa;      ...    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_private_template
parameter_list|(
name|tree
name|class
parameter_list|)
block|{
name|tree
name|ivar_context
decl_stmt|;
if|if
condition|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|uprivate_record
operator|=
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|ivar_context
operator|=
name|TYPE_FIELDS
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uprivate_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|ivar_context
operator|=
name|get_class_ivars
argument_list|(
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|uprivate_record
argument_list|,
name|ivar_context
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
operator|=
name|uprivate_record
expr_stmt|;
comment|/* mark this record as class template - for class type checking */
name|TREE_STATIC_TEMPLATE
argument_list|(
name|uprivate_record
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|instance_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|uprivate_record
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ivar_context
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin code generation for protocols...  */
end_comment

begin_comment
comment|/* struct objc_protocol {      char *protocol_name;      struct objc_protocol **protocol_list;      struct objc_method_desc *instance_methods;      struct objc_method_desc *class_methods;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_protocol_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_class *isa; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"isa"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *protocol_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_protocol **protocol_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *instance_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"instance_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *class_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
return|return
name|finish_struct
argument_list|(
name|template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_descriptor_table_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|entries
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|eltlist
init|=
name|NULL_TREE
decl_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_selector
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|entries
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|eltlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|eltlist
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
condition|)
do|;
return|return
name|objc_build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* struct objc_method_prototype_list {      int count;      struct objc_method_prototype { 	SEL name; 	char *types;      } list[1];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_prototype_list_template
parameter_list|(
name|tree
name|list_type
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
comment|/* Generate an unnamed struct definition.  */
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int method_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"method_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_method method_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"method_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_method_prototype_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|proto_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|proto_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_selector *_cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"method_types"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|proto_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|proto_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_method_parm_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objc_encoded_type_size
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|sz
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Make all integer and enum types at least as large      as an int.  */
if|if
condition|(
name|sz
operator|>
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|sz
operator|=
name|MAX
argument_list|(
name|sz
argument_list|,
name|int_size_in_bytes
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Treat arrays as pointers, since that's how they're      passed in.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|sz
operator|=
name|int_size_in_bytes
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|encode_method_prototype
parameter_list|(
name|tree
name|method_decl
parameter_list|)
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|parm_offset
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* ONEWAY and BYCOPY, for remote object are the only method qualifiers.  */
name|encode_type_qualifiers
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encode return type.  */
name|encode_type
argument_list|(
name|objc_method_parm_type
argument_list|(
name|method_decl
argument_list|)
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Stack size.  */
comment|/* The first two arguments (self and _cmd) are pointers; account for      their size.  */
name|i
operator|=
name|int_size_in_bytes
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|parm_offset
operator|=
literal|2
operator|*
name|i
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|objc_method_parm_type
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|sz
init|=
name|objc_encoded_type_size
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If a type size is not known, bail out.  */
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%Jtype '%D' does not have a known size"
argument_list|,
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Pretend that the encoding succeeded; the compilation will 	     fail nevertheless.  */
goto|goto
name|finish_encoding
goto|;
block|}
name|parm_offset
operator|+=
name|sz
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d@0:%d"
argument_list|,
name|parm_offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Argument types.  */
name|parm_offset
operator|=
literal|2
operator|*
name|i
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|objc_method_parm_type
argument_list|(
name|parms
argument_list|)
decl_stmt|;
comment|/* Process argument qualifiers for user supplied arguments.  */
name|encode_type_qualifiers
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Type.  */
name|encode_type
argument_list|(
name|type
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Compute offset.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|parm_offset
argument_list|)
expr_stmt|;
name|parm_offset
operator|+=
name|objc_encoded_type_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_encoding
label|:
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_descriptor_table
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|tree
name|list
parameter_list|,
name|tree
name|proto
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|proto
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_method_descriptors
parameter_list|(
name|tree
name|protocol
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|chain
decl_stmt|,
name|method_list_template
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_method_prototype_template
condition|)
name|objc_method_prototype_template
operator|=
name|build_method_prototype_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
name|chain
operator|=
name|PROTOCOL_CLS_METHODS
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_prototype_list_template
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_descriptor_table_initializer
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_METHODS_decl
operator|=
name|generate_descriptor_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_PROTOCOL_CLASS_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_CLASS_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_METHODS_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|PROTOCOL_NST_METHODS
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_prototype_list_template
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_descriptor_table_initializer
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_descriptor_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_PROTOCOL_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_INSTANCE_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_METHODS_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_protocol_references
parameter_list|(
name|tree
name|plist
parameter_list|)
block|{
name|tree
name|lproto
decl_stmt|;
comment|/* Forward declare protocols referenced.  */
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|tree
name|proto
init|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|proto
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_NAME
argument_list|(
name|proto
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|proto
argument_list|)
condition|)
name|build_protocol_reference
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|proto
argument_list|)
condition|)
name|generate_protocol_references
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each protocol which was referenced either from a @protocol()    expression, or because a class/category implements it (then a    pointer to the protocol is stored in the struct describing the    class/category), we create a statically allocated instance of the    Protocol class.  The code is written in such a way as to generate    as few Protocol objects as possible; we generate a unique Protocol    instance for each protocol, and we don't generate a Protocol    instance if the protocol is never referenced (either from a    @protocol() or from a class/category implementation).  These    statically allocated objects can be referred to via the static    (that is, private to this module) symbols _OBJC_PROTOCOL_n.     The statically allocated Protocol objects that we generate here    need to be fixed up at runtime in order to be used: the 'isa'    pointer of the objects need to be set up to point to the 'Protocol'    class, as known at runtime.     The NeXT runtime fixes up all protocols at program startup time,    before main() is entered.  It uses a low-level trick to look up all    those symbols, then loops on them and fixes them up.     The GNU runtime as well fixes up all protocols before user code    from the module is executed; it requires pointers to those symbols    to be put in the objc_symtab (which is then passed as argument to    the function __objc_exec_class() which the compiler sets up to be    executed automatically when the module is loaded); setup of those    Protocol objects happen in two ways in the GNU runtime: all    Protocol objects referred to by a class or category implementation    are fixed up when the class/category is loaded; all Protocol    objects referred to by a @protocol() expression are added by the    compiler to the list of statically allocated instances to fixup    (the same list holding the statically allocated constant string    objects).  Because, as explained above, the compiler generates as    few Protocol objects as possible, some Protocol object might end up    being referenced multiple times when compiled with the GNU runtime,    and end up being fixed up multiple times at runtime inizialization.    But that doesn't hurt, it's just a little inefficient.  */
end_comment

begin_function
specifier|static
name|void
name|generate_protocols
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|p
decl_stmt|,
name|encoding
decl_stmt|;
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|protocol_name_expr
decl_stmt|,
name|refs_decl
decl_stmt|,
name|refs_expr
decl_stmt|;
name|tree
name|cast_type2
decl_stmt|;
if|if
condition|(
operator|!
name|objc_protocol_template
condition|)
name|objc_protocol_template
operator|=
name|build_protocol_template
argument_list|()
expr_stmt|;
comment|/* If a protocol was directly referenced, pull in indirect references.  */
for|for
control|(
name|p
operator|=
name|protocol_chain
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
operator|&&
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|generate_protocol_references
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|protocol_chain
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|nst_methods
init|=
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|tree
name|cls_methods
init|=
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If protocol wasn't referenced, don't generate any code.  */
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
comment|/* Make sure we link in the Protocol class.  */
name|add_class_reference
argument_list|(
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nst_methods
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|nst_methods
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|nst_methods
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
name|nst_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cls_methods
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|cls_methods
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|cls_methods
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|cls_methods
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
name|cls_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|cls_methods
argument_list|)
expr_stmt|;
block|}
name|generate_method_descriptors
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|refs_decl
operator|=
name|generate_protocol_list
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|refs_decl
operator|=
literal|0
expr_stmt|;
comment|/* static struct objc_protocol _OBJC_PROTOCOL_<mumble>; */
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_protocol_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL"
argument_list|,
name|p
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|protocol_name_expr
operator|=
name|add_objc_string
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs_decl
condition|)
block|{
name|cast_type2
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_protocol_template
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|refs_expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|refs_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|refs_expr
argument_list|)
operator|=
name|cast_type2
expr_stmt|;
block|}
else|else
name|refs_expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* UOBJC_INSTANCE_METHODS_decl/UOBJC_CLASS_METHODS_decl are set 	 by generate_method_descriptors, which is called above.  */
name|initlist
operator|=
name|build_protocol_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|protocol_name_expr
argument_list|,
name|refs_expr
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Mark the decl as used to avoid "defined but not used" warning.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|build_protocol_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|protocol_name
parameter_list|,
name|tree
name|protocol_list
parameter_list|,
name|tree
name|instance_methods
parameter_list|,
name|tree
name|class_methods
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
name|tree
name|cast_type
decl_stmt|;
name|cast_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Filling the "isa" in with one allows the runtime system to      detect that the version change...should remove before final release.  */
name|expr
operator|=
name|build_int_2
argument_list|(
name|PROTOCOL_VERSION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|cast_type
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|class_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* struct objc_category {      char *category_name;      char *class_name;      struct objc_method_list *instance_methods;      struct objc_method_list *class_methods;      struct objc_protocol_list *protocols;    };   */
end_comment

begin_function
specifier|static
name|void
name|build_category_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_category_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CATEGORY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* char *category_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"category_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *class_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *instance_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"instance_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *class_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_protocol **protocol_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_category_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct objc_selector {      void *sel_id;      char *sel_type;    }; */
end_comment

begin_function
specifier|static
name|void
name|build_selector_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_selector_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SELECTOR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* void *sel_id; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"sel_id"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *sel_type; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"sel_type"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_selector_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct objc_class {      struct objc_class *isa;      struct objc_class *super_class;      char *name;      long version;      long info;      long instance_size;      struct objc_ivar_list *ivars;      struct objc_method_list *methods;      if (flag_next_runtime)        struct objc_cache *cache;      else {        struct sarray *dtable;        struct objc_class *subclass_list;        struct objc_class *sibling_class;      }      struct objc_protocol_list *protocols;      if (flag_next_runtime)        void *sel_id;      void *gc_object_type;    };  */
end_comment

begin_comment
comment|/* NB: The 'sel_id' and 'gc_object_type' fields are not being used by    the NeXT/Apple runtime; still, the compiler must generate them to    maintain backward binary compatibility (and to allow for future    expansion).  */
end_comment

begin_function
specifier|static
name|void
name|build_class_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_class_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_class *isa; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"isa"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_class *super_class; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"super_class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char *name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long version; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"version"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long info; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"info"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long instance_size; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"instance_size"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_ivar_list *ivars; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_IVAR_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"ivars"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* struct objc_cache *cache; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
literal|"objc_cache"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"cache"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* struct sarray *dtable; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
literal|"sarray"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"dtable"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_class *subclass_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"subclass_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_class *sibling_class; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"sibling_class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
comment|/* struct objc_protocol **protocol_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* void *sel_id; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"sel_id"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
comment|/* void *gc_object_type; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"gc_object_type"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_class_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate appropriate forward declarations for an implementation.  */
end_comment

begin_function
specifier|static
name|void
name|synth_forward_declarations
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|an_id
decl_stmt|;
comment|/* static struct objc_class _OBJC_CLASS_<my_name>; */
name|UOBJC_CLASS_decl
operator|=
name|build_metadata_decl
argument_list|(
literal|"_OBJC_CLASS"
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
comment|/* static struct objc_class _OBJC_METACLASS_<my_name>; */
name|UOBJC_METACLASS_decl
operator|=
name|build_metadata_decl
argument_list|(
literal|"_OBJC_METACLASS"
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
comment|/* Pre-build the following entities - for speed/convenience.  */
name|an_id
operator|=
name|get_identifier
argument_list|(
literal|"super_class"
argument_list|)
expr_stmt|;
name|ucls_super_ref
operator|=
name|build_component_ref
argument_list|(
name|UOBJC_CLASS_decl
argument_list|,
name|an_id
argument_list|)
expr_stmt|;
name|uucls_super_ref
operator|=
name|build_component_ref
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|,
name|an_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error_with_ivar
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|rawdecl
parameter_list|)
block|{
name|error
argument_list|(
literal|"%J%s `%s'"
argument_list|,
name|decl
argument_list|,
name|message
argument_list|,
name|gen_declaration
argument_list|(
name|rawdecl
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_ivars
parameter_list|(
name|tree
name|inter
parameter_list|,
name|tree
name|imp
parameter_list|)
block|{
name|tree
name|intdecls
init|=
name|CLASS_IVARS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|impdecls
init|=
name|CLASS_IVARS
argument_list|(
name|imp
argument_list|)
decl_stmt|;
name|tree
name|rawintdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|rawimpdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|imp
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|intdecls
operator|&&
name|TREE_CODE
argument_list|(
name|intdecls
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|intdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|&&
name|impdecls
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|||
name|impdecls
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|false
argument_list|)
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rawintdecls
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rawimpdecls
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable type"
argument_list|,
name|impdecls
argument_list|,
name|rawimpdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|,
name|rawintdecls
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* both the type and the name don't match */
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable name"
argument_list|,
name|impdecls
argument_list|,
name|rawimpdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|,
name|rawintdecls
argument_list|)
expr_stmt|;
block|}
name|intdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|impdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
name|rawintdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|rawintdecls
argument_list|)
expr_stmt|;
name|rawimpdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|rawimpdecls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set 'objc_super_template' to the data type node for 'struct _objc_super'.    This needs to be done just once per compilation.  */
end_comment

begin_function
specifier|static
name|void
name|build_super_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
comment|/* Suppress outputting debug symbols, because      dbxout_init hasn't been called yet.  */
name|enum
name|debug_info_type
name|save_write_symbols
init|=
name|write_symbols
decl_stmt|;
specifier|const
name|struct
name|gcc_debug_hooks
modifier|*
name|save_hooks
init|=
name|debug_hooks
decl_stmt|;
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
name|objc_super_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SUPER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_object *self; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_class *class; */
name|decl_specs
operator|=
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|decl_specs
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_super_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|save_write_symbols
expr_stmt|;
name|debug_hooks
operator|=
name|save_hooks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct objc_ivar {      char *ivar_name;      char *ivar_type;      int ivar_offset;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|objc_ivar_id
decl_stmt|,
name|objc_ivar_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_id
operator|=
name|get_identifier
argument_list|(
name|UTAG_IVAR
argument_list|)
expr_stmt|;
name|objc_ivar_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_ivar_id
argument_list|)
expr_stmt|;
comment|/* char *ivar_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *ivar_type; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_type"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* int ivar_offset; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"ivar_offset"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_record
return|;
block|}
end_function

begin_comment
comment|/* struct {      int ivar_count;      struct objc_ivar ivar_list[ivar_count];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_list_template
parameter_list|(
name|tree
name|list_type
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int ivar_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"ivar_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_ivar ivar_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_comment
comment|/* struct {      int method_next;      int method_count;      struct objc_method method_list[method_count];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_list_template
parameter_list|(
name|tree
name|list_type
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int method_next; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"method_next"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* int method_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"method_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method method_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"method_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_ivar_list_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|field_decl
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|ivar
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Set name.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
condition|)
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|meth_var_names
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
else|else
comment|/* Unnamed bit-field ivar (yuck).  */
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
comment|/* Set type.  */
name|encode_field_decl
argument_list|(
name|field_decl
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_DONT_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Null terminate string.  */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
comment|/* Set offset.  */
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|byte_position
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|ivar
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
do|do
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
do|while
condition|(
name|field_decl
operator|&&
name|TREE_CODE
argument_list|(
name|field_decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
do|;
block|}
do|while
condition|(
name|field_decl
condition|)
do|;
return|return
name|objc_build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_ivars_list
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Count only the fields occurring in T.  */
end_comment

begin_function
specifier|static
name|int
name|ivar_list_length
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_ivar_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|ivar_list_template
decl_stmt|,
name|chain
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
name|generating_instance_variables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|objc_ivar_template
condition|)
name|objc_ivar_template
operator|=
name|build_ivar_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_IVAR_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
comment|/* Only generate class variables for the root of the inheritance      hierarchy since these will be the same for every class.  */
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|chain
operator|=
name|TYPE_FIELDS
argument_list|(
name|objc_class_template
argument_list|)
operator|)
condition|)
block|{
name|size
operator|=
name|ivar_list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|objc_ivar_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_CLASS_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_CLASS_VARIABLES_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|ivar_list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|objc_ivar_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_INSTANCE_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_INSTANCE_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_INSTANCE_VARIABLES_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
name|generating_instance_variables
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_dispatch_table_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|entries
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|elemlist
init|=
name|NULL_TREE
decl_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_selector
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|entries
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Generate the method encoding if we don't have one already.  */
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
condition|)
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
operator|=
name|encode_method_prototype
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|elemlist
argument_list|)
expr_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|METHOD_DEFINITION
argument_list|(
name|entries
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|elemlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|elemlist
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
condition|)
do|;
return|return
name|objc_build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* To accomplish method prototyping without generating all kinds of    inane warnings, the definition of the dispatch table entries were    changed from:  	struct objc_method { SEL _cmd; ...; id (*_imp)(); };    to: 	struct objc_method { SEL _cmd; ...; void *_imp; };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|_SLT_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|_SLT_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_selector *_cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"method_types"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* void *_imp; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"_imp"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|_SLT_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|_SLT_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_dispatch_table
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_referenced_methods
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|METHOD_DEFINITION
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|METHOD_DEFINITION
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|generate_dispatch_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|chain
decl_stmt|,
name|method_list_template
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_method_template
condition|)
name|objc_method_template
operator|=
name|build_method_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|objc_method_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
condition|?
literal|"_OBJC_CLASS_METHODS"
else|:
literal|"_OBJC_CATEGORY_CLASS_METHODS"
operator|)
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_CLASS_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_METHODS_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|objc_method_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
comment|/* We have a category.  */
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_CATEGORY_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_INSTANCE_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_METHODS_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_protocol_list
parameter_list|(
name|tree
name|i_or_p
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|decl_specs
decl_stmt|,
name|sc_spec
decl_stmt|;
name|tree
name|refs_decl
decl_stmt|,
name|expr_decl
decl_stmt|,
name|lproto
decl_stmt|,
name|e
decl_stmt|,
name|plist
decl_stmt|;
name|tree
name|cast_type
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|plist
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|i_or_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
name|plist
operator|=
name|PROTOCOL_LIST
argument_list|(
name|i_or_p
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|cast_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute size.  */
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
argument_list|)
condition|)
name|size
operator|++
expr_stmt|;
comment|/* Build initializer.  */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
operator|=
name|cast_type
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|tree
name|pval
init|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|pval
argument_list|)
condition|)
block|{
name|e
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|pval
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* static struct objc_protocol *refs[n]; */
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL_REFS"
argument_list|,
name|i_or_p
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CLASS_PROTOCOLS"
argument_list|,
name|i_or_p
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY_PROTOCOLS"
argument_list|,
name|i_or_p
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|expr_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|expr_decl
argument_list|)
expr_stmt|;
name|refs_decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|refs_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_decl
argument_list|(
name|refs_decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|refs_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|refs_decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_category_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|cat_name
parameter_list|,
name|tree
name|class_name
parameter_list|,
name|tree
name|instance_methods
parameter_list|,
name|tree
name|class_methods
parameter_list|,
name|tree
name|protocol_list
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cat_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|class_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* protocol_list = */
if|if
condition|(
operator|!
name|protocol_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|cast_type2
init|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|protocol_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|cast_type2
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* struct objc_class {      struct objc_class *isa;      struct objc_class *super_class;      char *name;      long version;      long info;      long instance_size;      struct objc_ivar_list *ivars;      struct objc_method_list *methods;      if (flag_next_runtime)        struct objc_cache *cache;      else {        struct sarray *dtable;        struct objc_class *subclass_list;        struct objc_class *sibling_class;      }      struct objc_protocol_list *protocols;      if (flag_next_runtime)        void *sel_id;      void *gc_object_type;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_shared_structure_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|isa
parameter_list|,
name|tree
name|super
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|size
parameter_list|,
name|int
name|status
parameter_list|,
name|tree
name|dispatch_table
parameter_list|,
name|tree
name|ivar_list
parameter_list|,
name|tree
name|protocol_list
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
comment|/* isa = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|isa
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* super_class = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|super
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* name = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|name
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* version = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* info = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|status
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* instance_size = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* objc_ivar_list = */
if|if
condition|(
operator|!
name|ivar_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ivar_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* objc_method_list = */
if|if
condition|(
operator|!
name|dispatch_table
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|dispatch_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
comment|/* method_cache = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* dtable = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* subclass_list = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* sibling_class = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* protocol_list = */
if|if
condition|(
operator|!
name|protocol_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|cast_type2
init|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|protocol_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|cast_type2
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
comment|/* sel_id = NULL */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* gc_object_type = NULL */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve category interface CAT_NAME (if any) associated with CLASS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|lookup_category
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|cat_name
parameter_list|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
decl_stmt|;
while|while
condition|(
name|category
operator|&&
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
operator|!=
name|cat_name
condition|)
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
expr_stmt|;
return|return
name|category
return|;
block|}
end_function

begin_comment
comment|/* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_category
parameter_list|(
name|tree
name|cat
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|cat_name_expr
decl_stmt|,
name|class_name_expr
decl_stmt|;
name|tree
name|protocol_decl
decl_stmt|,
name|category
decl_stmt|;
name|add_class_reference
argument_list|(
name|CLASS_NAME
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
name|cat_name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|class_name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|cat
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|category
operator|=
name|lookup_category
argument_list|(
name|implementation_template
argument_list|,
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|&&
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
block|{
name|generate_protocol_references
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_decl
operator|=
name|generate_protocol_list
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
else|else
name|protocol_decl
operator|=
literal|0
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_category_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_category_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|cat_name_expr
argument_list|,
name|class_name_expr
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static struct objc_class _OBJC_METACLASS_Foo={ ... };    static struct objc_class _OBJC_CLASS_Foo={ ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_shared_structures
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|name_expr
decl_stmt|,
name|super_expr
decl_stmt|,
name|root_expr
decl_stmt|;
name|tree
name|my_root_id
init|=
name|NULL_TREE
decl_stmt|,
name|my_super_id
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cast_type
decl_stmt|,
name|initlist
decl_stmt|,
name|protocol_decl
decl_stmt|;
name|my_super_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_super_id
condition|)
block|{
name|add_class_reference
argument_list|(
name|my_super_id
argument_list|)
expr_stmt|;
comment|/* Compute "my_root_id" - this is required for code generation.          the "isa" for all meta class structures points to the root of          the inheritance hierarchy (e.g. "__Object")...  */
name|my_root_id
operator|=
name|my_super_id
expr_stmt|;
do|do
block|{
name|tree
name|my_root_int
init|=
name|lookup_interface
argument_list|(
name|my_root_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|my_root_int
operator|&&
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
condition|)
name|my_root_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
else|else
comment|/* No super class.  */
name|my_root_id
operator|=
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
name|cast_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
comment|/* Install class `isa' and `super' pointers at runtime.  */
if|if
condition|(
name|my_super_id
condition|)
block|{
name|super_expr
operator|=
name|add_objc_string
argument_list|(
name|my_super_id
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_c_cast
argument_list|(
name|cast_type
argument_list|,
name|super_expr
argument_list|)
expr_stmt|;
comment|/* cast! */
block|}
else|else
name|super_expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|root_expr
operator|=
name|add_objc_string
argument_list|(
name|my_root_id
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|root_expr
operator|=
name|build_c_cast
argument_list|(
name|cast_type
argument_list|,
name|root_expr
argument_list|)
expr_stmt|;
comment|/* cast! */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
condition|)
block|{
name|generate_protocol_references
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_decl
operator|=
name|generate_protocol_list
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
block|}
else|else
name|protocol_decl
operator|=
literal|0
expr_stmt|;
comment|/* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|root_expr
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|objc_class_template
argument_list|)
argument_list|)
argument_list|,
literal|2
comment|/*CLS_META*/
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|,
name|UOBJC_CLASS_VARIABLES_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* static struct objc_class _OBJC_CLASS_Foo={ ... }; */
name|decl
operator|=
name|start_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|UOBJC_CLASS_decl
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_METACLASS_decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
comment|/*CLS_FACTORY*/
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_INSTANCE_VARIABLES_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|synth_id_with_class_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|preamble
parameter_list|,
name|tree
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s"
argument_list|,
name|preamble
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|ctxt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
block|{
comment|/* We have a category.  */
specifier|const
name|char
modifier|*
specifier|const
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|class_super_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_super_name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|preamble
argument_list|,
name|class_name
argument_list|,
name|class_super_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
specifier|const
name|char
modifier|*
name|protocol_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|ctxt
argument_list|)
argument_list|)
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|protocol_name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s"
argument_list|,
name|preamble
argument_list|,
name|protocol_name
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_objc_type_qualifier
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_IN
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_OUT
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INOUT
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYCOPY
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYREF
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ONEWAY
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If type is empty or only type qualifiers are present, add default    type of id (otherwise grokdeclarator will default to int).  */
end_comment

begin_function
specifier|static
name|tree
name|adjust_type_for_id_default
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|declspecs
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
name|declspecs
operator|=
name|TREE_PURPOSE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Determine if a typespec is present.  */
for|for
control|(
name|chain
operator|=
name|declspecs
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
operator|)
condition|)
name|error
argument_list|(
literal|"can not use an object as parameter to a method\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_objc_type_qualifier
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|)
return|return
name|type
return|;
block|}
return|return
name|build_tree_list
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|,
name|declspecs
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Usage: 		keyworddecl: 			selector ':' '(' typename ')' identifier       Purpose: 		Transform an Objective-C keyword argument into 		the C equivalent parameter declarator.       In:	key_name, an "identifier_node" (optional). 		arg_type, a  "tree_list" (optional). 		arg_name, an "identifier_node".       Note:	It would be really nice to strongly type the preceding 		arguments in the function prototype; however, then I 		could not use the "accessor" macros defined in "tree.h".       Out:	an instance of "keyword_decl".  */
end_comment

begin_function
name|tree
name|build_keyword_decl
parameter_list|(
name|tree
name|key_name
parameter_list|,
name|tree
name|arg_type
parameter_list|,
name|tree
name|arg_name
parameter_list|)
block|{
name|tree
name|keyword_decl
decl_stmt|;
comment|/* If no type is specified, default to "id".  */
name|arg_type
operator|=
name|adjust_type_for_id_default
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|keyword_decl
operator|=
name|make_node
argument_list|(
name|KEYWORD_DECL
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_type
expr_stmt|;
name|KEYWORD_ARG_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_name
expr_stmt|;
name|KEYWORD_KEY_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|key_name
expr_stmt|;
return|return
name|keyword_decl
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of keyword_decl's, synthesize the full keyword selector.  */
end_comment

begin_function
specifier|static
name|tree
name|build_keyword_selector
parameter_list|(
name|tree
name|selector
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|tree
name|key_chain
decl_stmt|,
name|key_name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Scan the selector to see how much space we'll need.  */
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|len
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|key_name
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* Just a ':' arg.  */
name|len
operator|++
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Start the buffer out as an empty string.  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
comment|/* The keyword decl chain will later be used as a function argument 	     chain.  Unhook the selector itself so as to not confuse other 	     parts of the compiler.  */
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|key_name
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used for declarations and definitions.  */
end_comment

begin_function
name|tree
name|build_method_decl
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|ret_type
parameter_list|,
name|tree
name|selector
parameter_list|,
name|tree
name|add_args
parameter_list|)
block|{
name|tree
name|method_decl
decl_stmt|;
comment|/* If no type is specified, default to "id".  */
name|ret_type
operator|=
name|adjust_type_for_id_default
argument_list|(
name|ret_type
argument_list|)
expr_stmt|;
name|method_decl
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|method_decl
argument_list|)
operator|=
name|ret_type
expr_stmt|;
comment|/* If we have a keyword selector, create an identifier_node that      represents the full selector name (`:' included)...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|build_keyword_selector
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|add_args
expr_stmt|;
block|}
else|else
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|method_decl
return|;
block|}
end_function

begin_define
define|#
directive|define
name|METHOD_DEF
value|0
end_define

begin_define
define|#
directive|define
name|METHOD_REF
value|1
end_define

begin_comment
comment|/* Used by `build_objc_method_call' and `comp_proto_with_proto'.  Return    an argument list for method METH.  CONTEXT is either METHOD_DEF or    METHOD_REF, saying whether we are trying to define a method or call    one.  SUPERFLAG says this is for a send to super; this makes a    difference for the NeXT calling sequence in which the lookup and    the method call are done together.  If METH is null, user-defined    arguments (i.e., beyond self and _cmd) shall be represented by `...'.  */
end_comment

begin_function
specifier|static
name|tree
name|get_arg_type_list
parameter_list|(
name|tree
name|meth
parameter_list|,
name|int
name|context
parameter_list|,
name|int
name|superflag
parameter_list|)
block|{
name|tree
name|arglist
decl_stmt|,
name|akey
decl_stmt|;
comment|/* Receiver type.  */
if|if
condition|(
name|flag_next_runtime
operator|&&
name|superflag
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|super_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|==
name|METHOD_DEF
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|self_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|)
expr_stmt|;
comment|/* Selector type - will eventually change to `int'.  */
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No actual method prototype given -- assume that remaining arguments      are `...'.  */
if|if
condition|(
operator|!
name|meth
condition|)
return|return
name|arglist
return|;
comment|/* Build a list of argument types.  */
for|for
control|(
name|akey
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|meth
argument_list|)
init|;
name|akey
condition|;
name|akey
operator|=
name|TREE_CHAIN
argument_list|(
name|akey
argument_list|)
control|)
block|{
name|tree
name|arg_decl
init|=
name|groktypename_in_parm_context
argument_list|(
name|TREE_TYPE
argument_list|(
name|akey
argument_list|)
argument_list|)
decl_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
operator|==
name|objc_ellipsis_node
condition|)
comment|/* We have a `, ...' immediately following the selector,        finalize the arglist...simulate get_parm_info (0).  */
empty_stmt|;
elseif|else
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
condition|)
block|{
comment|/* we have a variable length selector */
name|tree
name|add_arg_list
init|=
name|TREE_CHAIN
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
argument_list|)
decl_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|add_arg_list
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* finalize the arglist...simulate get_parm_info (1) */
name|chainon
argument_list|(
name|arglist
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
expr_stmt|;
return|return
name|arglist
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|check_duplicates
parameter_list|(
name|hash
name|hsh
parameter_list|,
name|int
name|methods
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|tree
name|meth
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|hsh
condition|)
block|{
name|meth
operator|=
name|hsh
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
comment|/* We have two or more methods with the same name but 	     different types.  */
name|attr
name|loop
decl_stmt|;
name|warning
argument_list|(
literal|"multiple %s named `%c%s' found"
argument_list|,
name|methods
condition|?
literal|"methods"
else|:
literal|"selectors"
argument_list|,
operator|(
name|is_class
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
name|methods
condition|?
literal|"using"
else|:
literal|"found"
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
operator|)
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"also found"
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|loop
operator|->
name|value
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
operator|)
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|meth
return|;
block|}
end_function

begin_comment
comment|/* If RECEIVER is a class reference, return the identifier node for    the referenced class.  RECEIVER is created by get_class_reference,    so we check the exact form created depending on which runtimes are    used.  */
end_comment

begin_function
specifier|static
name|tree
name|receiver_is_class_object
parameter_list|(
name|tree
name|receiver
parameter_list|,
name|int
name|self
parameter_list|,
name|int
name|super
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|,
name|exp
decl_stmt|,
name|arg
decl_stmt|;
comment|/* The receiver is 'self' or 'super' in the context of a class method.  */
if|if
condition|(
name|objc_method_context
operator|&&
name|TREE_CODE
argument_list|(
name|objc_method_context
argument_list|)
operator|==
name|CLASS_METHOD_DECL
operator|&&
operator|(
name|self
operator|||
name|super
operator|)
condition|)
return|return
operator|(
name|super
condition|?
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
else|:
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|)
return|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* The receiver is a variable created by          build_class_reference_decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|objc_class_type
argument_list|)
condition|)
comment|/* Look up the identifier.  */
for|for
control|(
name|chain
operator|=
name|cls_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
operator|==
name|receiver
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
return|;
block|}
comment|/* The receiver is a function call that returns an id.  Check if      it is a call to objc_getClass, if so, pick up the class name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
comment|/* For some reason, we sometimes wind up with multiple FUNCTION_DECL 	 prototypes for objc_get_class().  Thankfuly, they seem to share the 	 same function type.  */
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|objc_get_class_decl
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|TAG_GETCLASS
argument_list|)
comment|/* We have a call to objc_get_class/objc_getClass!  */
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|STRING_CST
condition|)
comment|/* Finally, we have the class name.  */
return|return
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are currently building a message expr, this holds    the identifier of the selector of the message.  This is    used when printing warnings about argument mismatches.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_objc_message_selector
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|objc_message_selector
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_objc_message_selector
return|;
block|}
end_function

begin_comment
comment|/* Construct an expression for sending a message.    MESS has the object to send to in TREE_PURPOSE    and the argument list (including selector) in TREE_VALUE.     (*(<abstract_decl>(*)())_msg)(receiver, selTransTbl[n], ...);    (*(<abstract_decl>(*)())_msgSuper)(receiver, selTransTbl[n], ...);  */
end_comment

begin_function
name|tree
name|build_message_expr
parameter_list|(
name|tree
name|mess
parameter_list|)
block|{
name|tree
name|receiver
init|=
name|TREE_PURPOSE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
name|tree
name|sel_name
decl_stmt|;
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
name|tree
name|method_params
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Obtain the full selector name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* A unary selector.  */
name|sel_name
operator|=
name|args
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|sel_name
operator|=
name|build_keyword_selector
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Build the parameter list to give to the method.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|chain
init|=
name|args
decl_stmt|,
name|prev
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We have a keyword selector--check for comma expressions.  */
while|while
condition|(
name|chain
condition|)
block|{
name|tree
name|element
init|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
decl_stmt|;
comment|/* We have a comma expression, must collapse...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|element
expr_stmt|;
else|else
name|args
operator|=
name|element
expr_stmt|;
block|}
name|prev
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|method_params
operator|=
name|args
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Must wait until template instantiation time.  */
return|return
name|build_min_nt
argument_list|(
name|MESSAGE_SEND_EXPR
argument_list|,
name|receiver
argument_list|,
name|sel_name
argument_list|,
name|method_params
argument_list|)
return|;
endif|#
directive|endif
return|return
name|finish_message_expr
argument_list|(
name|receiver
argument_list|,
name|sel_name
argument_list|,
name|method_params
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up method SEL_NAME that would be suitable for receiver    of type 'id' (if IS_CLASS is zero) or 'Class' (if IS_CLASS is    nonzero), and report on any duplicates.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_method_in_hash_lists
parameter_list|(
name|tree
name|sel_name
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|hash
name|method_prototype
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|is_class
condition|)
name|method_prototype
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|method_prototype
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
name|is_class
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|check_duplicates
argument_list|(
name|method_prototype
argument_list|,
literal|1
argument_list|,
name|is_class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The 'finish_message_expr' routine is called from within    'build_message_expr' for non-template functions.  In the case of    C++ template functions, it is called from 'build_expr_from_tree'    (in decl2.c) after RECEIVER and METHOD_PARAMS have been expanded.  */
end_comment

begin_function
name|tree
name|finish_message_expr
parameter_list|(
name|tree
name|receiver
parameter_list|,
name|tree
name|sel_name
parameter_list|,
name|tree
name|method_params
parameter_list|)
block|{
name|tree
name|method_prototype
init|=
name|NULL_TREE
decl_stmt|,
name|rprotos
init|=
name|NULL_TREE
decl_stmt|,
name|rtype
decl_stmt|;
name|tree
name|selector
decl_stmt|,
name|retval
decl_stmt|,
name|is_class
decl_stmt|;
name|int
name|self
decl_stmt|,
name|super
decl_stmt|,
name|have_cast
decl_stmt|;
comment|/* Extract the receiver of the message, as well as its type      (where the latter may take the form of a cast or be inferred      from the implementation context).  */
name|rtype
operator|=
name|receiver
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|rtype
operator|=
name|TREE_OPERAND
argument_list|(
name|rtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|self
operator|=
operator|(
name|rtype
operator|==
name|self_decl
operator|)
expr_stmt|;
name|super
operator|=
operator|(
name|rtype
operator|==
name|UOBJC_SUPER_decl
operator|)
expr_stmt|;
name|rtype
operator|=
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|have_cast
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|NOP_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|!
name|IS_SUPER
argument_list|(
name|rtype
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If the receiver is a class object, retrieve the corresponding      @interface, if one exists. */
name|is_class
operator|=
name|receiver_is_class_object
argument_list|(
name|receiver
argument_list|,
name|self
argument_list|,
name|super
argument_list|)
expr_stmt|;
comment|/* Now determine the receiver type (if an explicit cast has not been      provided).  */
if|if
condition|(
operator|!
name|have_cast
condition|)
block|{
if|if
condition|(
name|is_class
condition|)
name|rtype
operator|=
name|lookup_interface
argument_list|(
name|is_class
argument_list|)
expr_stmt|;
comment|/* Handle `self' and `super'.  */
elseif|else
if|if
condition|(
name|super
condition|)
block|{
if|if
condition|(
operator|!
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no super class declared in @interface for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rtype
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|self
condition|)
name|rtype
operator|=
name|lookup_interface
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If receiver is of type `id' or `Class' (or if the @interface for a      class is not visible), we shall be satisfied with the existence of      any instance or class method. */
if|if
condition|(
operator|!
name|rtype
operator|||
name|IS_ID
argument_list|(
name|rtype
argument_list|)
operator|||
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|objc_class_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtype
condition|)
name|rtype
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|is_class
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_ID
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|rprotos
operator|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|is_class
operator|=
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
operator|=
name|get_identifier
argument_list|(
literal|"Class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rprotos
condition|)
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|rprotos
argument_list|,
name|sel_name
argument_list|,
name|is_class
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
operator|&&
operator|!
name|rprotos
condition|)
name|method_prototype
operator|=
name|lookup_method_in_hash_lists
argument_list|(
name|sel_name
argument_list|,
name|is_class
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|orig_rtype
init|=
name|rtype
decl_stmt|,
name|saved_rtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|rtype
operator|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
comment|/* Traverse typedef aliases */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
condition|)
name|rtype
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
expr_stmt|;
name|saved_rtype
operator|=
name|rtype
expr_stmt|;
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|rprotos
operator|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|lookup_interface
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we could not find an @interface declaration, we must have 	 only seen a @class declaration; so, we cannot say anything 	 more intelligent about which methods the receiver will 	 understand. */
if|if
condition|(
operator|!
name|rtype
condition|)
name|rtype
operator|=
name|saved_rtype
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* We have a valid ObjC class name.  Look up the method name 	     in the published @interface for the class (and its 	     superclasses). */
name|method_prototype
operator|=
name|lookup_method_static
argument_list|(
name|rtype
argument_list|,
name|sel_name
argument_list|,
name|is_class
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If the method was not found in the @interface, it may still 	     exist locally as part of the @implementation.  */
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|objc_implementation_context
operator|&&
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
condition|)
name|method_prototype
operator|=
name|lookup_method
argument_list|(
operator|(
name|is_class
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
operator|)
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
comment|/* If we haven't found a candidate method by now, try looking for 	     it in the protocol list.  */
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|rprotos
condition|)
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|rprotos
argument_list|,
name|sel_name
argument_list|,
name|is_class
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"invalid receiver type `%s'"
argument_list|,
name|gen_declaration
argument_list|(
name|orig_rtype
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|rprotos
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
specifier|static
name|bool
name|warn_missing_methods
init|=
name|false
decl_stmt|;
if|if
condition|(
name|rtype
condition|)
name|warning
argument_list|(
literal|"`%s' may not respond to `%c%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
argument_list|,
operator|(
name|is_class
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rprotos
condition|)
name|warning
argument_list|(
literal|"`%c%s' not implemented by protocol(s)"
argument_list|,
operator|(
name|is_class
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|warn_missing_methods
condition|)
block|{
name|warning
argument_list|(
literal|"(Messages without a matching method signature"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"will be assumed to return `id' and accept"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"`...' as arguments.)"
argument_list|)
expr_stmt|;
name|warn_missing_methods
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Save the selector name for printing error messages.  */
name|current_objc_message_selector
operator|=
name|sel_name
expr_stmt|;
comment|/* Build the parameters list for looking up the method.      These are the object itself and the selector.  */
if|if
condition|(
name|flag_typed_selectors
condition|)
name|selector
operator|=
name|build_typed_selector_reference
argument_list|(
name|sel_name
argument_list|,
name|method_prototype
argument_list|)
expr_stmt|;
else|else
name|selector
operator|=
name|build_selector_reference
argument_list|(
name|sel_name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_objc_method_call
argument_list|(
name|super
argument_list|,
name|method_prototype
argument_list|,
name|receiver
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
expr_stmt|;
name|current_objc_message_selector
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a tree expression to send OBJECT the operation SELECTOR,    looking up the method on object LOOKUP_OBJECT (often same as OBJECT),    assuming the method has prototype METHOD_PROTOTYPE.    (That is an INSTANCE_METHOD_DECL or CLASS_METHOD_DECL.)    Use METHOD_PARAMS as list of args to pass to the method.    If SUPER_FLAG is nonzero, we look up the superclass's method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_objc_method_call
parameter_list|(
name|int
name|super_flag
parameter_list|,
name|tree
name|method_prototype
parameter_list|,
name|tree
name|lookup_object
parameter_list|,
name|tree
name|selector
parameter_list|,
name|tree
name|method_params
parameter_list|)
block|{
name|tree
name|sender
init|=
operator|(
name|super_flag
condition|?
name|umsg_super_decl
else|:
operator|(
operator|!
name|flag_next_runtime
operator|||
name|flag_nil_receivers
condition|?
name|umsg_decl
else|:
name|umsg_nonnil_decl
operator|)
operator|)
decl_stmt|;
name|tree
name|rcv_p
init|=
operator|(
name|super_flag
condition|?
name|super_type
else|:
name|id_type
operator|)
decl_stmt|;
comment|/* If a prototype for the method to be called exists, then cast      the sender's return type and arguments to match that of the method.      Otherwise, leave sender as is.  */
name|tree
name|ret_type
init|=
operator|(
name|method_prototype
condition|?
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_prototype
argument_list|)
argument_list|)
else|:
name|id_type
operator|)
decl_stmt|;
name|tree
name|sender_cast
init|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|ret_type
argument_list|,
name|get_arg_type_list
argument_list|(
name|method_prototype
argument_list|,
name|METHOD_REF
argument_list|,
name|super_flag
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|lookup_object
operator|=
name|build_c_cast
argument_list|(
name|rcv_p
argument_list|,
name|lookup_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* If we are returning a struct in memory, and the address 	 of that memory location is passed as a hidden first 	 argument, then change which messenger entry point this 	 expr will call.  NB: Note that sender_cast remains 	 unchanged (it already has a struct return type).  */
if|if
condition|(
operator|!
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|return_in_memory
argument_list|(
name|ret_type
argument_list|,
literal|0
argument_list|)
condition|)
name|sender
operator|=
operator|(
name|super_flag
condition|?
name|umsg_super_stret_decl
else|:
name|flag_nil_receivers
condition|?
name|umsg_stret_decl
else|:
name|umsg_nonnil_stret_decl
operator|)
expr_stmt|;
name|method_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|sender
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|sender
argument_list|)
expr_stmt|;
comment|/* We want to cast the sender, not convert it.  */
return|return
name|build_function_call
argument_list|(
name|build_c_cast
argument_list|(
name|sender_cast
argument_list|,
name|sender
argument_list|)
argument_list|,
name|method_params
argument_list|)
return|;
block|}
else|else
block|{
comment|/* This is the portable (GNU) way.  */
name|tree
name|method
decl_stmt|,
name|object
decl_stmt|;
comment|/* First, call the lookup function to get a pointer to the method, 	 then cast the pointer, then call it with the method arguments. 	 Use SAVE_EXPR to avoid evaluating the receiver twice.  */
name|lookup_object
operator|=
name|save_expr
argument_list|(
name|lookup_object
argument_list|)
expr_stmt|;
name|object
operator|=
operator|(
name|super_flag
condition|?
name|self_decl
else|:
name|lookup_object
operator|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|sender
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|sender
argument_list|)
expr_stmt|;
name|method
operator|=
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass the object to the method.  */
name|TREE_USED
argument_list|(
name|method
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|method
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|build_c_cast
argument_list|(
name|sender_cast
argument_list|,
name|method
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|build_protocol_reference
parameter_list|(
name|tree
name|p
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|,
name|ptype
decl_stmt|;
comment|/* static struct objc_protocol _OBJC_PROTOCOL_<mumble>; */
name|ident
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_protocol_template
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier_global_value
argument_list|(
name|ident
argument_list|)
condition|)
name|decl
operator|=
name|identifier_global_value
argument_list|(
name|ident
argument_list|)
expr_stmt|;
comment|/* Set by pushdecl.  */
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called by the parser when (and only when) a    @protocol() expression is found, in order to compile it.  */
end_comment

begin_function
name|tree
name|build_protocol_expr
parameter_list|(
name|tree
name|protoname
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|p
init|=
name|lookup_protocol
argument_list|(
name|protoname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"cannot find protocol declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|protoname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
condition|)
name|build_protocol_reference
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|protocol_type
expr_stmt|;
comment|/* The @protocol() expression is being compiled into a pointer to a      statically allocated instance of the Protocol class.  To become      usable at runtime, the 'isa' pointer of the instance need to be      fixed up at runtime by the runtime library, to point to the      actual 'Protocol' class.  */
comment|/* For the GNU runtime, put the static Protocol instance in the list      of statically allocated instances, so that we make sure that its      'isa' pointer is fixed up at runtime by the GNU runtime library      to point to the Protocol class (at runtime, when loading the      module, the GNU runtime library loops on the statically allocated      instances (as found in the defs field in objc_symtab) and fixups      all the 'isa' pointers of those objects).  */
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* This type is a struct containing the fields of a Protocol         object.  (Cfr. protocol_type instead is the type of a pointer         to such a struct).  */
name|tree
name|protocol_struct_type
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|chain
decl_stmt|;
comment|/* Look for the list of Protocol statically allocated instances         to fixup at runtime.  Create a new list to hold Protocol         statically allocated instances, if the list is not found.  At         present there is only another list, holding NSConstantString         static instances to be fixed up at runtime.  */
for|for
control|(
name|chain
operator|=
operator|&
name|objc_static_instances
init|;
operator|*
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|!=
name|protocol_struct_type
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|chain
condition|)
block|{
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_struct_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_objc_string
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|protocol_struct_type
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
block|}
comment|/* Add this statically allocated instance to the Protocol list.  */
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* This function is called by the parser when a @selector() expression    is found, in order to compile it.  It is only called by the parser    and only to compile a @selector().  */
end_comment

begin_function
name|tree
name|build_selector_expr
parameter_list|(
name|tree
name|selnamelist
parameter_list|)
block|{
name|tree
name|selname
decl_stmt|;
comment|/* Obtain the full selector name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* A unary selector.  */
name|selname
operator|=
name|selnamelist
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|selname
operator|=
name|build_keyword_selector
argument_list|(
name|selnamelist
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If we are required to check @selector() expressions as they      are found, check that the selector has been declared.  */
if|if
condition|(
name|warn_undeclared_selector
condition|)
block|{
comment|/* Look the selector up in the list of all known class and          instance methods (up to this line) to check that the selector          exists.  */
name|hash
name|hsh
decl_stmt|;
comment|/* First try with instance methods.  */
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|selname
argument_list|)
expr_stmt|;
comment|/* If not found, try with class methods.  */
if|if
condition|(
operator|!
name|hsh
condition|)
block|{
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|selname
argument_list|)
expr_stmt|;
block|}
comment|/* If still not found, print out a warning.  */
if|if
condition|(
operator|!
name|hsh
condition|)
block|{
name|warning
argument_list|(
literal|"undeclared selector `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|selname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_typed_selectors
condition|)
return|return
name|build_typed_selector_reference
argument_list|(
name|selname
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|build_selector_reference
argument_list|(
name|selname
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_encode_expr
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|encode_type
argument_list|(
name|type
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* null terminate string */
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
comment|/* Synthesize a string that represents the encoded struct/union.  */
name|result
operator|=
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|build_ivar_reference
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_method_context
argument_list|)
operator|==
name|CLASS_METHOD_DECL
condition|)
block|{
comment|/* Historically, a class method that produced objects (factory 	 method) would assign `self' to the instance that it 	 allocated.  This would effectively turn the class method into 	 an instance method.  Following this assignment, the instance 	 variables could be accessed.  That practice, while safe, 	 violates the simple rule that a class method should not refer 	 to an instance variable.  It's better to catch the cases 	 where this is done unknowingly than to support the above 	 paradigm.  */
name|warning
argument_list|(
literal|"instance variable `%s' accessed in class method"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|self_decl
argument_list|)
operator|=
name|instance_type
expr_stmt|;
comment|/* cast */
block|}
return|return
name|build_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|self_decl
argument_list|,
literal|"->"
argument_list|)
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a hash value for a given method SEL_NAME.  */
end_comment

begin_function
specifier|static
name|size_t
name|hash_func
parameter_list|(
name|tree
name|sel_name
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
decl_stmt|;
name|size_t
name|h
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|h
operator|=
name|h
operator|*
literal|67
operator|+
operator|*
name|s
operator|++
operator|-
literal|113
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_init
parameter_list|(
name|void
parameter_list|)
block|{
name|nst_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|cls_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WARNING!!!!  hash_enter is called with a method, and will peek    inside to find its selector!  But hash_lookup is given a selector    directly, and looks for the selector that's inside the found    entry's key (method) for comparison.  */
end_comment

begin_function
specifier|static
name|void
name|hash_enter
parameter_list|(
name|hash
modifier|*
name|hashlist
parameter_list|,
name|tree
name|method
parameter_list|)
block|{
name|hash
name|obj
decl_stmt|;
name|int
name|slot
init|=
name|hash_func
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|%
name|SIZEHASHTABLE
decl_stmt|;
name|obj
operator|=
operator|(
name|hash
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashed_entry
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|list
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|hashlist
index|[
name|slot
index|]
expr_stmt|;
name|obj
operator|->
name|key
operator|=
name|method
expr_stmt|;
name|hashlist
index|[
name|slot
index|]
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_function
specifier|static
name|hash
name|hash_lookup
parameter_list|(
name|hash
modifier|*
name|hashlist
parameter_list|,
name|tree
name|sel_name
parameter_list|)
block|{
name|hash
name|target
decl_stmt|;
name|target
operator|=
name|hashlist
index|[
name|hash_func
argument_list|(
name|sel_name
argument_list|)
operator|%
name|SIZEHASHTABLE
index|]
expr_stmt|;
while|while
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|sel_name
operator|==
name|METHOD_SEL_NAME
argument_list|(
name|target
operator|->
name|key
argument_list|)
condition|)
return|return
name|target
return|;
name|target
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_add_attr
parameter_list|(
name|hash
name|entry
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|attr
name|obj
decl_stmt|;
name|obj
operator|=
operator|(
name|attr
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashed_attribute
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|entry
operator|->
name|list
expr_stmt|;
name|obj
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|list
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|lookup_method
parameter_list|(
name|tree
name|mchain
parameter_list|,
name|tree
name|method
parameter_list|)
block|{
name|tree
name|key
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|key
operator|=
name|method
expr_stmt|;
else|else
name|key
operator|=
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
expr_stmt|;
while|while
condition|(
name|mchain
condition|)
block|{
if|if
condition|(
name|METHOD_SEL_NAME
argument_list|(
name|mchain
argument_list|)
operator|==
name|key
condition|)
return|return
name|mchain
return|;
name|mchain
operator|=
name|TREE_CHAIN
argument_list|(
name|mchain
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_method_static
parameter_list|(
name|tree
name|interface
parameter_list|,
name|tree
name|ident
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|tree
name|meth
init|=
name|NULL_TREE
decl_stmt|,
name|root_inter
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|inter
init|=
name|interface
decl_stmt|;
while|while
condition|(
name|inter
condition|)
block|{
name|tree
name|chain
init|=
name|is_class
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|inter
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|category
init|=
name|inter
decl_stmt|;
comment|/* First, look up the method in the class itself.  */
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
comment|/* Failing that, look for the method in each category of the class.  */
while|while
condition|(
operator|(
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|)
condition|)
block|{
name|chain
operator|=
name|is_class
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
comment|/* Check directly in each category.  */
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
comment|/* Failing that, check in each category's protocols.  */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|,
name|ident
argument_list|,
name|is_class
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
block|}
comment|/* If not found in categories, check in protocols of the main class.  */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
argument_list|,
name|ident
argument_list|,
name|is_class
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
comment|/* Failing that, climb up the inheritance hierarchy.  */
name|root_inter
operator|=
name|inter
expr_stmt|;
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|inter
condition|)
empty_stmt|;
comment|/* If no class (factory) method was found, check if an _instance_      method of the same name exists in the root class.  This is what      the Objective-C runtime will do.  If an instance method was not      found, return 0.  */
return|return
name|is_class
condition|?
name|lookup_method_static
argument_list|(
name|root_inter
argument_list|,
name|ident
argument_list|,
literal|0
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Add the method to the hash list if it doesn't contain an identical    method already. */
end_comment

begin_function
specifier|static
name|void
name|add_method_to_hash_list
parameter_list|(
name|hash
modifier|*
name|hash_list
parameter_list|,
name|tree
name|method
parameter_list|)
block|{
name|hash
name|hsh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|hash_list
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Install on a global chain.  */
name|hash_enter
argument_list|(
name|hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check types against those; if different, add to a list.  */
name|attr
name|loop
decl_stmt|;
name|int
name|already_there
init|=
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|hsh
operator|->
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
operator|!
name|already_there
operator|&&
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|already_there
operator||=
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already_there
condition|)
name|hash_add_attr
argument_list|(
name|hsh
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|objc_add_method
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|method
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|tree
name|mth
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mth
operator|=
name|lookup_method
argument_list|(
name|is_class
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
argument_list|,
name|method
argument_list|)
operator|)
condition|)
block|{
comment|/* put method on list in reverse order */
if|if
condition|(
name|is_class
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* When processing an @interface for a class or category, give hard 	 errors on methods with identical selectors but differing argument 	 and/or return types. We do not do this for @implementations, because 	 C/C++ will do it for us (i.e., there will be duplicate function 	 definition errors).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
operator|)
operator|&&
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|mth
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate declaration of method `%c%s'"
argument_list|,
name|is_class
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_class
condition|)
name|add_method_to_hash_list
argument_list|(
name|cls_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
else|else
block|{
name|add_method_to_hash_list
argument_list|(
name|nst_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
comment|/* Instance methods in root classes (and categories thereof) 	 may acts as class methods as a last resort. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|class
operator|=
name|lookup_interface
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|!=
name|PROTOCOL_INTERFACE_TYPE
operator|&&
operator|!
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
condition|)
name|add_method_to_hash_list
argument_list|(
name|cls_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
return|return
name|method
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|add_class
parameter_list|(
name|tree
name|class
parameter_list|)
block|{
comment|/* Put interfaces on list in reverse order.  */
name|TREE_CHAIN
argument_list|(
name|class
argument_list|)
operator|=
name|interface_chain
expr_stmt|;
name|interface_chain
operator|=
name|class
expr_stmt|;
return|return
name|interface_chain
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_category
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|category
parameter_list|)
block|{
comment|/* Put categories on list in reverse order.  */
name|tree
name|cat
init|=
name|lookup_category
argument_list|(
name|class
argument_list|,
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cat
condition|)
block|{
name|warning
argument_list|(
literal|"duplicate interface declaration for category `%s(%s)'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
operator|=
name|category
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after parsing each instance variable declaration. Necessary to    preserve typedefs and implement public/private...     PUBLIC is 1 for public, 0 for protected, and 2 for private.  */
end_comment

begin_function
name|tree
name|add_instance_variable
parameter_list|(
name|tree
name|class
parameter_list|,
name|int
name|public
parameter_list|,
name|tree
name|declarator
parameter_list|,
name|tree
name|declspecs
parameter_list|,
name|tree
name|width
parameter_list|)
block|{
name|tree
name|field_decl
init|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|tree
name|field_type
init|=
name|TREE_TYPE
argument_list|(
name|field_decl
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ivar_name
init|=
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
argument_list|)
else|:
literal|"<unnamed>"
decl_stmt|;
name|tree
name|raw_decl
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"illegal reference type specified for instance variable `%s'"
argument_list|,
name|ivar_name
argument_list|)
expr_stmt|;
comment|/* Return class as is without adding this ivar.  */
return|return
name|class
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|field_type
operator|==
name|error_mark_node
operator|||
operator|!
name|TYPE_SIZE
argument_list|(
name|field_type
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|field_type
argument_list|)
operator|==
name|error_mark_node
comment|/* 'type[0]' is allowed, but 'type[]' is not! */
ifdef|#
directive|ifdef
name|OBJCPLUS
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|field_type
argument_list|)
operator|==
name|bitsize_zero_node
operator|&&
operator|!
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|"instance variable `%s' has unknown size"
argument_list|,
name|ivar_name
argument_list|)
expr_stmt|;
comment|/* Return class as is without adding this ivar.  */
return|return
name|class
return|;
block|}
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* zlaski 2001-Apr-24: C++ classes with non-trivial constructors and/or destructors      cannot be ivars; ditto for classes with vtables. */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|field_type
argument_list|)
operator|&&
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|field_type
argument_list|)
operator|||
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|field_type
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|field_type
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|type_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|field_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|field_type
argument_list|)
condition|)
block|{
comment|/* vtable pointers are Real Bad(tm), since Obj-C cannot initialize them */
name|error
argument_list|(
literal|"type `%s' has virtual member functions"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"illegal aggregate type `%s' specified for instance variable `%s'"
argument_list|,
name|type_name
argument_list|,
name|ivar_name
argument_list|)
expr_stmt|;
comment|/* Return class as is without adding this ivar.  */
return|return
name|class
return|;
block|}
comment|/* user-defined constructors and destructors are not known to Obj-C and          hence will not be called.  This may or may not be a problem. */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|field_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"type `%s' has a user-defined constructor"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|field_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"type `%s' has a user-defined destructor"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"C++ constructors and destructors will not be invoked for Objective-C fields"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Overload the public attribute, it is not used for FIELD_DECLs.  */
switch|switch
condition|(
name|public
condition|)
block|{
case|case
literal|0
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|raw_decl
operator|=
name|build_tree_list
argument_list|(
name|declspecs
argument_list|,
name|build_tree_list
argument_list|(
name|declarator
argument_list|,
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
argument_list|,
name|raw_decl
argument_list|)
expr_stmt|;
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|is_ivar
parameter_list|(
name|tree
name|decl_chain
parameter_list|,
name|tree
name|ident
parameter_list|)
block|{
for|for
control|(
init|;
name|decl_chain
condition|;
name|decl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_chain
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl_chain
argument_list|)
operator|==
name|ident
condition|)
return|return
name|decl_chain
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* True if the ivar is private and we are not in its implementation.  */
end_comment

begin_function
name|int
name|is_private
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|is_ivar
argument_list|(
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We have an instance variable reference;, check to see if it is public.  */
end_comment

begin_function
name|int
name|is_public
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|identifier
parameter_list|)
block|{
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_STATIC_TEMPLATE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_interface
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|decl
operator|=
name|is_ivar
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|identifier
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Important difference between the Stepstone translator: 		 all instance variables should be public within the context 		 of the implementation.  */
if|if
condition|(
name|objc_implementation_context
operator|&&
operator|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|)
operator|)
operator|&&
operator|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|OBJC_TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|private
init|=
name|is_private
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|private
condition|)
name|error
argument_list|(
literal|"instance variable `%s' is declared private"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|private
return|;
block|}
comment|/* The 2.95.2 compiler sometimes allowed C functions to access 		 non-@public ivars.  We will let this slide for now...  */
if|if
condition|(
operator|!
name|objc_method_context
condition|)
block|{
name|warning
argument_list|(
literal|"instance variable `%s' is %s; "
literal|"this will be a hard error in the future"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|?
literal|"@private"
else|:
literal|"@protected"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|error
argument_list|(
literal|"instance variable `%s' is declared %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|?
literal|"private"
else|:
literal|"protected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|objc_implementation_context
operator|&&
operator|(
name|basetype
operator|==
name|objc_object_reference
operator|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|uprivate_record
expr_stmt|;
name|warning
argument_list|(
literal|"static access to object of type `id'"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure all entries in CHAIN are also in LIST.  */
end_comment

begin_function
specifier|static
name|int
name|check_methods
parameter_list|(
name|tree
name|chain
parameter_list|,
name|tree
name|list
parameter_list|,
name|int
name|mtype
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_method
argument_list|(
name|list
argument_list|,
name|chain
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of category `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|warning
argument_list|(
literal|"method definition for `%c%s' not found"
argument_list|,
name|mtype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Check if CLASS, or its superclasses, explicitly conforms to PROTOCOL.  */
end_comment

begin_function
specifier|static
name|int
name|conforms_to_protocol
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|protocol
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|protocol
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|tree
name|p
init|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|class
argument_list|)
decl_stmt|;
while|while
condition|(
name|p
operator|&&
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|!=
name|protocol
condition|)
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|tree
name|super
init|=
operator|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
decl_stmt|;
name|int
name|tmp
init|=
name|super
condition|?
name|conforms_to_protocol
argument_list|(
name|super
argument_list|,
name|protocol
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make sure all methods in CHAIN are accessible as MTYPE methods in    CONTEXT.  This is one of two mechanisms to check protocol integrity.  */
end_comment

begin_function
specifier|static
name|int
name|check_methods_accessible
parameter_list|(
name|tree
name|chain
parameter_list|,
name|tree
name|context
parameter_list|,
name|int
name|mtype
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|base_context
init|=
name|context
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|context
operator|=
name|base_context
expr_stmt|;
while|while
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|mtype
operator|==
literal|'+'
condition|)
name|list
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|list
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_method
argument_list|(
name|list
argument_list|,
name|chain
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
name|context
operator|=
operator|(
name|CLASS_SUPER_NAME
argument_list|(
name|context
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|context
operator|=
operator|(
name|CLASS_NAME
argument_list|(
name|context
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of category `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|warning
argument_list|(
literal|"method definition for `%c%s' not found"
argument_list|,
name|mtype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* next method...  */
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Check whether the current interface (accessible via    'objc_implementation_context') actually implements protocol P, along    with any protocols that P inherits.  */
end_comment

begin_function
specifier|static
name|void
name|check_protocol
parameter_list|(
name|tree
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|int
name|f1
decl_stmt|,
name|f2
decl_stmt|;
comment|/* Ensure that all protocols have bodies!  */
if|if
condition|(
name|warn_protocol
condition|)
block|{
name|f1
operator|=
name|check_methods
argument_list|(
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|CLASS_CLS_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|f2
operator|=
name|check_methods
argument_list|(
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|CLASS_NST_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f1
operator|=
name|check_methods_accessible
argument_list|(
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|objc_implementation_context
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|f2
operator|=
name|check_methods_accessible
argument_list|(
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|objc_implementation_context
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1
operator|||
operator|!
name|f2
condition|)
name|warning
argument_list|(
literal|"%s `%s' does not fully implement the `%s' protocol"
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check protocols recursively.  */
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|tree
name|subs
init|=
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|tree
name|super_class
init|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|subs
condition|)
block|{
name|tree
name|sub
init|=
name|TREE_VALUE
argument_list|(
name|subs
argument_list|)
decl_stmt|;
comment|/* If the superclass does not conform to the protocols 	     inherited by P, then we must!  */
if|if
condition|(
operator|!
name|super_class
operator|||
operator|!
name|conforms_to_protocol
argument_list|(
name|super_class
argument_list|,
name|sub
argument_list|)
condition|)
name|check_protocol
argument_list|(
name|sub
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|subs
operator|=
name|TREE_CHAIN
argument_list|(
name|subs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check whether the current interface (accessible via    'objc_implementation_context') actually implements the protocols listed    in PROTO_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|check_protocols
parameter_list|(
name|tree
name|proto_list
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
for|for
control|(
init|;
name|proto_list
condition|;
name|proto_list
operator|=
name|TREE_CHAIN
argument_list|(
name|proto_list
argument_list|)
control|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|proto_list
argument_list|)
decl_stmt|;
name|check_protocol
argument_list|(
name|p
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the class CLASS_NAME is defined    CODE says which kind of thing CLASS_NAME ought to be.    It can be CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,    CATEGORY_INTERFACE_TYPE, or CATEGORY_IMPLEMENTATION_TYPE.  */
end_comment

begin_function
name|tree
name|start_class
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|class_name
parameter_list|,
name|tree
name|super_name
parameter_list|,
name|tree
name|protocol_list
parameter_list|)
block|{
name|tree
name|class
decl_stmt|,
name|decl
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
block|{
name|error
argument_list|(
literal|"Objective-C declarations may only appear in global scope"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJCPLUS */
if|if
condition|(
name|objc_implementation_context
condition|)
block|{
name|warning
argument_list|(
literal|"`@end' missing in implementation context"
argument_list|)
expr_stmt|;
name|finish_class
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
name|objc_ivar_chain
operator|=
name|NULL_TREE
expr_stmt|;
name|objc_implementation_context
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|class
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|class
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
name|CLASS_BINFO_ELTS
argument_list|)
expr_stmt|;
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|class_name
expr_stmt|;
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|super_name
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|is_class_name
argument_list|(
name|class_name
argument_list|)
operator|&&
operator|(
name|decl
operator|=
name|lookup_name
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' redeclared as different kind of symbol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jprevious declaration of '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|implemented_classes
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|==
name|class_name
condition|)
block|{
name|error
argument_list|(
literal|"reimplementation of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|implemented_classes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_name
argument_list|,
name|implemented_classes
argument_list|)
expr_stmt|;
block|}
comment|/* Reset for multiple classes per file.  */
name|method_slot
operator|=
literal|0
expr_stmt|;
name|objc_implementation_context
operator|=
name|class
expr_stmt|;
comment|/* Lookup the interface for this implementation.  */
if|if
condition|(
operator|!
operator|(
name|implementation_template
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|add_class
argument_list|(
name|implementation_template
operator|=
name|objc_implementation_context
argument_list|)
expr_stmt|;
block|}
comment|/* If a super class has been specified in the implementation, 	 insure it conforms to the one specified in the interface.  */
if|if
condition|(
name|super_name
operator|&&
operator|(
name|super_name
operator|!=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|)
condition|)
block|{
name|tree
name|previous_name
init|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|previous_name
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|previous_name
argument_list|)
else|:
literal|""
decl_stmt|;
name|error
argument_list|(
literal|"conflicting super class name `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|super_name
condition|)
block|{
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|OBJCPLUS
name|error
argument_list|(
literal|"duplicate interface declaration for class `%s'"
argument_list|,
else|#
directive|else
argument|warning (
literal|"duplicate interface declaration for class `%s'"
argument|,
endif|#
directive|endif
argument|IDENTIFIER_POINTER (class_name));       else         add_class (class);        if (protocol_list) 	CLASS_PROTOCOL_LIST (class) 	  = lookup_and_install_protocols (protocol_list);     }    else if (code == CATEGORY_INTERFACE_TYPE)     {       tree class_category_is_assoc_with;
comment|/* For a category, class_name is really the name of the class that 	 the following set of methods will be associated with. We must 	 find the interface so that can derive the objects template.  */
argument|if (!(class_category_is_assoc_with = lookup_interface (class_name))) 	{ 	  error (
literal|"cannot find interface declaration for `%s'"
argument|, 		 IDENTIFIER_POINTER (class_name)); 	  exit (FATAL_EXIT_CODE); 	}       else         add_category (class_category_is_assoc_with, class);        if (protocol_list) 	CLASS_PROTOCOL_LIST (class) 	  = lookup_and_install_protocols (protocol_list);     }    else if (code == CATEGORY_IMPLEMENTATION_TYPE)     {
comment|/* Reset for multiple classes per file.  */
argument|method_slot =
literal|0
argument|;        objc_implementation_context = class;
comment|/* For a category, class_name is really the name of the class that 	 the following set of methods will be associated with.  We must 	 find the interface so that can derive the objects template.  */
argument|if (!(implementation_template = lookup_interface (class_name)))         { 	  error (
literal|"cannot find interface declaration for `%s'"
argument|, 		 IDENTIFIER_POINTER (class_name)); 	  exit (FATAL_EXIT_CODE);         }     }   return class; }  tree continue_class (tree class) {   if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE       || TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)     {       struct imp_entry *imp_entry;       tree ivar_context;
comment|/* Check consistency of the instance variables.  */
argument|if (CLASS_IVARS (class)) 	check_ivars (implementation_template, class);
comment|/* code generation */
argument|ivar_context = build_private_template (implementation_template);        if (!objc_class_template) 	build_class_template ();        imp_entry = (struct imp_entry *) ggc_alloc (sizeof (struct imp_entry));        imp_entry->next = imp_list;       imp_entry->imp_context = class;       imp_entry->imp_template = implementation_template;        synth_forward_declarations ();       imp_entry->class_decl = UOBJC_CLASS_decl;       imp_entry->meta_decl = UOBJC_METACLASS_decl;
comment|/* Append to front and increment count.  */
argument|imp_list = imp_entry;       if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE) 	imp_count++;       else 	cat_count++;        return ivar_context;     }    else if (TREE_CODE (class) == CLASS_INTERFACE_TYPE)     {       if (!CLASS_STATIC_TEMPLATE (class)) 	{ 	  tree record = start_struct (RECORD_TYPE, CLASS_NAME (class)); 	  finish_struct (record, get_class_ivars (class,
literal|0
argument|), NULL_TREE); 	  CLASS_STATIC_TEMPLATE (class) = record;
comment|/* Mark this record as a class template for static typing.  */
argument|TREE_STATIC_TEMPLATE (record) =
literal|1
argument|; 	}        return NULL_TREE;     }    else     return error_mark_node; }
comment|/* This is called once we see the "@end" in an interface/implementation.  */
argument|void finish_class (tree class) {   if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE)     {
comment|/* All code generation is done in finish_objc.  */
argument|if (implementation_template != objc_implementation_context) 	{
comment|/* Ensure that all method listed in the interface contain bodies.  */
argument|check_methods (CLASS_CLS_METHODS (implementation_template), 			 CLASS_CLS_METHODS (objc_implementation_context),
literal|'+'
argument|); 	  check_methods (CLASS_NST_METHODS (implementation_template), 			 CLASS_NST_METHODS (objc_implementation_context),
literal|'-'
argument|);  	  if (CLASS_PROTOCOL_LIST (implementation_template)) 	    check_protocols (CLASS_PROTOCOL_LIST (implementation_template),
literal|"class"
argument|, 			     IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context))); 	}     }    else if (TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)     {       tree category = lookup_category (implementation_template, CLASS_SUPER_NAME (class));        if (category) 	{
comment|/* Ensure all method listed in the interface contain bodies.  */
argument|check_methods (CLASS_CLS_METHODS (category), 			 CLASS_CLS_METHODS (objc_implementation_context),
literal|'+'
argument|); 	  check_methods (CLASS_NST_METHODS (category), 			 CLASS_NST_METHODS (objc_implementation_context),
literal|'-'
argument|);  	  if (CLASS_PROTOCOL_LIST (category)) 	    check_protocols (CLASS_PROTOCOL_LIST (category),
literal|"category"
argument|, 			     IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context))); 	}     }    else if (TREE_CODE (class) == CLASS_INTERFACE_TYPE)     {       tree decl_specs;       const char *class_name = IDENTIFIER_POINTER (CLASS_NAME (class));       char *string = (char *) alloca (strlen (class_name) +
literal|3
argument|);
comment|/* extern struct objc_object *_<my_name>; */
argument|sprintf (string,
literal|"_%s"
argument|, class_name);        decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_EXTERN]);       decl_specs = tree_cons (NULL_TREE, objc_object_reference, decl_specs);       define_decl (build1 (INDIRECT_REF, NULL_TREE, get_identifier (string)), 		   decl_specs);     } }  static tree add_protocol (tree protocol) {
comment|/* Put protocol on list in reverse order.  */
argument|TREE_CHAIN (protocol) = protocol_chain;   protocol_chain = protocol;   return protocol_chain; }  static tree lookup_protocol (tree ident) {   tree chain;    for (chain = protocol_chain; chain; chain = TREE_CHAIN (chain))     if (ident == PROTOCOL_NAME (chain))       return chain;    return NULL_TREE; }
comment|/* This function forward declares the protocols named by NAMES.  If    they are already declared or defined, the function has no effect.  */
argument|void objc_declare_protocols (tree names) {   tree list;
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|if (current_namespace != global_namespace) {     error (
literal|"Objective-C declarations may only appear in global scope"
argument|);   }
endif|#
directive|endif
comment|/* OBJCPLUS */
argument|for (list = names; list; list = TREE_CHAIN (list))     {       tree name = TREE_VALUE (list);        if (lookup_protocol (name) == NULL_TREE) 	{ 	  tree protocol = make_node (PROTOCOL_INTERFACE_TYPE);  	  TYPE_BINFO (protocol) = make_tree_vec (
literal|2
argument|); 	  PROTOCOL_NAME (protocol) = name; 	  PROTOCOL_LIST (protocol) = NULL_TREE; 	  add_protocol (protocol); 	  PROTOCOL_DEFINED (protocol) =
literal|0
argument|; 	  PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE; 	}     } }  tree start_protocol (enum tree_code code, tree name, tree list) {   tree protocol;
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|if (current_namespace != global_namespace) {     error (
literal|"Objective-C declarations may only appear in global scope"
argument|);   }
endif|#
directive|endif
comment|/* OBJCPLUS */
comment|/* This is as good a place as any.  Need to invoke      push_tag_toplevel.  */
argument|if (!objc_protocol_template)     objc_protocol_template = build_protocol_template ();    protocol = lookup_protocol (name);    if (!protocol)     {       protocol = make_node (code);       TYPE_BINFO (protocol) = make_tree_vec (
literal|2
argument|);        PROTOCOL_NAME (protocol) = name;       PROTOCOL_LIST (protocol) = lookup_and_install_protocols (list);       add_protocol (protocol);       PROTOCOL_DEFINED (protocol) =
literal|1
argument|;       PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE;        check_protocol_recursively (protocol, list);     }   else if (! PROTOCOL_DEFINED (protocol))     {       PROTOCOL_DEFINED (protocol) =
literal|1
argument|;       PROTOCOL_LIST (protocol) = lookup_and_install_protocols (list);        check_protocol_recursively (protocol, list);     }   else     {       warning (
literal|"duplicate declaration for protocol `%s'"
argument|, 	       IDENTIFIER_POINTER (name));     }   return protocol; }  void finish_protocol (tree protocol ATTRIBUTE_UNUSED) { }
comment|/* "Encode" a data type into a string, which grows in util_obstack.    ??? What is the FORMAT?  Someone please document this!  */
argument|static void encode_type_qualifiers (tree declspecs) {   tree spec;    for (spec = declspecs; spec; spec = TREE_CHAIN (spec))     {       if (ridpointers[(int) RID_CONST] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'r'
argument|);       else if (ridpointers[(int) RID_IN] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'n'
argument|);       else if (ridpointers[(int) RID_INOUT] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'N'
argument|);       else if (ridpointers[(int) RID_OUT] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'o'
argument|);       else if (ridpointers[(int) RID_BYCOPY] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'O'
argument|);       else if (ridpointers[(int) RID_BYREF] == TREE_VALUE (spec))         obstack_1grow (&util_obstack,
literal|'R'
argument|);       else if (ridpointers[(int) RID_ONEWAY] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'V'
argument|);     } }
comment|/* Encode a pointer type.  */
argument|static void encode_pointer (tree type, int curtype, int format) {   tree pointer_to = TREE_TYPE (type);    if (TREE_CODE (pointer_to) == RECORD_TYPE)     {       if (OBJC_TYPE_NAME (pointer_to)&& TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE) 	{ 	  const char *name = IDENTIFIER_POINTER (OBJC_TYPE_NAME (pointer_to));  	  if (strcmp (name, TAG_OBJECT) ==
literal|0
argument|)
comment|/* '@' */
argument|{ 	      obstack_1grow (&util_obstack,
literal|'@'
argument|); 	      return; 	    } 	  else if (TREE_STATIC_TEMPLATE (pointer_to)) 	    {               if (generating_instance_variables) 	        { 	          obstack_1grow (&util_obstack,
literal|'@'
argument|); 	          obstack_1grow (&util_obstack,
literal|'"'
argument|); 	          obstack_grow (&util_obstack, name, strlen (name)); 	          obstack_1grow (&util_obstack,
literal|'"'
argument|); 	          return; 		}               else 	        { 	          obstack_1grow (&util_obstack,
literal|'@'
argument|); 	          return; 		} 	    } 	  else if (strcmp (name, TAG_CLASS) ==
literal|0
argument|)
comment|/* '#' */
argument|{ 	      obstack_1grow (&util_obstack,
literal|'#'
argument|); 	      return; 	    } 	  else if (strcmp (name, TAG_SELECTOR) ==
literal|0
argument|)
comment|/* ':' */
argument|{ 	      obstack_1grow (&util_obstack,
literal|':'
argument|); 	      return; 	    } 	}     }   else if (TREE_CODE (pointer_to) == INTEGER_TYPE&& TYPE_MODE (pointer_to) == QImode)     {       tree pname = TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE 	          ? OBJC_TYPE_NAME (pointer_to) 	          : DECL_NAME (OBJC_TYPE_NAME (pointer_to));        if (!flag_next_runtime || strcmp (IDENTIFIER_POINTER (pname),
literal|"BOOL"
argument|)) 	{ 	  obstack_1grow (&util_obstack,
literal|'*'
argument|); 	  return; 	}     }
comment|/* We have a type that does not get special treatment.  */
comment|/* NeXT extension */
argument|obstack_1grow (&util_obstack,
literal|'^'
argument|);   encode_type (pointer_to, curtype, format); }  static void encode_array (tree type, int curtype, int format) {   tree an_int_cst = TYPE_SIZE (type);   tree array_of = TREE_TYPE (type);   char buffer[
literal|40
argument|];
comment|/* An incomplete array is treated like a pointer.  */
argument|if (an_int_cst == NULL)     {       encode_pointer (type, curtype, format);       return;     }    sprintf (buffer,
literal|"[%ld"
argument|, 	   (long) (TREE_INT_CST_LOW (an_int_cst) 		   / TREE_INT_CST_LOW (TYPE_SIZE (array_of))));    obstack_grow (&util_obstack, buffer, strlen (buffer));   encode_type (array_of, curtype, format);   obstack_1grow (&util_obstack,
literal|']'
argument|);   return; }
argument|static void encode_aggregate_within (tree type, int curtype, int format, int left, 			 int right) {   tree name;
comment|/* NB: aggregates that are pointed to have slightly different encoding      rules in that you never encode the names of instance variables.  */
argument|int pointed_to    = (obstack_object_size (&util_obstack)>
literal|0
argument|&& *(obstack_next_free (&util_obstack) -
literal|1
argument|) ==
literal|'^'
argument|);   int inline_contents    = ((format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)&& (!pointed_to || obstack_object_size (&util_obstack) - curtype ==
literal|1
argument|));
comment|/* Traverse struct aliases; it is important to get the      original struct and its tag name (if any).  */
argument|type = TYPE_MAIN_VARIANT (type);   name = OBJC_TYPE_NAME (type);
comment|/* Open parenth/bracket.  */
argument|obstack_1grow (&util_obstack, left);
comment|/* Encode the struct/union tag name, or '?' if a tag was      not provided.  Typedef aliases do not qualify.  */
argument|if (name&& TREE_CODE (name) == IDENTIFIER_NODE
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* Did this struct have a tag?  */
argument|&& !TYPE_WAS_ANONYMOUS (type)
endif|#
directive|endif
argument|)     obstack_grow (&util_obstack, 		  IDENTIFIER_POINTER (name), 		  strlen (IDENTIFIER_POINTER (name)));   else     obstack_1grow (&util_obstack,
literal|'?'
argument|);
comment|/* Encode the types (and possibly names) of the inner fields,      if required.  */
argument|if (inline_contents)     {       tree fields = TYPE_FIELDS (type);        obstack_1grow (&util_obstack,
literal|'='
argument|);       for (; fields; fields = TREE_CHAIN (fields)) 	{
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* C++ static members, and things that are not fields at all, 	     should not appear in the encoding.  */
argument|if (TREE_CODE (fields) != FIELD_DECL || TREE_STATIC (fields)) 	    continue;
endif|#
directive|endif
argument|if (generating_instance_variables&& !pointed_to) 	    { 	      tree fname = DECL_NAME (fields);  	      obstack_1grow (&util_obstack,
literal|'"'
argument|); 	      if (fname&& TREE_CODE (fname) == IDENTIFIER_NODE) 		obstack_grow (&util_obstack, 			      IDENTIFIER_POINTER (fname), 			      strlen (IDENTIFIER_POINTER (fname))); 	      obstack_1grow (&util_obstack,
literal|'"'
argument|); 	    } 	  encode_field_decl (fields, curtype, format); 	}     }
comment|/* Close parenth/bracket.  */
argument|obstack_1grow (&util_obstack, right); }  static void encode_aggregate (tree type, int curtype, int format) {   enum tree_code code = TREE_CODE (type);    switch (code)     {     case RECORD_TYPE:       { 	encode_aggregate_within (type, curtype, format,
literal|'{'
argument|,
literal|'}'
argument|); 	break;       }     case UNION_TYPE:       { 	encode_aggregate_within (type, curtype, format,
literal|'('
argument|,
literal|')'
argument|); 	break;       }      case ENUMERAL_TYPE:       obstack_1grow (&util_obstack,
literal|'i'
argument|);       break;      default:       break;     } }
comment|/* Encode a bitfield NeXT-style (i.e., without a bit offset or the underlying    field type.  */
argument|static void encode_next_bitfield (int width) {   char buffer[
literal|40
argument|];   sprintf (buffer,
literal|"b%d"
argument|, width);   obstack_grow (&util_obstack, buffer, strlen (buffer)); }
comment|/* FORMAT will be OBJC_ENCODE_INLINE_DEFS or OBJC_ENCODE_DONT_INLINE_DEFS.  */
argument|static void encode_type (tree type, int curtype, int format) {   enum tree_code code = TREE_CODE (type);   char c;    if (code == INTEGER_TYPE)     {       switch (GET_MODE_BITSIZE (TYPE_MODE (type))) 	{ 	case
literal|8
argument|:  c = TREE_UNSIGNED (type) ?
literal|'C'
argument|:
literal|'c'
argument|; break; 	case
literal|16
argument|: c = TREE_UNSIGNED (type) ?
literal|'S'
argument|:
literal|'s'
argument|; break; 	case
literal|32
argument|:  	  if (type == long_unsigned_type_node 	      || type == long_integer_type_node) 	         c = TREE_UNSIGNED (type) ?
literal|'L'
argument|:
literal|'l'
argument|; 	  else 	         c = TREE_UNSIGNED (type) ?
literal|'I'
argument|:
literal|'i'
argument|; 	  break; 	case
literal|64
argument|: c = TREE_UNSIGNED (type) ?
literal|'Q'
argument|:
literal|'q'
argument|; break; 	default: abort (); 	}       obstack_1grow (&util_obstack, c);     }    else if (code == REAL_TYPE)     {
comment|/* Floating point types.  */
argument|switch (GET_MODE_BITSIZE (TYPE_MODE (type))) 	{ 	case
literal|32
argument|:  c =
literal|'f'
argument|; break; 	case
literal|64
argument|: 	case
literal|128
argument|: c =
literal|'d'
argument|; break; 	default: abort (); 	}       obstack_1grow (&util_obstack, c);     }    else if (code == VOID_TYPE)     obstack_1grow (&util_obstack,
literal|'v'
argument|);    else if (code == BOOLEAN_TYPE)     obstack_1grow (&util_obstack,
literal|'B'
argument|);    else if (code == ARRAY_TYPE)     encode_array (type, curtype, format);    else if (code == POINTER_TYPE)     encode_pointer (type, curtype, format);    else if (code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE)     encode_aggregate (type, curtype, format);    else if (code == FUNCTION_TYPE)
comment|/* '?' */
argument|obstack_1grow (&util_obstack,
literal|'?'
argument|); }  static void encode_gnu_bitfield (int position, tree type, int size) {   enum tree_code code = TREE_CODE (type);   char buffer[
literal|40
argument|];   char charType =
literal|'?'
argument|;    if (code == INTEGER_TYPE)     {       if (integer_zerop (TYPE_MIN_VALUE (type))) 	{
comment|/* Unsigned integer types.  */
argument|if (TYPE_MODE (type) == QImode) 	    charType =
literal|'C'
argument|; 	  else if (TYPE_MODE (type) == HImode) 	    charType =
literal|'S'
argument|; 	  else if (TYPE_MODE (type) == SImode) 	    { 	      if (type == long_unsigned_type_node) 		charType =
literal|'L'
argument|; 	      else 		charType =
literal|'I'
argument|; 	    } 	  else if (TYPE_MODE (type) == DImode) 	    charType =
literal|'Q'
argument|; 	}        else
comment|/* Signed integer types.  */
argument|{ 	  if (TYPE_MODE (type) == QImode) 	    charType =
literal|'c'
argument|; 	  else if (TYPE_MODE (type) == HImode) 	    charType =
literal|'s'
argument|; 	  else if (TYPE_MODE (type) == SImode) 	    { 	      if (type == long_integer_type_node) 		charType =
literal|'l'
argument|; 	      else 		charType =
literal|'i'
argument|; 	    }  	  else if (TYPE_MODE (type) == DImode) 	    charType =
literal|'q'
argument|; 	}     }   else if (code == ENUMERAL_TYPE)     charType =
literal|'i'
argument|;   else     abort ();    sprintf (buffer,
literal|"b%d%c%d"
argument|, position, charType, size);   obstack_grow (&util_obstack, buffer, strlen (buffer)); }  static void encode_field_decl (tree field_decl, int curtype, int format) {   tree type;
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* C++ static members, and things that are not fields at all,      should not appear in the encoding.  */
argument|if (TREE_CODE (field_decl) != FIELD_DECL || TREE_STATIC (field_decl))     return;
endif|#
directive|endif
argument|type = TREE_TYPE (field_decl);
comment|/* Generate the bitfield typing information, if needed.  Note the difference      between GNU and NeXT runtimes.  */
argument|if (DECL_BIT_FIELD_TYPE (field_decl))     {       int size = tree_low_cst (DECL_SIZE (field_decl),
literal|1
argument|);        if (flag_next_runtime) 	encode_next_bitfield (size);       else 	encode_gnu_bitfield (int_bit_position (field_decl), 				  DECL_BIT_FIELD_TYPE (field_decl), size);     }   else     encode_type (TREE_TYPE (field_decl), curtype, format); }  static tree objc_expr_last (tree complex_expr) {   tree next;    if (complex_expr)     while ((next = TREE_OPERAND (complex_expr,
literal|0
argument|)))       complex_expr = next;    return complex_expr; }  static void synth_self_and_ucmd_args (void) {   tree decl_specs;    if (objc_method_context&& TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL)     decl_specs = build_tree_list (NULL_TREE, uprivate_record);   else
comment|/* Really a `struct objc_class *'. However, we allow people to        assign to self, which changes its type midstream.  */
argument|decl_specs = build_tree_list (NULL_TREE, objc_object_reference);    push_parm_decl (build_tree_list 		  (build_tree_list (decl_specs, 				    build1 (INDIRECT_REF, NULL_TREE, self_id)), 		   unused_list));    decl_specs = build_tree_list (NULL_TREE, 				xref_tag (RECORD_TYPE, 					  get_identifier (TAG_SELECTOR)));   push_parm_decl (build_tree_list 		  (build_tree_list (decl_specs, 				    build1 (INDIRECT_REF, NULL_TREE, ucmd_id)), 		   unused_list)); }
comment|/* Transform a method definition into a function definition as follows:    - synthesize the first two arguments, "self" and "_cmd".  */
argument|void start_method_def (tree method) {
comment|/* Required to implement _msgSuper.  */
argument|objc_method_context = method;   UOBJC_SUPER_decl = NULL_TREE;
comment|/* Must be called BEFORE start_function.  */
argument|pushlevel (
literal|0
argument|);
comment|/* Generate prototype declarations for arguments..."new-style".  */
argument|synth_self_and_ucmd_args ();
comment|/* Generate argument declarations if a keyword_decl.  */
argument|if (METHOD_SEL_ARGS (method))     {       tree arglist = METHOD_SEL_ARGS (method);       do 	{ 	  tree arg_spec = TREE_PURPOSE (TREE_TYPE (arglist)); 	  tree arg_decl = TREE_VALUE (TREE_TYPE (arglist));  	  if (arg_decl) 	    { 	      tree last_expr = objc_expr_last (arg_decl);
comment|/* Unite the abstract decl with its name.  */
argument|TREE_OPERAND (last_expr,
literal|0
argument|) = KEYWORD_ARG_NAME (arglist); 	      push_parm_decl (build_tree_list 			      (build_tree_list (arg_spec, arg_decl), 			       NULL_TREE));
ifndef|#
directive|ifndef
name|OBJCPLUS
comment|/* Unhook: restore the abstract declarator.  */
argument|TREE_OPERAND (last_expr,
literal|0
argument|) = NULL_TREE;
endif|#
directive|endif
argument|}  	  else 	    push_parm_decl (build_tree_list 			    (build_tree_list (arg_spec, 					      KEYWORD_ARG_NAME (arglist)), 			     NULL_TREE));  	  arglist = TREE_CHAIN (arglist); 	}       while (arglist);     }    if (METHOD_ADD_ARGS (method) != NULL_TREE&& METHOD_ADD_ARGS (method) != objc_ellipsis_node)     {
comment|/* We have a variable length selector - in "prototype" format.  */
argument|tree akey = TREE_PURPOSE (METHOD_ADD_ARGS (method));       while (akey) 	{
comment|/* This must be done prior to calling pushdecl.  pushdecl is 	     going to change our chain on us.  */
argument|tree nextkey = TREE_CHAIN (akey); 	  pushdecl (akey); 	  akey = nextkey; 	}     } }  static void warn_with_method (const char *message, int mtype, tree method) {
comment|/* Add a readable method name to the warning.  */
argument|warning (
literal|"%J%s `%c%s'"
argument|, method,            message, mtype, gen_method_decl (method, errbuf)); }
comment|/* Return 1 if METHOD is consistent with PROTO.  */
argument|static int comp_method_with_proto (tree method, tree proto) {
comment|/* Create a function template node at most once.  */
argument|if (!function1_template)     function1_template = make_node (FUNCTION_TYPE);
comment|/* Install argument types - normally set by build_function_type.  */
argument|TYPE_ARG_TYPES (function1_template) = get_arg_type_list (proto, METHOD_DEF,
literal|0
argument|);
comment|/* install return type */
argument|TREE_TYPE (function1_template) = groktypename (TREE_TYPE (proto));    return comptypes (TREE_TYPE (METHOD_DEFINITION (method)), function1_template, 		    false); }
comment|/* Return 1 if TYPE1 is equivalent to TYPE2.  */
argument|static int objc_types_are_equivalent (tree type1, tree type2) {   if (type1 == type2)     return
literal|1
argument|;   if (TYPE_MAIN_VARIANT (type1) != TYPE_MAIN_VARIANT (type2))     return
literal|0
argument|;   type1 = TYPE_PROTOCOL_LIST (type1);   type2 = TYPE_PROTOCOL_LIST (type2);   if (list_length (type1) == list_length (type2))     {       for (; type2; type2 = TREE_CHAIN (type2)) 	if (!lookup_protocol_in_reflist (type1, TREE_VALUE (type2))) 	  return
literal|0
argument|;       return
literal|1
argument|;     }   return
literal|0
argument|; }
comment|/* Return 1 if PROTO1 is equivalent to PROTO2.  */
argument|static int comp_proto_with_proto (tree proto1, tree proto2) {   tree type1
argument_list|,
argument|type2;
comment|/* The following test is needed in case there are hashing      collisions.  */
argument|if (METHOD_SEL_NAME (proto1) != METHOD_SEL_NAME (proto2))     return
literal|0
argument|;
comment|/* Compare return types.  */
argument|type1 = groktypename (TREE_TYPE (proto1));   type2 = groktypename (TREE_TYPE (proto2));    if (!objc_types_are_equivalent (type1, type2))     return
literal|0
argument|;
comment|/* Compare argument types.  */
argument|for (type1 = get_arg_type_list (proto1, METHOD_REF,
literal|0
argument|),        type2 = get_arg_type_list (proto2, METHOD_REF,
literal|0
argument|);        type1&& type2;        type1 = TREE_CHAIN (type1), type2 = TREE_CHAIN (type2))     {       if (!objc_types_are_equivalent (TREE_VALUE (type1), TREE_VALUE (type2))) 	return
literal|0
argument|;     }    return (!type1&& !type2); }
comment|/* - Generate an identifier for the function. the format is "_n_cls",      where 1<= n<= nMethods, and cls is the name the implementation we      are processing.    - Install the return type from the method declaration.    - If we have a prototype, check for type consistency.  */
argument|static void really_start_method (tree method, tree parmlist) {   tree sc_spec
argument_list|,
argument|ret_spec
argument_list|,
argument|ret_decl
argument_list|,
argument|decl_specs;   tree method_decl
argument_list|,
argument|method_id;   const char *sel_name
argument_list|,
argument|*class_name
argument_list|,
argument|*cat_name;   char *buf;
comment|/* Synth the storage class& assemble the return type.  */
argument|sc_spec = tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);   ret_spec = TREE_PURPOSE (TREE_TYPE (method));   decl_specs = chainon (sc_spec, ret_spec);    sel_name = IDENTIFIER_POINTER (METHOD_SEL_NAME (method));   class_name = IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context));   cat_name = ((TREE_CODE (objc_implementation_context) 	       == CLASS_IMPLEMENTATION_TYPE) 	      ? NULL 	      : IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context)));   method_slot++;
comment|/* Make sure this is big enough for any plausible method label.  */
argument|buf = (char *) alloca (
literal|50
argument|+ strlen (sel_name) + strlen (class_name) 			 + (cat_name ? strlen (cat_name) :
literal|0
argument|));    OBJC_GEN_METHOD_LABEL (buf, TREE_CODE (method) == INSTANCE_METHOD_DECL, 			 class_name, cat_name, sel_name, method_slot);    method_id = get_identifier (buf);
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* Objective-C methods cannot be overloaded, so we don't need      the type encoding appended.  It looks bad anyway... */
argument|push_lang_context (lang_name_c);
endif|#
directive|endif
argument|method_decl = build_nt (CALL_EXPR, method_id, parmlist, NULL_TREE);
comment|/* Check the declarator portion of the return type for the method.  */
argument|if ((ret_decl = TREE_VALUE (TREE_TYPE (method))))     {
comment|/* Unite the complex decl (specified in the abstract decl) with the 	 function decl just synthesized..(int *), (int (*)()), (int (*)[]).  */
argument|tree save_expr = objc_expr_last (ret_decl);        TREE_OPERAND (save_expr,
literal|0
argument|) = method_decl;       method_decl = ret_decl;
comment|/* Fool the parser into thinking it is starting a function.  */
argument|start_function (decl_specs, method_decl, NULL_TREE);
comment|/* Unhook: this has the effect of restoring the abstract declarator.  */
argument|TREE_OPERAND (save_expr,
literal|0
argument|) = NULL_TREE;     }    else     {       TREE_VALUE (TREE_TYPE (method)) = method_decl;
comment|/* Fool the parser into thinking it is starting a function.  */
argument|start_function (decl_specs, method_decl, NULL_TREE);
comment|/* Unhook: this has the effect of restoring the abstract declarator.  */
argument|TREE_VALUE (TREE_TYPE (method)) = NULL_TREE;     }
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* set self_decl from the first argument...this global is used by    * build_ivar_reference().build_indirect_ref().    */
argument|self_decl = DECL_ARGUMENTS (current_function_decl);
comment|/* snaroff (3/28/96): when compiling with -Wall, this suppresses    * the following: warning:unused parameter `struct objc_selector * _cmd'    */
argument|TREE_USED (self_decl) =
literal|1
argument|;   TREE_USED (TREE_CHAIN (self_decl)) =
literal|1
argument|;
comment|/* Ditto for the underlying (static) C function.  */
argument|TREE_USED (current_function_decl) =
literal|1
argument|;   pop_lang_context ();
endif|#
directive|endif
argument|METHOD_DEFINITION (method) = current_function_decl;
comment|/* Check consistency...start_function, pushdecl, duplicate_decls.  */
argument|if (implementation_template != objc_implementation_context)     {       tree proto 	= lookup_method_static (implementation_template, 				METHOD_SEL_NAME (method), 				TREE_CODE (method) == CLASS_METHOD_DECL);        if (proto) 	{ 	  if (!comp_method_with_proto (method, proto)) 	    { 	      char type = (TREE_CODE (method) == INSTANCE_METHOD_DECL ?
literal|'-'
argument|:
literal|'+'
argument|);  	      warn_with_method (
literal|"conflicting types for"
argument|, type, method); 	      warn_with_method (
literal|"previous declaration of"
argument|, type, proto); 	    } 	}       else 	{
comment|/* We have a method @implementation even though we did not 	     see a corresponding @interface declaration (which is allowed 	     by Objective-C rules).  Go ahead and place the method in 	     the @interface anyway, so that message dispatch lookups 	     will see it.  */
argument|tree interface = implementation_template;  	  if (TREE_CODE (objc_implementation_context) 	      == CATEGORY_IMPLEMENTATION_TYPE) 	    interface = lookup_category 			(interface, 			 CLASS_SUPER_NAME (objc_implementation_context));  	  if (interface) 	    objc_add_method (interface, copy_node (method), 			     TREE_CODE (method) == CLASS_METHOD_DECL); 	}     } }
comment|/* The following routine is always called...this "architecture" is to    accommodate "old-style" variable length selectors.     - a:a b:b // prototype  ; id c; id d; // old-style.  */
argument|void continue_method_def (void) {   tree parmlist;    if (METHOD_ADD_ARGS (objc_method_context) == objc_ellipsis_node)
comment|/* We have a `, ...' immediately following the selector.  */
argument|parmlist = get_parm_info (
literal|0
argument|);   else     parmlist = get_parm_info (
literal|1
argument|);
comment|/* place a `void_at_end' */
ifndef|#
directive|ifndef
name|OBJCPLUS
comment|/* Set self_decl from the first argument...this global is used by      build_ivar_reference calling build_indirect_ref.  */
argument|self_decl = TREE_PURPOSE (parmlist);
endif|#
directive|endif
comment|/* !OBJCPLUS */
argument|poplevel (
literal|0
argument|,
literal|0
argument|,
literal|0
argument|);   really_start_method (objc_method_context, parmlist);   store_parm_decls (); }  static void *UOBJC_SUPER_scope =
literal|0
argument|;
comment|/* _n_Method (id self, SEL sel, ...)      {        struct objc_super _S;        _msgSuper ((_S.self = self, _S.class = _cls,&_S), ...);      }  */
argument|tree get_super_receiver (void) {   if (objc_method_context)     {       tree super_expr
argument_list|,
argument|super_expr_list;        if (!UOBJC_SUPER_decl)       { 	UOBJC_SUPER_decl = start_decl (get_identifier (TAG_SUPER), 				       build_tree_list (NULL_TREE, 				       objc_super_template),
literal|0
argument|, NULL_TREE); 	 	finish_decl (UOBJC_SUPER_decl, NULL_TREE, NULL_TREE);
comment|/* This prevents `unused variable' warnings when compiling with -Wall.  */
argument|TREE_USED (UOBJC_SUPER_decl) =
literal|1
argument|; 	DECL_ARTIFICIAL (UOBJC_SUPER_decl) =
literal|1
argument|;  	UOBJC_SUPER_scope = get_current_scope ();       }
comment|/* Set receiver to self.  */
argument|super_expr = build_component_ref (UOBJC_SUPER_decl, self_id);       super_expr = build_modify_expr (super_expr, NOP_EXPR, self_decl);       super_expr_list = build_tree_list (NULL_TREE, super_expr);
comment|/* Set class to begin searching.  */
argument|super_expr = build_component_ref (UOBJC_SUPER_decl, 					get_identifier (
literal|"class"
argument|));        if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE) 	{
comment|/* [_cls, __cls]Super are "pre-built" in 	     synth_forward_declarations.  */
argument|super_expr = build_modify_expr (super_expr, NOP_EXPR, 					  ((TREE_CODE (objc_method_context) 					    == INSTANCE_METHOD_DECL) 					   ? ucls_super_ref 					   : uucls_super_ref)); 	}        else
comment|/* We have a category.  */
argument|{ 	  tree super_name = CLASS_SUPER_NAME (implementation_template); 	  tree super_class;
comment|/* Barf if super used in a category of Object.  */
argument|if (!super_name) 	    { 	      error (
literal|"no super class declared in interface for `%s'"
argument|, 		    IDENTIFIER_POINTER (CLASS_NAME (implementation_template))); 	      return error_mark_node; 	    }  	  if (flag_next_runtime&& !flag_zero_link) 	    { 	      super_class = get_class_reference (super_name); 	      if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)
comment|/* If we are in a class method, we must retrieve the 		   _metaclass_ for the current class, pointed at by 		   the class's "isa" pointer.  The following assumes that 		   "isa" is the first ivar in a class (which it must be).  */
argument|super_class 		  = build_indirect_ref 		    (build_c_cast (build_pointer_type (objc_class_type), 				   super_class),
literal|"unary *"
argument|); 	    } 	  else 	    { 	      add_class_reference (super_name); 	      super_class = (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL 			     ? objc_get_class_decl : objc_get_meta_class_decl); 	      assemble_external (super_class); 	      super_class 		= build_function_call 		  (super_class, 		   build_tree_list 		   (NULL_TREE, 		    my_build_string (IDENTIFIER_LENGTH (super_name) +
literal|1
argument|, 				     IDENTIFIER_POINTER (super_name)))); 	    }  	  super_expr 	    = build_modify_expr (super_expr, NOP_EXPR, 				 build_c_cast (TREE_TYPE (super_expr), 					       super_class)); 	}        chainon (super_expr_list, build_tree_list (NULL_TREE, super_expr));        super_expr = build_unary_op (ADDR_EXPR, UOBJC_SUPER_decl,
literal|0
argument|);       chainon (super_expr_list, build_tree_list (NULL_TREE, super_expr));        return build_compound_expr (super_expr_list);     }   else     {       error (
literal|"[super ...] must appear in a method context"
argument|);       return error_mark_node;     } }
comment|/* When exiting a scope, sever links to a 'super' declaration (if any)    therein contained.  */
argument|void objc_clear_super_receiver (void) {   if (objc_method_context&& UOBJC_SUPER_scope == get_current_scope ()) {     UOBJC_SUPER_decl =
literal|0
argument|;     UOBJC_SUPER_scope =
literal|0
argument|;   } }  static void objc_expand_function_end (void) {
comment|/* This routine may also get called for C functions, including those      nested within ObjC methods.  In such cases, method encoding is      meaningless.  */
argument|if (objc_method_context == NULL_TREE       || DECL_INITIAL (objc_method_context) != current_function_decl)     return;    METHOD_ENCODING (objc_method_context)     = encode_method_prototype (objc_method_context); }  void finish_method_def (void) {   lang_expand_function_end = objc_expand_function_end;
comment|/* We cannot validly inline ObjC methods, at least not without a language      extension to declare that a method need not be dynamically      dispatched, so suppress all thoughts of doing so.  */
argument|DECL_INLINE (current_function_decl) =
literal|0
argument|;   DECL_UNINLINABLE (current_function_decl) =
literal|1
argument|;   current_function_cannot_inline =
literal|"methods cannot be inlined"
argument|;    finish_function ();   lang_expand_function_end = NULL;
comment|/* Required to implement _msgSuper. This must be done AFTER finish_function,      since the optimizer may find "may be used before set" errors.  */
argument|objc_method_context = NULL_TREE; }
if|#
directive|if
literal|0
argument|int lang_report_error_function (tree decl) {   if (objc_method_context)     {       fprintf (stderr, "In method `%s'\n", 	       IDENTIFIER_POINTER (METHOD_SEL_NAME (objc_method_context)));       return 1;     }    else     return 0; }
endif|#
directive|endif
argument|static int is_complex_decl (tree type) {   return (TREE_CODE (type) == ARRAY_TYPE 	  || TREE_CODE (type) == FUNCTION_TYPE 	  || (TREE_CODE (type) == POINTER_TYPE&& ! IS_ID (type))); }
comment|/* Code to convert a decl node into text for a declaration in C.  */
argument|static char tmpbuf[
literal|256
argument|];  static void adorn_decl (tree decl, char *str) {   enum tree_code code = TREE_CODE (decl);    if (code == ARRAY_REF)     {       tree an_int_cst = TREE_OPERAND (decl,
literal|1
argument|);        if (an_int_cst&& TREE_CODE (an_int_cst) == INTEGER_CST) 	sprintf (str + strlen (str),
literal|"[%ld]"
argument|, 		 (long) TREE_INT_CST_LOW (an_int_cst));       else 	strcat (str,
literal|"[]"
argument|);     }    else if (code == ARRAY_TYPE)     {       tree an_int_cst = TYPE_SIZE (decl);       tree array_of = TREE_TYPE (decl);        if (an_int_cst&& TREE_CODE (an_int_cst) == INTEGER_TYPE) 	sprintf (str + strlen (str),
literal|"[%ld]"
argument|, 		 (long) (TREE_INT_CST_LOW (an_int_cst) 			 / TREE_INT_CST_LOW (TYPE_SIZE (array_of))));       else 	strcat (str,
literal|"[]"
argument|);     }    else if (code == CALL_EXPR)     {       tree chain = TREE_PURPOSE (TREE_OPERAND (decl,
literal|1
argument|));        strcat (str,
literal|"("
argument|);       while (chain) 	{ 	  gen_declaration_1 (chain, str); 	  chain = TREE_CHAIN (chain); 	  if (chain) 	    strcat (str,
literal|", "
argument|); 	}       strcat (str,
literal|")"
argument|);     }    else if (code == FUNCTION_TYPE)     {       tree chain  = TYPE_ARG_TYPES (decl);        strcat (str,
literal|"("
argument|);       while (chain&& TREE_VALUE (chain) != void_type_node) 	{ 	  gen_declaration_1 (TREE_VALUE (chain), str); 	  chain = TREE_CHAIN (chain); 	  if (chain&& TREE_VALUE (chain) != void_type_node) 	    strcat (str,
literal|", "
argument|); 	}       strcat (str,
literal|")"
argument|);     }    else if (code == INDIRECT_REF)     {       strcpy (tmpbuf,
literal|"*"
argument|);       if (TREE_TYPE (decl)&& TREE_CODE (TREE_TYPE (decl)) == TREE_LIST) 	{ 	  tree chain;  	  for (chain = nreverse (copy_list (TREE_TYPE (decl))); 	       chain; 	       chain = TREE_CHAIN (chain)) 	    { 	      if (TREE_CODE (TREE_VALUE (chain)) == IDENTIFIER_NODE) 		{ 		  strcat (tmpbuf,
literal|" "
argument|); 		  strcat (tmpbuf, IDENTIFIER_POINTER (TREE_VALUE (chain))); 		} 	    } 	  if (str[
literal|0
argument|]) 	    strcat (tmpbuf,
literal|" "
argument|); 	}       strcat (tmpbuf, str);       strcpy (str, tmpbuf);     }    else if (code == POINTER_TYPE)     {       strcpy (tmpbuf,
literal|"*"
argument|);       if (TREE_READONLY (decl) || TYPE_VOLATILE (decl)) 	{ 	  if (TREE_READONLY (decl)) 	    strcat (tmpbuf,
literal|" const"
argument|); 	  if (TYPE_VOLATILE (decl)) 	    strcat (tmpbuf,
literal|" volatile"
argument|); 	  if (str[
literal|0
argument|]) 	    strcat (tmpbuf,
literal|" "
argument|); 	}       strcat (tmpbuf, str);       strcpy (str, tmpbuf);     } }  static char * gen_declarator (tree decl, char *buf, const char *name) {   if (decl)     {       enum tree_code code = TREE_CODE (decl);       char *str;       tree op;       int wrap =
literal|0
argument|;        switch (code) 	{ 	case ARRAY_REF: 	case INDIRECT_REF: 	case CALL_EXPR: 	  op = TREE_OPERAND (decl,
literal|0
argument|);
comment|/* We have a pointer to a function or array...(*)(), (*)[] */
argument|if ((code == ARRAY_REF || code == CALL_EXPR)&& op&& TREE_CODE (op) == INDIRECT_REF) 	    wrap =
literal|1
argument|;  	  str = gen_declarator (op, buf, name);  	  if (wrap) 	    { 	      strcpy (tmpbuf,
literal|"("
argument|); 	      strcat (tmpbuf, str); 	      strcat (tmpbuf,
literal|")"
argument|); 	      strcpy (str, tmpbuf); 	    }  	  adorn_decl (decl, str); 	  break;  	case ARRAY_TYPE: 	case FUNCTION_TYPE: 	case POINTER_TYPE: 	  strcpy (buf, name); 	  str = buf;
comment|/* This clause is done iteratively rather than recursively.  */
argument|do 	    { 	      op = (is_complex_decl (TREE_TYPE (decl)) 		    ? TREE_TYPE (decl) : NULL_TREE);  	      adorn_decl (decl, str);
comment|/* We have a pointer to a function or array...(*)(), (*)[] */
argument|if (code == POINTER_TYPE&& op&& (TREE_CODE (op) == FUNCTION_TYPE 			    || TREE_CODE (op) == ARRAY_TYPE)) 		{ 		  strcpy (tmpbuf,
literal|"("
argument|); 		  strcat (tmpbuf, str); 		  strcat (tmpbuf,
literal|")"
argument|); 		  strcpy (str, tmpbuf); 		}  	      decl = (is_complex_decl (TREE_TYPE (decl)) 		      ? TREE_TYPE (decl) : NULL_TREE); 	    }  	  while (decl&& (code = TREE_CODE (decl))) 	    ;  	  break;  	case IDENTIFIER_NODE:
comment|/* Will only happen if we are processing a "raw" expr-decl.  */
argument|strcpy (buf, IDENTIFIER_POINTER (decl)); 	  return buf;  	default: 	  abort (); 	}        return str;     }    else
comment|/* We have an abstract declarator or a _DECL node.  */
argument|{       strcpy (buf, name);       return buf;     } }  static void gen_declspecs (tree declspecs, char *buf, int raw) {   if (raw)     {       tree chain;        for (chain = nreverse (copy_list (declspecs)); 	   chain; chain = TREE_CHAIN (chain)) 	{ 	  tree aspec = TREE_VALUE (chain);  	  if (TREE_CODE (aspec) == IDENTIFIER_NODE) 	    strcat (buf, IDENTIFIER_POINTER (aspec)); 	  else if (TREE_CODE (aspec) == RECORD_TYPE) 	    { 	      if (OBJC_TYPE_NAME (aspec)) 		{ 		  tree protocol_list = TYPE_PROTOCOL_LIST (aspec);  		  if (! TREE_STATIC_TEMPLATE (aspec)) 		    strcat (buf,
literal|"struct "
argument|); 		  strcat (buf, IDENTIFIER_POINTER (OBJC_TYPE_NAME (aspec)));
comment|/* NEW!!! */
argument|if (protocol_list) 		    { 		      tree chain = protocol_list;  		      strcat (buf,
literal|"<"
argument|); 		      while (chain) 			{ 			  strcat (buf, 				  IDENTIFIER_POINTER 				  (PROTOCOL_NAME (TREE_VALUE (chain)))); 			  chain = TREE_CHAIN (chain); 			  if (chain) 			    strcat (buf,
literal|", "
argument|); 			} 		      strcat (buf,
literal|">"
argument|); 		    } 		}  	      else 		strcat (buf,
literal|"untagged struct"
argument|); 	    }  	  else if (TREE_CODE (aspec) == UNION_TYPE) 	    { 	      if (OBJC_TYPE_NAME (aspec)) 		{ 		  if (! TREE_STATIC_TEMPLATE (aspec)) 		    strcat (buf,
literal|"union "
argument|); 		  strcat (buf, IDENTIFIER_POINTER (OBJC_TYPE_NAME (aspec))); 		} 	      else 		strcat (buf,
literal|"untagged union"
argument|); 	    }  	  else if (TREE_CODE (aspec) == ENUMERAL_TYPE) 	    { 	      if (OBJC_TYPE_NAME (aspec)) 		{ 		  if (! TREE_STATIC_TEMPLATE (aspec)) 		    strcat (buf,
literal|"enum "
argument|); 		  strcat (buf, IDENTIFIER_POINTER (OBJC_TYPE_NAME (aspec))); 		} 	      else 		strcat (buf,
literal|"untagged enum"
argument|); 	    }  	  else if (TREE_CODE (aspec) == TYPE_DECL&& DECL_NAME (aspec)) 	    strcat (buf, IDENTIFIER_POINTER (DECL_NAME (aspec)));  	  else if (IS_ID (aspec)) 	    { 	      tree protocol_list = TYPE_PROTOCOL_LIST (aspec);  	      strcat (buf,
literal|"id"
argument|); 	      if (protocol_list) 		{ 		  tree chain = protocol_list;  		  strcat (buf,
literal|"<"
argument|); 		  while (chain) 		    { 		      strcat (buf, 			      IDENTIFIER_POINTER 			      (PROTOCOL_NAME (TREE_VALUE (chain)))); 		      chain = TREE_CHAIN (chain); 		      if (chain) 			strcat (buf,
literal|", "
argument|); 		    } 		  strcat (buf,
literal|">"
argument|); 		} 	    } 	  if (TREE_CHAIN (chain)) 	    strcat (buf,
literal|" "
argument|); 	}     }   else     {
comment|/* Type qualifiers.  */
argument|if (TREE_READONLY (declspecs)) 	strcat (buf,
literal|"const "
argument|);       if (TYPE_VOLATILE (declspecs)) 	strcat (buf,
literal|"volatile "
argument|);        switch (TREE_CODE (declspecs)) 	{
comment|/* Type specifiers.  */
argument|case INTEGER_TYPE: 	  declspecs = TYPE_MAIN_VARIANT (declspecs);
comment|/* Signed integer types.  */
argument|if (declspecs == short_integer_type_node) 	    strcat (buf,
literal|"short int "
argument|); 	  else if (declspecs == integer_type_node) 	    strcat (buf,
literal|"int "
argument|); 	  else if (declspecs == long_integer_type_node) 	    strcat (buf,
literal|"long int "
argument|); 	  else if (declspecs == long_long_integer_type_node) 	    strcat (buf,
literal|"long long int "
argument|); 	  else if (declspecs == signed_char_type_node 		   || declspecs == char_type_node) 	    strcat (buf,
literal|"char "
argument|);
comment|/* Unsigned integer types.  */
argument|else if (declspecs == short_unsigned_type_node) 	    strcat (buf,
literal|"unsigned short "
argument|); 	  else if (declspecs == unsigned_type_node) 	    strcat (buf,
literal|"unsigned int "
argument|); 	  else if (declspecs == long_unsigned_type_node) 	    strcat (buf,
literal|"unsigned long "
argument|); 	  else if (declspecs == long_long_unsigned_type_node) 	    strcat (buf,
literal|"unsigned long long "
argument|); 	  else if (declspecs == unsigned_char_type_node) 	    strcat (buf,
literal|"unsigned char "
argument|); 	  break;  	case REAL_TYPE: 	  declspecs = TYPE_MAIN_VARIANT (declspecs);  	  if (declspecs == float_type_node) 	    strcat (buf,
literal|"float "
argument|); 	  else if (declspecs == double_type_node) 	    strcat (buf,
literal|"double "
argument|); 	  else if (declspecs == long_double_type_node) 	    strcat (buf,
literal|"long double "
argument|); 	  break;  	case RECORD_TYPE: 	  if (OBJC_TYPE_NAME (declspecs)&& TREE_CODE (OBJC_TYPE_NAME (declspecs)) == IDENTIFIER_NODE) 	    { 	      tree protocol_list = TYPE_PROTOCOL_LIST (declspecs);  	      if (! TREE_STATIC_TEMPLATE (declspecs)) 		strcat (buf,
literal|"struct "
argument|); 	      strcat (buf, IDENTIFIER_POINTER (OBJC_TYPE_NAME (declspecs)));  	      if (protocol_list) 		{ 		  tree chain = protocol_list;  		  strcat (buf,
literal|"<"
argument|); 		  while (chain) 		    { 		      strcat (buf, 			      IDENTIFIER_POINTER 			      (PROTOCOL_NAME (TREE_VALUE (chain)))); 		      chain = TREE_CHAIN (chain); 		      if (chain) 			strcat (buf,
literal|", "
argument|); 		    } 		  strcat (buf,
literal|">"
argument|); 		} 	    }  	  else 	    strcat (buf,
literal|"untagged struct"
argument|);  	  strcat (buf,
literal|" "
argument|); 	  break;  	case UNION_TYPE: 	  if (OBJC_TYPE_NAME (declspecs)&& TREE_CODE (OBJC_TYPE_NAME (declspecs)) == IDENTIFIER_NODE) 	    { 	      strcat (buf,
literal|"union "
argument|); 	      strcat (buf, IDENTIFIER_POINTER (OBJC_TYPE_NAME (declspecs))); 	      strcat (buf,
literal|" "
argument|); 	    }  	  else 	    strcat (buf,
literal|"untagged union "
argument|); 	  break;  	case ENUMERAL_TYPE: 	  if (OBJC_TYPE_NAME (declspecs)&& TREE_CODE (OBJC_TYPE_NAME (declspecs)) == IDENTIFIER_NODE) 	    { 	      strcat (buf,
literal|"enum "
argument|); 	      strcat (buf, IDENTIFIER_POINTER (OBJC_TYPE_NAME (declspecs))); 	      strcat (buf,
literal|" "
argument|); 	    }  	  else 	    strcat (buf,
literal|"untagged enum "
argument|); 	  break;  	case VOID_TYPE: 	  strcat (buf,
literal|"void "
argument|); 	  break;  	case POINTER_TYPE: 	  { 	    tree protocol_list = TYPE_PROTOCOL_LIST (declspecs);  	    strcat (buf,
literal|"id"
argument|); 	    if (protocol_list) 	      { 		tree chain = protocol_list;  		strcat (buf,
literal|"<"
argument|); 		while (chain) 		  { 		    strcat (buf, 			    IDENTIFIER_POINTER 			    (PROTOCOL_NAME (TREE_VALUE (chain)))); 		    chain = TREE_CHAIN (chain); 		    if (chain) 		      strcat (buf,
literal|", "
argument|); 		  }  		strcat (buf,
literal|">"
argument|); 	      } 	  } 	  break;  	default: 	  break; 	}     } }
comment|/* Given a tree node, produce a printable description of it in the given    buffer, overwriting the buffer.  */
argument|static char * gen_declaration (tree atype_or_adecl, char *buf) {   buf[
literal|0
argument|] =
literal|'\0'
argument|;   gen_declaration_1 (atype_or_adecl, buf);   return buf; }
comment|/* Given a tree node, append a printable description to the end of the    given buffer.  */
argument|static void gen_declaration_1 (tree atype_or_adecl, char *buf) {   char declbuf[
literal|256
argument|];    if (TREE_CODE (atype_or_adecl) == TREE_LIST)     {       tree declspecs;
comment|/* "identifier_node", "record_type" */
argument|tree declarator;
comment|/* "array_ref", "indirect_ref", "call_expr"...  */
argument|tree width = NULL_TREE;
comment|/* for bitfields */
comment|/* We have a "raw", abstract declarator (typename).  */
argument|declarator = TREE_VALUE (atype_or_adecl);
comment|/* In the case of raw ivars, the declarator itself is a list, 	 and contains bitfield widths.  */
argument|if (declarator&& TREE_CODE (declarator) == TREE_LIST) 	{ 	  width = TREE_VALUE (declarator); 	  declarator = TREE_PURPOSE (declarator); 	}       declspecs  = TREE_PURPOSE (atype_or_adecl);        gen_declspecs (declspecs, buf,
literal|1
argument|);       if (declarator) 	{ 	  strcat (buf,
literal|" "
argument|); 	  strcat (buf, gen_declarator (declarator, declbuf,
literal|""
argument|)); 	}       if (width) 	sprintf (buf + strlen (buf),
literal|": "
argument|HOST_WIDE_INT_PRINT_UNSIGNED,  		 TREE_INT_CST_LOW (width));     }    else     {       tree atype;       tree declspecs;
comment|/* "integer_type", "real_type", "record_type"...  */
argument|tree declarator;
comment|/* "array_type", "function_type", "pointer_type".  */
argument|if (TREE_CODE (atype_or_adecl) == FIELD_DECL 	  || TREE_CODE (atype_or_adecl) == PARM_DECL 	  || TREE_CODE (atype_or_adecl) == FUNCTION_DECL) 	atype = TREE_TYPE (atype_or_adecl);       else
comment|/* Assume we have a *_type node.  */
argument|atype = atype_or_adecl;        if (is_complex_decl (atype)) 	{ 	  tree chain;
comment|/* Get the declaration specifier; it is at the end of the list.  */
argument|declarator = chain = atype; 	  do 	    chain = TREE_TYPE (chain);
comment|/* not TREE_CHAIN (chain); */
argument|while (is_complex_decl (chain)); 	  declspecs = chain; 	}        else 	{ 	  declspecs = atype; 	  declarator = NULL_TREE; 	}        gen_declspecs (declspecs, buf,
literal|0
argument|);        if (TREE_CODE (atype_or_adecl) == FIELD_DECL 	  || TREE_CODE (atype_or_adecl) == PARM_DECL 	  || TREE_CODE (atype_or_adecl) == FUNCTION_DECL) 	{ 	  const char *const decl_name = 	    (DECL_NAME (atype_or_adecl) 	     ? IDENTIFIER_POINTER (DECL_NAME (atype_or_adecl)) :
literal|""
argument|);  	  if (declarator) 	    { 	      strcat (buf,
literal|" "
argument|); 	      strcat (buf, gen_declarator (declarator, declbuf, decl_name)); 	    }  	  else if (decl_name[
literal|0
argument|]) 	    { 	      strcat (buf,
literal|" "
argument|); 	      strcat (buf, decl_name); 	    } 	}       else if (declarator) 	{ 	  strcat (buf,
literal|" "
argument|); 	  strcat (buf, gen_declarator (declarator, declbuf,
literal|""
argument|)); 	}     } }
define|#
directive|define
name|RAW_TYPESPEC
parameter_list|(
name|meth
parameter_list|)
value|(TREE_VALUE (TREE_PURPOSE (TREE_TYPE (meth))))
comment|/* Given a method tree, put a printable description into the given    buffer (overwriting) and return a pointer to the buffer.  */
argument|static char * gen_method_decl (tree method, char *buf) {   tree chain;    buf[
literal|0
argument|] =
literal|'\0'
argument|;   if (RAW_TYPESPEC (method) != objc_object_reference)     {       strcat (buf,
literal|"("
argument|);       gen_declaration_1 (TREE_TYPE (method), buf);       strcat (buf,
literal|")"
argument|);     }    chain = METHOD_SEL_ARGS (method);   if (chain)     {
comment|/* We have a chain of keyword_decls.  */
argument|do         { 	  if (KEYWORD_KEY_NAME (chain)) 	    strcat (buf, IDENTIFIER_POINTER (KEYWORD_KEY_NAME (chain)));  	  strcat (buf,
literal|":"
argument|); 	  if (RAW_TYPESPEC (chain) != objc_object_reference) 	    { 	      strcat (buf,
literal|"("
argument|); 	      gen_declaration_1 (TREE_TYPE (chain), buf); 	      strcat (buf,
literal|")"
argument|); 	    }  	  strcat (buf, IDENTIFIER_POINTER (KEYWORD_ARG_NAME (chain))); 	  if ((chain = TREE_CHAIN (chain))) 	    strcat (buf,
literal|" "
argument|);         }       while (chain);        if (METHOD_ADD_ARGS (method) == objc_ellipsis_node)         strcat (buf,
literal|", ..."
argument|);       else if (METHOD_ADD_ARGS (method))         {
comment|/* We have a tree list node as generate by get_parm_info.  */
argument|chain  = TREE_PURPOSE (METHOD_ADD_ARGS (method));
comment|/* Know we have a chain of parm_decls.  */
argument|while (chain)             { 	      strcat (buf,
literal|", "
argument|); 	      gen_declaration_1 (chain, buf); 	      chain = TREE_CHAIN (chain);             } 	}     }    else
comment|/* We have a unary selector.  */
argument|strcat (buf, IDENTIFIER_POINTER (METHOD_SEL_NAME (method)));    return buf; }
comment|/* Debug info.  */
comment|/* Dump an @interface declaration of the supplied class CHAIN to the    supplied file FP.  Used to implement the -gen-decls option (which    prints out an @interface declaration of all classes compiled in    this run); potentially useful for debugging the compiler too.  */
argument|static void dump_interface (FILE *fp, tree chain) {
comment|/* FIXME: A heap overflow here whenever a method (or ivar)      declaration is so long that it doesn't fit in the buffer.  The      code and all the related functions should be rewritten to avoid      using fixed size buffers.  */
argument|char *buf = (char *) xmalloc (
literal|1024
argument|*
literal|10
argument|);   const char *my_name = IDENTIFIER_POINTER (CLASS_NAME (chain));   tree ivar_decls = CLASS_RAW_IVARS (chain);   tree nst_methods = CLASS_NST_METHODS (chain);   tree cls_methods = CLASS_CLS_METHODS (chain);    fprintf (fp,
literal|"\n@interface %s"
argument|, my_name);
comment|/* CLASS_SUPER_NAME is used to store the superclass name for      classes, and the category name for categories.  */
argument|if (CLASS_SUPER_NAME (chain))     {       const char *name = IDENTIFIER_POINTER (CLASS_SUPER_NAME (chain));        if (TREE_CODE (chain) == CATEGORY_IMPLEMENTATION_TYPE 	  || TREE_CODE (chain) == CATEGORY_INTERFACE_TYPE) 	{ 	  fprintf (fp,
literal|" (%s)\n"
argument|, name); 	}       else 	{ 	  fprintf (fp,
literal|" : %s\n"
argument|, name); 	}     }   else     fprintf (fp,
literal|"\n"
argument|);
comment|/* FIXME - the following doesn't seem to work at the moment.  */
argument|if (ivar_decls)     {       fprintf (fp,
literal|"{\n"
argument|);       do 	{ 	  fprintf (fp,
literal|"\t%s;\n"
argument|, gen_declaration (ivar_decls, buf)); 	  ivar_decls = TREE_CHAIN (ivar_decls); 	}       while (ivar_decls);       fprintf (fp,
literal|"}\n"
argument|);     }    while (nst_methods)     {       fprintf (fp,
literal|"- %s;\n"
argument|, gen_method_decl (nst_methods, buf));       nst_methods = TREE_CHAIN (nst_methods);     }    while (cls_methods)     {       fprintf (fp,
literal|"+ %s;\n"
argument|, gen_method_decl (cls_methods, buf));       cls_methods = TREE_CHAIN (cls_methods);     }    fprintf (fp,
literal|"@end\n"
argument|); }
comment|/* Demangle function for Objective-C */
argument|static const char * objc_demangle (const char *mangled) {   char *demangled
argument_list|,
argument|*cp;    if (mangled[
literal|0
argument|] ==
literal|'_'
argument|&&       (mangled[
literal|1
argument|] ==
literal|'i'
argument||| mangled[
literal|1
argument|] ==
literal|'c'
argument|)&&       mangled[
literal|2
argument|] ==
literal|'_'
argument|)     {       cp = demangled = xmalloc(strlen(mangled) +
literal|2
argument|);       if (mangled[
literal|1
argument|] ==
literal|'i'
argument|) 	*cp++ =
literal|'-'
argument|;
comment|/* for instance method */
argument|else 	*cp++ =
literal|'+'
argument|;
comment|/* for class method */
argument|*cp++ =
literal|'['
argument|;
comment|/* opening left brace */
argument|strcpy(cp, mangled+
literal|3
argument|);
comment|/* tack on the rest of the mangled name */
argument|while (*cp&& *cp ==
literal|'_'
argument|) 	cp++;
comment|/* skip any initial underbars in class name */
argument|cp = strchr(cp,
literal|'_'
argument|);
comment|/* find first non-initial underbar */
argument|if (cp == NULL) 	{ 	  free(demangled);
comment|/* not mangled name */
argument|return mangled; 	}       if (cp[
literal|1
argument|] ==
literal|'_'
argument|)
comment|/* easy case: no category name */
argument|{ 	  *cp++ =
literal|' '
argument|;
comment|/* replace two '_' with one ' ' */
argument|strcpy(cp, mangled + (cp - demangled) +
literal|2
argument|); 	}       else 	{ 	  *cp++ =
literal|'('
argument|;
comment|/* less easy case: category name */
argument|cp = strchr(cp,
literal|'_'
argument|); 	  if (cp ==
literal|0
argument|) 	    { 	      free(demangled);
comment|/* not mangled name */
argument|return mangled; 	    } 	  *cp++ =
literal|')'
argument|; 	  *cp++ =
literal|' '
argument|;
comment|/* overwriting 1st char of method name... */
argument|strcpy(cp, mangled + (cp - demangled));
comment|/* get it back */
argument|}       while (*cp&& *cp ==
literal|'_'
argument|) 	cp++;
comment|/* skip any initial underbars in method name */
argument|for (; *cp; cp++) 	if (*cp ==
literal|'_'
argument|) 	  *cp =
literal|':'
argument|;
comment|/* replace remaining '_' with ':' */
argument|*cp++ =
literal|']'
argument|;
comment|/* closing right brace */
argument|*cp++ =
literal|0
argument|;
comment|/* string terminator */
argument|return demangled;     }   else     return mangled;
comment|/* not an objc mangled name */
argument|}  const char * objc_printable_name (tree decl, int kind ATTRIBUTE_UNUSED) {   return objc_demangle (IDENTIFIER_POINTER (DECL_NAME (decl))); }  static void init_objc (void) {   gcc_obstack_init (&util_obstack);   util_firstobj = (char *) obstack_finish (&util_obstack);    errbuf = (char *) xmalloc (BUFSIZE);   hash_init ();   synth_module_prologue (); }
argument|static void finish_objc (void) {   struct imp_entry *impent;   tree chain;
comment|/* The internally generated initializers appear to have missing braces.      Don't warn about this.  */
argument|int save_warn_missing_braces = warn_missing_braces;   warn_missing_braces =
literal|0
argument|;
comment|/* A missing @end may not be detected by the parser.  */
argument|if (objc_implementation_context)     {       warning (
literal|"`@end' missing in implementation context"
argument|);       finish_class (objc_implementation_context);       objc_ivar_chain = NULL_TREE;       objc_implementation_context = NULL_TREE;     }    generate_forward_declaration_to_string_table ();
comment|/* Process the static instances here because initialization of objc_symtab      depends on them.  */
argument|if (objc_static_instances)     generate_static_references ();    if (imp_list || class_names_chain       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)     generate_objc_symtab_decl ();    for (impent = imp_list; impent; impent = impent->next)     {       objc_implementation_context = impent->imp_context;       implementation_template = impent->imp_template;        UOBJC_CLASS_decl = impent->class_decl;       UOBJC_METACLASS_decl = impent->meta_decl;
comment|/* Dump the @interface of each class as we compile it, if the 	 -gen-decls option is in use.  TODO: Dump the classes in the          order they were found, rather than in reverse order as we          are doing now.  */
argument|if (flag_gen_declaration) 	{ 	  dump_interface (gen_declaration_file, objc_implementation_context); 	}        if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE) 	{
comment|/* all of the following reference the string pool...  */
argument|generate_ivar_lists (); 	  generate_dispatch_tables (); 	  generate_shared_structures (); 	}       else 	{ 	  generate_dispatch_tables (); 	  generate_category (objc_implementation_context); 	}     }
comment|/* If we are using an array of selectors, we must always      finish up the array decl even if no selectors were used.  */
argument|if (! flag_next_runtime || sel_ref_chain)     build_selector_translation_table ();    if (protocol_chain)     generate_protocols ();    if (flag_replace_objc_classes&& imp_list)     generate_objc_image_info ();    if (objc_implementation_context || class_names_chain || objc_static_instances       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)     {
comment|/* Arrange for ObjC data structures to be initialized at run time.  */
argument|rtx init_sym = build_module_descriptor ();       if (init_sym&& targetm.have_ctors_dtors) 	(* targetm.asm_out.constructor) (init_sym, DEFAULT_INIT_PRIORITY);     }
comment|/* Dump the class references.  This forces the appropriate classes      to be linked into the executable image, preserving unix archive      semantics.  This can be removed when we move to a more dynamically      linked environment.  */
argument|for (chain = cls_ref_chain; chain; chain = TREE_CHAIN (chain))     {       handle_class_ref (chain);       if (TREE_PURPOSE (chain)) 	generate_classref_translation_entry (chain);     }    for (impent = imp_list; impent; impent = impent->next)     handle_impent (impent);
comment|/* Dump the string table last.  */
argument|generate_strings ();    if (warn_selector)     {       int slot;       hash hsh;
comment|/* Run through the selector hash tables and print a warning for any          selector which has multiple methods.  */
argument|for (slot =
literal|0
argument|; slot< SIZEHASHTABLE; slot++) 	{ 	  for (hsh = cls_method_hash_list[slot]; hsh; hsh = hsh->next) 	    check_duplicates (hsh,
literal|0
argument|,
literal|1
argument|); 	  for (hsh = nst_method_hash_list[slot]; hsh; hsh = hsh->next) 	    check_duplicates (hsh,
literal|0
argument|,
literal|1
argument|); 	}     }    warn_missing_braces = save_warn_missing_braces; }
comment|/* Subroutines of finish_objc.  */
argument|static void generate_classref_translation_entry (tree chain) {   tree expr
argument_list|,
argument|name
argument_list|,
argument|decl_specs
argument_list|,
argument|decl
argument_list|,
argument|sc_spec;   tree type;    type = TREE_TYPE (TREE_PURPOSE (chain));    expr = add_objc_string (TREE_VALUE (chain), class_names);   expr = build_c_cast (type, expr);
comment|/* cast! */
argument|name = DECL_NAME (TREE_PURPOSE (chain));    sc_spec = build_tree_list (NULL_TREE, ridpointers[(int) RID_STATIC]);
comment|/* static struct objc_class * _OBJC_CLASS_REFERENCES_n = ...; */
argument|decl_specs = tree_cons (NULL_TREE, type, sc_spec);
comment|/* The decl that is returned from start_decl is the one that we      forward declared in build_class_reference.  */
argument|decl = start_decl (name, decl_specs,
literal|1
argument|, NULL_TREE);   DECL_CONTEXT (decl) = NULL_TREE;   finish_decl (decl, expr, NULL_TREE);   return; }  static void handle_class_ref (tree chain) {   const char *name = IDENTIFIER_POINTER (TREE_VALUE (chain));   char *string = (char *) alloca (strlen (name) +
literal|30
argument|);   tree decl;   tree exp;    sprintf (string,
literal|"%sobjc_class_name_%s"
argument|, 	   (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), name);
ifdef|#
directive|ifdef
name|ASM_DECLARE_UNRESOLVED_REFERENCE
argument|if (flag_next_runtime)     {       ASM_DECLARE_UNRESOLVED_REFERENCE (asm_out_file, string);       return;     }
endif|#
directive|endif
comment|/* Make a decl for this name, so we can use its address in a tree.  */
argument|decl = build_decl (VAR_DECL, get_identifier (string), char_type_node);   DECL_EXTERNAL (decl) =
literal|1
argument|;   TREE_PUBLIC (decl) =
literal|1
argument|;    pushdecl (decl);   rest_of_decl_compilation (decl,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|);
comment|/* Make a decl for the address.  */
argument|sprintf (string,
literal|"%sobjc_class_ref_%s"
argument|, 	   (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), name);   exp = build1 (ADDR_EXPR, string_type_node, decl);   decl = build_decl (VAR_DECL, get_identifier (string), string_type_node);   DECL_INITIAL (decl) = exp;   TREE_STATIC (decl) =
literal|1
argument|;   TREE_USED (decl) =
literal|1
argument|;    pushdecl (decl);   rest_of_decl_compilation (decl,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|); }  static void handle_impent (struct imp_entry *impent) {   char *string;    objc_implementation_context = impent->imp_context;   implementation_template = impent->imp_template;    if (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)     {       const char *const class_name = 	IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));        string = (char *) alloca (strlen (class_name) +
literal|30
argument|);        sprintf (string,
literal|"%sobjc_class_name_%s"
argument|,                (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), class_name);     }   else if (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)     {       const char *const class_name = 	IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));       const char *const class_super_name =         IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));        string = (char *) alloca (strlen (class_name) 				+ strlen (class_super_name) +
literal|30
argument|);
comment|/* Do the same for categories.  Even though no references to          these symbols are generated automatically by the compiler, it          gives you a handle to pull them into an archive by hand.  */
argument|sprintf (string,
literal|"*%sobjc_category_name_%s_%s"
argument|,                (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), class_name, class_super_name);     }   else     return;
ifdef|#
directive|ifdef
name|ASM_DECLARE_CLASS_REFERENCE
argument|if (flag_next_runtime)     {       ASM_DECLARE_CLASS_REFERENCE (asm_out_file, string);       return;     }   else
endif|#
directive|endif
argument|{       tree decl
argument_list|,
argument|init;        init = build_int_2 (
literal|0
argument|,
literal|0
argument|);       TREE_TYPE (init) = c_common_type_for_size (BITS_PER_WORD,
literal|1
argument|);       decl = build_decl (VAR_DECL, get_identifier (string), TREE_TYPE (init));       TREE_PUBLIC (decl) =
literal|1
argument|;       TREE_READONLY (decl) =
literal|1
argument|;       TREE_USED (decl) =
literal|1
argument|;       TREE_CONSTANT (decl) =
literal|1
argument|;       DECL_CONTEXT (decl) =
literal|0
argument|;       DECL_ARTIFICIAL (decl) =
literal|1
argument|;       DECL_INITIAL (decl) = init;       assemble_variable (decl,
literal|1
argument|,
literal|0
argument|,
literal|0
argument|);     } }
comment|/* The Fix-and-Countinue functionality available in Mac OS X 10.3 and    later requires that ObjC translation units participating in F&C be    specially marked.  The following routine accomplishes this.  */
comment|/* static int _OBJC_IMAGE_INFO[2] = { 0, 1 }; */
argument|static void generate_objc_image_info (void) {   tree sc_spec
argument_list|,
argument|decl
argument_list|,
argument|initlist;    sc_spec = build_tree_list (NULL_TREE, ridpointers[(int) RID_STATIC]);   decl    = start_decl (get_identifier (
literal|"_OBJC_IMAGE_INFO"
argument|), 		 tree_cons (NULL_TREE, 			    build_array_type 			    (integer_type_node, 			     build_index_type (build_int_2 (
literal|1
argument|,
literal|0
argument|))), 			    sc_spec),
literal|1
argument|, 		 NULL_TREE);    initlist = build_tree_list (NULL_TREE, build_int_2 (
literal|0
argument|,
literal|0
argument|));   initlist = tree_cons (NULL_TREE, build_int_2 (
literal|1
argument|,
literal|0
argument|), initlist);   initlist = build_constructor (TREE_TYPE (decl), nreverse (initlist));    TREE_USED (decl) = DECL_IGNORED_P (decl) = DECL_ARTIFICIAL (decl) =
literal|1
argument|;   TREE_CONSTANT (initlist) = TREE_STATIC (initlist) =
literal|1
argument|;   finish_decl (decl, initlist, NULL_TREE); }
comment|/* Look up ID as an instance variable.  */
argument|tree lookup_objc_ivar (tree id) {   tree decl;    if (objc_method_context&& !strcmp (IDENTIFIER_POINTER (id),
literal|"super"
argument|))
comment|/* We have a message to super.  */
argument|return get_super_receiver ();   else if (objc_method_context&& (decl = is_ivar (objc_ivar_chain, id)))     {       if (is_private (decl)) 	return
literal|0
argument|;       else         return build_ivar_reference (id);     }   else     return
literal|0
argument|; }
end_function

begin_include
include|#
directive|include
file|"gt-objc-objc-act.h"
end_include

begin_include
include|#
directive|include
file|"gtype-objc.h"
end_include

end_unit

