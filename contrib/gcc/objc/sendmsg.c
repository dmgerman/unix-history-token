begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime message lookup     Copyright (C) 1993, 1995 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"../tconfig.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"sarray.h"
end_include

begin_include
include|#
directive|include
file|"encoding.h"
end_include

begin_comment
comment|/* this is how we hack STRUCT_VALUE to be 1 or 0 */
end_comment

begin_define
define|#
directive|define
name|gen_rtx
parameter_list|(
name|args
modifier|...
parameter_list|)
value|1
end_define

begin_define
define|#
directive|define
name|rtx
value|int
end_define

begin_if
if|#
directive|if
name|STRUCT_VALUE
operator|==
literal|0
end_if

begin_define
define|#
directive|define
name|INVISIBLE_STRUCT_RETURN
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INVISIBLE_STRUCT_RETURN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The uninstalled dispatch table */
end_comment

begin_decl_stmt
name|struct
name|sarray
modifier|*
name|__objc_uninstalled_dtable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send +initialize to class */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_send_initialize
parameter_list|(
name|Class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__objc_install_dispatch_table_for_class
parameter_list|(
name|Class
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declare some functions */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_init_install_dtable
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|id
name|__objc_word_forward
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|id
name|many
index|[
literal|8
index|]
decl_stmt|;
block|}
name|__big
typedef|;
end_typedef

begin_if
if|#
directive|if
name|INVISIBLE_STRUCT_RETURN
end_if

begin_function_decl
specifier|static
name|__big
else|#
directive|else
specifier|static
name|id
endif|#
directive|endif
name|__objc_block_forward
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Method_t
name|search_for_method_in_hierarchy
parameter_list|(
name|Class
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Method_t
name|search_for_method_in_list
parameter_list|(
name|MethodList_t
name|list
parameter_list|,
name|SEL
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|id
name|nil_method
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|id
name|nil_method
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
return|return
name|receiver
return|;
block|}
end_function

begin_comment
comment|/* Given a class and selector, return the selector's implementation.  */
end_comment

begin_function
name|__inline__
name|IMP
name|get_imp
parameter_list|(
name|Class
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|IMP
name|impl
decl_stmt|;
name|void
modifier|*
name|res
init|=
name|sarray_get
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
operator|->
name|sel_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|__objc_init_install_dtable
condition|)
block|{
name|__objc_install_dispatch_table_for_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|res
operator|=
name|sarray_get
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
operator|->
name|sel_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|sel
operator|->
name|sel_types
decl_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'['
operator|||
operator|*
name|t
operator|==
literal|'('
operator|||
operator|*
name|t
operator|==
literal|'{'
operator|)
condition|)
name|res
operator|=
operator|(
name|IMP
operator|)
name|__objc_block_forward
expr_stmt|;
else|else
name|res
operator|=
operator|(
name|IMP
operator|)
name|__objc_word_forward
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|__inline__
name|BOOL
name|__objc_responds_to
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
name|sarray_get
argument_list|(
name|object
operator|->
name|class_pointer
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
operator|->
name|sel_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|__objc_init_install_dtable
condition|)
block|{
name|__objc_install_dispatch_table_for_class
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
name|res
operator|=
name|sarray_get
argument_list|(
name|object
operator|->
name|class_pointer
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
operator|->
name|sel_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the lookup function.  All entries in the table are either a     valid method *or* one of `__objc_missing_method' which calls    forward:: etc, or `__objc_init_install_dtable' which installs the    real dtable */
end_comment

begin_function
name|__inline__
name|IMP
name|objc_msg_lookup
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|IMP
name|result
decl_stmt|;
if|if
condition|(
name|receiver
condition|)
block|{
name|result
operator|=
name|sarray_get
argument_list|(
name|receiver
operator|->
name|class_pointer
operator|->
name|dtable
argument_list|,
operator|(
name|sidx
operator|)
name|op
operator|->
name|sel_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|op
operator|->
name|sel_types
decl_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'['
operator|||
operator|*
name|t
operator|==
literal|'('
operator|||
operator|*
name|t
operator|==
literal|'{'
operator|)
condition|)
name|result
operator|=
operator|(
name|IMP
operator|)
name|__objc_block_forward
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|IMP
operator|)
name|__objc_word_forward
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
else|else
return|return
name|nil_method
return|;
block|}
end_function

begin_function
name|IMP
name|objc_msg_lookup_super
parameter_list|(
name|Super_t
name|super
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
if|if
condition|(
name|super
operator|->
name|self
condition|)
return|return
name|get_imp
argument_list|(
name|super
operator|->
name|class
argument_list|,
name|sel
argument_list|)
return|;
else|else
return|return
name|nil_method
return|;
block|}
end_function

begin_function_decl
name|int
name|method_get_sizeof_arguments
parameter_list|(
name|Method
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|retval_t
name|objc_msg_sendv
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|op
parameter_list|,
name|arglist_t
name|arg_frame
parameter_list|)
block|{
name|Method
modifier|*
name|m
init|=
name|class_get_instance_method
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|op
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
operator|*
operator|(
operator|(
name|id
operator|*
operator|)
name|method_get_first_argument
argument_list|(
name|m
argument_list|,
name|arg_frame
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|=
name|object
expr_stmt|;
operator|*
operator|(
operator|(
name|SEL
operator|*
operator|)
name|method_get_next_argument
argument_list|(
name|arg_frame
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|=
name|op
expr_stmt|;
return|return
name|__builtin_apply
argument_list|(
operator|(
name|apply_t
operator|)
name|m
operator|->
name|method_imp
argument_list|,
name|arg_frame
argument_list|,
name|method_get_sizeof_arguments
argument_list|(
name|m
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|__objc_init_dispatch_tables
parameter_list|()
block|{
name|__objc_uninstalled_dtable
operator|=
name|sarray_new
argument_list|(
literal|200
argument_list|,
name|__objc_init_install_dtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This one is a bit hairy.  This function is installed in the     premature dispatch table, and thus called once for each class,    namely when the very first message is send to it.  */
end_comment

begin_function
specifier|static
name|void
name|__objc_init_install_dtable
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|__label__
name|already_initialized
decl_stmt|;
name|IMP
name|imp
decl_stmt|;
name|void
modifier|*
name|args
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
comment|/* This may happen, if the programmer has taken the address of a       method before the dtable was initialized... too bad for him! */
if|if
condition|(
name|receiver
operator|->
name|class_pointer
operator|->
name|dtable
operator|!=
name|__objc_uninstalled_dtable
condition|)
goto|goto
name|already_initialized
goto|;
if|if
condition|(
name|CLS_ISCLASS
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
condition|)
block|{
comment|/* receiver is an ordinary object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install instance methods table */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* call +initialize -- this will in turn install the factory  	 dispatch table if not already done :-) */
name|__objc_send_initialize
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* receiver is a class object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
operator|(
name|Class
operator|)
name|receiver
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Install real dtable for factory methods */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sel_get_name
argument_list|(
name|op
argument_list|)
argument_list|,
literal|"initialize"
argument_list|)
condition|)
name|__objc_send_initialize
argument_list|(
operator|(
name|Class
operator|)
name|receiver
argument_list|)
expr_stmt|;
else|else
name|CLS_SETINITIALIZED
argument_list|(
operator|(
name|Class
operator|)
name|receiver
argument_list|)
expr_stmt|;
block|}
name|already_initialized
label|:
comment|/* Get real method for this in newly installed dtable */
name|imp
operator|=
name|get_imp
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|args
operator|=
name|__builtin_apply_args
argument_list|()
expr_stmt|;
name|result
operator|=
name|__builtin_apply
argument_list|(
operator|(
name|apply_t
operator|)
name|imp
argument_list|,
name|args
argument_list|,
literal|96
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|__builtin_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
end_function

begin_comment
comment|/* Install dummy table for class which causes the first message to    that class (or instances hereof) to be initialized properly */
end_comment

begin_function
name|void
name|__objc_install_premature_dtable
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|assert
argument_list|(
name|__objc_uninstalled_dtable
argument_list|)
expr_stmt|;
name|class
operator|->
name|dtable
operator|=
name|__objc_uninstalled_dtable
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send +initialize to class if not already done */
end_comment

begin_function
specifier|static
name|void
name|__objc_send_initialize
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
comment|/* This *must* be a class object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|CLS_ISMETA
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLS_ISINITIALIZED
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|CLS_SETINITIALIZED
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLS_SETINITIALIZED
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|super_class
condition|)
name|__objc_send_initialize
argument_list|(
name|class
operator|->
name|super_class
argument_list|)
expr_stmt|;
block|{
name|SEL
name|op
init|=
name|sel_register_name
argument_list|(
literal|"initialize"
argument_list|)
decl_stmt|;
name|Class
name|tmpclass
init|=
name|class
decl_stmt|;
name|IMP
name|imp
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|imp
operator|&&
name|tmpclass
condition|)
block|{
name|MethodList_t
name|method_list
init|=
name|tmpclass
operator|->
name|class_pointer
operator|->
name|methods
decl_stmt|;
while|while
condition|(
operator|!
name|imp
operator|&&
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
name|Method_t
name|method
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
name|i
operator|++
control|)
block|{
name|method
operator|=
operator|&
operator|(
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
operator|->
name|sel_id
operator|==
name|op
operator|->
name|sel_id
condition|)
block|{
name|imp
operator|=
name|method
operator|->
name|method_imp
expr_stmt|;
break|break;
block|}
block|}
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
name|tmpclass
operator|=
name|tmpclass
operator|->
name|super_class
expr_stmt|;
block|}
if|if
condition|(
name|imp
condition|)
call|(
modifier|*
name|imp
call|)
argument_list|(
operator|(
name|id
operator|)
name|class
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_install_dispatch_table_for_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|Class
name|super
decl_stmt|;
name|MethodList_t
name|mlist
decl_stmt|;
name|int
name|counter
decl_stmt|;
comment|/* If the class has not yet had it's class links resolved, we must       re-compute all class links */
if|if
condition|(
operator|!
name|CLS_ISRESOLV
argument_list|(
name|class
argument_list|)
condition|)
name|__objc_resolve_class_links
argument_list|()
expr_stmt|;
name|super
operator|=
name|class
operator|->
name|super_class
expr_stmt|;
if|if
condition|(
name|super
operator|!=
literal|0
operator|&&
operator|(
name|super
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
operator|)
condition|)
name|__objc_install_dispatch_table_for_class
argument_list|(
name|super
argument_list|)
expr_stmt|;
comment|/* Allocate dtable if necessary */
if|if
condition|(
name|super
operator|==
literal|0
condition|)
block|{
name|class
operator|->
name|dtable
operator|=
name|sarray_new
argument_list|(
name|__objc_selector_max_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|class
operator|->
name|dtable
operator|=
name|sarray_lazy_copy
argument_list|(
name|super
operator|->
name|dtable
argument_list|)
expr_stmt|;
for|for
control|(
name|mlist
operator|=
name|class
operator|->
name|methods
init|;
name|mlist
condition|;
name|mlist
operator|=
name|mlist
operator|->
name|method_next
control|)
block|{
name|counter
operator|=
name|mlist
operator|->
name|method_count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|counter
operator|>=
literal|0
condition|)
block|{
name|Method_t
name|method
init|=
operator|&
operator|(
name|mlist
operator|->
name|method_list
index|[
name|counter
index|]
operator|)
decl_stmt|;
name|sarray_at_put_safe
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|sidx
operator|)
name|method
operator|->
name|method_name
operator|->
name|sel_id
argument_list|,
name|method
operator|->
name|method_imp
argument_list|)
expr_stmt|;
name|counter
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|__objc_update_dispatch_table_for_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|Class
name|next
decl_stmt|;
comment|/* not yet installed -- skip it */
if|if
condition|(
name|class
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
condition|)
return|return;
name|sarray_free
argument_list|(
name|class
operator|->
name|dtable
argument_list|)
expr_stmt|;
comment|/* release memory */
name|__objc_install_premature_dtable
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* someone might require it... */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* could have been lazy... */
if|if
condition|(
name|class
operator|->
name|subclass_list
condition|)
comment|/* Traverse subclasses */
for|for
control|(
name|next
operator|=
name|class
operator|->
name|subclass_list
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|sibling_class
control|)
name|__objc_update_dispatch_table_for_class
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function adds a method list to a class.  This function is    typically called by another function specific to the run-time.  As    such this function does not worry about thread safe issued.     This one is only called for categories. Class objects have their    methods installed right away, and their selectors are made into    SEL's by the function __objc_register_selectors_from_class. */
end_comment

begin_function
name|void
name|class_add_method_list
parameter_list|(
name|Class
name|class
parameter_list|,
name|MethodList_t
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|SEL
name|initialize_sel
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialize_sel
condition|)
name|initialize_sel
operator|=
name|sel_register_name
argument_list|(
literal|"initialize"
argument_list|)
expr_stmt|;
comment|/* Passing of a linked list is not allowed.  Do multiple calls.  */
name|assert
argument_list|(
operator|!
name|list
operator|->
name|method_next
argument_list|)
expr_stmt|;
comment|/* Check for duplicates.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
comment|/* Sometimes these are NULL */
block|{
comment|/* This is where selector names are transmogrified to SEL's */
name|method
operator|->
name|method_name
operator|=
name|sel_register_typed_name
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|method
operator|->
name|method_name
argument_list|,
name|method
operator|->
name|method_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_for_method_in_list
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|method
operator|->
name|method_name
argument_list|)
operator|&&
name|method
operator|->
name|method_name
operator|->
name|sel_id
operator|!=
name|initialize_sel
operator|->
name|sel_id
condition|)
block|{
comment|/* Duplication. Print a error message an change the method name 		 to NULL. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"attempt to add a existing method: %s\n"
argument_list|,
name|sel_get_name
argument_list|(
name|method
operator|->
name|method_name
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|->
name|method_name
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the methods to the class's method list.  */
name|list
operator|->
name|method_next
operator|=
name|class
operator|->
name|methods
expr_stmt|;
name|class
operator|->
name|methods
operator|=
name|list
expr_stmt|;
block|}
end_function

begin_function
name|Method_t
name|class_get_instance_method
parameter_list|(
name|Class
name|class
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
return|return
name|search_for_method_in_hierarchy
argument_list|(
name|class
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|Method_t
name|class_get_class_method
parameter_list|(
name|MetaClass
name|class
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
return|return
name|search_for_method_in_hierarchy
argument_list|(
name|class
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Search for a method starting from the current class up its hierarchy.    Return a pointer to the method's method structure if found.  NULL    otherwise. */
end_comment

begin_function
specifier|static
name|Method_t
name|search_for_method_in_hierarchy
parameter_list|(
name|Class
name|cls
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|Method_t
name|method
init|=
name|NULL
decl_stmt|;
name|Class
name|class
decl_stmt|;
if|if
condition|(
operator|!
name|sel_is_mapped
argument_list|(
name|sel
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Scan the method list of the class.  If the method isn't found in the      list then step to its super class. */
for|for
control|(
name|class
operator|=
name|cls
init|;
operator|(
operator|(
operator|!
name|method
operator|)
operator|&&
name|class
operator|)
condition|;
name|class
operator|=
name|class
operator|->
name|super_class
control|)
name|method
operator|=
name|search_for_method_in_list
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|sel
argument_list|)
expr_stmt|;
return|return
name|method
return|;
block|}
end_function

begin_comment
comment|/* Given a linked list of method and a method's name.  Search for the named    method's method structure.  Return a pointer to the method's method    structure if found.  NULL otherwise. */
end_comment

begin_function
specifier|static
name|Method_t
name|search_for_method_in_list
parameter_list|(
name|MethodList_t
name|list
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|MethodList_t
name|method_list
init|=
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|sel_is_mapped
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If not found then we'll search the list.  */
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Search the method list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
if|if
condition|(
name|method
operator|->
name|method_name
operator|->
name|sel_id
operator|==
name|op
operator|->
name|sel_id
condition|)
return|return
name|method
return|;
block|}
comment|/* The method wasn't found.  Follow the link to the next list of          methods.  */
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|retval_t
name|__objc_forward
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|,
name|arglist_t
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|id
name|__objc_word_forward
parameter_list|(
name|id
name|rcv
parameter_list|,
name|SEL
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
name|void
modifier|*
name|args
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|args
operator|=
name|__builtin_apply_args
argument_list|()
expr_stmt|;
name|res
operator|=
name|__objc_forward
argument_list|(
name|rcv
argument_list|,
name|op
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|__builtin_return
argument_list|(
name|res
argument_list|)
expr_stmt|;
else|else
return|return
name|res
return|;
block|}
end_function

begin_if
if|#
directive|if
name|INVISIBLE_STRUCT_RETURN
end_if

begin_function
specifier|static
name|__big
else|#
directive|else
specifier|static
name|id
endif|#
directive|endif
name|__objc_block_forward
parameter_list|(
name|id
name|rcv
parameter_list|,
name|SEL
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
name|void
modifier|*
name|args
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|args
operator|=
name|__builtin_apply_args
argument_list|()
expr_stmt|;
name|res
operator|=
name|__objc_forward
argument_list|(
name|rcv
argument_list|,
name|op
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|__builtin_return
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is installed in the dispatch table for all methods which are    not implemented.  Thus, it is called when a selector is not recognized. */
end_comment

begin_function
specifier|static
name|retval_t
name|__objc_forward
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|,
name|arglist_t
name|args
parameter_list|)
block|{
name|IMP
name|imp
decl_stmt|;
specifier|static
name|SEL
name|frwd_sel
init|=
literal|0
decl_stmt|;
name|SEL
name|err_sel
decl_stmt|;
comment|/* first try if the object understands forward:: */
if|if
condition|(
operator|!
name|frwd_sel
condition|)
name|frwd_sel
operator|=
name|sel_get_any_uid
argument_list|(
literal|"forward::"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__objc_responds_to
argument_list|(
name|object
argument_list|,
name|frwd_sel
argument_list|)
condition|)
block|{
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|frwd_sel
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|frwd_sel
argument_list|,
name|sel
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/* If the object recognizes the doesNotRecognize: method then we're going      to send it. */
name|err_sel
operator|=
name|sel_get_any_uid
argument_list|(
literal|"doesNotRecognize:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__objc_responds_to
argument_list|(
name|object
argument_list|,
name|err_sel
argument_list|)
condition|)
block|{
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|err_sel
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|err_sel
argument_list|,
name|sel
argument_list|)
return|;
block|}
comment|/* The object doesn't recognize the method.  Check for responding to      error:.  If it does then sent it. */
block|{
name|size_t
name|strlen
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
name|msg
index|[
literal|256
operator|+
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|sel_get_name
argument_list|(
name|sel
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"(%s) %s does not recognize %s"
argument_list|,
operator|(
name|CLS_ISMETA
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
literal|"class"
else|:
literal|"instance"
operator|)
argument_list|,
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|,
name|sel_get_name
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|err_sel
operator|=
name|sel_get_any_uid
argument_list|(
literal|"error:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__objc_responds_to
argument_list|(
name|object
argument_list|,
name|err_sel
argument_list|)
condition|)
block|{
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|err_sel
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|sel_get_any_uid
argument_list|(
literal|"error:"
argument_list|)
argument_list|,
name|msg
argument_list|)
return|;
block|}
comment|/* The object doesn't respond to doesNotRecognize: or error:;  Therefore,        a default action is taken. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fatal: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|__objc_print_dtable_stats
parameter_list|()
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"memory usage: (%s)\n"
argument_list|,
ifdef|#
directive|ifdef
name|OBJC_SPARSE2
literal|"2-level sparse arrays"
else|#
directive|else
literal|"3-level sparse arrays"
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arrays: %d = %ld bytes\n"
argument_list|,
name|narrays
argument_list|,
operator|(
name|int
operator|)
name|narrays
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|narrays
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"buckets: %d = %ld bytes\n"
argument_list|,
name|nbuckets
argument_list|,
operator|(
name|int
operator|)
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"idxtables: %d = %ld bytes\n"
argument_list|,
name|idxsize
argument_list|,
operator|(
name|int
operator|)
name|idxsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|idxsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total: %d bytes\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"===================================\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

