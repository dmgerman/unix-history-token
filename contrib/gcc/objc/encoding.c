begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Encoding of types for Objective C.    Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"encoding.h"
end_include

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof(X) __x = (X), __y = (Y); \      (__x> __y ? __x : __y); })
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof(X) __x = (X), __y = (Y); \      (__x< __y ? __x : __y); })
end_define

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|V
parameter_list|,
name|A
parameter_list|)
define|\
value|({ typeof(V) __v=(V); typeof(A) __a=(A); \      __a*((__v+__a-1)/__a); })
end_define

begin_function
specifier|static
specifier|inline
name|int
name|atoi
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|res
operator|*=
literal|10
operator|,
name|res
operator|+=
operator|(
operator|*
name|str
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*   return the size of an object specified by type  */
end_comment

begin_function
name|int
name|objc_sizeof_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ID
case|:
return|return
sizeof|sizeof
argument_list|(
name|id
argument_list|)
return|;
break|break;
case|case
name|_C_CLASS
case|:
return|return
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
return|;
break|break;
case|case
name|_C_SEL
case|:
return|return
sizeof|sizeof
argument_list|(
name|SEL
argument_list|)
return|;
break|break;
case|case
name|_C_CHR
case|:
return|return
sizeof|sizeof
argument_list|(
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
sizeof|sizeof
argument_list|(
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
sizeof|sizeof
argument_list|(
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
sizeof|sizeof
argument_list|(
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
sizeof|sizeof
argument_list|(
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
sizeof|sizeof
argument_list|(
name|double
argument_list|)
return|;
break|break;
case|case
name|_C_VOID
case|:
return|return
sizeof|sizeof
argument_list|(
name|void
argument_list|)
return|;
break|break;
case|case
name|_C_PTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_CHARPTR
case|:
return|return
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
return|;
break|break;
case|case
name|_C_ARY_B
case|:
block|{
name|int
name|len
init|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
return|return
name|len
operator|*
name|objc_aligned_size
argument_list|(
name|type
argument_list|)
return|;
block|}
break|break;
case|case
name|_C_STRUCT_B
case|:
block|{
name|int
name|acc_size
init|=
literal|0
decl_stmt|;
name|int
name|align
decl_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
empty_stmt|;
comment|/* skip "<name>=" */
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
condition|)
block|{
name|align
operator|=
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* padd to alignment */
name|acc_size
operator|=
name|ROUND
argument_list|(
name|acc_size
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|acc_size
operator|+=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* add component size */
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* skip component */
block|}
return|return
name|acc_size
return|;
block|}
case|case
name|_C_UNION_B
case|:
block|{
name|int
name|max_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
comment|/* do nothing */
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
condition|)
block|{
name|max_size
operator|=
name|MAX
argument_list|(
name|max_size
argument_list|,
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|max_size
return|;
block|}
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   Return the alignment of an object specified by type  */
end_comment

begin_function
name|int
name|objc_alignof_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ID
case|:
return|return
name|__alignof__
argument_list|(
name|id
argument_list|)
return|;
break|break;
case|case
name|_C_CLASS
case|:
return|return
name|__alignof__
argument_list|(
name|Class
argument_list|)
return|;
break|break;
case|case
name|_C_SEL
case|:
return|return
name|__alignof__
argument_list|(
name|SEL
argument_list|)
return|;
break|break;
case|case
name|_C_CHR
case|:
return|return
name|__alignof__
argument_list|(
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned char
argument_list|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
name|__alignof__
argument_list|(
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned short
argument_list|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
name|__alignof__
argument_list|(
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned int
argument_list|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
name|__alignof__
argument_list|(
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned long
argument_list|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
name|__alignof__
argument_list|(
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
name|__alignof__
argument_list|(
name|double
argument_list|)
return|;
break|break;
case|case
name|_C_PTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_CHARPTR
case|:
return|return
name|__alignof__
argument_list|(
name|char
operator|*
argument_list|)
return|;
break|break;
case|case
name|_C_ARY_B
case|:
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
return|return
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
return|;
case|case
name|_C_STRUCT_B
case|:
block|{
struct|struct
block|{
name|int
name|x
decl_stmt|;
name|double
name|y
decl_stmt|;
block|}
name|fooalign
struct|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
condition|)
return|return
name|MAX
argument_list|(
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|__alignof__
argument_list|(
name|fooalign
argument_list|)
argument_list|)
return|;
else|else
return|return
name|__alignof__
argument_list|(
name|fooalign
argument_list|)
return|;
block|}
case|case
name|_C_UNION_B
case|:
block|{
name|int
name|maxalign
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
comment|/* do nothing */
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
condition|)
block|{
name|maxalign
operator|=
name|MAX
argument_list|(
name|maxalign
argument_list|,
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|maxalign
return|;
block|}
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   The aligned size if the size rounded up to the nearest alignment. */
end_comment

begin_function
name|int
name|objc_aligned_size
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|size
init|=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|ROUND
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   The size rounded up to the nearest integral of the wordsize, taken   to be the size of a void*. */
end_comment

begin_function
name|int
name|objc_promoted_size
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|size
init|=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|wordsize
init|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
return|return
name|ROUND
argument_list|(
name|size
argument_list|,
name|wordsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Skip type qualifiers.  These may eventually precede typespecs   occurring in method prototype encodings. */
end_comment

begin_function
specifier|inline
specifier|const
name|char
modifier|*
name|objc_skip_type_qualifiers
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
while|while
condition|(
operator|*
name|type
operator|==
name|_C_CONST
operator|||
operator|*
name|type
operator|==
name|_C_IN
operator|||
operator|*
name|type
operator|==
name|_C_INOUT
operator|||
operator|*
name|type
operator|==
name|_C_OUT
operator|||
operator|*
name|type
operator|==
name|_C_BYCOPY
operator|||
operator|*
name|type
operator|==
name|_C_ONEWAY
condition|)
block|{
name|type
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Skip one typespec element.  If the typespec is prepended by type   qualifiers, these are skipped as well. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|objc_skip_typespec
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ID
case|:
comment|/* An id may be annotated by the actual type if it is known        with the @"ClassName" syntax */
if|if
condition|(
operator|*
operator|++
name|type
operator|!=
literal|'"'
condition|)
return|return
name|type
return|;
else|else
block|{
while|while
condition|(
operator|*
operator|++
name|type
operator|!=
literal|'"'
condition|)
comment|/* do nothing */
empty_stmt|;
return|return
name|type
operator|+
literal|1
return|;
block|}
comment|/* The following are one character type codes */
case|case
name|_C_CLASS
case|:
case|case
name|_C_SEL
case|:
case|case
name|_C_CHR
case|:
case|case
name|_C_UCHR
case|:
case|case
name|_C_CHARPTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_SHT
case|:
case|case
name|_C_USHT
case|:
case|case
name|_C_INT
case|:
case|case
name|_C_UINT
case|:
case|case
name|_C_LNG
case|:
case|case
name|_C_ULNG
case|:
case|case
name|_C_FLT
case|:
case|case
name|_C_DBL
case|:
case|case
name|_C_VOID
case|:
case|case
name|_C_UNDEF
case|:
return|return
operator|++
name|type
return|;
break|break;
case|case
name|_C_ARY_B
case|:
comment|/* skip digits, typespec and closing ']' */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|_C_ARY_E
condition|)
return|return
operator|++
name|type
return|;
else|else
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"bad array type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|_C_STRUCT_B
case|:
comment|/* skip name, and elements until closing '}'  */
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
condition|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|type
return|;
case|case
name|_C_UNION_B
case|:
comment|/* skip name, and elements until closing ')'  */
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
condition|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|type
return|;
case|case
name|_C_PTR
case|:
comment|/* Just skip the following typespec */
return|return
name|objc_skip_typespec
argument_list|(
operator|++
name|type
argument_list|)
return|;
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   Skip an offset as part of a method encoding.  This is prepended by a   '+' if the argument is passed in registers. */
end_comment

begin_function
specifier|inline
specifier|const
name|char
modifier|*
name|objc_skip_offset
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
operator|*
name|type
operator|==
literal|'+'
condition|)
name|type
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Skip an argument specification of a method encoding. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|objc_skip_argspec
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|objc_skip_offset
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Return the number of arguments that the method MTH expects.   Note that all methods need two implicit arguments `self' and   `_cmd'.  */
end_comment

begin_function
name|int
name|method_get_number_of_arguments
parameter_list|(
name|struct
name|objc_method
modifier|*
name|mth
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|mth
operator|->
name|method_types
decl_stmt|;
while|while
condition|(
operator|*
name|type
condition|)
block|{
name|type
operator|=
name|objc_skip_argspec
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|i
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*   Return the size of the argument block needed on the stack to invoke   the method MTH.  This may be zero, if all arguments are passed in   registers. */
end_comment

begin_function
name|int
name|method_get_sizeof_arguments
parameter_list|(
name|struct
name|objc_method
modifier|*
name|mth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|type
init|=
name|objc_skip_typespec
argument_list|(
name|mth
operator|->
name|method_types
argument_list|)
decl_stmt|;
return|return
name|atoi
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Return a pointer to the next argument of ARGFRAME.  type points to   the last argument.  Typical use of this look like:    {     char *datum, *type;      for (datum = method_get_first_argument (method, argframe,&type);          datum; datum = method_get_next_argument (argframe,&type))       {         unsigned flags = objc_get_type_qualifiers (type);         type = objc_skip_type_qualifiers (type); 	if (*type != _C_PTR)           [portal encodeData: datum ofType: type]; 	else 	  { 	    if ((flags& _F_IN) == _F_IN)               [portal encodeData: *(char**)datum ofType: ++type]; 	  }       }   } */
end_comment

begin_function
name|char
modifier|*
name|method_get_next_argument
parameter_list|(
name|arglist_t
name|argframe
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|objc_skip_argspec
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
operator|*
name|type
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|objc_skip_typespec
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
return|return
name|argframe
operator|->
name|arg_regs
operator|+
name|atoi
argument_list|(
operator|++
name|t
argument_list|)
return|;
else|else
return|return
name|argframe
operator|->
name|arg_ptr
operator|+
name|atoi
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Return a pointer to the value of the first argument of the method    described in M with the given argumentframe ARGFRAME.  The type   is returned in TYPE.  type must be passed to successive calls of    method_get_next_argument. */
end_comment

begin_function
name|char
modifier|*
name|method_get_first_argument
parameter_list|(
name|struct
name|objc_method
modifier|*
name|m
parameter_list|,
name|arglist_t
name|argframe
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
operator|*
name|type
operator|=
name|m
operator|->
name|method_types
expr_stmt|;
return|return
name|method_get_next_argument
argument_list|(
name|argframe
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    Return a pointer to the ARGth argument of the method    M from the frame ARGFRAME.  The type of the argument    is returned in the value-result argument TYPE  */
end_comment

begin_function
name|char
modifier|*
name|method_get_nth_argument
parameter_list|(
name|struct
name|objc_method
modifier|*
name|m
parameter_list|,
name|arglist_t
name|argframe
parameter_list|,
name|int
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|objc_skip_argspec
argument_list|(
name|m
operator|->
name|method_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|>
name|method_get_number_of_arguments
argument_list|(
name|m
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|arg
operator|--
condition|)
name|t
operator|=
name|objc_skip_argspec
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|objc_skip_typespec
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
return|return
name|argframe
operator|->
name|arg_regs
operator|+
name|atoi
argument_list|(
operator|++
name|t
argument_list|)
return|;
else|else
return|return
name|argframe
operator|->
name|arg_ptr
operator|+
name|atoi
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|objc_get_type_qualifiers
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|res
init|=
literal|0
decl_stmt|;
name|BOOL
name|flag
init|=
name|YES
decl_stmt|;
while|while
condition|(
name|flag
condition|)
switch|switch
condition|(
operator|*
name|type
operator|++
condition|)
block|{
case|case
name|_C_CONST
case|:
name|res
operator||=
name|_F_CONST
expr_stmt|;
break|break;
case|case
name|_C_IN
case|:
name|res
operator||=
name|_F_IN
expr_stmt|;
break|break;
case|case
name|_C_INOUT
case|:
name|res
operator||=
name|_F_INOUT
expr_stmt|;
break|break;
case|case
name|_C_OUT
case|:
name|res
operator||=
name|_F_OUT
expr_stmt|;
break|break;
case|case
name|_C_BYCOPY
case|:
name|res
operator||=
name|_F_BYCOPY
expr_stmt|;
break|break;
case|case
name|_C_ONEWAY
case|:
name|res
operator||=
name|_F_ONEWAY
expr_stmt|;
break|break;
default|default:
name|flag
operator|=
name|NO
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

end_unit

