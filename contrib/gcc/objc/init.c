begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime initialization     Copyright (C) 1993, 1995 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_comment
comment|/* The version number of this runtime.  This must match the number     defined in gcc (objc-act.c) */
end_comment

begin_define
define|#
directive|define
name|OBJC_VERSION
value|7
end_define

begin_define
define|#
directive|define
name|PROTOCOL_VERSION
value|2
end_define

begin_comment
comment|/* This list contains all modules currently loaded into the runtime */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|__objc_module_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This list contains all proto_list's not yet assigned class links */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|unclaimed_proto_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of unresolved static instances.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|uninitialized_statics
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check compiler vs runtime version */
end_comment

begin_function_decl
specifier|static
name|void
name|init_check_module_version
parameter_list|(
name|Module_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Assign isa links to protos */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_init_protocols
parameter_list|(
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add protocol to class */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_class_add_protocols
parameter_list|(
name|Class
parameter_list|,
name|struct
name|objc_protocol_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is a hook which is called by __objc_exec_class every time a class    or a category is loaded into the runtime.  This may e.g. help a    dynamic loader determine the classes that have been loaded when    an object file is dynamically linked in */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|_objc_load_callback
function_decl|)
parameter_list|(
name|Class
name|class
parameter_list|,
name|Category
modifier|*
name|category
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/* Is all categories/classes resolved? */
end_comment

begin_decl_stmt
name|BOOL
name|__objc_dangling_categories
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|SEL
name|__sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|,
name|struct
name|objc_selector
modifier|*
name|orig
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Run through the statics list, removing modules as soon as all its statics    have been initialized.  */
end_comment

begin_function
specifier|static
name|void
name|objc_init_statics
parameter_list|()
block|{
name|struct
name|objc_list
modifier|*
modifier|*
name|cell
init|=
operator|&
name|uninitialized_statics
decl_stmt|;
name|struct
name|objc_static_instances
modifier|*
modifier|*
name|statics_in_module
decl_stmt|;
while|while
condition|(
operator|*
name|cell
condition|)
block|{
name|int
name|module_initialized
init|=
literal|1
decl_stmt|;
for|for
control|(
name|statics_in_module
operator|=
operator|(
operator|*
name|cell
operator|)
operator|->
name|head
init|;
operator|*
name|statics_in_module
condition|;
name|statics_in_module
operator|++
control|)
block|{
name|struct
name|objc_static_instances
modifier|*
name|statics
init|=
operator|*
name|statics_in_module
decl_stmt|;
name|Class
name|class
init|=
name|objc_lookup_class
argument_list|(
name|statics
operator|->
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|class
condition|)
name|module_initialized
operator|=
literal|0
expr_stmt|;
comment|/* Actually, the static's class_pointer will be NULL when we              haven't been here before.  However, the comparison is to be              reminded of taking into account class posing and to think about              possible semantics...  */
elseif|else
if|if
condition|(
name|class
operator|!=
name|statics
operator|->
name|instances
index|[
literal|0
index|]
operator|->
name|class_pointer
condition|)
block|{
name|id
modifier|*
name|inst
decl_stmt|;
for|for
control|(
name|inst
operator|=
operator|&
name|statics
operator|->
name|instances
index|[
literal|0
index|]
init|;
operator|*
name|inst
condition|;
name|inst
operator|++
control|)
block|{
operator|(
operator|*
name|inst
operator|)
operator|->
name|class_pointer
operator|=
name|class
expr_stmt|;
comment|/* ??? Make sure the object will not be freed.  With                      refcounting, invoke `-retain'.  Without refcounting, do                      nothing and hope that `-free' will never be invoked.  */
comment|/* ??? Send the object an `-initStatic' or something to                      that effect now or later on?  What are the semantics of                      statically allocated instances, besides the trivial                      NXConstantString, anyway?  */
block|}
block|}
block|}
if|if
condition|(
name|module_initialized
condition|)
block|{
comment|/* Remove this module from the uninitialized list.  */
name|struct
name|objc_list
modifier|*
name|this
init|=
operator|*
name|cell
decl_stmt|;
operator|*
name|cell
operator|=
name|this
operator|->
name|tail
expr_stmt|;
name|free
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
name|cell
operator|=
operator|&
operator|(
operator|*
name|cell
operator|)
operator|->
name|tail
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* objc_init_statics */
end_comment

begin_comment
comment|/* This function is called by constructor functions generated for each    module compiled.  (_GLOBAL_$I$...) The purpose of this function is to    gather the module pointers so that they may be processed by the    initialization routines as soon as possible */
end_comment

begin_function
name|void
name|__objc_exec_class
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
comment|/* Have we processed any constructors previously?  This flag is used to      indicate that some global data structures need to be built.  */
specifier|static
name|BOOL
name|previous_constructors
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|objc_list
modifier|*
name|unclaimed_categories
init|=
literal|0
decl_stmt|;
comment|/* The symbol table (defined in objc-api.h) generated by gcc */
name|Symtab_t
name|symtab
init|=
name|module
operator|->
name|symtab
decl_stmt|;
comment|/* Entry used to traverse hash lists */
name|struct
name|objc_list
modifier|*
modifier|*
name|cell
decl_stmt|;
comment|/* The table of selector references for this module */
name|SEL
name|selectors
init|=
name|symtab
operator|->
name|refs
decl_stmt|;
comment|/* dummy counter */
name|int
name|i
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"received module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* check gcc version */
name|init_check_module_version
argument_list|(
name|module
argument_list|)
expr_stmt|;
comment|/* On the first call of this routine, initialize some data structures.  */
if|if
condition|(
operator|!
name|previous_constructors
condition|)
block|{
name|__objc_init_selector_tables
argument_list|()
expr_stmt|;
name|__objc_init_class_tables
argument_list|()
expr_stmt|;
name|__objc_init_dispatch_tables
argument_list|()
expr_stmt|;
name|previous_constructors
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Save the module pointer for later processing. (not currently used) */
name|__objc_module_list
operator|=
name|list_cons
argument_list|(
name|module
argument_list|,
name|__objc_module_list
argument_list|)
expr_stmt|;
comment|/* Replace referenced selectors from names to SEL's.  */
if|if
condition|(
name|selectors
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|selectors
index|[
name|i
index|]
operator|.
name|sel_id
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|selectors
index|[
name|i
index|]
operator|.
name|sel_id
expr_stmt|;
name|type
operator|=
operator|(
name|char
operator|*
operator|)
name|selectors
index|[
name|i
index|]
operator|.
name|sel_types
expr_stmt|;
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
operator|(
expr|struct
name|objc_selector
operator|*
operator|)
operator|&
operator|(
name|selectors
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Parse the classes in the load module and gather selector information.  */
name|DEBUG_PRINTF
argument_list|(
literal|"gathering selectors from module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cls_def_cnt
condition|;
operator|++
name|i
control|)
block|{
name|Class
name|class
init|=
operator|(
name|Class
operator|)
name|symtab
operator|->
name|defs
index|[
name|i
index|]
decl_stmt|;
comment|/* Make sure we have what we think.  */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"phase 1, processing class: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Store the class in the class table and assign class numbers.  */
name|__objc_add_class_to_hash
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* Register all of the selectors in the class and meta class.  */
name|__objc_register_selectors_from_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|__objc_register_selectors_from_class
argument_list|(
operator|(
name|Class
operator|)
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* Install the fake dispatch tables */
name|__objc_install_premature_dtable
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|__objc_install_premature_dtable
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|protocols
condition|)
name|__objc_init_protocols
argument_list|(
name|class
operator|->
name|protocols
argument_list|)
expr_stmt|;
if|if
condition|(
name|_objc_load_callback
condition|)
name|_objc_load_callback
argument_list|(
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Process category information from the module.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cat_def_cnt
condition|;
operator|++
name|i
control|)
block|{
name|Category_t
name|category
init|=
name|symtab
operator|->
name|defs
index|[
name|i
operator|+
name|symtab
operator|->
name|cls_def_cnt
index|]
decl_stmt|;
name|Class
name|class
init|=
name|objc_lookup_class
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
comment|/* If the class for the category exists then append its methods.  */
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"processing categories from (module,object): %s, %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Do instance methods.  */
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|class_add_method_list
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
comment|/* Do class methods.  */
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|class_add_method_list
argument_list|(
operator|(
name|Class
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|protocols
condition|)
block|{
name|__objc_init_protocols
argument_list|(
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
name|__objc_class_add_protocols
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_objc_load_callback
condition|)
name|_objc_load_callback
argument_list|(
name|class
argument_list|,
name|category
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The object to which the category methods belong can't be found. 	     Save the information.  */
name|unclaimed_categories
operator|=
name|list_cons
argument_list|(
name|category
argument_list|,
name|unclaimed_categories
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|module
operator|->
name|statics
condition|)
name|uninitialized_statics
operator|=
name|list_cons
argument_list|(
name|module
operator|->
name|statics
argument_list|,
name|uninitialized_statics
argument_list|)
expr_stmt|;
if|if
condition|(
name|uninitialized_statics
condition|)
name|objc_init_statics
argument_list|()
expr_stmt|;
comment|/* Scan the unclaimed category hash.  Attempt to attach any unclaimed      categories to objects.  */
for|for
control|(
name|cell
operator|=
operator|&
name|unclaimed_categories
init|;
operator|*
name|cell
condition|;
operator|(
block|{
if|if
condition|(
operator|*
name|cell
condition|)
name|cell
operator|=
operator|&
operator|(
operator|*
name|cell
operator|)
operator|->
name|tail
expr_stmt|;
block|}
control|)
block|)
block|{
name|Category_t
name|category
init|=
operator|(
operator|*
name|cell
operator|)
operator|->
name|head
decl_stmt|;
name|Class
name|class
init|=
name|objc_lookup_class
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"attaching stored categories to object: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
name|list_remove_head
argument_list|(
name|cell
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|class_add_method_list
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|class_add_method_list
argument_list|(
operator|(
name|Class
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|protocols
condition|)
block|{
name|__objc_init_protocols
argument_list|(
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
name|__objc_class_add_protocols
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_objc_load_callback
condition|)
name|_objc_load_callback
argument_list|(
name|class
argument_list|,
name|category
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|if
condition|(
name|unclaimed_proto_list
operator|&&
name|objc_lookup_class
argument_list|(
literal|"Protocol"
argument_list|)
condition|)
block|{
name|list_mapcar
argument_list|(
name|unclaimed_proto_list
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|__objc_init_protocols
argument_list|)
expr_stmt|;
name|list_free
argument_list|(
name|unclaimed_proto_list
argument_list|)
expr_stmt|;
name|unclaimed_proto_list
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|/* Sanity check the version of gcc used to compile `module'*/
end_comment

begin_function
unit|static
name|void
name|init_check_module_version
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
if|if
condition|(
operator|(
name|module
operator|->
name|version
operator|!=
name|OBJC_VERSION
operator|)
operator|||
operator|(
name|module
operator|->
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|Module
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Module %s version %d doesn't match runtime %d\n"
argument_list|,
name|module
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|module
operator|->
name|version
argument_list|,
name|OBJC_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|module
operator|->
name|version
operator|>
name|OBJC_VERSION
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Runtime (libobjc.a) is out of date\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|module
operator|->
name|version
operator|<
name|OBJC_VERSION
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compiler (gcc) is out of date\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Objective C internal error -- bad Module size\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_init_protocols
parameter_list|(
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|Class
name|proto_class
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|protos
condition|)
return|return;
if|if
condition|(
operator|!
name|proto_class
condition|)
name|proto_class
operator|=
name|objc_lookup_class
argument_list|(
literal|"Protocol"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proto_class
condition|)
block|{
name|unclaimed_proto_list
operator|=
name|list_cons
argument_list|(
name|protos
argument_list|,
name|unclaimed_proto_list
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|assert (protos->next == 0);
comment|/* only single ones allowed */
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|protos
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|objc_protocol
modifier|*
name|aProto
init|=
name|protos
operator|->
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|aProto
operator|->
name|class_pointer
operator|)
operator|==
name|PROTOCOL_VERSION
condition|)
block|{
comment|/* assign class pointer */
name|aProto
operator|->
name|class_pointer
operator|=
name|proto_class
expr_stmt|;
comment|/* init super protocols */
name|__objc_init_protocols
argument_list|(
name|aProto
operator|->
name|protocol_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|protos
operator|->
name|list
index|[
name|i
index|]
operator|->
name|class_pointer
operator|!=
name|proto_class
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Version %d doesn't match runtime protocol version %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|protos
operator|->
name|list
index|[
name|i
index|]
operator|->
name|class_pointer
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
argument_list|,
name|PROTOCOL_VERSION
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_class_add_protocols
parameter_list|(
name|Class
name|class
parameter_list|,
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
block|{
comment|/* Well... */
if|if
condition|(
operator|!
name|protos
condition|)
return|return;
comment|/* Add it... */
name|protos
operator|->
name|next
operator|=
name|class
operator|->
name|protocols
expr_stmt|;
name|class
operator|->
name|protocols
operator|=
name|protos
expr_stmt|;
block|}
end_function

end_unit

