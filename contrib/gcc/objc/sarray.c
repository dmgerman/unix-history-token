begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Sparse Arrays for Objective C dispatch tables    Copyright (C) 1993, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"objc/sarray.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_decl_stmt
name|int
name|nbuckets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nindices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|narrays
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|idxsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJC_SPARSE2
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|__objc_sparse2_id
init|=
literal|"2 level sparse indices"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|__objc_sparse3_id
init|=
literal|"3 level sparse indices"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_function_decl
specifier|const
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sarray_at_put
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|,
name|sidx
name|index
parameter_list|,
name|void
modifier|*
name|element
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|struct
name|sindex
modifier|*
modifier|*
name|the_index
decl_stmt|;
endif|#
directive|endif
name|struct
name|sbucket
modifier|*
modifier|*
name|the_bucket
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|ioffset
decl_stmt|;
endif|#
directive|endif
name|size_t
name|boffset
decl_stmt|;
name|size_t
name|eoffset
decl_stmt|;
ifdef|#
directive|ifdef
name|PRECOMPUTE_SELECTORS
name|union
name|sofftype
name|xx
decl_stmt|;
name|xx
operator|.
name|idx
operator|=
name|index
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|ioffset
operator|=
name|xx
operator|.
name|off
operator|.
name|ioffset
expr_stmt|;
endif|#
directive|endif
name|boffset
operator|=
name|xx
operator|.
name|off
operator|.
name|boffset
expr_stmt|;
name|eoffset
operator|=
name|xx
operator|.
name|off
operator|.
name|eoffset
expr_stmt|;
else|#
directive|else
comment|/* not PRECOMPUTE_SELECTORS */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|ioffset
operator|=
name|index
operator|/
name|INDEX_CAPACITY
expr_stmt|;
name|boffset
operator|=
operator|(
name|index
operator|/
name|BUCKET_SIZE
operator|)
operator|%
name|INDEX_SIZE
expr_stmt|;
name|eoffset
operator|=
name|index
operator|%
name|BUCKET_SIZE
expr_stmt|;
else|#
directive|else
name|boffset
operator|=
name|index
operator|/
name|BUCKET_SIZE
expr_stmt|;
name|eoffset
operator|=
name|index
operator|%
name|BUCKET_SIZE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* not PRECOMPUTE_SELECTORS */
name|assert
argument_list|(
name|soffset_decode
argument_list|(
name|index
argument_list|)
operator|<
name|array
operator|->
name|capacity
argument_list|)
expr_stmt|;
comment|/* Range check */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|the_index
operator|=
operator|&
operator|(
name|array
operator|->
name|indices
index|[
name|ioffset
index|]
operator|)
expr_stmt|;
name|the_bucket
operator|=
operator|&
operator|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
else|#
directive|else
name|the_bucket
operator|=
operator|&
operator|(
name|array
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|elems
index|[
name|eoffset
index|]
operator|==
name|element
condition|)
return|return;
comment|/* great! we just avoided a lazy copy */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* First, perform lazy copy/allocation of index if needed */
if|if
condition|(
operator|(
operator|*
name|the_index
operator|)
operator|==
name|array
operator|->
name|empty_index
condition|)
block|{
comment|/* The index was previously empty, allocate a new */
operator|*
name|the_index
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|the_index
argument_list|,
name|array
operator|->
name|empty_index
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|the_index
operator|)
operator|->
name|version
operator|=
name|array
operator|->
name|version
expr_stmt|;
name|the_bucket
operator|=
operator|&
operator|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
name|nindices
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|version
operator|!=
name|array
operator|->
name|version
condition|)
block|{
comment|/* This index must be lazy copied */
name|struct
name|sindex
modifier|*
name|old_index
init|=
operator|*
name|the_index
decl_stmt|;
operator|*
name|the_index
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|the_index
argument_list|,
name|old_index
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|the_index
operator|)
operator|->
name|version
operator|=
name|array
operator|->
name|version
expr_stmt|;
name|the_bucket
operator|=
operator|&
operator|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
name|nindices
operator|+=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJC_SPARSE3 */
comment|/* next, perform lazy allocation/copy of the bucket if needed */
if|if
condition|(
operator|(
operator|*
name|the_bucket
operator|)
operator|==
name|array
operator|->
name|empty_bucket
condition|)
block|{
comment|/* The bucket was previously empty (or something like that), */
comment|/* allocate a new.  This is the effect of `lazy' allocation */
operator|*
name|the_bucket
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|the_bucket
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|array
operator|->
name|empty_bucket
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|version
operator|=
name|array
operator|->
name|version
expr_stmt|;
name|nbuckets
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|version
operator|!=
name|array
operator|->
name|version
condition|)
block|{
comment|/* Perform lazy copy. */
name|struct
name|sbucket
modifier|*
name|old_bucket
init|=
operator|*
name|the_bucket
decl_stmt|;
operator|*
name|the_bucket
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|the_bucket
argument_list|,
name|old_bucket
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|version
operator|=
name|array
operator|->
name|version
expr_stmt|;
name|nbuckets
operator|+=
literal|1
expr_stmt|;
block|}
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|elems
index|[
name|eoffset
index|]
operator|=
name|element
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sarray_at_put_safe
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|,
name|sidx
name|index
parameter_list|,
name|void
modifier|*
name|element
parameter_list|)
block|{
if|if
condition|(
name|soffset_decode
argument_list|(
name|index
argument_list|)
operator|>=
name|array
operator|->
name|capacity
condition|)
name|sarray_realloc
argument_list|(
name|array
argument_list|,
name|soffset_decode
argument_list|(
name|index
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sarray_at_put
argument_list|(
name|array
argument_list|,
name|index
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|sarray
modifier|*
name|sarray_new
parameter_list|(
name|int
name|size
parameter_list|,
name|void
modifier|*
name|default_element
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
operator|(
name|INDEX_CAPACITY
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
operator|)
operator|+
literal|1
decl_stmt|;
endif|#
directive|endif
name|int
name|counter
decl_stmt|;
name|struct
name|sarray
modifier|*
name|arr
decl_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate core array */
name|arr
operator|=
operator|(
expr|struct
name|sarray
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|version
operator|=
literal|0
expr_stmt|;
name|narrays
operator|+=
literal|1
expr_stmt|;
comment|/* Initialize members */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|arr
operator|->
name|capacity
operator|=
name|num_indices
operator|*
name|INDEX_CAPACITY
expr_stmt|;
name|arr
operator|->
name|indices
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|idxsize
operator|+=
name|num_indices
expr_stmt|;
name|arr
operator|->
name|empty_index
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|empty_index
operator|->
name|version
operator|=
literal|0
expr_stmt|;
name|nindices
operator|+=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|arr
operator|->
name|capacity
operator|=
name|num_indices
operator|*
name|BUCKET_SIZE
expr_stmt|;
name|arr
operator|->
name|buckets
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|idxsize
operator|+=
name|num_indices
expr_stmt|;
endif|#
directive|endif
name|arr
operator|->
name|empty_bucket
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|empty_bucket
operator|->
name|version
operator|=
literal|0
expr_stmt|;
name|nbuckets
operator|+=
literal|1
expr_stmt|;
name|arr
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|arr
operator|->
name|is_copy_of
operator|=
operator|(
expr|struct
name|sarray
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|BUCKET_SIZE
condition|;
name|counter
operator|++
control|)
name|arr
operator|->
name|empty_bucket
operator|->
name|elems
index|[
name|counter
index|]
operator|=
name|default_element
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|INDEX_SIZE
condition|;
name|counter
operator|++
control|)
name|arr
operator|->
name|empty_index
operator|->
name|buckets
index|[
name|counter
index|]
operator|=
name|arr
operator|->
name|empty_bucket
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|num_indices
condition|;
name|counter
operator|++
control|)
name|arr
operator|->
name|indices
index|[
name|counter
index|]
operator|=
name|arr
operator|->
name|empty_index
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|num_indices
condition|;
name|counter
operator|++
control|)
name|arr
operator|->
name|buckets
index|[
name|counter
index|]
operator|=
name|arr
operator|->
name|empty_bucket
expr_stmt|;
endif|#
directive|endif
return|return
name|arr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reallocate the sparse array to hold `newsize' entries */
end_comment

begin_function
name|void
name|sarray_realloc
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|,
name|int
name|newsize
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
decl_stmt|;
name|size_t
name|new_max_index
init|=
operator|(
operator|(
name|newsize
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
operator|)
decl_stmt|;
name|size_t
name|rounded_size
init|=
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
name|INDEX_CAPACITY
decl_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
decl_stmt|;
name|size_t
name|new_max_index
init|=
operator|(
operator|(
name|newsize
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
operator|)
decl_stmt|;
name|size_t
name|rounded_size
init|=
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
name|BUCKET_SIZE
decl_stmt|;
endif|#
directive|endif
name|int
name|counter
decl_stmt|;
name|assert
argument_list|(
name|newsize
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* The size is the same, just ignore the request */
if|if
condition|(
name|rounded_size
operator|==
name|array
operator|->
name|capacity
condition|)
return|return;
name|assert
argument_list|(
name|array
operator|->
name|ref_count
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* stop if lazy copied... */
if|if
condition|(
name|rounded_size
operator|<
name|array
operator|->
name|capacity
condition|)
block|{
comment|/* update capacity */
name|array
operator|->
name|capacity
operator|=
name|rounded_size
expr_stmt|;
comment|/* free buckets above new_max_index */
for|for
control|(
name|counter
operator|=
name|old_max_index
init|;
name|counter
operator|>
name|new_max_index
condition|;
name|counter
operator|--
control|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|struct
name|sindex
modifier|*
name|idx
init|=
name|array
operator|->
name|indices
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|idx
operator|!=
name|array
operator|->
name|empty_index
operator|)
operator|&&
operator|(
name|idx
operator|->
name|version
operator|==
name|array
operator|->
name|version
operator|)
condition|)
block|{
name|int
name|c2
decl_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|INDEX_SIZE
condition|;
name|c2
operator|++
control|)
block|{
name|struct
name|sbucket
modifier|*
name|bkt
init|=
name|idx
operator|->
name|buckets
index|[
name|c2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|bkt
operator|!=
name|array
operator|->
name|empty_bucket
operator|)
operator|&&
operator|(
name|bkt
operator|->
name|version
operator|==
name|array
operator|->
name|version
operator|)
condition|)
block|{
name|free
argument_list|(
name|bkt
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|nindices
operator|-=
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|struct
name|sbucket
modifier|*
name|bkt
init|=
name|array
operator|->
name|buckets
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|bkt
operator|!=
name|array
operator|->
name|empty_bucket
operator|)
operator|&&
operator|(
name|bkt
operator|->
name|version
operator|==
name|array
operator|->
name|version
operator|)
condition|)
block|{
name|free
argument_list|(
name|bkt
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* realloc to free the space above new_max_index */
name|array
operator|->
name|indices
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|*
operator|)
name|__objc_xrealloc
argument_list|(
name|array
operator|->
name|indices
argument_list|,
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|array
operator|->
name|buckets
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|*
operator|)
name|__objc_xrealloc
argument_list|(
name|array
operator|->
name|buckets
argument_list|,
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idxsize
operator|-=
operator|(
name|old_max_index
operator|-
name|new_max_index
operator|)
expr_stmt|;
return|return;
block|}
comment|/* We are asked to extend the array -- reallocate the bucket table, */
comment|/* and insert empty_bucket in newly allocated places. */
if|if
condition|(
name|rounded_size
operator|>
name|array
operator|->
name|capacity
condition|)
block|{
comment|/* update capacity */
name|array
operator|->
name|capacity
operator|=
name|rounded_size
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* realloc to make room in table above old_max_index */
name|array
operator|->
name|indices
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|*
operator|)
name|__objc_xrealloc
argument_list|(
name|array
operator|->
name|indices
argument_list|,
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset entries above old_max_index to empty_bucket */
for|for
control|(
name|counter
operator|=
name|old_max_index
operator|+
literal|1
init|;
name|counter
operator|<=
name|new_max_index
condition|;
name|counter
operator|++
control|)
name|array
operator|->
name|indices
index|[
name|counter
index|]
operator|=
name|array
operator|->
name|empty_index
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
comment|/* realloc to make room in table above old_max_index */
name|array
operator|->
name|buckets
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|*
operator|)
name|__objc_xrealloc
argument_list|(
name|array
operator|->
name|buckets
argument_list|,
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset entries above old_max_index to empty_bucket */
for|for
control|(
name|counter
operator|=
name|old_max_index
operator|+
literal|1
init|;
name|counter
operator|<=
name|new_max_index
condition|;
name|counter
operator|++
control|)
name|array
operator|->
name|buckets
index|[
name|counter
index|]
operator|=
name|array
operator|->
name|empty_bucket
expr_stmt|;
endif|#
directive|endif
name|idxsize
operator|+=
operator|(
name|new_max_index
operator|-
name|old_max_index
operator|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free a sparse array allocated with sarray_new */
end_comment

begin_function
name|void
name|sarray_free
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
decl_stmt|;
else|#
directive|else
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
decl_stmt|;
endif|#
directive|endif
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|array
operator|->
name|ref_count
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Freed multiple times!!! */
if|if
condition|(
operator|--
operator|(
name|array
operator|->
name|ref_count
operator|)
operator|!=
literal|0
condition|)
comment|/* There exists copies of me */
return|return;
if|if
condition|(
operator|(
name|array
operator|->
name|is_copy_of
operator|)
operator|&&
operator|(
operator|(
name|array
operator|->
name|is_copy_of
operator|->
name|ref_count
operator|-
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|sarray_free
argument_list|(
name|array
operator|->
name|is_copy_of
argument_list|)
expr_stmt|;
comment|/* Free all entries that do not point to empty_bucket */
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<=
name|old_max_index
condition|;
name|counter
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|struct
name|sindex
modifier|*
name|idx
init|=
name|array
operator|->
name|indices
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|idx
operator|!=
name|array
operator|->
name|empty_index
operator|)
operator|&&
operator|(
name|idx
operator|->
name|version
operator|==
name|array
operator|->
name|version
operator|)
condition|)
block|{
name|int
name|c2
decl_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|INDEX_SIZE
condition|;
name|c2
operator|++
control|)
block|{
name|struct
name|sbucket
modifier|*
name|bkt
init|=
name|idx
operator|->
name|buckets
index|[
name|c2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|bkt
operator|!=
name|array
operator|->
name|empty_bucket
operator|)
operator|&&
operator|(
name|bkt
operator|->
name|version
operator|==
name|array
operator|->
name|version
operator|)
condition|)
block|{
name|free
argument_list|(
name|bkt
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|nindices
operator|-=
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|struct
name|sbucket
modifier|*
name|bkt
init|=
name|array
operator|->
name|buckets
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|bkt
operator|!=
name|array
operator|->
name|empty_bucket
operator|)
operator|&&
operator|(
name|bkt
operator|->
name|version
operator|==
name|array
operator|->
name|version
operator|)
condition|)
block|{
name|free
argument_list|(
name|bkt
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* free empty_index */
if|if
condition|(
name|array
operator|->
name|empty_index
operator|->
name|version
operator|==
name|array
operator|->
name|version
condition|)
block|{
name|free
argument_list|(
name|array
operator|->
name|empty_index
argument_list|)
expr_stmt|;
name|nindices
operator|-=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* free empty_bucket */
if|if
condition|(
name|array
operator|->
name|empty_bucket
operator|->
name|version
operator|==
name|array
operator|->
name|version
condition|)
block|{
name|free
argument_list|(
name|array
operator|->
name|empty_bucket
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* free bucket table */
name|free
argument_list|(
name|array
operator|->
name|indices
argument_list|)
expr_stmt|;
name|idxsize
operator|-=
operator|(
name|old_max_index
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
comment|/* free bucket table */
name|free
argument_list|(
name|array
operator|->
name|buckets
argument_list|)
expr_stmt|;
name|idxsize
operator|-=
operator|(
name|old_max_index
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* free array */
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|narrays
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a lazy copy.  Only the core of the structure is actually */
end_comment

begin_comment
comment|/* copied.   */
end_comment

begin_function
name|struct
name|sarray
modifier|*
name|sarray_lazy_copy
parameter_list|(
name|struct
name|sarray
modifier|*
name|oarr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|oarr
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
operator|)
operator|+
literal|1
decl_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|oarr
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
operator|)
operator|+
literal|1
decl_stmt|;
endif|#
directive|endif
name|struct
name|sarray
modifier|*
name|arr
decl_stmt|;
comment|/* Allocate core array */
name|arr
operator|=
operator|(
expr|struct
name|sarray
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|arr
argument_list|,
name|oarr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|version
operator|=
name|oarr
operator|->
name|version
operator|+
literal|1
expr_stmt|;
name|arr
operator|->
name|is_copy_of
operator|=
name|oarr
expr_stmt|;
name|oarr
operator|->
name|ref_count
operator|+=
literal|1
expr_stmt|;
name|arr
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* Copy bucket table */
name|arr
operator|->
name|indices
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|arr
operator|->
name|indices
argument_list|,
name|oarr
operator|->
name|indices
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Copy bucket table */
name|arr
operator|->
name|buckets
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|arr
operator|->
name|buckets
argument_list|,
name|oarr
operator|->
name|buckets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idxsize
operator|+=
name|num_indices
expr_stmt|;
name|narrays
operator|+=
literal|1
expr_stmt|;
return|return
name|arr
return|;
block|}
end_function

end_unit

