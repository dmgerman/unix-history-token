begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime selector related functions    Copyright (C) 1993, 1995 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"objc/sarray.h"
end_include

begin_include
include|#
directive|include
file|"encoding.h"
end_include

begin_comment
comment|/* Initial selector hash table size. Value doesn't matter much */
end_comment

begin_define
define|#
directive|define
name|SELECTOR_HASH_SIZE
value|128
end_define

begin_comment
comment|/* Tables mapping selector names to uid and opposite */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sarray
modifier|*
name|__objc_selector_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uid -> sel */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sarray
modifier|*
name|__objc_selector_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uid -> name */
end_comment

begin_decl_stmt
specifier|static
name|cache_ptr
name|__objc_selector_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name -> uid */
end_comment

begin_function_decl
specifier|static
name|void
name|register_selectors_from_list
parameter_list|(
name|MethodList_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Number of selectors stored in each of the above tables */
end_comment

begin_decl_stmt
name|int
name|__objc_selector_max_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|__objc_init_selector_tables
parameter_list|()
block|{
name|__objc_selector_array
operator|=
name|sarray_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__objc_selector_names
operator|=
name|sarray_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__objc_selector_hash
operator|=
name|hash_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_string
argument_list|,
operator|(
name|compare_func_type
operator|)
name|compare_strings
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is given a class and records all of the methods in its class    structure in the record table.  */
end_comment

begin_function
name|void
name|__objc_register_selectors_from_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|MethodList_t
name|method_list
decl_stmt|;
name|method_list
operator|=
name|class
operator|->
name|methods
expr_stmt|;
while|while
condition|(
name|method_list
condition|)
block|{
name|register_selectors_from_list
argument_list|(
name|method_list
argument_list|)
expr_stmt|;
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is given a list of methods and records each of the methods in    the record table.  This is the routine that does the actual recording    work.     This one is only called for Class objects.  For categories,    class_add_method_list is called.    */
end_comment

begin_function
specifier|static
name|void
name|register_selectors_from_list
parameter_list|(
name|MethodList_t
name|method_list
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
name|method
operator|->
name|method_name
operator|=
name|sel_register_typed_name
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|method
operator|->
name|method_name
argument_list|,
name|method
operator|->
name|method_types
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns YES iff t1 and t2 have same method types, but we ignore    the argframe layout */
end_comment

begin_function
name|BOOL
name|sel_types_match
parameter_list|(
specifier|const
name|char
modifier|*
name|t1
parameter_list|,
specifier|const
name|char
modifier|*
name|t2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t1
operator|||
operator|!
name|t2
condition|)
return|return
name|NO
return|;
while|while
condition|(
operator|*
name|t1
operator|&&
operator|*
name|t2
condition|)
block|{
if|if
condition|(
operator|*
name|t1
operator|==
literal|'+'
condition|)
name|t1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t2
operator|==
literal|'+'
condition|)
name|t2
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|t1
argument_list|)
condition|)
name|t1
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|t2
argument_list|)
condition|)
name|t2
operator|++
expr_stmt|;
comment|/* xxx Remove these next two lines when qualifiers are put in 	 all selectors, not just Protocol selectors. */
name|t1
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t1
operator|&&
operator|!
operator|*
name|t2
condition|)
return|return
name|YES
return|;
if|if
condition|(
operator|*
name|t1
operator|!=
operator|*
name|t2
condition|)
return|return
name|NO
return|;
name|t1
operator|++
expr_stmt|;
name|t2
operator|++
expr_stmt|;
block|}
return|return
name|NO
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|SEL
name|s
init|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|0
operator|||
name|s
operator|->
name|sel_types
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|sel_types
operator|==
name|types
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sel_types_match
argument_list|(
name|s
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return selector representing name; prefer a selector with non-NULL type */
end_comment

begin_function
name|SEL
name|sel_get_any_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|SEL
name|s
decl_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|s
operator|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sel_types
condition|)
return|return
name|s
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_any_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soffset_decode
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|sel_register_typed_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get name of selector.  If selector is unknown, the empty string ""     is returned */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sel_get_name
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
if|if
condition|(
operator|(
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
operator|<=
name|__objc_selector_max_index
operator|)
condition|)
return|return
name|sarray_get
argument_list|(
name|__objc_selector_names
argument_list|,
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|BOOL
name|sel_is_mapped
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
name|unsigned
name|int
name|idx
init|=
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|idx
operator|>
literal|0
operator|)
operator|&&
operator|(
name|idx
operator|<=
name|__objc_selector_max_index
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sel_get_type
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
if|if
condition|(
name|selector
condition|)
return|return
name|selector
operator|->
name|sel_types
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The uninstalled dispatch table */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|sarray
modifier|*
name|__objc_uninstalled_dtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store the passed selector name in the selector record and return its    selector value (value returned by sel_get_uid). */
end_comment

begin_function
name|SEL
name|__sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|,
name|struct
name|objc_selector
modifier|*
name|orig
parameter_list|)
block|{
name|struct
name|objc_selector
modifier|*
name|j
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soffset_decode
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|SEL
name|s
init|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|0
operator|||
name|s
operator|->
name|sel_types
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|sel_types
operator|==
name|types
condition|)
block|{
if|if
condition|(
name|orig
condition|)
block|{
name|orig
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
return|return
name|orig
return|;
block|}
else|else
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
name|orig
condition|)
block|{
name|orig
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
return|return
name|orig
return|;
block|}
else|else
return|return
name|s
return|;
block|}
block|}
if|if
condition|(
name|orig
condition|)
name|j
operator|=
name|orig
expr_stmt|;
else|else
name|j
operator|=
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objc_selector
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
name|j
operator|->
name|sel_types
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|types
expr_stmt|;
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__objc_selector_max_index
operator|+=
literal|1
expr_stmt|;
name|i
operator|=
name|soffset_encode
argument_list|(
name|__objc_selector_max_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
condition|)
name|j
operator|=
name|orig
expr_stmt|;
else|else
name|j
operator|=
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objc_selector
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
name|j
operator|->
name|sel_types
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|types
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUG_PRINTF
argument_list|(
literal|"Record selector %s[%s] as: %ld\n"
argument_list|,
name|name
argument_list|,
name|types
argument_list|,
name|soffset_decode
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|is_new
init|=
operator|(
name|l
operator|==
literal|0
operator|)
decl_stmt|;
name|l
operator|=
name|list_cons
argument_list|(
operator|(
name|void
operator|*
operator|)
name|j
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sarray_at_put_safe
argument_list|(
name|__objc_selector_names
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
name|sarray_at_put_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
name|hash_add
argument_list|(
operator|&
name|__objc_selector_hash
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|sarray_realloc
argument_list|(
name|__objc_uninstalled_dtable
argument_list|,
name|__objc_selector_max_index
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|SEL
operator|)
name|j
return|;
block|}
end_function

begin_function
name|SEL
name|sel_register_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|SEL
name|sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
return|return
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

