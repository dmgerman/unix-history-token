begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions to analyze and validate GIMPLE trees.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>    Rewritten by Jason Merrill<jason@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_comment
comment|/* For the definitive definition of GIMPLE, see doc/tree-ssa.texi.  */
end_comment

begin_comment
comment|/* Validation of GIMPLE expressions.  */
end_comment

begin_comment
comment|/* Return true if T is a GIMPLE RHS for an assignment to a temporary.  */
end_comment

begin_function
name|bool
name|is_gimple_formal_tmp_rhs
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_unary
case|:
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|COMPLEX_EXPR
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|OBJ_TYPE_REF
case|:
case|case
name|ASSERT_EXPR
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
return|return
name|is_gimple_lvalue
argument_list|(
name|t
argument_list|)
operator|||
name|is_gimple_val
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff T is a valid RHS for an assignment to a renamed    user -- or front-end generated artificial -- variable.  */
end_comment

begin_function
name|bool
name|is_gimple_reg_rhs
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto      and the LHS is a user variable, then we need to introduce a formal      temporary.  This way the optimizers can determine that the user      variable is only modified if evaluation of the RHS does not throw.       Don't force a temp of a non-renamable type; the copy could be      arbitrarily expensive.  Instead we will generate a V_MAY_DEF for      the assignment.  */
if|if
condition|(
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|)
operator|||
name|tree_could_throw_p
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
return|return
name|is_gimple_formal_tmp_rhs
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff T is a valid RHS for an assignment to an un-renamed    LHS, or for a call argument.  */
end_comment

begin_function
name|bool
name|is_gimple_mem_rhs
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* If we're dealing with a renamable type, either source or dest must be      a renamed variable.  Also force a temporary if the type doesn't need      to be stored in memory, since it's cheap and prevents erroneous      tailcalls (PR 17526).  */
if|if
condition|(
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CALL_EXPR
operator|||
operator|!
name|aggregate_value_p
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
operator|)
operator|)
condition|)
return|return
name|is_gimple_val
argument_list|(
name|t
argument_list|)
return|;
else|else
return|return
name|is_gimple_formal_tmp_rhs
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the appropriate RHS predicate for this LHS.  */
end_comment

begin_function
name|gimple_predicate
name|rhs_predicate_for
parameter_list|(
name|tree
name|lhs
parameter_list|)
block|{
if|if
condition|(
name|is_gimple_formal_tmp_var
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|is_gimple_formal_tmp_rhs
return|;
elseif|else
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|is_gimple_reg_rhs
return|;
else|else
return|return
name|is_gimple_mem_rhs
return|;
block|}
end_function

begin_comment
comment|/*  Return true if T is a valid LHS for a GIMPLE assignment expression.  */
end_comment

begin_function
name|bool
name|is_gimple_lvalue
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|is_gimple_addressable
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|WITH_SIZE_EXPR
comment|/* These are complex lvalues, but don't have addresses, so they 	     go here.  */
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Return true if T is a GIMPLE condition.  */
end_comment

begin_function
name|bool
name|is_gimple_condexpr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|is_gimple_val
argument_list|(
name|t
argument_list|)
operator|||
name|COMPARISON_CLASS_P
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Return true if T is something whose address can be taken.  */
end_comment

begin_function
name|bool
name|is_gimple_addressable
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|is_gimple_id
argument_list|(
name|t
argument_list|)
operator|||
name|handled_component_p
argument_list|(
name|t
argument_list|)
operator|||
name|INDIRECT_REF_P
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is function invariant.  Or rather a restricted    form of function invariant.  */
end_comment

begin_function
name|bool
name|is_gimple_min_invariant
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
return|return
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|VECTOR_CST
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if T looks like a valid GIMPLE statement.  */
end_comment

begin_function
name|bool
name|is_gimple_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
comment|/* The only valid NOP_EXPR is the empty statement.  */
return|return
name|IS_EMPTY_STMT
argument_list|(
name|t
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
case|case
name|COND_EXPR
case|:
comment|/* These are only valid if they're void.  */
return|return
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL
operator|||
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|SWITCH_EXPR
case|:
case|case
name|GOTO_EXPR
case|:
case|case
name|RETURN_EXPR
case|:
case|case
name|LABEL_EXPR
case|:
case|case
name|CASE_LABEL_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|EH_FILTER_EXPR
case|:
case|case
name|CATCH_EXPR
case|:
case|case
name|ASM_EXPR
case|:
case|case
name|RESX_EXPR
case|:
case|case
name|PHI_NODE
case|:
case|case
name|STATEMENT_LIST
case|:
case|case
name|OMP_PARALLEL
case|:
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_SINGLE
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
case|case
name|OMP_RETURN
case|:
case|case
name|OMP_CONTINUE
case|:
comment|/* These are always void.  */
return|return
name|true
return|;
case|case
name|CALL_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
comment|/* These are valid regardless of their type.  */
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if T is a variable.  */
end_comment

begin_function
name|bool
name|is_gimple_variable
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Return true if T is a GIMPLE identifier (something with an address).  */
end_comment

begin_function
name|bool
name|is_gimple_id
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|is_gimple_variable
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
comment|/* Allow string constants, since they are addressable.  */
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STRING_CST
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE is a suitable type for a scalar register variable.  */
end_comment

begin_function
name|bool
name|is_gimple_reg_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a non-aggregate register variable.  */
end_comment

begin_function
name|bool
name|is_gimple_reg
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|t
operator|=
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|MTAG_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|is_gimple_variable
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* A volatile decl is not acceptable because we can't reuse it as      needed.  We need to copy it into a temp first.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We define "registers" as things that can be renamed as needed,      which with our infrastructure does not apply to memory.  */
if|if
condition|(
name|needs_to_live_in_memory
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Hard register variables are an interesting case.  For those that      are call-clobbered, we don't know where all the calls are, since      we don't (want to) take into account which operations will turn      into libcalls at the rtl level.  For those that are call-saved,      we don't currently model the fact that calls may in fact change      global hard registers, nor do we examine ASM_CLOBBERS at the tree      level, and so miss variable changes that might imply.  All around,      it seems safest to not do too much optimization with these at the      tree level at all.  We'll have to rely on the rtl optimizers to      clean this up, as there we've got all the appropriate bits exposed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HARD_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Complex values must have been put into ssa form.  That is, no       assignments to the individual components.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|t
argument_list|)
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns true if T is a GIMPLE formal temporary variable.  */
end_comment

begin_function
name|bool
name|is_gimple_formal_tmp_var
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|true
return|;
return|return
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_GIMPLE_FORMAL_TEMP_P
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if T is a GIMPLE formal temporary register variable.  */
end_comment

begin_function
name|bool
name|is_gimple_formal_tmp_reg
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* The intent of this is to get hold of a value that won't change.      An SSA_NAME qualifies no matter if its of a user variable or not.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|true
return|;
comment|/* We don't know the lifetime characteristics of user variables.  */
if|if
condition|(
operator|!
name|is_gimple_formal_tmp_var
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Finally, it must be capable of being placed in a register.  */
return|return
name|is_gimple_reg
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a GIMPLE variable whose address is not needed.  */
end_comment

begin_function
name|bool
name|is_gimple_non_addressable
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|t
operator|=
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|is_gimple_variable
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|needs_to_live_in_memory
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a GIMPLE rvalue, i.e. an identifier or a constant.  */
end_comment

begin_function
name|bool
name|is_gimple_val
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* Make loads from volatiles and memory vars explicit.  */
if|if
condition|(
name|is_gimple_variable
argument_list|(
name|t
argument_list|)
operator|&&
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME make these decls.  That can happen only when we expose the      entire landing-pad construct at the tree level.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|EXC_PTR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FILTER_EXPR
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|is_gimple_variable
argument_list|(
name|t
argument_list|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but accept hard registers as inputs to asm statements.  */
end_comment

begin_function
name|bool
name|is_gimple_asm_val
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HARD_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|is_gimple_val
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a GIMPLE minimal lvalue.  */
end_comment

begin_function
name|bool
name|is_gimple_min_lval
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|is_gimple_id
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a typecast operation.  */
end_comment

begin_function
name|bool
name|is_gimple_cast
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIX_TRUNC_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIX_CEIL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIX_FLOOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIX_ROUND_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a valid op0 of a CALL_EXPR.  */
end_comment

begin_function
name|bool
name|is_gimple_call_addr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OBJ_TYPE_REF
operator|||
name|is_gimple_val
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If T makes a function call, return the corresponding CALL_EXPR operand.    Otherwise, return NULL_TREE.  */
end_comment

begin_function
name|tree
name|get_call_expr_in
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given a memory reference expression T, return its base address.    The base address of a memory reference expression is the main    object being referenced.  For instance, the base address for    'array[i].fld[j]' is 'array'.  You can think of this as stripping    away the offset part from a memory address.     This function calls handled_component_p to strip away all the inner    parts of the memory reference until it reaches the base object.  */
end_comment

begin_function
name|tree
name|get_base_address
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
while|while
condition|(
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONSTRUCTOR
operator|||
name|INDIRECT_REF_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|recalculate_side_effects
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
comment|/* All of these have side-effects, no matter what their 	     operands are.  */
return|return;
default|default:
break|break;
block|}
comment|/* Fall through.  */
case|case
name|tcc_comparison
case|:
comment|/* a comparison expression */
case|case
name|tcc_unary
case|:
comment|/* a unary arithmetic expression */
case|case
name|tcc_binary
case|:
comment|/* a binary arithmetic expression */
case|case
name|tcc_reference
case|:
comment|/* a reference */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Can never be used with non-expressions.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

