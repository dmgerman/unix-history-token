begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output xcoff-format symbol table information from GNU compiler.    Copyright (C) 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Output xcoff-format symbol table data.  The main functionality is contained    in dbxout.c.  This file implements the sdbout-like parts of the xcoff    interface.  Many functions are very similar to their counterparts in    sdbout.c.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_comment
comment|/* This defines the C_* storage classes.  */
end_comment

begin_include
include|#
directive|include
file|"xcoff.h"
end_include

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* Line number of beginning of current function, minus one.    Negative means not in a function or not using xcoff.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xcoff_begin_function_line
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xcoff_inlining
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current include file.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|xcoff_current_include_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current function file.  This is the file the `.bf' is    emitted from.  In case a line is emitted from a different file,    (by including that file of course), then the line number will be    absolute.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|xcoff_current_function_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of bss and data sections.  These should be unique names for each    compilation unit.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xcoff_bss_section_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xcoff_private_data_section_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xcoff_read_only_section_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last source file name mentioned in a NOTE insn.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|xcoff_lastfile
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Macro definitions used below.  */
end_comment

begin_define
define|#
directive|define
name|ABS_OR_RELATIVE_LINENO
parameter_list|(
name|LINENO
parameter_list|)
define|\
value|((xcoff_inlining) ? (LINENO) : (LINENO) - xcoff_begin_function_line)
end_define

begin_comment
comment|/* Output source line numbers via ".line".  */
end_comment

begin_define
define|#
directive|define
name|ASM_OUTPUT_LINE
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|)
define|\
value|do									   \     {									   \       if (xcoff_begin_function_line>= 0)				   \ 	fprintf (FILE, "\t.line\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM)); \     }									   \   while (0)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LFB
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|)
define|\
value|{						\   if (xcoff_begin_function_line == -1)		\     {						\       xcoff_begin_function_line = (LINENUM) - 1;\       fprintf (FILE, "\t.bf\t%d\n", (LINENUM));	\     }						\   xcoff_current_function_file			\     = (xcoff_current_include_file		\        ? xcoff_current_include_file : main_input_filename); \ }
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LFE
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|)
define|\
value|do						\     {						\       fprintf (FILE, "\t.ef\t%d\n", (LINENUM));	\       xcoff_begin_function_line = -1;		\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LBB
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|,
name|BLOCKNUM
parameter_list|)
define|\
value|fprintf (FILE, "\t.bb\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM))
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LBE
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|,
name|BLOCKNUM
parameter_list|)
define|\
value|fprintf (FILE, "\t.eb\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM))
end_define

begin_function_decl
specifier|static
name|void
name|xcoffout_block
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xcoffout_source_file
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Support routines for XCOFF debugging info.  */
end_comment

begin_struct
struct|struct
name|xcoff_type_number
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xcoff_type_number
name|xcoff_type_numbers
index|[]
init|=
block|{
block|{
literal|"int"
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"char"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|"short int"
block|,
operator|-
literal|3
block|}
block|,
block|{
literal|"long int"
block|,
operator|-
literal|4
block|}
block|,
comment|/* fiddled to -31 if 64 bits */
block|{
literal|"unsigned char"
block|,
operator|-
literal|5
block|}
block|,
block|{
literal|"signed char"
block|,
operator|-
literal|6
block|}
block|,
block|{
literal|"short unsigned int"
block|,
operator|-
literal|7
block|}
block|,
block|{
literal|"unsigned int"
block|,
operator|-
literal|8
block|}
block|,
comment|/* No such type "unsigned".  */
block|{
literal|"long unsigned int"
block|,
operator|-
literal|10
block|}
block|,
comment|/* fiddled to -32 if 64 bits */
block|{
literal|"void"
block|,
operator|-
literal|11
block|}
block|,
block|{
literal|"float"
block|,
operator|-
literal|12
block|}
block|,
block|{
literal|"double"
block|,
operator|-
literal|13
block|}
block|,
block|{
literal|"long double"
block|,
operator|-
literal|14
block|}
block|,
comment|/* Pascal and Fortran types run from -15 to -29.  */
block|{
literal|"wchar"
block|,
operator|-
literal|30
block|}
block|,
comment|/* XXX Should be "wchar_t" ? */
block|{
literal|"long long int"
block|,
operator|-
literal|31
block|}
block|,
block|{
literal|"long long unsigned int"
block|,
operator|-
literal|32
block|}
block|,
comment|/* Additional Fortran types run from -33 to -37.  */
comment|/* ??? Should also handle built-in C++ and Obj-C types.  There perhaps      aren't any that C doesn't already have.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns an XCOFF fundamental type number for DECL (assumed to be a    TYPE_DECL), or 0 if dbxout.c should assign a type number normally.  */
end_comment

begin_function
name|int
name|xcoff_assign_fundamental_type_number
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* Do not waste time searching the list for non-intrinsic types.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|DECL_IS_BUILTIN
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Linear search, blech, but the list is too small to bother      doing anything else.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|xcoff_type_numbers
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xcoff_type_numbers
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
goto|goto
name|found
goto|;
return|return
literal|0
return|;
name|found
label|:
comment|/* -4 and -10 should be replaced with -31 and -32, respectively,      when used for a 64-bit type.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|xcoff_type_numbers
index|[
name|i
index|]
operator|.
name|number
operator|==
operator|-
literal|4
condition|)
return|return
operator|-
literal|31
return|;
if|if
condition|(
name|xcoff_type_numbers
index|[
name|i
index|]
operator|.
name|number
operator|==
operator|-
literal|10
condition|)
return|return
operator|-
literal|32
return|;
block|}
return|return
name|xcoff_type_numbers
index|[
name|i
index|]
operator|.
name|number
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for unrecognized stab codes.  */
end_comment

begin_define
define|#
directive|define
name|UNKNOWN_STAB
parameter_list|(
name|STR
parameter_list|)
define|\
value|internal_error ("no sclass for %s stab (0x%x)", STR, stab)
end_define

begin_comment
comment|/* Conversion routine from BSD stabs to AIX storage classes.  */
end_comment

begin_function
name|int
name|stab_to_sclass
parameter_list|(
name|int
name|stab
parameter_list|)
block|{
switch|switch
condition|(
name|stab
condition|)
block|{
case|case
name|N_GSYM
case|:
return|return
name|C_GSYM
return|;
case|case
name|N_FNAME
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_FNAME"
argument_list|)
expr_stmt|;
case|case
name|N_FUN
case|:
return|return
name|C_FUN
return|;
case|case
name|N_STSYM
case|:
case|case
name|N_LCSYM
case|:
return|return
name|C_STSYM
return|;
case|case
name|N_MAIN
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_MAIN"
argument_list|)
expr_stmt|;
case|case
name|N_RSYM
case|:
return|return
name|C_RSYM
return|;
case|case
name|N_SSYM
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SSYM"
argument_list|)
expr_stmt|;
case|case
name|N_RPSYM
case|:
return|return
name|C_RPSYM
return|;
case|case
name|N_PSYM
case|:
return|return
name|C_PSYM
return|;
case|case
name|N_LSYM
case|:
return|return
name|C_LSYM
return|;
case|case
name|N_DECL
case|:
return|return
name|C_DECL
return|;
case|case
name|N_ENTRY
case|:
return|return
name|C_ENTRY
return|;
case|case
name|N_SO
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SO"
argument_list|)
expr_stmt|;
case|case
name|N_SOL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SOL"
argument_list|)
expr_stmt|;
case|case
name|N_SLINE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SLINE"
argument_list|)
expr_stmt|;
case|case
name|N_DSLINE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_DSLINE"
argument_list|)
expr_stmt|;
case|case
name|N_BSLINE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_BSLINE"
argument_list|)
expr_stmt|;
case|case
name|N_BINCL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_BINCL"
argument_list|)
expr_stmt|;
case|case
name|N_EINCL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_EINCL"
argument_list|)
expr_stmt|;
case|case
name|N_EXCL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_EXCL"
argument_list|)
expr_stmt|;
case|case
name|N_LBRAC
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_LBRAC"
argument_list|)
expr_stmt|;
case|case
name|N_RBRAC
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_RBRAC"
argument_list|)
expr_stmt|;
case|case
name|N_BCOMM
case|:
return|return
name|C_BCOMM
return|;
case|case
name|N_ECOMM
case|:
return|return
name|C_ECOMM
return|;
case|case
name|N_ECOML
case|:
return|return
name|C_ECOML
return|;
case|case
name|N_LENG
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_LENG"
argument_list|)
expr_stmt|;
case|case
name|N_PC
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_PC"
argument_list|)
expr_stmt|;
case|case
name|N_M2C
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_M2C"
argument_list|)
expr_stmt|;
case|case
name|N_SCOPE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SCOPE"
argument_list|)
expr_stmt|;
case|case
name|N_CATCH
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_CATCH"
argument_list|)
expr_stmt|;
case|case
name|N_OPT
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_OPT"
argument_list|)
expr_stmt|;
default|default:
name|UNKNOWN_STAB
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debugging info to FILE to switch to sourcefile FILENAME.    INLINE_P is true if this is from an inlined function.  */
end_comment

begin_function
specifier|static
name|void
name|xcoffout_source_file
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|inline_p
parameter_list|)
block|{
if|if
condition|(
name|filename
operator|&&
operator|(
name|xcoff_lastfile
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|xcoff_lastfile
argument_list|)
operator|||
operator|(
name|inline_p
operator|&&
operator|!
name|xcoff_inlining
operator|)
operator|||
operator|(
operator|!
name|inline_p
operator|&&
name|xcoff_inlining
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|xcoff_current_include_file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ei\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|file
argument_list|,
name|xcoff_current_include_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xcoff_current_include_file
operator|=
name|NULL
expr_stmt|;
block|}
name|xcoff_inlining
operator|=
name|inline_p
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|main_input_filename
argument_list|,
name|filename
argument_list|)
operator|||
name|inline_p
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.bi\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xcoff_current_include_file
operator|=
name|filename
expr_stmt|;
block|}
name|xcoff_lastfile
operator|=
name|filename
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a line number symbol entry for location (FILENAME, LINE).  */
end_comment

begin_function
name|void
name|xcoffout_source_line
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|bool
name|inline_p
init|=
operator|(
name|strcmp
argument_list|(
name|xcoff_current_function_file
argument_list|,
name|filename
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|int
operator|)
name|line
operator|<
name|xcoff_begin_function_line
operator|)
decl_stmt|;
name|xcoffout_source_file
argument_list|(
name|asm_out_file
argument_list|,
name|filename
argument_list|,
name|inline_p
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LINE
argument_list|(
name|asm_out_file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the symbols defined in block number DO_BLOCK.     This function works by walking the tree structure of blocks,    counting blocks until it finds the desired block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xcoffout_block
parameter_list|(
name|tree
name|block
parameter_list|,
name|int
name|depth
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
while|while
condition|(
name|block
condition|)
block|{
comment|/* Ignore blocks never expanded or otherwise marked as real.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* When we reach the specified block, output its symbols.  */
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
operator|==
name|do_block
condition|)
block|{
comment|/* Output the syms of the block.  */
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|||
name|depth
operator|==
literal|0
condition|)
name|dbxout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* We are now done with the block.  Don't go to inner blocks.  */
return|return;
block|}
comment|/* If we are past the specified block, stop the scan.  */
elseif|else
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
operator|>=
name|do_block
condition|)
return|return;
comment|/* Output the subblocks.  */
name|xcoffout_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Describe the beginning of an internal block within a function.    Also output descriptions of variables defined in this block.     N is the number of the block, by order of beginning, counting from 1,    and not counting the outermost (function top-level) block.    The blocks match the BLOCKs in DECL_INITIAL (current_function_decl),    if the count starts at 0 for the outermost one.  */
end_comment

begin_function
name|void
name|xcoffout_begin_block
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|tree
name|decl
init|=
name|current_function_decl
decl_stmt|;
comment|/* The IBM AIX compiler does not emit a .bb for the function level scope,      so we avoid it here also.  */
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
name|ASM_OUTPUT_LBB
argument_list|(
name|asm_out_file
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|do_block
operator|=
name|n
expr_stmt|;
name|xcoffout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Describe the end line-number of an internal block within a function.  */
end_comment

begin_function
name|void
name|xcoffout_end_block
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
name|ASM_OUTPUT_LBE
argument_list|(
name|asm_out_file
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at beginning of function (before prologue).    Declare function as needed for debugging.  */
end_comment

begin_function
name|void
name|xcoffout_declare_function
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|alloca
argument_list|(
name|len
operator|-
literal|3
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|n
argument_list|,
name|name
argument_list|,
name|len
operator|-
literal|4
argument_list|)
expr_stmt|;
name|n
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|n
expr_stmt|;
block|}
comment|/* Any pending .bi or .ei must occur before the .function pseudo op.      Otherwise debuggers will think that the function is in the previous      file and/or at the wrong line number.  */
name|xcoffout_source_file
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* .function NAME, TOP, MAPPING, TYPE, SIZE      16 and 044 are placeholders for backwards compatibility */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.function .%s,.%s,16,044,FE..%s-.%s\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at beginning of function body (at start of prologue).    Record the function's starting line number, so we can output    relative line numbers for the other lines.    Record the file name that this function is contained in.  */
end_comment

begin_function
name|void
name|xcoffout_begin_prologue
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|ASM_OUTPUT_LFB
argument_list|(
name|asm_out_file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dbxout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the symbols for the outermost BLOCK's variables.  sdbout.c does this      in sdbout_begin_block, but there is no guarantee that there will be any      inner block 1, so we must do it here.  This gives a result similar to      dbxout, so it does make some sense.  */
name|do_block
operator|=
name|BLOCK_NUMBER
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|xcoffout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LINE
argument_list|(
name|asm_out_file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at end of function (before epilogue).    Describe end of outermost block.  */
end_comment

begin_function
name|void
name|xcoffout_end_function
parameter_list|(
name|unsigned
name|int
name|last_linenum
parameter_list|)
block|{
name|ASM_OUTPUT_LFE
argument_list|(
name|asm_out_file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output xcoff info for the absolute end of a function.    Called after the epilogue is output.  */
end_comment

begin_function
name|void
name|xcoffout_end_epilogue
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We need to pass the correct function size to .function, otherwise,      the xas assembler can't figure out the correct size for the function      aux entry.  So, we emit a label after the last instruction which can      be used by the .function pseudo op to calculate the function size.  */
specifier|const
name|char
modifier|*
name|fname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|fname
operator|==
literal|'*'
condition|)
operator|++
name|fname
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"FE.."
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XCOFF_DEBUGGING_INFO */
end_comment

end_unit

