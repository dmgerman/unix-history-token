begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output xcoff-format symbol table information from GNU compiler.    Copyright (C) 1992, 1994, 1995, 1997, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Output xcoff-format symbol table data.  The main functionality is contained    in dbxout.c.  This file implements the sdbout-like parts of the xcoff    interface.  Many functions are very similar to their counterparts in    sdbout.c.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_comment
comment|/* This defines the C_* storage classes.  */
end_comment

begin_include
include|#
directive|include
file|<dbxstclass.h>
end_include

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_STAB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* This is a GNU extension we need to reference in this file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_CATCH
end_ifndef

begin_define
define|#
directive|define
name|N_CATCH
value|0x54
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Line number of beginning of current function, minus one.    Negative means not in a function or not using xcoff.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xcoff_begin_function_line
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xcoff_inlining
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current include file.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xcoff_current_include_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current function file.  This is the file the `.bf' is    emitted from.  In case a line is emitted from a different file,    (by including that file of course), then the line number will be    absolute.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xcoff_current_function_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of bss and data sections.  These should be unique names for each    compilation unit.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xcoff_bss_section_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xcoff_private_data_section_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xcoff_read_only_section_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last source file name mentioned in a NOTE insn.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xcoff_lastfile
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Macro definitions used below.  */
end_comment

begin_define
define|#
directive|define
name|ABS_OR_RELATIVE_LINENO
parameter_list|(
name|LINENO
parameter_list|)
define|\
value|((xcoff_inlining) ? (LINENO) : (LINENO) - xcoff_begin_function_line)
end_define

begin_comment
comment|/* Output source line numbers via ".line" rather than ".stabd".  */
end_comment

begin_define
define|#
directive|define
name|ASM_OUTPUT_SOURCE_LINE
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|)
define|\
value|do {						\     if (xcoff_begin_function_line>= 0)		\       fprintf (FILE, "\t.line\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM)); \   } while (0)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LFB
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|)
define|\
value|{						\   if (xcoff_begin_function_line == -1)		\     {						\       xcoff_begin_function_line = (LINENUM) - 1;\       fprintf (FILE, "\t.bf\t%d\n", (LINENUM));	\     }						\   xcoff_current_function_file			\     = (xcoff_current_include_file		\        ? xcoff_current_include_file : main_input_filename); \ }
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LFE
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|)
define|\
value|do {						\     fprintf (FILE, "\t.ef\t%d\n", (LINENUM));	\     xcoff_begin_function_line = -1;		\   } while (0)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LBB
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|,
name|BLOCKNUM
parameter_list|)
define|\
value|fprintf (FILE, "\t.bb\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM))
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_LBE
parameter_list|(
name|FILE
parameter_list|,
name|LINENUM
parameter_list|,
name|BLOCKNUM
parameter_list|)
define|\
value|fprintf (FILE, "\t.eb\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM))
end_define

begin_decl_stmt
specifier|static
name|void
name|assign_type_number
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoffout_block
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Support routines for XCOFF debugging info.  */
end_comment

begin_comment
comment|/* Assign NUMBER as the stabx type number for the type described by NAME.    Search all decls in the list SYMS to find the type NAME.  */
end_comment

begin_function
specifier|static
name|void
name|assign_type_number
parameter_list|(
name|syms
parameter_list|,
name|name
parameter_list|,
name|number
parameter_list|)
name|tree
name|syms
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|syms
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|number
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Setup gcc primitive types to use the XCOFF built-in type numbers where    possible.  */
end_comment

begin_function
name|void
name|xcoff_output_standard_types
parameter_list|(
name|syms
parameter_list|)
name|tree
name|syms
decl_stmt|;
block|{
comment|/* Handle built-in C types here.  */
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"int"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"char"
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"short int"
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"long int"
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
operator|-
literal|31
else|:
operator|-
literal|4
operator|)
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"unsigned char"
argument_list|,
operator|-
literal|5
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"signed char"
argument_list|,
operator|-
literal|6
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"short unsigned int"
argument_list|,
operator|-
literal|7
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"unsigned int"
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* No such type "unsigned".  */
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"long unsigned int"
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
operator|-
literal|32
else|:
operator|-
literal|10
operator|)
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"void"
argument_list|,
operator|-
literal|11
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"float"
argument_list|,
operator|-
literal|12
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"double"
argument_list|,
operator|-
literal|13
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"long double"
argument_list|,
operator|-
literal|14
argument_list|)
expr_stmt|;
comment|/* Pascal and Fortran types run from -15 to -29.  */
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"wchar"
argument_list|,
operator|-
literal|30
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"long long int"
argument_list|,
operator|-
literal|31
argument_list|)
expr_stmt|;
name|assign_type_number
argument_list|(
name|syms
argument_list|,
literal|"long long unsigned int"
argument_list|,
operator|-
literal|32
argument_list|)
expr_stmt|;
comment|/* Additional Fortran types run from -33 to -37.  */
comment|/* ??? Should also handle built-in C++ and Obj-C types.  There perhaps      aren't any that C doesn't already have.  */
block|}
end_function

begin_comment
comment|/* Print an error message for unrecognized stab codes.  */
end_comment

begin_define
define|#
directive|define
name|UNKNOWN_STAB
parameter_list|(
name|STR
parameter_list|)
define|\
value|do { \      error ("Unknown stab %s: : 0x%x\n", STR, stab);	\      fflush (stderr);	\    } while (0)
end_define

begin_comment
comment|/* Conversion routine from BSD stabs to AIX storage classes.  */
end_comment

begin_function
name|int
name|stab_to_sclass
parameter_list|(
name|stab
parameter_list|)
name|int
name|stab
decl_stmt|;
block|{
switch|switch
condition|(
name|stab
condition|)
block|{
case|case
name|N_GSYM
case|:
return|return
name|C_GSYM
return|;
case|case
name|N_FNAME
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_FNAME"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_FUN
case|:
return|return
name|C_FUN
return|;
case|case
name|N_STSYM
case|:
case|case
name|N_LCSYM
case|:
return|return
name|C_STSYM
return|;
ifdef|#
directive|ifdef
name|N_MAIN
case|case
name|N_MAIN
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_MAIN"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|N_RSYM
case|:
return|return
name|C_RSYM
return|;
case|case
name|N_SSYM
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SSYM"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_RPSYM
case|:
return|return
name|C_RPSYM
return|;
case|case
name|N_PSYM
case|:
return|return
name|C_PSYM
return|;
case|case
name|N_LSYM
case|:
return|return
name|C_LSYM
return|;
case|case
name|N_DECL
case|:
return|return
name|C_DECL
return|;
case|case
name|N_ENTRY
case|:
return|return
name|C_ENTRY
return|;
case|case
name|N_SO
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SO"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_SOL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SOL"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_SLINE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SLINE"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|N_DSLINE
case|case
name|N_DSLINE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_DSLINE"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_BSLINE
case|case
name|N_BSLINE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_BSLINE"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* This has the same value as N_BSLINE.  */
block|case N_BROWS:       UNKNOWN_STAB ("N_BROWS");        abort ();
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_BINCL
case|case
name|N_BINCL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_BINCL"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_EINCL
case|case
name|N_EINCL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_EINCL"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_EXCL
case|case
name|N_EXCL
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_EXCL"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|N_LBRAC
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_LBRAC"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_RBRAC
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_RBRAC"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_BCOMM
case|:
return|return
name|C_BCOMM
return|;
case|case
name|N_ECOMM
case|:
return|return
name|C_ECOMM
return|;
case|case
name|N_ECOML
case|:
return|return
name|C_ECOML
return|;
case|case
name|N_LENG
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_LENG"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_PC
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_PC"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|N_M2C
case|case
name|N_M2C
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_M2C"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_SCOPE
case|case
name|N_SCOPE
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_SCOPE"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|N_CATCH
case|:
name|UNKNOWN_STAB
argument_list|(
literal|"N_CATCH"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
default|default:
name|UNKNOWN_STAB
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debugging info to FILE to switch to sourcefile FILENAME.    INLINE_P is true if this is from an inlined function.  */
end_comment

begin_function
name|void
name|xcoffout_source_file
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|,
name|inline_p
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|inline_p
decl_stmt|;
block|{
if|if
condition|(
name|filename
operator|&&
operator|(
name|xcoff_lastfile
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|xcoff_lastfile
argument_list|)
operator|||
operator|(
name|inline_p
operator|&&
operator|!
name|xcoff_inlining
operator|)
operator|||
operator|(
operator|!
name|inline_p
operator|&&
name|xcoff_inlining
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|xcoff_current_include_file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ei\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|file
argument_list|,
name|xcoff_current_include_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xcoff_current_include_file
operator|=
name|NULL
expr_stmt|;
block|}
name|xcoff_inlining
operator|=
name|inline_p
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|main_input_filename
argument_list|,
name|filename
argument_list|)
operator|||
name|inline_p
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.bi\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xcoff_current_include_file
operator|=
name|filename
expr_stmt|;
block|}
name|xcoff_lastfile
operator|=
name|filename
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a line number symbol entry into output stream FILE,    for source file FILENAME and line number NOTE.  */
end_comment

begin_function
name|void
name|xcoffout_source_line
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|,
name|note
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|rtx
name|note
decl_stmt|;
block|{
name|xcoffout_source_file
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the symbols defined in block number DO_BLOCK.    Set NEXT_BLOCK_NUMBER to 0 before calling.     This function works by walking the tree structure of blocks,    counting blocks until it finds the desired block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_block_number
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xcoffout_block
parameter_list|(
name|block
parameter_list|,
name|depth
parameter_list|,
name|args
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
while|while
condition|(
name|block
condition|)
block|{
comment|/* Ignore blocks never expanded or otherwise marked as real.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* When we reach the specified block, output its symbols.  */
if|if
condition|(
name|next_block_number
operator|==
name|do_block
condition|)
block|{
comment|/* Output the syms of the block.  */
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|||
name|depth
operator|==
literal|0
condition|)
name|dbxout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* We are now done with the block.  Don't go to inner blocks.  */
return|return;
block|}
comment|/* If we are past the specified block, stop the scan.  */
elseif|else
if|if
condition|(
name|next_block_number
operator|>=
name|do_block
condition|)
return|return;
name|next_block_number
operator|++
expr_stmt|;
comment|/* Output the subblocks.  */
name|xcoffout_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Describe the beginning of an internal block within a function.    Also output descriptions of variables defined in this block.     N is the number of the block, by order of beginning, counting from 1,    and not counting the outermost (function top-level) block.    The blocks match the BLOCKs in DECL_INITIAL (current_function_decl),    if the count starts at 0 for the outermost one.  */
end_comment

begin_function
name|void
name|xcoffout_begin_block
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|n
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|current_function_decl
decl_stmt|;
comment|/* The IBM AIX compiler does not emit a .bb for the function level scope,      so we avoid it here also.  */
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
name|ASM_OUTPUT_LBB
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|do_block
operator|=
name|n
expr_stmt|;
name|next_block_number
operator|=
literal|0
expr_stmt|;
name|xcoffout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Describe the end line-number of an internal block within a function.  */
end_comment

begin_function
name|void
name|xcoffout_end_block
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|n
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
name|ASM_OUTPUT_LBE
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at beginning of function (before prologue).    Declare function as needed for debugging.  */
end_comment

begin_function
name|void
name|xcoffout_declare_function
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|n
init|=
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|n
operator|==
literal|'*'
condition|)
name|n
operator|++
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'['
condition|)
block|{
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|n
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* Any pending .bi or .ei must occur before the .function pseudo op.      Otherwise debuggers will think that the function is in the previous      file and/or at the wrong line number.  */
name|xcoffout_source_file
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.function .%s,.%s,16,044,FE..%s-.%s\n"
argument_list|,
name|n
argument_list|,
name|n
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at beginning of function body (after prologue).    Record the function's starting line number, so we can output    relative line numbers for the other lines.    Record the file name that this function is contained in.  */
end_comment

begin_function
name|void
name|xcoffout_begin_function
parameter_list|(
name|file
parameter_list|,
name|last_linenum
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|last_linenum
decl_stmt|;
block|{
name|ASM_OUTPUT_LFB
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
name|dbxout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the symbols for the outermost BLOCK's variables.  sdbout.c does this      in sdbout_begin_block, but there is no guarantee that there will be any      inner block 1, so we must do it here.  This gives a result similar to      dbxout, so it does make some sense.  */
name|do_block
operator|=
literal|0
expr_stmt|;
name|next_block_number
operator|=
literal|0
expr_stmt|;
name|xcoffout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at end of function (before epilogue).    Describe end of outermost block.  */
end_comment

begin_function
name|void
name|xcoffout_end_function
parameter_list|(
name|file
parameter_list|,
name|last_linenum
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|last_linenum
decl_stmt|;
block|{
name|ASM_OUTPUT_LFE
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output xcoff info for the absolute end of a function.    Called after the epilogue is output.  */
end_comment

begin_function
name|void
name|xcoffout_end_epilogue
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
comment|/* We need to pass the correct function size to .function, otherwise,      the xas assembler can't figure out the correct size for the function      aux entry.  So, we emit a label after the last instruction which can      be used by the .function pseudo op to calculate the function size.  */
name|char
modifier|*
name|fname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|fname
operator|==
literal|'*'
condition|)
operator|++
name|fname
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"FE.."
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XCOFF_DEBUGGING_INFO */
end_comment

end_unit

