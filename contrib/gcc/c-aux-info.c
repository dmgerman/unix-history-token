begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate information regarding function declarations and definitions based    on information stored in GCC's tree structure.  This code implements the    -aux-info option.    Copyright (C) 1989, 91, 94, 95, 97-98, 1999 Free Software Foundation, Inc.    Contributed by Ron Guilmette (rfg@segfault.us.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_enum
enum|enum
name|formals_style_enum
block|{
name|ansi
block|,
name|k_and_r_names
block|,
name|k_and_r_decls
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|formals_style_enum
name|formals_style
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|data_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|affix_data_type
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gen_formal_list_for_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|formals_style
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deserves_ellipsis
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gen_formal_list_for_func_def
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|formals_style
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gen_type
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|formals_style
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gen_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|formals_style
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Concatenate a sequence of strings, returning the result.     This function is based on the one in libiberty.  */
end_comment

begin_comment
comment|/* This definition will conflict with the one from prefix.c in    libcpp.a when linking cc1 and cc1obj.  So only provide it if we are    not using libcpp.a */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_CPPLIB
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|concat
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|first
operator|,
operator|...
operator|)
argument_list|)
block|{
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|char
modifier|*
name|newstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|va_list
name|args
decl_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|first
decl_stmt|;
endif|#
directive|endif
comment|/* First compute the size of the result and get sufficient memory.  */
name|VA_START
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|first
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arg
operator|=
name|first
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg
operator|!=
literal|0
condition|)
block|{
name|length
operator|+=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Now copy the individual pieces to the result string.  */
name|VA_START
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|first
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
name|newstr
expr_stmt|;
name|arg
operator|=
name|first
expr_stmt|;
while|while
condition|(
name|arg
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|arg
condition|)
operator|*
name|end
operator|++
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
operator|*
name|end
operator|=
literal|'\000'
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstr
operator|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! USE_CPPLIB */
end_comment

begin_comment
comment|/* Given a string representing an entire type or an entire declaration    which only lacks the actual "data-type" specifier (at its left end),    affix the data-type specifier to the left end of the given type    specification or object declaration.     Because of C language weirdness, the data-type specifier (which normally    goes in at the very left end) may have to be slipped in just to the    right of any leading "const" or "volatile" qualifiers (there may be more    than one).  Actually this may not be strictly necessary because it seems    that GCC (at least) accepts `<data-type> const foo;' and treats it the    same as `const<data-type> foo;' but people are accustomed to seeing    `const char *foo;' and *not* `char const *foo;' so we try to create types    that look as expected.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|affix_data_type
parameter_list|(
name|param
parameter_list|)
specifier|const
name|char
modifier|*
name|param
decl_stmt|;
block|{
name|char
modifier|*
name|type_or_decl
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|param
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|type_or_decl
decl_stmt|;
name|char
modifier|*
name|qualifiers_then_data_type
decl_stmt|;
name|char
name|saved
decl_stmt|;
name|strcpy
argument_list|(
name|type_or_decl
argument_list|,
name|param
argument_list|)
expr_stmt|;
comment|/* Skip as many leading const's or volatile's as there are.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"volatile "
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|9
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"const "
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|6
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* p now points to the place where we can insert the data type.  We have to      add a blank after the data-type of course.  */
if|if
condition|(
name|p
operator|==
name|type_or_decl
condition|)
return|return
name|concat
argument_list|(
name|data_type
argument_list|,
literal|" "
argument_list|,
name|type_or_decl
argument_list|,
name|NULL_PTR
argument_list|)
return|;
name|saved
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|qualifiers_then_data_type
operator|=
name|concat
argument_list|(
name|type_or_decl
argument_list|,
name|data_type
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|saved
expr_stmt|;
return|return
name|concat
argument_list|(
name|qualifiers_then_data_type
argument_list|,
literal|" "
argument_list|,
name|p
argument_list|,
name|NULL_PTR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a tree node which represents some "function type", generate the    source code version of a formal parameter list (of some given style) for    this function type.  Return the whole formal parameter list (including    a pair of surrounding parens) as a string.   Note that if the style    we are currently aiming for is non-ansi, then we just return a pair    of empty parens here.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|gen_formal_list_for_type
parameter_list|(
name|fntype
parameter_list|,
name|style
parameter_list|)
name|tree
name|fntype
decl_stmt|;
name|formals_style
name|style
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|formal_list
init|=
literal|""
decl_stmt|;
name|tree
name|formal_type
decl_stmt|;
if|if
condition|(
name|style
operator|!=
name|ansi
condition|)
return|return
literal|"()"
return|;
name|formal_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
while|while
condition|(
name|formal_type
operator|&&
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
specifier|const
name|char
modifier|*
name|this_type
decl_stmt|;
if|if
condition|(
operator|*
name|formal_list
condition|)
name|formal_list
operator|=
name|concat
argument_list|(
name|formal_list
argument_list|,
literal|", "
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|this_type
operator|=
name|gen_type
argument_list|(
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|,
name|ansi
argument_list|)
expr_stmt|;
name|formal_list
operator|=
operator|(
operator|(
name|strlen
argument_list|(
name|this_type
argument_list|)
operator|)
condition|?
name|concat
argument_list|(
name|formal_list
argument_list|,
name|affix_data_type
argument_list|(
name|this_type
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
else|:
name|concat
argument_list|(
name|formal_list
argument_list|,
name|data_type
argument_list|,
name|NULL_PTR
argument_list|)
operator|)
expr_stmt|;
name|formal_type
operator|=
name|TREE_CHAIN
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
block|}
comment|/* If we got to here, then we are trying to generate an ANSI style formal      parameters list.       New style prototyped ANSI formal parameter lists should in theory always      contain some stuff between the opening and closing parens, even if it is      only "void".       The brutal truth though is that there is lots of old K&R code out there      which contains declarations of "pointer-to-function" parameters and      these almost never have fully specified formal parameter lists associated      with them.  That is, the pointer-to-function parameters are declared      with just empty parameter lists.       In cases such as these, protoize should really insert *something* into      the vacant parameter lists, but what?  It has no basis on which to insert      anything in particular.       Here, we make life easy for protoize by trying to distinguish between      K&R empty parameter lists and new-style prototyped parameter lists      that actually contain "void".  In the latter case we (obviously) want      to output the "void" verbatim, and that what we do.  In the former case,      we do our best to give protoize something nice to insert.       This "something nice" should be something that is still valid (when      re-compiled) but something that can clearly indicate to the user that      more typing information (for the parameter list) should be added (by      hand) at some convenient moment.       The string chosen here is a comment with question marks in it.  */
if|if
condition|(
operator|!
operator|*
name|formal_list
condition|)
block|{
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
condition|)
comment|/* assert (TREE_VALUE (TYPE_ARG_TYPES (fntype)) == void_type_node);  */
name|formal_list
operator|=
literal|"void"
expr_stmt|;
else|else
name|formal_list
operator|=
literal|"/* ??? */"
expr_stmt|;
block|}
else|else
block|{
comment|/* If there were at least some parameters, and if the formals-types-list          petered out to a NULL (i.e. without being terminated by a          void_type_node) then we need to tack on an ellipsis.  */
if|if
condition|(
operator|!
name|formal_type
condition|)
name|formal_list
operator|=
name|concat
argument_list|(
name|formal_list
argument_list|,
literal|", ..."
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
return|return
name|concat
argument_list|(
literal|" ("
argument_list|,
name|formal_list
argument_list|,
literal|")"
argument_list|,
name|NULL_PTR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For the generation of an ANSI prototype for a function definition, we have    to look at the formal parameter list of the function's own "type" to    determine if the function's formal parameter list should end with an    ellipsis.  Given a tree node, the following function will return non-zero    if the "function type" parameter list should end with an ellipsis.  */
end_comment

begin_function
specifier|static
name|int
name|deserves_ellipsis
parameter_list|(
name|fntype
parameter_list|)
name|tree
name|fntype
decl_stmt|;
block|{
name|tree
name|formal_type
decl_stmt|;
name|formal_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
while|while
condition|(
name|formal_type
operator|&&
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
operator|!=
name|void_type_node
condition|)
name|formal_type
operator|=
name|TREE_CHAIN
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
comment|/* If there were at least some parameters, and if the formals-types-list      petered out to a NULL (i.e. without being terminated by a void_type_node)      then we need to tack on an ellipsis.  */
return|return
operator|(
operator|!
name|formal_type
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a parameter list for a function definition (in some given style).     Note that this routine has to be separate (and different) from the code that    generates the prototype parameter lists for function declarations, because    in the case of a function declaration, all we have to go on is a tree node    representing the function's own "function type".  This can tell us the types    of all of the formal parameters for the function, but it cannot tell us the    actual *names* of each of the formal parameters.  We need to output those    parameter names for each function definition.     This routine gets a pointer to a tree node which represents the actual    declaration of the given function, and this DECL node has a list of formal    parameter (variable) declarations attached to it.  These formal parameter    (variable) declaration nodes give us the actual names of the formal    parameters for the given function definition.     This routine returns a string which is the source form for the entire    function formal parameter list.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|gen_formal_list_for_func_def
parameter_list|(
name|fndecl
parameter_list|,
name|style
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|formals_style
name|style
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|formal_list
init|=
literal|""
decl_stmt|;
name|tree
name|formal_decl
decl_stmt|;
name|formal_decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|formal_decl
condition|)
block|{
specifier|const
name|char
modifier|*
name|this_formal
decl_stmt|;
if|if
condition|(
operator|*
name|formal_list
operator|&&
operator|(
operator|(
name|style
operator|==
name|ansi
operator|)
operator|||
operator|(
name|style
operator|==
name|k_and_r_names
operator|)
operator|)
condition|)
name|formal_list
operator|=
name|concat
argument_list|(
name|formal_list
argument_list|,
literal|", "
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|this_formal
operator|=
name|gen_decl
argument_list|(
name|formal_decl
argument_list|,
literal|0
argument_list|,
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|k_and_r_decls
condition|)
name|formal_list
operator|=
name|concat
argument_list|(
name|formal_list
argument_list|,
name|this_formal
argument_list|,
literal|"; "
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
name|formal_list
operator|=
name|concat
argument_list|(
name|formal_list
argument_list|,
name|this_formal
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|formal_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|formal_decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|ansi
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
condition|)
name|formal_list
operator|=
name|concat
argument_list|(
name|formal_list
argument_list|,
literal|"void"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|deserves_ellipsis
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|formal_list
operator|=
name|concat
argument_list|(
name|formal_list
argument_list|,
literal|", ..."
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|style
operator|==
name|ansi
operator|)
operator|||
operator|(
name|style
operator|==
name|k_and_r_names
operator|)
condition|)
name|formal_list
operator|=
name|concat
argument_list|(
literal|" ("
argument_list|,
name|formal_list
argument_list|,
literal|")"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|formal_list
return|;
block|}
end_function

begin_comment
comment|/* Generate a string which is the source code form for a given type (t).  This    routine is ugly and complex because the C syntax for declarations is ugly    and complex.  This routine is straightforward so long as *no* pointer types,    array types, or function types are involved.     In the simple cases, this routine will return the (string) value which was    passed in as the "ret_val" argument.  Usually, this starts out either as an    empty string, or as the name of the declared item (i.e. the formal function    parameter variable).     This routine will also return with the global variable "data_type" set to    some string value which is the "basic" data-type of the given complete type.    This "data_type" string can be concatenated onto the front of the returned    string after this routine returns to its caller.     In complicated cases involving pointer types, array types, or function    types, the C declaration syntax requires an "inside out" approach, i.e. if    you have a type which is a "pointer-to-function" type, you need to handle    the "pointer" part first, but it also has to be "innermost" (relative to    the declaration stuff for the "function" type).  Thus, is this case, you    must prepend a "(*" and append a ")" to the name of the item (i.e. formal    variable).  Then you must append and prepend the other info for the    "function type" part of the overall type.     To handle the "innermost precedence" rules of complicated C declarators, we    do the following (in this routine).  The input parameter called "ret_val"    is treated as a "seed".  Each time gen_type is called (perhaps recursively)    some additional strings may be appended or prepended (or both) to the "seed"    string.  If yet another (lower) level of the GCC tree exists for the given    type (as in the case of a pointer type, an array type, or a function type)    then the (wrapped) seed is passed to a (recursive) invocation of gen_type()    this recursive invocation may again "wrap" the (new) seed with yet more    declarator stuff, by appending, prepending (or both).  By the time the    recursion bottoms out, the "seed value" at that point will have a value    which is (almost) the complete source version of the declarator (except    for the data_type info).  Thus, this deepest "seed" value is simply passed    back up through all of the recursive calls until it is given (as the return    value) to the initial caller of the gen_type() routine.  All that remains    to do at this point is for the initial caller to prepend the "data_type"    string onto the returned "seed".  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|gen_type
parameter_list|(
name|ret_val
parameter_list|,
name|t
parameter_list|,
name|style
parameter_list|)
specifier|const
name|char
modifier|*
name|ret_val
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|formals_style
name|style
decl_stmt|;
block|{
name|tree
name|chain_p
decl_stmt|;
comment|/* If there is a typedef name for this type, use it.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"const "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"volatile "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|concat
argument_list|(
literal|"*"
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"("
argument_list|,
name|ret_val
argument_list|,
literal|")"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|gen_type
argument_list|(
name|ret_val
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|ret_val
operator|=
name|gen_type
argument_list|(
name|concat
argument_list|(
name|ret_val
argument_list|,
literal|"[]"
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|ret_val
operator|=
name|gen_type
argument_list|(
name|concat
argument_list|(
name|ret_val
argument_list|,
literal|"[0]"
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|size
init|=
operator|(
name|int_size_in_bytes
argument_list|(
name|t
argument_list|)
operator|/
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|char
name|buff
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"[%d]"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|gen_type
argument_list|(
name|concat
argument_list|(
name|ret_val
argument_list|,
name|buff
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|ret_val
operator|=
name|gen_type
argument_list|(
name|concat
argument_list|(
name|ret_val
argument_list|,
name|gen_formal_list_for_type
argument_list|(
name|t
argument_list|,
name|style
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
comment|/* The following three cases are complicated by the fact that a            user may do something really stupid, like creating a brand new            "anonymous" type specification in a formal argument list (or as            part of a function return type specification).  For example:  		int f (enum { red, green, blue } color);  	   In such cases, we have no name that we can put into the prototype 	   to represent the (anonymous) type.  Thus, we have to generate the 	   whole darn type specification.  Yuck!  */
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|data_type
operator|=
literal|""
expr_stmt|;
name|chain_p
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain_p
condition|)
block|{
name|data_type
operator|=
name|concat
argument_list|(
name|data_type
argument_list|,
name|gen_decl
argument_list|(
name|chain_p
argument_list|,
literal|0
argument_list|,
name|ansi
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|chain_p
operator|=
name|TREE_CHAIN
argument_list|(
name|chain_p
argument_list|)
expr_stmt|;
name|data_type
operator|=
name|concat
argument_list|(
name|data_type
argument_list|,
literal|"; "
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|data_type
operator|=
name|concat
argument_list|(
literal|"{ "
argument_list|,
name|data_type
argument_list|,
literal|"}"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|data_type
operator|=
name|concat
argument_list|(
literal|"struct "
argument_list|,
name|data_type
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|data_type
operator|=
literal|""
expr_stmt|;
name|chain_p
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain_p
condition|)
block|{
name|data_type
operator|=
name|concat
argument_list|(
name|data_type
argument_list|,
name|gen_decl
argument_list|(
name|chain_p
argument_list|,
literal|0
argument_list|,
name|ansi
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|chain_p
operator|=
name|TREE_CHAIN
argument_list|(
name|chain_p
argument_list|)
expr_stmt|;
name|data_type
operator|=
name|concat
argument_list|(
name|data_type
argument_list|,
literal|"; "
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|data_type
operator|=
name|concat
argument_list|(
literal|"{ "
argument_list|,
name|data_type
argument_list|,
literal|"}"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|data_type
operator|=
name|concat
argument_list|(
literal|"union "
argument_list|,
name|data_type
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|data_type
operator|=
literal|""
expr_stmt|;
name|chain_p
operator|=
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain_p
condition|)
block|{
name|data_type
operator|=
name|concat
argument_list|(
name|data_type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain_p
argument_list|)
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|chain_p
operator|=
name|TREE_CHAIN
argument_list|(
name|chain_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain_p
condition|)
name|data_type
operator|=
name|concat
argument_list|(
name|data_type
argument_list|,
literal|", "
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|data_type
operator|=
name|concat
argument_list|(
literal|"{ "
argument_list|,
name|data_type
argument_list|,
literal|" }"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|data_type
operator|=
name|concat
argument_list|(
literal|"enum "
argument_list|,
name|data_type
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Normally, `unsigned' is part of the deal.  Not so if it comes     	     with a type qualifier.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
condition|)
name|data_type
operator|=
name|concat
argument_list|(
literal|"unsigned "
argument_list|,
name|data_type
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|data_type
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|data_type
operator|=
literal|"void"
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|data_type
operator|=
literal|"[ERROR]"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"const "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"volatile "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_RESTRICT
argument_list|(
name|t
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"restrict "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* Generate a string (source) representation of an entire entity declaration    (using some particular style for function types).     The given entity may be either a variable or a function.     If the "is_func_definition" parameter is non-zero, assume that the thing    we are generating a declaration for is a FUNCTION_DECL node which is    associated with a function definition.  In this case, we can assume that    an attached list of DECL nodes for function formal arguments is present.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|gen_decl
parameter_list|(
name|decl
parameter_list|,
name|is_func_definition
parameter_list|,
name|style
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|is_func_definition
decl_stmt|;
name|formals_style
name|style
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|ret_val
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|ret_val
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
literal|""
expr_stmt|;
comment|/* If we are just generating a list of names of formal parameters, we can      simply return the formal parameter name (with no typing information      attached to it) now.  */
if|if
condition|(
name|style
operator|==
name|k_and_r_names
condition|)
return|return
name|ret_val
return|;
comment|/* Note that for the declaration of some entity (either a function or a      data object, like for instance a parameter) if the entity itself was      declared as either const or volatile, then const and volatile properties      are associated with just the declaration of the entity, and *not* with      the `type' of the entity.  Thus, for such declared entities, we have to      generate the qualifiers here.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"volatile "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"const "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|data_type
operator|=
literal|""
expr_stmt|;
comment|/* For FUNCTION_DECL nodes, there are two possible cases here.  First, if      this FUNCTION_DECL node was generated from a function "definition", then      we will have a list of DECL_NODE's, one for each of the function's formal      parameters.  In this case, we can print out not only the types of each      formal, but also each formal's name.  In the second case, this      FUNCTION_DECL node came from an actual function declaration (and *not*      a definition).  In this case, we do nothing here because the formal      argument type-list will be output later, when the "type" of the function      is added to the string we are building.  Note that the ANSI-style formal      parameter list is considered to be a (suffix) part of the "type" of the      function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|is_func_definition
condition|)
block|{
name|ret_val
operator|=
name|concat
argument_list|(
name|ret_val
argument_list|,
name|gen_formal_list_for_func_def
argument_list|(
name|decl
argument_list|,
name|ansi
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Since we have already added in the formals list stuff, here we don't          add the whole "type" of the function we are considering (which          would include its parameter-list info), rather, we only add in          the "type" of the "type" of the function, which is really just          the return-type of the function (and does not include the parameter          list info).  */
name|ret_val
operator|=
name|gen_type
argument_list|(
name|ret_val
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
else|else
name|ret_val
operator|=
name|gen_type
argument_list|(
name|ret_val
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|affix_data_type
argument_list|(
name|ret_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"register "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"extern "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|ret_val
operator|=
name|concat
argument_list|(
literal|"static "
argument_list|,
name|ret_val
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|aux_info_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate and write a new line of info to the aux-info (.X) file.  This    routine is called once for each function declaration, and once for each    function definition (even the implicit ones).  */
end_comment

begin_function
name|void
name|gen_aux_info_record
parameter_list|(
name|fndecl
parameter_list|,
name|is_definition
parameter_list|,
name|is_implicit
parameter_list|,
name|is_prototyped
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|is_definition
decl_stmt|;
name|int
name|is_implicit
decl_stmt|;
name|int
name|is_prototyped
decl_stmt|;
block|{
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
specifier|static
name|int
name|compiled_from_record
init|=
literal|0
decl_stmt|;
comment|/* Each output .X file must have a header line.  Write one now if we 	 have not yet done so.  */
if|if
condition|(
operator|!
name|compiled_from_record
operator|++
condition|)
block|{
comment|/* The first line tells which directory file names are relative to. 	     Currently, -aux-info works only for files in the working 	     directory, so just use a `.' as a placeholder for now.  */
name|fprintf
argument_list|(
name|aux_info_file
argument_list|,
literal|"/* compiled from: . */\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Write the actual line of auxiliary info.  */
name|fprintf
argument_list|(
name|aux_info_file
argument_list|,
literal|"/* %s:%d:%c%c */ %s;"
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
operator|(
name|is_implicit
operator|)
condition|?
literal|'I'
else|:
operator|(
name|is_prototyped
operator|)
condition|?
literal|'N'
else|:
literal|'O'
argument_list|,
operator|(
name|is_definition
operator|)
condition|?
literal|'F'
else|:
literal|'C'
argument_list|,
name|gen_decl
argument_list|(
name|fndecl
argument_list|,
name|is_definition
argument_list|,
name|ansi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is an explicit function declaration, we need to also write 	 out an old-style (i.e. K&R) function header, just in case the user 	 wants to run unprotoize.  */
if|if
condition|(
name|is_definition
condition|)
block|{
name|fprintf
argument_list|(
name|aux_info_file
argument_list|,
literal|" /*%s %s*/"
argument_list|,
name|gen_formal_list_for_func_def
argument_list|(
name|fndecl
argument_list|,
name|k_and_r_names
argument_list|)
argument_list|,
name|gen_formal_list_for_func_def
argument_list|(
name|fndecl
argument_list|,
name|k_and_r_decls
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|aux_info_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

