begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expand the basic unary and binary arithmetic operations, for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Include insn-config.h before expr.h so that HAVE_conditional_move    is properly defined.  */
end_comment

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_comment
comment|/* Each optab contains info on how this target machine    can perform a particular operation    for all sizes and kinds of operands.     The operation to be performed is often specified    by passing one of these optabs as an argument.     See expr.h for documentation of these optabs.  */
end_comment

begin_decl_stmt
name|optab
name|optab_table
index|[
name|OTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|libfunc_table
index|[
name|LTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tables of patterns for extending one integer mode to another.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|extendtab
index|[
name|MAX_MACHINE_MODE
index|]
index|[
name|MAX_MACHINE_MODE
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tables of patterns for converting between fixed and floating point.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|fixtab
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|NUM_MACHINE_MODES
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|fixtrunctab
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|NUM_MACHINE_MODES
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|floattab
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|NUM_MACHINE_MODES
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the optab used for each rtx code.  */
end_comment

begin_decl_stmt
name|optab
name|code_to_optab
index|[
name|NUM_RTX_CODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the gen_function to make a branch to test that condition.  */
end_comment

begin_decl_stmt
name|rtxfun
name|bcc_gen_fctn
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the insn code to make a store-condition insn    to test that condition.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|setcc_gen_code
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_move
end_ifdef

begin_comment
comment|/* Indexed by the machine mode, gives the insn code to make a conditional    move insn.  This is not indexed by the rtx-code like bcc_gen_fctn and    setcc_gen_code to cut down on the number of named patterns.  Consider a day    when a lot more rtx codes are conditional (eg: for the ARM).  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|movcc_gen_code
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|add_equal_note
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|widen_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expand_cmplxdiv_straight
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
expr|enum
name|optab_methods
operator|,
expr|enum
name|mode_class
operator|,
name|optab
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expand_cmplxdiv_wide
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
expr|enum
name|optab_methods
operator|,
expr|enum
name|mode_class
operator|,
name|optab
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prepare_cmp_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|rtx_code
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|can_compare_purpose
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|can_fix_p
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|can_float_p
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ftruncify
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|optab
name|new_optab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|optab
name|init_optab
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|optab
name|init_optabv
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_libfuncs
name|PARAMS
argument_list|(
operator|(
name|optab
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_integral_libfuncs
name|PARAMS
argument_list|(
operator|(
name|optab
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_floating_libfuncs
name|PARAMS
argument_list|(
operator|(
name|optab
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_trap
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|init_traps
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|emit_cmp_and_jump_insn_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|rtx_code
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prepare_float_lib_cmp
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|rtx_code
operator|*
operator|,
expr|enum
name|machine_mode
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add a REG_EQUAL note to the last insn in SEQ.  TARGET is being set to    the result of operation CODE applied to OP0 (and OP1 if it is a binary    operation).     If the last insn does not set TARGET, don't do anything, but return 1.     If a previous insn sets TARGET and TARGET is one of OP0 or OP1,    don't add the REG_EQUAL note but return 0.  Our caller can then try    again, ensuring that TARGET is not one of the operands.  */
end_comment

begin_function
specifier|static
name|int
name|add_equal_note
parameter_list|(
name|seq
parameter_list|,
name|target
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|seq
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'1'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'2'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|)
operator|||
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|!=
name|SEQUENCE
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|target
argument_list|)
comment|/* For a STRICT_LOW_PART, the REG_NOTE applies to what is inside the 	     SUBREG.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If TARGET is in OP0 or OP1, check if anything in SEQ sets TARGET      besides the last insn.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
operator|(
name|op1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_set_p
argument_list|(
name|target
argument_list|,
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
name|note
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|note
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|REG_EQUAL
argument_list|,
name|note
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Widen OP to MODE and return the rtx for the widened operand.  UNSIGNEDP    says whether OP is signed or unsigned.  NO_EXTEND is nonzero if we need    not actually do a sign-extend or zero-extend, but can leave the     higher-order bits of the result rtx undefined, for example, in the case    of logical operations, but not right shifts.  */
end_comment

begin_function
specifier|static
name|rtx
name|widen_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|oldmode
parameter_list|,
name|unsignedp
parameter_list|,
name|no_extend
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|oldmode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|no_extend
decl_stmt|;
block|{
name|rtx
name|result
decl_stmt|;
comment|/* If we must extend do so.  If OP is either a constant or a SUBREG      for a promoted object, also extend since it will be more efficient to      do so.  */
if|if
condition|(
operator|!
name|no_extend
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op
argument_list|)
operator|)
condition|)
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|oldmode
argument_list|,
name|op
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* If MODE is no wider than a single word, we return a paradoxical      SUBREG.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Otherwise, get an object of MODE, clobber it, and set the low-order      part to OP.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|result
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform a straightforward complex divide.  */
end_comment

begin_function
specifier|static
name|int
name|expand_cmplxdiv_straight
parameter_list|(
name|real0
parameter_list|,
name|real1
parameter_list|,
name|imag0
parameter_list|,
name|imag1
parameter_list|,
name|realr
parameter_list|,
name|imagr
parameter_list|,
name|submode
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|,
name|class
parameter_list|,
name|binoptab
parameter_list|)
name|rtx
name|real0
decl_stmt|,
name|real1
decl_stmt|,
name|imag0
decl_stmt|,
name|imag1
decl_stmt|,
name|realr
decl_stmt|,
name|imagr
decl_stmt|;
name|enum
name|machine_mode
name|submode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|optab
name|binoptab
decl_stmt|;
block|{
name|rtx
name|divisor
decl_stmt|;
name|rtx
name|real_t
decl_stmt|,
name|imag_t
decl_stmt|;
name|rtx
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
name|rtx
name|res
decl_stmt|;
name|optab
name|this_add_optab
init|=
name|add_optab
decl_stmt|;
name|optab
name|this_sub_optab
init|=
name|sub_optab
decl_stmt|;
name|optab
name|this_neg_optab
init|=
name|neg_optab
decl_stmt|;
name|optab
name|this_mul_optab
init|=
name|smul_optab
decl_stmt|;
if|if
condition|(
name|binoptab
operator|==
name|sdivv_optab
condition|)
block|{
name|this_add_optab
operator|=
name|addv_optab
expr_stmt|;
name|this_sub_optab
operator|=
name|subv_optab
expr_stmt|;
name|this_neg_optab
operator|=
name|negv_optab
expr_stmt|;
name|this_mul_optab
operator|=
name|smulv_optab
expr_stmt|;
block|}
comment|/* Don't fetch these from memory more than once.  */
name|real0
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real0
argument_list|)
expr_stmt|;
name|real1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real1
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag0
operator|!=
literal|0
condition|)
name|imag0
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|imag0
argument_list|)
expr_stmt|;
name|imag1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|imag1
argument_list|)
expr_stmt|;
comment|/* Divisor: c*c + d*d.  */
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real1
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|imag1
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
operator|||
name|temp2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|divisor
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_add_optab
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|imag0
operator|==
literal|0
condition|)
block|{
comment|/* Mathematically, ((a)(c-id))/divisor.  */
comment|/* Computationally, (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)).  */
comment|/* Calculate the dividend.  */
name|real_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|imag_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_t
operator|==
literal|0
operator|||
name|imag_t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|imag_t
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|this_neg_optab
argument_list|,
name|imag_t
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Mathematically, ((a+ib)(c-id))/divider.  */
comment|/* Calculate the dividend.  */
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
operator|||
name|temp2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|real_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_add_optab
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|imag0
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
operator|||
name|temp2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|imag_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_sub_optab
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_t
operator|==
literal|0
operator|||
name|imag_t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real_t
argument_list|,
name|divisor
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|real_t
argument_list|,
name|divisor
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag_t
argument_list|,
name|divisor
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|imag_t
argument_list|,
name|divisor
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform a wide-input-range-acceptable complex divide.  */
end_comment

begin_function
specifier|static
name|int
name|expand_cmplxdiv_wide
parameter_list|(
name|real0
parameter_list|,
name|real1
parameter_list|,
name|imag0
parameter_list|,
name|imag1
parameter_list|,
name|realr
parameter_list|,
name|imagr
parameter_list|,
name|submode
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|,
name|class
parameter_list|,
name|binoptab
parameter_list|)
name|rtx
name|real0
decl_stmt|,
name|real1
decl_stmt|,
name|imag0
decl_stmt|,
name|imag1
decl_stmt|,
name|realr
decl_stmt|,
name|imagr
decl_stmt|;
name|enum
name|machine_mode
name|submode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|optab
name|binoptab
decl_stmt|;
block|{
name|rtx
name|ratio
decl_stmt|,
name|divisor
decl_stmt|;
name|rtx
name|real_t
decl_stmt|,
name|imag_t
decl_stmt|;
name|rtx
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|lab1
decl_stmt|,
name|lab2
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|res
decl_stmt|;
name|optab
name|this_add_optab
init|=
name|add_optab
decl_stmt|;
name|optab
name|this_sub_optab
init|=
name|sub_optab
decl_stmt|;
name|optab
name|this_neg_optab
init|=
name|neg_optab
decl_stmt|;
name|optab
name|this_mul_optab
init|=
name|smul_optab
decl_stmt|;
if|if
condition|(
name|binoptab
operator|==
name|sdivv_optab
condition|)
block|{
name|this_add_optab
operator|=
name|addv_optab
expr_stmt|;
name|this_sub_optab
operator|=
name|subv_optab
expr_stmt|;
name|this_neg_optab
operator|=
name|negv_optab
expr_stmt|;
name|this_mul_optab
operator|=
name|smulv_optab
expr_stmt|;
block|}
comment|/* Don't fetch these from memory more than once.  */
name|real0
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real0
argument_list|)
expr_stmt|;
name|real1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real1
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag0
operator|!=
literal|0
condition|)
name|imag0
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|imag0
argument_list|)
expr_stmt|;
name|imag1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|imag1
argument_list|)
expr_stmt|;
comment|/* XXX What's an "unsigned" complex number?  */
if|if
condition|(
name|unsignedp
condition|)
block|{
name|temp1
operator|=
name|real1
expr_stmt|;
name|temp2
operator|=
name|imag1
expr_stmt|;
block|}
else|else
block|{
name|temp1
operator|=
name|expand_abs
argument_list|(
name|submode
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|expand_abs
argument_list|(
name|submode
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp1
operator|==
literal|0
operator|||
name|temp2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
name|lab1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|temp1
argument_list|,
name|temp2
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
comment|/* |c|>= |d|; use ratio d/c to scale dividend and divisor.  */
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|ratio
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag1
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|ratio
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|imag1
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ratio
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Calculate divisor.  */
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|imag1
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|divisor
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_add_optab
argument_list|,
name|temp1
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Calculate dividend.  */
if|if
condition|(
name|imag0
operator|==
literal|0
condition|)
block|{
name|real_t
operator|=
name|real0
expr_stmt|;
comment|/* Compute a / (c+id) as a / (c+d(d/c)) + i (-a(d/c)) / (c+d(d/c)).  */
name|imag_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag_t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|imag_t
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|this_neg_optab
argument_list|,
name|imag_t
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_t
operator|==
literal|0
operator|||
name|imag_t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Compute (a+ib)/(c+id) as 	 (a+b(d/c))/(c+d(d/c) + i(b-a(d/c))/(c+d(d/c)).  */
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|imag0
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|real_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_add_optab
argument_list|,
name|temp1
argument_list|,
name|real0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|imag_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_sub_optab
argument_list|,
name|imag0
argument_list|,
name|temp1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_t
operator|==
literal|0
operator|||
name|imag_t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real_t
argument_list|,
name|divisor
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|real_t
argument_list|,
name|divisor
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag_t
argument_list|,
name|divisor
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|imag_t
argument_list|,
name|divisor
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|lab2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
comment|/* |d|> |c|; use ratio c/d to scale dividend and divisor.  */
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|ratio
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real1
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|ratio
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|real1
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ratio
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Calculate divisor.  */
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real1
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|divisor
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_add_optab
argument_list|,
name|temp1
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Calculate dividend.  */
if|if
condition|(
name|imag0
operator|==
literal|0
condition|)
block|{
comment|/* Compute a / (c+id) as a(c/d) / (c(c/d)+d) + i (-a) / (c(c/d)+d).  */
name|real_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|imag_t
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|this_neg_optab
argument_list|,
name|real0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_t
operator|==
literal|0
operator|||
name|imag_t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Compute (a+ib)/(c+id) as 	 (a(c/d)+b)/(c(c/d)+d) + i (b(c/d)-a)/(c(c/d)+d).  */
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|real0
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|real_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_add_optab
argument_list|,
name|temp1
argument_list|,
name|imag0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_mul_optab
argument_list|,
name|imag0
argument_list|,
name|ratio
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|imag_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|this_sub_optab
argument_list|,
name|temp1
argument_list|,
name|real0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_t
operator|==
literal|0
operator|||
name|imag_t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real_t
argument_list|,
name|divisor
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|real_t
argument_list|,
name|divisor
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag_t
argument_list|,
name|divisor
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|imag_t
argument_list|,
name|divisor
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrapper around expand_binop which takes an rtx code to specify    the operation to perform, not an optab pointer.  All other    arguments are the same.  */
end_comment

begin_function
name|rtx
name|expand_simple_binop
parameter_list|(
name|mode
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
block|{
name|optab
name|binop
init|=
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
decl_stmt|;
if|if
condition|(
name|binop
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binop
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_binop
parameter_list|(
name|mode
parameter_list|,
name|binoptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|binoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
block|{
name|enum
name|optab_methods
name|next_methods
init|=
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|?
name|OPTAB_WIDEN
else|:
name|methods
operator|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|commutative_op
init|=
literal|0
decl_stmt|;
name|int
name|shift_op
init|=
operator|(
name|binoptab
operator|->
name|code
operator|==
name|ASHIFT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ASHIFTRT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|LSHIFTRT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ROTATE
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ROTATERT
operator|)
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* If subtracting an integer constant, convert this into an addition of      the negated constant.  */
if|if
condition|(
name|binoptab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|negate_rtx
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|add_optab
expr_stmt|;
block|}
comment|/* If we are inside an appropriately-short loop and one operand is an      expensive constant, force it into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|op0
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
operator|!
name|shift_op
operator|&&
name|rtx_cost
argument_list|(
name|op1
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Record where to delete back to if we backtrack.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* If operation is commutative,      try to make the first operand a register.      Even better, try to make it the same as the target.      Also try to make the last operand a constant.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|binoptab
operator|->
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|binoptab
operator|==
name|smul_widen_optab
operator|||
name|binoptab
operator|==
name|umul_widen_optab
operator|||
name|binoptab
operator|==
name|smul_highpart_optab
operator|||
name|binoptab
operator|==
name|umul_highpart_optab
condition|)
block|{
name|commutative_op
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|)
condition|?
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|)
operator|||
name|target
operator|==
name|op1
operator|)
else|:
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|temp
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* If we can do it with a three-operand insn, do so.  */
if|if
condition|(
name|methods
operator|!=
name|OPTAB_MUST_WIDEN
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If it is a commutative operator and the modes would match 	 if we would swap the operands, we can save the conversions.  */
if|if
condition|(
name|commutative_op
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode0
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|xop0
expr_stmt|;
name|xop0
operator|=
name|xop1
expr_stmt|;
name|xop1
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* In case the insn wants input operands in modes different from 	 the result, convert the operands.  It would seem that we 	 don't need to convert CONST_INTs, but we do, so that they're 	 a properly sign-extended for their modes; we choose the 	 widest mode between mode and mode[01], so that, in a widening 	 operation, we call convert_modes with different FROM and TO 	 modes, which ensures the value is sign-extended.  Shift 	 operations are an exception, because the second operand needs 	 not be extended to the mode of the result.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|mode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|convert_modes
argument_list|(
name|mode0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode0
argument_list|)
condition|?
name|mode
else|:
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|mode1
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|convert_modes
argument_list|(
name|mode1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op1
argument_list|)
else|:
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode1
argument_list|)
operator|&&
operator|!
name|shift_op
operator|)
condition|?
name|mode
else|:
name|mode1
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn's predicates don't allow our operands, put them into 	 pseudo regs.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop0
operator|,
name|mode0
operator|)
operator|&&
name|mode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop1
operator|,
name|mode1
operator|)
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|temp
operator|,
name|mode
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
comment|/* If PAT is a multi-insn sequence, try to add an appropriate 	     REG_EQUAL note to it.  If we can't because TEMP conflicts with an 	     operand, call ourselves again, this time without a target.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|binoptab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a multiply, see if we can do a widening operation that      takes operands of this mode and makes a wider mode.  */
if|if
condition|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
operator|(
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
index|]
operator|.
name|insn_code
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
block|}
comment|/* Look for a wider mode of the same class for which we think we      can open-code the operation.  Check for a widening multiply at the      wider mode as well.  */
if|if
condition|(
operator|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
operator|&&
name|methods
operator|!=
name|OPTAB_DIRECT
operator|&&
name|methods
operator|!=
name|OPTAB_LIB
condition|)
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|||
operator|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
operator|(
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
index|]
operator|.
name|insn_code
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
name|int
name|no_extend
init|=
literal|0
decl_stmt|;
comment|/* For certain integer operations, we need not actually extend 	       the narrow operands, as long as we will truncate 	       the results to the same narrowness.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
condition|)
name|no_extend
operator|=
literal|1
expr_stmt|;
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
argument_list|)
expr_stmt|;
comment|/* The second operand of a shift must always be extended.  */
name|xop1
operator|=
name|widen_operand
argument_list|(
name|xop1
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
operator|&&
name|binoptab
operator|!=
name|ashl_optab
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|binoptab
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These can be done a word at a time.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|rtx
name|equiv_value
decl_stmt|;
comment|/* If TARGET is the same as one of the operands, the REG_EQUAL note 	 won't be accurate, so use a new target.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|equiv_value
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|equiv_value
operator|=
literal|0
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* Synthesize double word shifts from single word shifts.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|lshr_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|||
name|binoptab
operator|==
name|ashr_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|insns
decl_stmt|,
name|inter
decl_stmt|,
name|equiv_value
decl_stmt|;
name|rtx
name|into_target
decl_stmt|,
name|outof_target
decl_stmt|;
name|rtx
name|into_input
decl_stmt|,
name|outof_input
decl_stmt|;
name|int
name|shift_count
decl_stmt|,
name|left_shift
decl_stmt|,
name|outof_word
decl_stmt|;
comment|/* If TARGET is the same as one of the operands, the REG_EQUAL note 	 won't be accurate, so use a new target.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|shift_count
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* OUTOF_* is the word we are shifting bits away from, and 	 INTO_* is the word that we are shifting bits towards, thus 	 they differ depending on the direction of the shift and 	 WORDS_BIG_ENDIAN.  */
name|left_shift
operator|=
name|binoptab
operator|==
name|ashl_optab
expr_stmt|;
name|outof_word
operator|=
name|left_shift
operator|^
operator|!
name|WORDS_BIG_ENDIAN
expr_stmt|;
name|outof_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|outof_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_count
operator|>=
name|BITS_PER_WORD
condition|)
block|{
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|GEN_INT
argument_list|(
name|shift_count
operator|-
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|into_target
condition|)
name|emit_move_insn
argument_list|(
name|into_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
comment|/* For a signed right shift, we must fill the word we are shifting 	     out of with copies of the sign bit.  Otherwise it is zeroed.  */
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|binoptab
operator|!=
name|ashr_optab
condition|)
name|inter
operator|=
name|CONST0_RTX
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inter
operator|!=
literal|0
condition|)
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
literal|1
argument_list|)
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|outof_target
condition|)
name|emit_move_insn
argument_list|(
name|outof_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|carries
decl_stmt|;
name|optab
name|reverse_unsigned_shift
decl_stmt|,
name|unsigned_shift
decl_stmt|;
comment|/* For a shift of less then BITS_PER_WORD, to compute the carry, 	     we must do a logical shift in the opposite direction of the 	     desired shift.  */
name|reverse_unsigned_shift
operator|=
operator|(
name|left_shift
condition|?
name|lshr_optab
else|:
name|ashl_optab
operator|)
expr_stmt|;
comment|/* For a shift of less than BITS_PER_WORD, to compute the word 	     shifted towards, we need to unsigned shift the orig value of 	     that word.  */
name|unsigned_shift
operator|=
operator|(
name|left_shift
condition|?
name|ashl_optab
else|:
name|lshr_optab
operator|)
expr_stmt|;
name|carries
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|reverse_unsigned_shift
argument_list|,
name|outof_input
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
name|shift_count
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|carries
operator|==
literal|0
condition|)
name|inter
operator|=
literal|0
expr_stmt|;
else|else
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|unsigned_shift
argument_list|,
name|into_input
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
condition|)
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|carries
argument_list|,
name|inter
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|into_target
condition|)
name|emit_move_insn
argument_list|(
name|into_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
condition|)
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|op1
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|outof_target
condition|)
name|emit_move_insn
argument_list|(
name|outof_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|equiv_value
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|equiv_value
operator|=
literal|0
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* Synthesize double word rotates from single word shifts.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|rotl_optab
operator|||
name|binoptab
operator|==
name|rotr_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|insns
decl_stmt|,
name|equiv_value
decl_stmt|;
name|rtx
name|into_target
decl_stmt|,
name|outof_target
decl_stmt|;
name|rtx
name|into_input
decl_stmt|,
name|outof_input
decl_stmt|;
name|rtx
name|inter
decl_stmt|;
name|int
name|shift_count
decl_stmt|,
name|left_shift
decl_stmt|,
name|outof_word
decl_stmt|;
comment|/* If TARGET is the same as one of the operands, the REG_EQUAL note 	 won't be accurate, so use a new target.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|shift_count
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* OUTOF_* is the word we are shifting bits away from, and 	 INTO_* is the word that we are shifting bits towards, thus 	 they differ depending on the direction of the shift and 	 WORDS_BIG_ENDIAN.  */
name|left_shift
operator|=
operator|(
name|binoptab
operator|==
name|rotl_optab
operator|)
expr_stmt|;
name|outof_word
operator|=
name|left_shift
operator|^
operator|!
name|WORDS_BIG_ENDIAN
expr_stmt|;
name|outof_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|outof_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_count
operator|==
name|BITS_PER_WORD
condition|)
block|{
comment|/* This is just a word swap.  */
name|emit_move_insn
argument_list|(
name|outof_target
argument_list|,
name|into_input
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|into_target
argument_list|,
name|outof_input
argument_list|)
expr_stmt|;
name|inter
operator|=
name|const0_rtx
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|into_temp1
decl_stmt|,
name|into_temp2
decl_stmt|,
name|outof_temp1
decl_stmt|,
name|outof_temp2
decl_stmt|;
name|rtx
name|first_shift_count
decl_stmt|,
name|second_shift_count
decl_stmt|;
name|optab
name|reverse_unsigned_shift
decl_stmt|,
name|unsigned_shift
decl_stmt|;
name|reverse_unsigned_shift
operator|=
operator|(
name|left_shift
operator|^
operator|(
name|shift_count
operator|<
name|BITS_PER_WORD
operator|)
condition|?
name|lshr_optab
else|:
name|ashl_optab
operator|)
expr_stmt|;
name|unsigned_shift
operator|=
operator|(
name|left_shift
operator|^
operator|(
name|shift_count
operator|<
name|BITS_PER_WORD
operator|)
condition|?
name|ashl_optab
else|:
name|lshr_optab
operator|)
expr_stmt|;
if|if
condition|(
name|shift_count
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|first_shift_count
operator|=
name|GEN_INT
argument_list|(
name|shift_count
operator|-
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|second_shift_count
operator|=
name|GEN_INT
argument_list|(
literal|2
operator|*
name|BITS_PER_WORD
operator|-
name|shift_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first_shift_count
operator|=
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
name|shift_count
argument_list|)
expr_stmt|;
name|second_shift_count
operator|=
name|GEN_INT
argument_list|(
name|shift_count
argument_list|)
expr_stmt|;
block|}
name|into_temp1
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|unsigned_shift
argument_list|,
name|outof_input
argument_list|,
name|first_shift_count
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
name|into_temp2
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|reverse_unsigned_shift
argument_list|,
name|into_input
argument_list|,
name|second_shift_count
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|into_temp1
operator|!=
literal|0
operator|&&
name|into_temp2
operator|!=
literal|0
condition|)
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|into_temp1
argument_list|,
name|into_temp2
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
else|else
name|inter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|into_target
condition|)
name|emit_move_insn
argument_list|(
name|into_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
name|outof_temp1
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|unsigned_shift
argument_list|,
name|into_input
argument_list|,
name|first_shift_count
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
name|outof_temp2
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|reverse_unsigned_shift
argument_list|,
name|outof_input
argument_list|,
name|second_shift_count
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|outof_temp1
operator|!=
literal|0
operator|&&
name|outof_temp2
operator|!=
literal|0
condition|)
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|outof_temp1
argument_list|,
name|outof_temp2
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|outof_target
condition|)
name|emit_move_insn
argument_list|(
name|outof_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|equiv_value
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|equiv_value
operator|=
literal|0
expr_stmt|;
comment|/* We can't make this a no conflict block if this is a word swap, 	     because the word swap case fails if the input and output values 	     are in the same register.  */
if|if
condition|(
name|shift_count
operator|!=
name|BITS_PER_WORD
condition|)
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
else|else
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* These can be done a word at a time by propagating carries.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|optab
name|otheroptab
init|=
name|binoptab
operator|==
name|add_optab
condition|?
name|sub_optab
else|:
name|add_optab
decl_stmt|;
name|unsigned
name|int
name|nwords
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|carry_in
init|=
name|NULL_RTX
decl_stmt|,
name|carry_out
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|xop0
decl_stmt|,
name|xop1
decl_stmt|;
comment|/* We can handle either a 1 or -1 value for the carry.  If STORE_FLAG 	 value is one of those, use it.  Otherwise, use 1 since it is the 	 one easiest to get.  */
if|#
directive|if
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
name|int
name|normalizep
init|=
name|STORE_FLAG_VALUE
decl_stmt|;
else|#
directive|else
name|int
name|normalizep
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* Prepare the operands.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|xop1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|target
operator|==
name|xop0
operator|||
name|target
operator|==
name|xop1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Indicate for flow that the entire target reg is being set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_piece
init|=
name|operand_subword_force
argument_list|(
name|xop0
argument_list|,
name|index
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_piece
init|=
name|operand_subword_force
argument_list|(
name|xop1
argument_list|,
name|index
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Main add/subtract of the input operands.  */
name|x
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|op0_piece
argument_list|,
name|op1_piece
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nwords
condition|)
block|{
comment|/* Store carry from main add/subtract.  */
name|carry_out
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|carry_out
operator|=
name|emit_store_flag_force
argument_list|(
name|carry_out
argument_list|,
operator|(
name|binoptab
operator|==
name|add_optab
condition|?
name|LT
else|:
name|GT
operator|)
argument_list|,
name|x
argument_list|,
name|op0_piece
argument_list|,
name|word_mode
argument_list|,
literal|1
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rtx
name|newx
decl_stmt|;
comment|/* Add/subtract previous carry to main result.  */
name|newx
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|normalizep
operator|==
literal|1
condition|?
name|binoptab
else|:
name|otheroptab
argument_list|,
name|x
argument_list|,
name|carry_in
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nwords
condition|)
block|{
comment|/* Get out carry from adding/subtracting carry in.  */
name|rtx
name|carry_tmp
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|carry_tmp
operator|=
name|emit_store_flag_force
argument_list|(
name|carry_tmp
argument_list|,
operator|(
name|binoptab
operator|==
name|add_optab
condition|?
name|LT
else|:
name|GT
operator|)
argument_list|,
name|newx
argument_list|,
name|x
argument_list|,
name|word_mode
argument_list|,
literal|1
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
comment|/* Logical-ior the two poss. carry together.  */
name|carry_out
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|carry_out
argument_list|,
name|carry_tmp
argument_list|,
name|carry_out
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|carry_out
operator|==
literal|0
condition|)
break|break;
block|}
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|newx
argument_list|)
expr_stmt|;
block|}
name|carry_in
operator|=
name|carry_out
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|temp
init|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|set_unique_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|xop0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|xop1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If we want to multiply two two-word values and have normal and widening      multiplies of single-word values, we can do this with three smaller      multiplications.  Note that we do not make a REG_NO_CONFLICT block here      because we are not operating on one word at a time.        The multiplication proceeds as follows: 			         _______________________ 			        [__op0_high_|__op0_low__] 			         _______________________         *			[__op1_high_|__op1_low__]         _______________________________________________ 			         _______________________     (1)				[__op0_low__*__op1_low__] 		     _______________________     (2a)	    [__op0_low__*__op1_high_] 		     _______________________     (2b)	    [__op0_high_*__op1_low__]          _______________________     (3) [__op0_high_*__op1_high_]       This gives a 4-word result.  Since we are only interested in the     lower 2 words, partial result (3) and the upper words of (2a) and     (2b) don't need to be calculated.  Hence (2a) and (2b) can be     calculated using non-widening multiplication.      (1), however, needs to be calculated with an unsigned widening     multiplication.  If this operation is not directly supported we     try using a signed widening multiplication and adjust the result.     This adjustment works as follows:        If both operands are positive then no adjustment is needed.        If the operands have different signs, for example op0_low< 0 and       op1_low>= 0, the instruction treats the most significant bit of       op0_low as a sign bit instead of a bit with significance       2**(BITS_PER_WORD-1), i.e. the instruction multiplies op1_low       with 2**BITS_PER_WORD - op0_low, and two's complements the       result.  Conclusion: We need to add op1_low * 2**BITS_PER_WORD to       the result.        Similarly, if both operands are negative, we need to add       (op0_low + op1_low) * 2**BITS_PER_WORD.        We use a trick to adjust quickly.  We logically shift op0_low right       (op1_low) BITS_PER_WORD-1 steps to get 0 or 1, and add this to       op0_high (op1_high) before it is used to calculate 2b (2a).  If no       logical shift exists, we do an arithmetic right shift and subtract       the 0 or -1.  */
if|if
condition|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
name|int
name|low
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|high
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|rtx
name|op0_high
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_low
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|low
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_high
init|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_low
init|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|low
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|product
init|=
literal|0
decl_stmt|;
name|rtx
name|op0_xhigh
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|op1_xhigh
init|=
name|NULL_RTX
decl_stmt|;
comment|/* If the target is the same as one of the inputs, don't use it.  This 	 prevents problems with the REG_EQUAL note.  */
if|if
condition|(
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
operator|||
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Multiply the two lower words to get a double-word product. 	 If unsigned widening multiplication is available, use that; 	 otherwise use the signed form and compensate.  */
if|if
condition|(
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|product
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|umul_widen_optab
argument_list|,
name|op0_low
argument_list|,
name|op1_low
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* If we didn't succeed, delete everything we did so far.  */
if|if
condition|(
name|product
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
else|else
name|op0_xhigh
operator|=
name|op0_high
operator|,
name|op1_xhigh
operator|=
name|op1_high
expr_stmt|;
block|}
if|if
condition|(
name|product
operator|==
literal|0
operator|&&
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|wordm1
init|=
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
literal|1
argument_list|)
decl_stmt|;
name|product
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smul_widen_optab
argument_list|,
name|op0_low
argument_list|,
name|op1_low
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|lshr_optab
argument_list|,
name|op0_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0_xhigh
condition|)
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|op0_high
argument_list|,
name|op0_xhigh
argument_list|,
name|op0_xhigh
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
else|else
block|{
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashr_optab
argument_list|,
name|op0_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0_xhigh
condition|)
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|sub_optab
argument_list|,
name|op0_high
argument_list|,
name|op0_xhigh
argument_list|,
name|op0_xhigh
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
block|}
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|lshr_optab
argument_list|,
name|op1_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1_xhigh
condition|)
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|op1_high
argument_list|,
name|op1_xhigh
argument_list|,
name|op1_xhigh
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
else|else
block|{
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashr_optab
argument_list|,
name|op1_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1_xhigh
condition|)
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|sub_optab
argument_list|,
name|op1_high
argument_list|,
name|op1_xhigh
argument_list|,
name|op1_xhigh
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have been able to directly compute the product of the 	 low-order words of the operands and perform any required adjustments 	 of the operands, we proceed by trying two more multiplications 	 and then computing the appropriate sum.  	 We have checked above that the required addition is provided. 	 Full-word addition will normally always succeed, especially if 	 it is provided at all, so we don't worry about its failure.  The 	 multiplication may well fail, however, so we do handle that.  */
if|if
condition|(
name|product
operator|&&
name|op0_xhigh
operator|&&
name|op1_xhigh
condition|)
block|{
name|rtx
name|product_high
init|=
name|operand_subword
argument_list|(
name|product
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|temp
init|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|op0_low
argument_list|,
name|op1_xhigh
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|product_high
argument_list|,
name|product_high
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|temp
operator|!=
name|product_high
condition|)
name|emit_move_insn
argument_list|(
name|product_high
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|op1_low
argument_list|,
name|op0_xhigh
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|product_high
argument_list|,
name|product_high
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|temp
operator|!=
name|product_high
condition|)
name|emit_move_insn
argument_list|(
name|product_high
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|temp
operator|=
name|emit_move_insn
argument_list|(
name|product
argument_list|,
name|product
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|product
return|;
block|}
block|}
comment|/* If we get here, we couldn't do it for some reason even though we 	 originally thought we could.  Delete anything we've emitted in 	 trying to do it.  */
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* We need to open-code the complex type operations: '+, -, * and /' */
comment|/* At this point we allow operations between two similar complex      numbers, and also if one of the operands is not a complex number      but rather of MODE_FLOAT or MODE_INT. However, the caller      must make sure that the MODE of the non-complex operand matches      the SUBMODE of the complex operand.  */
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|rtx
name|real0
init|=
literal|0
decl_stmt|,
name|imag0
init|=
literal|0
decl_stmt|;
name|rtx
name|real1
init|=
literal|0
decl_stmt|,
name|imag1
init|=
literal|0
decl_stmt|;
name|rtx
name|realr
decl_stmt|,
name|imagr
decl_stmt|,
name|res
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|equiv_value
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|/* Find the correct mode for the real and imaginary parts */
name|enum
name|machine_mode
name|submode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|submode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|realr
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|imagr
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
block|{
name|real0
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|imag0
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
name|real0
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode
condition|)
block|{
name|real1
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|imag1
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
name|real1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|real0
operator|==
literal|0
operator|||
name|real1
operator|==
literal|0
operator|||
operator|!
operator|(
name|imag0
operator|!=
literal|0
operator|||
name|imag1
operator|!=
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|binoptab
operator|->
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* (a+ib) + (c+id) = (a+c) + i(b+d) */
case|case
name|MINUS
case|:
comment|/* (a+ib) - (c+id) = (a-c) + i(b-d) */
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag0
operator|&&
name|imag1
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imag0
condition|)
name|res
operator|=
name|imag0
expr_stmt|;
elseif|else
if|if
condition|(
name|binoptab
operator|->
name|code
operator|==
name|MINUS
condition|)
name|res
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|binoptab
operator|==
name|subv_optab
condition|?
name|negv_optab
else|:
name|neg_optab
argument_list|,
name|imag1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|imag1
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* (a+ib) * (c+id) = (ac-bd) + i(ad+cb) */
if|if
condition|(
name|imag0
operator|&&
name|imag1
condition|)
block|{
name|rtx
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
comment|/* Don't fetch these from memory more than once.  */
name|real0
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real0
argument_list|)
expr_stmt|;
name|real1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real1
argument_list|)
expr_stmt|;
name|imag0
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|imag0
argument_list|)
expr_stmt|;
name|imag1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|imag1
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
operator|||
name|temp2
operator|==
literal|0
condition|)
break|break;
name|res
operator|=
operator|(
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
operator|==
name|smulv_optab
condition|?
name|subv_optab
else|:
name|sub_optab
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real1
argument_list|,
name|imag0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
operator|==
literal|0
operator|||
name|temp2
operator|==
literal|0
condition|)
break|break;
name|res
operator|=
operator|(
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
operator|==
name|smulv_optab
condition|?
name|addv_optab
else|:
name|add_optab
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't fetch these from memory more than once.  */
name|real0
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real0
argument_list|)
expr_stmt|;
name|real1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real1
argument_list|)
expr_stmt|;
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag0
operator|!=
literal|0
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real1
argument_list|,
name|imag0
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|DIV
case|:
comment|/* (a+ib) / (c+id) = ((ac+bd)/(cc+dd)) + i((bc-ad)/(cc+dd)) */
if|if
condition|(
name|imag1
operator|==
literal|0
condition|)
block|{
comment|/* (a+ib) / (c+i0) = (a/c) + i(b/c) */
comment|/* Don't fetch these from memory more than once.  */
name|real1
operator|=
name|force_reg
argument_list|(
name|submode
argument_list|,
name|real1
argument_list|)
expr_stmt|;
comment|/* Simply divide the real and imaginary parts by `c' */
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag0
argument_list|,
name|real1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|submode
argument_list|,
name|imag0
argument_list|,
name|real1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|flag_complex_divide_method
condition|)
block|{
case|case
literal|0
case|:
name|ok
operator|=
name|expand_cmplxdiv_straight
argument_list|(
name|real0
argument_list|,
name|real1
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
name|realr
argument_list|,
name|imagr
argument_list|,
name|submode
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|,
name|class
argument_list|,
name|binoptab
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ok
operator|=
name|expand_cmplxdiv_wide
argument_list|(
name|real0
argument_list|,
name|real1
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
name|realr
argument_list|,
name|imagr
argument_list|,
name|submode
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|,
name|class
argument_list|,
name|binoptab
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|equiv_value
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|equiv_value
operator|=
literal|0
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|seq
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* It can't be open-coded in this mode.      Use a library call if one is available and caller says that's ok.  */
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|&&
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|)
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|op1x
init|=
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|op1_mode
init|=
name|mode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|shift_op
condition|)
block|{
name|op1_mode
operator|=
name|word_mode
expr_stmt|;
comment|/* Specify unsigned here, 	     since negative shift counts are meaningless.  */
name|op1x
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|mode
argument_list|,
literal|2
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
name|op1x
argument_list|,
name|op1_mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
operator|!
operator|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_MUST_WIDEN
operator|)
condition|)
block|{
comment|/* Caller says, don't even try.  */
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Compute the value of METHODS to pass to recursive calls.      Don't allow widening to be tried recursively.  */
name|methods
operator|=
operator|(
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|?
name|OPTAB_LIB
else|:
name|OPTAB_DIRECT
operator|)
expr_stmt|;
comment|/* Look for a wider mode of the same class for which it appears we can do      the operation.  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
name|int
name|no_extend
init|=
literal|0
decl_stmt|;
comment|/* For certain integer operations, we need not actually extend 		 the narrow operands, as long as we will truncate 		 the results to the same narrowness.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
condition|)
name|no_extend
operator|=
literal|1
expr_stmt|;
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
argument_list|)
expr_stmt|;
comment|/* The second operand of a shift must always be extended.  */
name|xop1
operator|=
name|widen_operand
argument_list|(
name|xop1
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
operator|&&
name|binoptab
operator|!=
name|ashl_optab
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|binoptab
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a binary operator which has both signed and unsigned forms.    UOPTAB is the optab for unsigned operations, and SOPTAB is for    signed operations.     If we widen unsigned operands, we may use a signed wider operation instead    of an unsigned wider operation, since the result would be the same.  */
end_comment

begin_function
name|rtx
name|sign_expand_binop
parameter_list|(
name|mode
parameter_list|,
name|uoptab
parameter_list|,
name|soptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|uoptab
decl_stmt|,
name|soptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|optab
name|direct_optab
init|=
name|unsignedp
condition|?
name|uoptab
else|:
name|soptab
decl_stmt|;
name|struct
name|optab
name|wide_soptab
decl_stmt|;
comment|/* Do it without widening, if possible.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_DIRECT
condition|)
return|return
name|temp
return|;
comment|/* Try widening to a signed int.  Make a fake signed optab that      hides any signed insn for direct use.  */
name|wide_soptab
operator|=
operator|*
name|soptab
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
comment|/* For unsigned operands, try widening to an unsigned int.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|unsignedp
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_WIDEN
condition|)
return|return
name|temp
return|;
comment|/* Use the right width lib call if that exists.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_LIB
condition|)
return|return
name|temp
return|;
comment|/* Must widen and use a lib call, use either signed or unsigned.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with two results to TARG1 and TARG2.    We assume that the order of the operands for the instruction    is TARG0, OP0, OP1, TARG1, which would fit a pattern like    [(set TARG0 (operate OP0 OP1)) (set TARG1 (operate ...))].     Either TARG0 or TARG1 may be zero, but what that means is that    the result is not actually wanted.  We will generate it into    a dummy pseudo-reg and discard it.  They may not both be zero.     Returns 1 if this operation can be performed; 0 if not.  */
end_comment

begin_function
name|int
name|expand_twoval_binop
parameter_list|(
name|binoptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|targ0
parameter_list|,
name|targ1
parameter_list|,
name|unsignedp
parameter_list|)
name|optab
name|binoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|targ0
decl_stmt|,
name|targ1
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|targ0
condition|?
name|targ0
else|:
name|targ1
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* If we are inside an appropriately-short loop and one operand is an      expensive constant, force it into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|op0
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|op1
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ0
condition|)
name|targ0
operator|=
name|protect_from_queue
argument_list|(
name|targ0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|targ0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ1
condition|)
name|targ1
operator|=
name|protect_from_queue
argument_list|(
name|targ1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|targ1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Record where to go back to if we fail.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
comment|/* In case this insn wants input operands in modes different from the 	 result, convert the operands.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
condition|)
name|xop1
operator|=
name|convert_to_mode
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept these operands, put them into pseudos.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop0
operator|,
name|mode0
operator|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop1
operator|,
name|mode1
operator|)
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
comment|/* We could handle this, but we should always be called with a pseudo 	 for our targets and all insns should take them as outputs.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|targ0
operator|,
name|mode
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|targ1
operator|,
name|mode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|targ0
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|targ1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|t0
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
name|rtx
name|t1
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
name|rtx
name|cop0
init|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|rtx
name|cop1
init|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|binoptab
argument_list|,
name|cop0
argument_list|,
name|cop1
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
condition|)
block|{
name|convert_move
argument_list|(
name|targ0
argument_list|,
name|t0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|targ1
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrapper around expand_unop which takes an rtx code to specify    the operation to perform, not an optab pointer.  All other    arguments are the same.  */
end_comment

begin_function
name|rtx
name|expand_simple_unop
parameter_list|(
name|mode
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|optab
name|unop
init|=
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
decl_stmt|;
if|if
condition|(
name|unop
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|unop
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to perform an operation specified by UNOPTAB    on operand OP0, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_unop
parameter_list|(
name|mode
parameter_list|,
name|unoptab
parameter_list|,
name|op0
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|unoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept our operand, put it into a pseudo.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop0
operator|,
name|mode0
operator|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|temp
operator|,
name|mode
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|unoptab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|unoptab
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we open-code it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
comment|/* For certain operations, we need not actually extend 	       the narrow operand, as long as we will truncate the 	       results to the same narrowness.  */
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
operator|(
name|unoptab
operator|==
name|neg_optab
operator|||
name|unoptab
operator|==
name|one_cmpl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|unoptab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These can be done a word at a time.  */
if|if
condition|(
name|unoptab
operator|==
name|one_cmpl_optab
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|expand_unop
argument_list|(
name|word_mode
argument_list|,
name|unoptab
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Open-code the complex negation operation.  */
elseif|else
if|if
condition|(
name|unoptab
operator|->
name|code
operator|==
name|NEG
operator|&&
operator|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_INT
operator|)
condition|)
block|{
name|rtx
name|target_piece
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* Find the correct mode for the real and imaginary parts */
name|enum
name|machine_mode
name|submode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|submode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|target_piece
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|unoptab
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|target_piece
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|unoptab
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|seq
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Now try a library call in this mode.  */
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
comment|/* For certain operations, we need not actually extend 		 the narrow operand, as long as we will truncate the 		 results to the same narrowness.  */
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
operator|(
name|unoptab
operator|==
name|neg_optab
operator|||
name|unoptab
operator|==
name|one_cmpl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|unoptab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If there is no negate operation, try doing a subtract from zero.      The US Software GOFAST library needs this.  */
if|if
condition|(
name|unoptab
operator|->
name|code
operator|==
name|NEG
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|unoptab
operator|==
name|negv_optab
condition|?
name|subv_optab
else|:
name|sub_optab
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to compute the absolute value of OP0, with result to    TARGET if convenient.  (TARGET may be 0.)  The return value says    where the result actually is to be found.     MODE is the mode of the operand; the mode of the result is    different but can be deduced from MODE.   */
end_comment

begin_function
name|rtx
name|expand_abs
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|target
parameter_list|,
name|result_unsignedp
parameter_list|,
name|safe
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|result_unsignedp
decl_stmt|;
name|int
name|safe
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
operator|!
name|flag_trapv
condition|)
name|result_unsignedp
operator|=
literal|1
expr_stmt|;
comment|/* First try to do it with a special abs instruction.  */
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|result_unsignedp
condition|?
name|abs_optab
else|:
name|absv_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* If we have a MAX insn, we can do this as MAX (x, -x).  */
if|if
condition|(
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smax_optab
argument_list|,
name|op0
argument_list|,
name|temp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine has expensive jumps, we can do integer absolute      value of X as (((signed) x>> (W-1)) ^ x) - ((signed) x>> (W-1)),      where W is the width of MODE.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|BRANCH_COST
operator|>=
literal|2
condition|)
block|{
name|rtx
name|extended
init|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|extended
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|result_unsignedp
condition|?
name|sub_optab
else|:
name|subv_optab
argument_list|,
name|temp
argument_list|,
name|extended
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
block|}
comment|/* If that does not win, use conditional jump and negate.  */
comment|/* It is safe to use the target if it is the same      as the source if this is also a pseudo register */
if|if
condition|(
name|op0
operator|==
name|target
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|safe
operator|=
literal|1
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
comment|/* If this mode is an integer too wide to compare properly,      compare word by word.  Rely on CSE to optimize constant cases.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GE
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|target
argument_list|,
name|const0_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|do_compare_rtx_and_jump
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|result_unsignedp
condition|?
name|neg_optab
else|:
name|negv_optab
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to compute the absolute value of OP0, with result to    TARGET if convenient.  (TARGET may be 0.)  The return value says    where the result actually is to be found.     MODE is the mode of the operand; the mode of the result is    different but can be deduced from MODE.     UNSIGNEDP is relevant for complex integer modes.  */
end_comment

begin_function
name|rtx
name|expand_complex_abs
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|optab
name|this_abs_optab
decl_stmt|;
comment|/* Find the correct mode for the real and imaginary parts.  */
name|enum
name|machine_mode
name|submode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|submode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|this_abs_optab
operator|=
operator|!
name|unsignedp
operator|&&
name|flag_trapv
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|?
name|absv_optab
else|:
name|abs_optab
expr_stmt|;
if|if
condition|(
name|this_abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|this_abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept our operand, put it into a pseudo.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop0
operator|,
name|mode0
operator|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|temp
operator|,
name|submode
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|this_abs_optab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|this_abs_optab
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we open-code it in a wider mode?  */
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|this_abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|xop0
operator|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_complex_abs
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_COMPLEX_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|submode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Open-code the complex absolute-value operation      if we can open-code sqrt.  Otherwise it's not worth while.  */
if|if
condition|(
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|!
name|flag_trapv
condition|)
block|{
name|rtx
name|real
decl_stmt|,
name|imag
decl_stmt|,
name|total
decl_stmt|;
name|real
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|imag
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Square both parts.  */
name|real
operator|=
name|expand_mult
argument_list|(
name|submode
argument_list|,
name|real
argument_list|,
name|real
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imag
operator|=
name|expand_mult
argument_list|(
name|submode
argument_list|,
name|imag
argument_list|,
name|imag
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sum the parts.  */
name|total
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|add_optab
argument_list|,
name|real
argument_list|,
name|imag
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Get sqrt in TARGET.  Set TARGET to where the result is.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|sqrt_optab
argument_list|,
name|total
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
else|else
return|return
name|target
return|;
block|}
comment|/* Now try a library call in this mode.  */
if|if
condition|(
name|this_abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|submode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|this_abs_optab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|this_abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
name|this_abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|xop0
operator|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_complex_abs
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_COMPLEX_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|submode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an instruction whose insn-code is INSN_CODE,    with two operands: an output TARGET and an input OP0.    TARGET *must* be nonzero, and the output is always stored there.    CODE is an rtx code such that (CODE OP0) is an rtx that describes    the value that is stored into TARGET.  */
end_comment

begin_function
name|void
name|emit_unop_insn
parameter_list|(
name|icode
parameter_list|,
name|target
parameter_list|,
name|op0
parameter_list|,
name|code
parameter_list|)
name|int
name|icode
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|temp
operator|=
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sign and zero extension from memory is often done specially on      RISC machines, so forcing into a register here can pessimize      code.  */
if|if
condition|(
name|flag_force_mem
operator|&&
name|code
operator|!=
name|SIGN_EXTEND
operator|&&
name|code
operator|!=
name|ZERO_EXTEND
condition|)
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* Now, if insn does not accept our operands, put them into pseudos.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|temp
operator|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|)
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|code
operator|!=
name|UNKNOWN
condition|)
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|code
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform a series of operations on a multi-word quantity, one    word at a time.     Such a block is preceded by a CLOBBER of the output, consists of multiple    insns, each setting one word of the output, and followed by a SET copying    the output to itself.     Each of the insns setting words of the output receives a REG_NO_CONFLICT    note indicating that it doesn't conflict with the (also multi-word)    inputs.  The entire block is surrounded by REG_LIBCALL and REG_RETVAL    notes.     INSNS is a block of code generated to perform the operation, not including    the CLOBBER and final copy.  All insns that compute intermediate values    are first emitted, followed by the block as described above.       TARGET, OP0, and OP1 are the output and inputs of the operations,    respectively.  OP1 may be zero for a unary operation.     EQUIV, if non-zero, is an expression to be placed into a REG_EQUAL note    on the last insn.     If TARGET is not a register, INSNS is simply emitted with no special    processing.  Likewise if anything in INSNS is not an INSN or if    there is a libcall block inside INSNS.     The final insn emitted is returned.  */
end_comment

begin_function
name|rtx
name|emit_no_conflict_block
parameter_list|(
name|insns
parameter_list|,
name|target
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|equiv
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|equiv
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|reload_in_progress
condition|)
return|return
name|emit_insns
argument_list|(
name|insns
argument_list|)
return|;
else|else
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
name|emit_insns
argument_list|(
name|insns
argument_list|)
return|;
comment|/* First emit all insns that do not store into words of the output and remove      these from the list.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|set
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|insns
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Now write the CLOBBER of the output, followed by the setting of each      of the words, followed by the final copy.  */
if|if
condition|(
name|target
operator|!=
name|op0
operator|&&
name|target
operator|!=
name|op1
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NO_CONFLICT
argument_list|,
name|op1
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NO_CONFLICT
argument_list|,
name|op0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|target
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|last
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|equiv
condition|)
name|set_unique_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Remove any existing REG_EQUAL note from "last", or else it will 	 be mistaken for a note referring to the full contents of the 	 alleged libcall value when found together with the REG_RETVAL 	 note added below.  An existing note can come from an insn 	 expansion at "last".  */
name|remove_note
argument_list|(
name|last
argument_list|,
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* Encapsulate the block so it gets manipulated as a unit.  */
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LIBCALL
argument_list|,
name|last
argument_list|,
name|REG_NOTES
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_RETVAL
argument_list|,
name|first
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to make a call to a constant function or a library call.     INSNS is a list containing all insns emitted in the call.    These insns leave the result in RESULT.  Our block is to copy RESULT    to TARGET, which is logically equivalent to EQUIV.     We first emit any insns that set a pseudo on the assumption that these are    loading constants into registers; doing so allows them to be safely cse'ed    between blocks.  Then we emit all the other insns in the block, followed by    an insn to move RESULT to TARGET.  This last insn will have a REQ_EQUAL    note with an operand of EQUIV.     Moving assignments to pseudos outside of the block is done to improve    the generated code, but is not required to generate correct code,    hence being unable to move an assignment is not grounds for not making    a libcall block.  There are two reasons why it is safe to leave these    insns inside the block: First, we know that these pseudos cannot be    used in generated RTL outside the block since they are created for    temporary purposes within the block.  Second, CSE will not record the    values of anything set inside a libcall block, so we know they must    be dead at the end of the block.     Except for the first group of insns (the ones setting pseudos), the    block is delimited by REG_RETVAL and REG_LIBCALL notes.  */
end_comment

begin_function
name|void
name|emit_libcall_block
parameter_list|(
name|insns
parameter_list|,
name|target
parameter_list|,
name|result
parameter_list|,
name|equiv
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|rtx
name|equiv
decl_stmt|;
block|{
name|rtx
name|final_dest
init|=
name|target
decl_stmt|;
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|insn
decl_stmt|;
comment|/* If this is a reg with REG_USERVAR_P set, then it could possibly turn      into a MEM later.  Protect the libcall block from this change.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|REG_USERVAR_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're using non-call exceptions, a libcall corresponding to an      operation that may trap may also trap.  */
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|equiv
argument_list|)
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|!=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* look for any CALL_INSNs in this sequence, and attach a REG_EH_REGION      reg note to indicate that this call cannot throw or execute a nonlocal      goto (unless there is already a REG_EH_REGION note, in which case      we update it).  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|!=
literal|0
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* First emit all insns that set pseudos.  Remove them from the list as      we go.  Avoid insns that set pseudos which were referenced in previous      insns.  These can be generated by move_by_pieces, for example,      to update an address.  Similarly, avoid insns that reference things      set in previous insns.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|insn
operator|==
name|insns
operator|||
operator|(
operator|(
operator|!
name|INSN_P
argument_list|(
name|insns
argument_list|)
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insns
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|insns
argument_list|,
name|insn
argument_list|)
operator|&&
operator|!
name|modified_in_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|insns
argument_list|)
operator|&&
operator|!
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|insns
argument_list|,
name|insn
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|insns
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Write the remaining insns followed by the final copy.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|target
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|set_unique_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_rtx
argument_list|(
name|equiv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Remove any existing REG_EQUAL note from "last", or else it will 	 be mistaken for a note referring to the full contents of the 	 libcall value when found together with the REG_RETVAL note added 	 below.  An existing note can come from an insn expansion at 	 "last".  */
name|remove_note
argument_list|(
name|last
argument_list|,
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|final_dest
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|final_dest
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* Encapsulate the block so it gets manipulated as a unit.  */
if|if
condition|(
operator|!
name|flag_non_call_exceptions
operator|||
operator|!
name|may_trap_p
argument_list|(
name|equiv
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LIBCALL
argument_list|,
name|last
argument_list|,
name|REG_NOTES
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_RETVAL
argument_list|,
name|first
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to store zero in X.  */
end_comment

begin_function
name|void
name|emit_clr_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to store 1 in X    assuming it contains zero beforehand.  */
end_comment

begin_function
name|void
name|emit_0_to_1_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if we can perform a comparison of mode MODE straightforwardly.    PURPOSE describes how this comparison will be used.  CODE is the rtx    comparison code we will be using.     ??? Actually, CODE is slightly weaker than that.  A target is still    required to implement all of the normal bcc operations, but not     required to implement all (or any) of the unordered bcc operations.  */
end_comment

begin_function
name|int
name|can_compare_p
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|purpose
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|can_compare_purpose
name|purpose
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|purpose
operator|==
name|ccp_jump
condition|)
return|return
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|!=
name|NULL
return|;
elseif|else
if|if
condition|(
name|purpose
operator|==
name|ccp_store_flag
condition|)
return|return
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|!=
name|CODE_FOR_nothing
return|;
else|else
comment|/* There's only one cmov entry point, and it's allowed to fail.  */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|purpose
operator|==
name|ccp_jump
operator|&&
name|cbranch_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|purpose
operator|==
name|ccp_cmov
operator|&&
name|cmov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|purpose
operator|==
name|ccp_store_flag
operator|&&
name|cstore_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function is called when we are going to emit a compare instruction that    compares the values found in *PX and *PY, using the rtl operator COMPARISON.     *PMODE is the mode of the inputs (in case they are const_int).    *PUNSIGNEDP nonzero says that the operands are unsigned;    this matters if they need to be widened.     If they have mode BLKmode, then SIZE specifies the size of both operands.     This function performs all the setup necessary so that the caller only has    to emit a single comparison insn.  This setup can involve doing a BLKmode    comparison or emitting a library call to perform the comparison if no insn    is available to handle it.    The values which are passed in through pointers can be modified; the caller    should perform the comparison on the modified values.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_cmp_insn
parameter_list|(
name|px
parameter_list|,
name|py
parameter_list|,
name|pcomparison
parameter_list|,
name|size
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|,
name|purpose
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|,
decl|*
name|py
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|rtx_code
modifier|*
name|pcomparison
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|punsignedp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|can_compare_purpose
name|purpose
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|enum
name|machine_mode
name|mode
init|=
operator|*
name|pmode
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|,
name|y
init|=
operator|*
name|py
decl_stmt|;
name|int
name|unsignedp
init|=
operator|*
name|punsignedp
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* They could both be VOIDmode if both args are immediate constants,      but we should fold that at an earlier stage.      With no special code here, this will call abort,      reminding the programmer to implement such folding.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|flag_force_mem
condition|)
block|{
name|x
operator|=
name|force_not_mem
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|force_not_mem
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* If we are inside an appropriately-short loop and one operand is an      expensive constant, force it into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|COMPARE
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|y
argument_list|,
name|COMPARE
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|y
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Abort if we have a non-canonical comparison.  The RTL documentation      states that canonical comparisons are required only for targets which      have cc0.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Don't let both operands fail to indicate the mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|VOIDmode
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Handle all BLKmode compares.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|result
decl_stmt|;
name|enum
name|machine_mode
name|result_mode
decl_stmt|;
name|rtx
name|opalign
name|ATTRIBUTE_UNUSED
init|=
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cmpstrqi
if|if
condition|(
name|HAVE_cmpstrqi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|)
condition|)
block|{
name|result_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrqi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrqi
argument_list|(
name|result
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|opalign
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrhi
if|if
condition|(
name|HAVE_cmpstrhi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|)
condition|)
block|{
name|result_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrhi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrhi
argument_list|(
name|result
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|opalign
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
block|{
name|result_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|size
operator|=
name|protect_from_queue
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opalign
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcmp_libfunc
argument_list|,
name|LCT_PURE_MAKE_BLOCK
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcmp_libfunc
argument_list|,
name|LCT_PURE_MAKE_BLOCK
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Immediately move the result of the libcall into a pseudo 	     register so reload doesn't clobber the value if it needs 	     the return register for a spill reg.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|result_mode
operator|=
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|hard_libcall_value
argument_list|(
name|result_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|px
operator|=
name|result
expr_stmt|;
operator|*
name|py
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|pmode
operator|=
name|result_mode
expr_stmt|;
return|return;
block|}
operator|*
name|px
operator|=
name|x
expr_stmt|;
operator|*
name|py
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|can_compare_p
argument_list|(
operator|*
name|pcomparison
argument_list|,
name|mode
argument_list|,
name|purpose
argument_list|)
condition|)
return|return;
comment|/* Handle a lib call just for the mode we are using.  */
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|&&
name|class
operator|!=
name|MODE_FLOAT
condition|)
block|{
name|rtx
name|libfunc
init|=
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* If we want unsigned, and this mode has a distinct unsigned 	 comparison routine, use that.  */
if|if
condition|(
name|unsignedp
operator|&&
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
name|libfunc
operator|=
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
expr_stmt|;
name|emit_library_call
argument_list|(
name|libfunc
argument_list|,
name|LCT_CONST_MAKE_BLOCK
argument_list|,
name|word_mode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Immediately move the result of the libcall into a pseudo 	 register so reload doesn't clobber the value if it needs 	 the return register for a spill reg.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|hard_libcall_value
argument_list|(
name|word_mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Integer comparison returns a result that must be compared against 1, 	 so that even if we do an unsigned compare afterward, 	 there is still a value that can represent the result "less than".  */
operator|*
name|px
operator|=
name|result
expr_stmt|;
operator|*
name|py
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|pmode
operator|=
name|word_mode
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|class
operator|==
name|MODE_FLOAT
condition|)
name|prepare_float_lib_cmp
argument_list|(
name|px
argument_list|,
name|py
argument_list|,
name|pcomparison
argument_list|,
name|pmode
argument_list|,
name|punsignedp
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Before emitting an insn with code ICODE, make sure that X, which is going    to be used for operand OPNUM of the insn, is converted from mode MODE to    WIDER_MODE (UNSIGNEDP determines whether it is an unsigned conversion), and    that it is accepted by the operand predicate.  Return the new value.  */
end_comment

begin_function
name|rtx
name|prepare_operand
parameter_list|(
name|icode
parameter_list|,
name|x
parameter_list|,
name|opnum
parameter_list|,
name|mode
parameter_list|,
name|wider_mode
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|icode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|wider_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|wider_mode
condition|)
name|x
operator|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|mode
operator|)
condition|)
name|x
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of emit_cmp_and_jump_insns; this function is called when we know    we can do the comparison.    The arguments are the same as for emit_cmp_and_jump_insns; but LABEL may    be NULL_RTX which indicates that only a comparison is to be generated.  */
end_comment

begin_function
specifier|static
name|void
name|emit_cmp_and_jump_insn_1
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|mode
parameter_list|,
name|comparison
parameter_list|,
name|unsignedp
parameter_list|,
name|label
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|comparison
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|rtx
name|test
init|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
init|=
name|mode
decl_stmt|;
comment|/* Try combined insns first.  */
do|do
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|PUT_MODE
argument_list|(
name|test
argument_list|,
name|wider_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|icode
operator|=
name|cbranch_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|test
operator|,
name|wider_mode
operator|)
condition|)
block|{
name|x
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|x
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|y
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|y
argument_list|,
literal|2
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|test
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Handle some compares against zero.  */
name|icode
operator|=
operator|(
name|int
operator|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|x
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|comparison
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle compares for which there is a directly suitable insn.  */
name|icode
operator|=
operator|(
name|int
operator|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|x
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|y
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|y
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|comparison
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|class
operator|!=
name|MODE_INT
operator|&&
name|class
operator|!=
name|MODE_FLOAT
operator|&&
name|class
operator|!=
name|MODE_COMPLEX_FLOAT
condition|)
break|break;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wider_mode
operator|!=
name|VOIDmode
condition|)
do|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to compare X with Y so that the condition codes are    set and to jump to LABEL if the condition is true.  If X is a    constant and Y is not a constant, then the comparison is swapped to    ensure that the comparison RTL has the canonical form.     UNSIGNEDP nonzero says that X and Y are unsigned; this matters if they    need to be widened by emit_cmp_insn.  UNSIGNEDP is also used to select    the proper branch condition code.     If X and Y have mode BLKmode, then SIZE specifies the size of both X and Y.     MODE is the mode of the inputs (in case they are const_int).     COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  It will    be passed unchanged to emit_cmp_insn, then potentially converted into an    unsigned variant based on UNSIGNEDP to select a proper jump instruction.  */
end_comment

begin_function
name|void
name|emit_cmp_and_jump_insns
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|comparison
parameter_list|,
name|size
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|label
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|rtx_code
name|comparison
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|x
decl_stmt|,
name|op1
init|=
name|y
decl_stmt|;
comment|/* Swap operands and condition to ensure canonical RTL.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
comment|/* If we're not emitting a branch, this means some caller          is out of sync.  */
if|if
condition|(
operator|!
name|label
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|y
operator|,
name|op1
operator|=
name|x
expr_stmt|;
name|comparison
operator|=
name|swap_condition
argument_list|(
name|comparison
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If OP0 is still a constant, then both X and Y must be constants.  Force      X into a register to avoid aborting in emit_cmp_insn due to non-canonical      RTL.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_queue
argument_list|()
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|comparison
operator|=
name|unsigned_condition
argument_list|(
name|comparison
argument_list|)
expr_stmt|;
name|prepare_cmp_insn
argument_list|(
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
operator|&
name|comparison
argument_list|,
name|size
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
name|ccp_jump
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insn_1
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|comparison
argument_list|,
name|unsignedp
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like emit_cmp_and_jump_insns, but generate only the comparison.  */
end_comment

begin_function
name|void
name|emit_cmp_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|comparison
parameter_list|,
name|size
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|rtx_code
name|comparison
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|comparison
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a library call comparison between floating point X and Y.    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */
end_comment

begin_function
specifier|static
name|void
name|prepare_float_lib_cmp
parameter_list|(
name|px
parameter_list|,
name|py
parameter_list|,
name|pcomparison
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|,
decl|*
name|py
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|rtx_code
modifier|*
name|pcomparison
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|punsignedp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|enum
name|rtx_code
name|comparison
init|=
operator|*
name|pcomparison
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|px
operator|=
name|protect_from_queue
argument_list|(
operator|*
name|px
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
operator|*
name|py
operator|=
name|protect_from_queue
argument_list|(
operator|*
name|py
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|libfunc
init|=
literal|0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|HFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqhf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|nehf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gthf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|gehf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|lthf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|lehf2_libfunc
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|libfunc
operator|=
name|unordhf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqsf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|nesf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gtsf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|gesf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|ltsf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|lesf2_libfunc
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|libfunc
operator|=
name|unordsf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqdf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|nedf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gtdf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|gedf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|ltdf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|ledf2_libfunc
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|libfunc
operator|=
name|unorddf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqxf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|nexf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gtxf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|gexf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|ltxf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|lexf2_libfunc
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|libfunc
operator|=
name|unordxf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqtf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|netf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gttf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|getf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|lttf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|letf2_libfunc
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|libfunc
operator|=
name|unordtf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
else|else
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
operator|!=
literal|0
operator|)
condition|)
block|{
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|py
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prepare_float_lib_cmp
argument_list|(
name|px
argument_list|,
name|py
argument_list|,
name|pcomparison
argument_list|,
name|pmode
argument_list|,
name|punsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|libfunc
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|libfunc
argument_list|,
name|LCT_CONST_MAKE_BLOCK
argument_list|,
name|word_mode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Immediately move the result of the libcall into a pseudo      register so reload doesn't clobber the value if it needs      the return register for a spill reg.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|hard_libcall_value
argument_list|(
name|word_mode
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|result
expr_stmt|;
operator|*
name|py
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|pmode
operator|=
name|word_mode
expr_stmt|;
if|if
condition|(
name|comparison
operator|==
name|UNORDERED
condition|)
operator|*
name|pcomparison
operator|=
name|NE
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_LIB_COMPARE_RETURNS_BOOL
elseif|else
if|if
condition|(
name|FLOAT_LIB_COMPARE_RETURNS_BOOL
argument_list|(
name|mode
argument_list|,
name|comparison
argument_list|)
condition|)
operator|*
name|pcomparison
operator|=
name|NE
expr_stmt|;
endif|#
directive|endif
operator|*
name|punsignedp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Generate code to indirectly jump to a location given in the rtx LOC.  */
end_comment

begin_function
name|void
name|emit_indirect_jump
parameter_list|(
name|loc
parameter_list|)
name|rtx
name|loc
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_indirect_jump
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|loc
operator|,
name|Pmode
operator|)
operator|)
condition|)
name|loc
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_indirect_jump
argument_list|(
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_move
end_ifdef

begin_comment
comment|/* Emit a conditional move instruction if the machine supports one for that    condition and machine mode.     OP0 and OP1 are the operands that should be compared using CODE.  CMODE is    the mode to use should they be constants.  If it is VOIDmode, they cannot    both be constants.     OP2 should be stored in TARGET if the comparison is true, otherwise OP3    should be stored there.  MODE is the mode to use should they be constants.    If it is VOIDmode, they cannot both be constants.     The result is either TARGET (perhaps modified) or NULL_RTX if the operation    is not supported.  */
end_comment

begin_function
name|rtx
name|emit_conditional_move
parameter_list|(
name|target
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|cmode
parameter_list|,
name|op2
parameter_list|,
name|op3
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|cmode
decl_stmt|;
name|rtx
name|op2
decl_stmt|,
name|op3
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|,
name|subtarget
decl_stmt|,
name|comparison
decl_stmt|,
name|insn
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|rtx_code
name|reversed
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* get_condition will prefer to generate LT and GT even if the old      comparison was against zero, so undo that canonicalization here since      comparisons against zero are cheaper.  */
if|if
condition|(
name|code
operator|==
name|LT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|1
condition|)
name|code
operator|=
name|LE
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|code
operator|=
name|GE
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|cmode
operator|==
name|VOIDmode
condition|)
name|cmode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op2
argument_list|,
name|op3
argument_list|)
operator|&&
operator|(
operator|(
name|reversed
operator|=
name|reversed_comparison_code_parts
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|UNKNOWN
operator|)
condition|)
block|{
name|tem
operator|=
name|op2
expr_stmt|;
name|op2
operator|=
name|op3
expr_stmt|;
name|op3
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|reversed
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|icode
operator|=
name|movcc_gen_code
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op2
operator|=
name|force_not_mem
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|op3
operator|=
name|force_not_mem
argument_list|(
name|op3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|target
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|op2
operator|=
name|protect_from_queue
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op3
operator|=
name|protect_from_queue
argument_list|(
name|op3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the insn doesn't accept these operands, put them in pseudos.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|subtarget
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op3
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
operator|)
condition|)
name|op3
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* Everything should now be in the suitable form, so emit the compare insn      and then the conditional move.  */
name|comparison
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|cmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */
comment|/* We can get const0_rtx or const_true_rtx in some circumstances.  Just      return NULL and let the caller figure out how best to deal with this      situation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|!=
name|code
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|subtarget
argument_list|,
name|comparison
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* If that failed, then give up.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtarget
operator|!=
name|target
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if a conditional move of mode MODE is supported.     This function is for combine so it can tell whether an insn that looks    like a conditional move is actually supported by the hardware.  If we    guess wrong we lose a bit on optimization, but that's it.  */
end_comment

begin_comment
comment|/* ??? sparc64 supports conditionally moving integers values based on fp    comparisons, and vice versa.  How do we handle them?  */
end_comment

begin_function
name|int
name|can_conditionally_move_p
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|movcc_gen_code
index|[
name|mode
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_conditional_move */
end_comment

begin_escape
end_escape

begin_comment
comment|/* These functions generate an insn body and return it    rather than emitting the insn.     They do not protect from queued increments,    because they may be used 1) in protect_from_queue itself    and 2) in other passes where there is no queue.  */
end_comment

begin_comment
comment|/* Generate and return an insn body to add Y to X.  */
end_comment

begin_function
name|rtx
name|gen_add2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|y
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to add r1 and c,    storing the result in r0.  */
end_comment

begin_function
name|rtx
name|gen_add3_insn
parameter_list|(
name|r0
parameter_list|,
name|r1
parameter_list|,
name|c
parameter_list|)
name|rtx
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|r0
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|r0
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|r1
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|c
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|have_add2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|icode
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|y
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to subtract Y from X.  */
end_comment

begin_function
name|rtx
name|gen_sub2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|y
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to subtract r1 and c,    storing the result in r0.  */
end_comment

begin_function
name|rtx
name|gen_sub3_insn
parameter_list|(
name|r0
parameter_list|,
name|r1
parameter_list|,
name|c
parameter_list|)
name|rtx
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|r0
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|r0
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|r1
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|c
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|have_sub2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|icode
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|y
operator|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate the body of an instruction to copy Y into X.    It may be a SEQUENCE, if one insn isn't enough.  */
end_comment

begin_function
name|rtx
name|gen_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|insn_code
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|insn_code
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
comment|/* Handle MODE_CC modes:  If we don't have a special move insn for this mode,      find a mode to do it in.  If we have a movcc, use it.  Otherwise,      find the MODE_INT mode of the same width.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|x1
init|=
name|x
decl_stmt|,
name|y1
init|=
name|y
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|CCmode
operator|&&
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|CCmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|tmode
operator|=
name|CCmode
expr_stmt|;
else|else
for|for
control|(
name|tmode
operator|=
name|QImode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get X and Y in TMODE.  We can't use gen_lowpart here because it 	 may call change_address which is not appropriate if we were 	 called when a reload was in progress.  We don't have to worry 	 about changing the address since the size in bytes is supposed to 	 be the same.  Copy the MEM to change the mode and move any 	 substitutions from the old MEM to the new one.  */
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|x
operator|=
name|gen_lowpart_common
argument_list|(
name|tmode
argument_list|,
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|x
operator|=
name|adjust_address_nv
argument_list|(
name|x1
argument_list|,
name|tmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_replacements
argument_list|(
name|x1
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|gen_lowpart_common
argument_list|(
name|tmode
argument_list|,
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|y
operator|=
name|adjust_address_nv
argument_list|(
name|y1
argument_list|,
name|tmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_replacements
argument_list|(
name|y1
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|x
operator|=
name|gen_lowpart
argument_list|(
name|tmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|gen_lowpart
argument_list|(
name|tmode
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|insn_code
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|tmode
index|]
operator|.
name|insn_code
expr_stmt|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the insn code used to extend FROM_MODE to TO_MODE.    UNSIGNEDP specifies zero-extension instead of sign-extension.  If    no such operation exists, CODE_FOR_nothing will be returned.  */
end_comment

begin_function
name|enum
name|insn_code
name|can_extend_p
parameter_list|(
name|to_mode
parameter_list|,
name|from_mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|to_mode
decl_stmt|,
name|from_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_ptr_extend
if|if
condition|(
name|unsignedp
operator|<
literal|0
condition|)
return|return
name|CODE_FOR_ptr_extend
return|;
else|else
endif|#
directive|endif
return|return
name|extendtab
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
index|[
operator|(
name|int
operator|)
name|from_mode
index|]
index|[
name|unsignedp
operator|!=
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* Generate the body of an insn to extend Y (with mode MFROM)    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */
end_comment

begin_function
name|rtx
name|gen_extend_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|mto
parameter_list|,
name|mfrom
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|machine_mode
name|mto
decl_stmt|,
name|mfrom
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
operator|(
name|GEN_FCN
argument_list|(
name|extendtab
index|[
operator|(
name|int
operator|)
name|mto
index|]
index|[
operator|(
name|int
operator|)
name|mfrom
index|]
index|[
name|unsignedp
operator|!=
literal|0
index|]
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* can_fix_p and can_float_p say whether the target machine    can directly convert a given fixed point type to    a given floating point type, or vice versa.    The returned value is the CODE_FOR_... value to use,    or CODE_FOR_nothing if these modes cannot be directly converted.     *TRUNCP_PTR is set to 1 if it is necessary to output    an explicit FTRUNC insn before the fix insn; otherwise 0.  */
end_comment

begin_function
specifier|static
name|enum
name|insn_code
name|can_fix_p
parameter_list|(
name|fixmode
parameter_list|,
name|fltmode
parameter_list|,
name|unsignedp
parameter_list|,
name|truncp_ptr
parameter_list|)
name|enum
name|machine_mode
name|fltmode
decl_stmt|,
name|fixmode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
modifier|*
name|truncp_ptr
decl_stmt|;
block|{
operator|*
name|truncp_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
operator|!=
literal|0
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
operator|!=
literal|0
index|]
return|;
if|if
condition|(
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
operator|*
name|truncp_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|fixtab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
operator|!=
literal|0
index|]
return|;
block|}
return|return
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|insn_code
name|can_float_p
parameter_list|(
name|fltmode
parameter_list|,
name|fixmode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|fixmode
decl_stmt|,
name|fltmode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
name|floattab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
operator|!=
literal|0
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to convert FROM to floating point    and store in TO.  FROM must be fixed point and not VOIDmode.    UNSIGNEDP nonzero means regard FROM as unsigned.    Normally this is done by correcting the final value    if it is negative.  */
end_comment

begin_function
name|void
name|expand_float
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|target
init|=
name|to
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|imode
decl_stmt|;
comment|/* Crash now, because we won't be able to decide which mode to use.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for an insn to do the conversion.  Do it in the specified      modes if possible; otherwise convert either input, output or both to      wider mode.  If the integer mode is wider than the mode of FROM,      we can do the conversion signed even if the input is unsigned.  */
for|for
control|(
name|imode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|imode
operator|!=
name|VOIDmode
condition|;
name|imode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|imode
argument_list|)
control|)
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
block|{
name|int
name|doing_unsigned
init|=
name|unsignedp
decl_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|&&
name|significand_size
argument_list|(
name|fmode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
continue|continue;
name|icode
operator|=
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|imode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|unsignedp
condition|)
name|icode
operator|=
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|imode
argument_list|,
literal|0
argument_list|)
operator|,
name|doing_unsigned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|imode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|from
argument_list|,
name|doing_unsigned
condition|?
name|UNSIGNED_FLOAT
else|:
name|FLOAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
comment|/* Unsigned integer, and no way to convert directly.      Convert as signed, then conditionally adjust the result.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|REAL_VALUE_TYPE
name|offset
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* Look for a usable floating mode FMODE wider than the source and at 	 least as wide as the target.  Using FMODE will avoid rounding woes 	 with unsigned values greater than the signed maximum value.  */
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|fmode
argument_list|)
operator|&&
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
if|if
condition|(
name|fmode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* There is no such mode.  Pretend the target is wide enough.  */
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Avoid double-rounding when TO is narrower than FROM.  */
if|if
condition|(
operator|(
name|significand_size
argument_list|(
name|fmode
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp1
decl_stmt|;
name|rtx
name|neglabel
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Don't use TARGET if it isn't a register, is a hard register,  		 or is the wrong mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|fmode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
name|imode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Test whether the sign bit is set.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|from
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|imode
argument_list|,
literal|0
argument_list|,
name|neglabel
argument_list|)
expr_stmt|;
comment|/* The sign bit is not set.  Convert as signed.  */
name|expand_float
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* The sign bit is set. 		 Convert to a usable (positive signed) value by shifting right 		 one bit, while remembering if a nonzero bit was shifted 		 out; i.e., compute  (from& 1) | (from>> 1).  */
name|emit_label
argument_list|(
name|neglabel
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|and_optab
argument_list|,
name|from
argument_list|,
name|const1_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|from
argument_list|,
name|integer_one_node
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|ior_optab
argument_list|,
name|temp
argument_list|,
name|temp1
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Multiply by 2 to undo the shift above.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|fmode
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* If we are about to do some arithmetic to correct for an 	 unsigned operand, do it in a pseudo-register.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|!=
name|fmode
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|to
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
comment|/* Convert as signed integer to floating.  */
name|expand_float
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If FROM is negative (and therefore TO is negative), 	 correct its value by 2**bitwidth.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|from
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* On SCO 3.2.1, ldexp rejects values outside [0.5, 1). 	 Rather than setting up a dconst_dot_5, let's hope SCO 	 fixes the bug.  */
name|offset
operator|=
name|REAL_VALUE_LDEXP
argument_list|(
name|dconst1
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|fmode
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|offset
argument_list|,
name|fmode
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* No hardware instruction available; call a library routine to convert from      SImode, DImode, or TImode into SFmode, DFmode, XFmode, or TFmode.  */
block|{
name|rtx
name|libfcn
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsisf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatdisf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattisf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsidf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatdidf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattidf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|XFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsixf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatdixf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattixf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsitf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatditf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattitf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libfcn
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* Copy result to requested destination      if we have been computing in a temp location.  */
if|if
condition|(
name|target
operator|!=
name|to
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* expand_fix: generate code to convert FROM to fixed point    and store in TO.  FROM must be floating point.  */
end_comment

begin_function
specifier|static
name|rtx
name|ftruncify
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ftrunc_optab
argument_list|,
name|x
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|expand_fix
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|target
init|=
name|to
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|imode
decl_stmt|;
name|int
name|must_trunc
init|=
literal|0
decl_stmt|;
name|rtx
name|libfcn
init|=
literal|0
decl_stmt|;
comment|/* We first try to find a pair of modes, one real and one integer, at      least as wide as FROM and TO, respectively, in which we can open-code      this conversion.  If the integer mode is wider than the mode of TO,      we can do the conversion either signed or unsigned.  */
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
for|for
control|(
name|imode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|imode
operator|!=
name|VOIDmode
condition|;
name|imode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|imode
argument_list|)
control|)
block|{
name|int
name|doing_unsigned
init|=
name|unsignedp
decl_stmt|;
name|icode
operator|=
name|can_fix_p
argument_list|(
name|imode
argument_list|,
name|fmode
argument_list|,
name|unsignedp
argument_list|,
operator|&
name|must_trunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|&&
name|unsignedp
condition|)
name|icode
operator|=
name|can_fix_p
argument_list|(
name|imode
argument_list|,
name|fmode
argument_list|,
literal|0
argument_list|,
operator|&
name|must_trunc
argument_list|)
operator|,
name|doing_unsigned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|fmode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_trunc
condition|)
name|from
operator|=
name|ftruncify
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|imode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|from
argument_list|,
name|doing_unsigned
condition|?
name|UNSIGNED_FIX
else|:
name|FIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
comment|/* For an unsigned conversion, there is one more way to do it.      If we have a signed conversion, we generate code that compares      the real value to the largest representable positive number.  If if      is smaller, the conversion is done normally.  Otherwise, subtract      one plus the highest signed number, convert, and add it back.       We only need to check all real modes, since we know we didn't find      anything with a wider integer mode.  */
if|if
condition|(
name|unsignedp
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
comment|/* Make sure we won't lose significant bits doing this.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|fmode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|&&
name|CODE_FOR_nothing
operator|!=
name|can_fix_p
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|fmode
argument_list|,
literal|0
argument_list|,
operator|&
name|must_trunc
argument_list|)
condition|)
block|{
name|int
name|bitsize
decl_stmt|;
name|REAL_VALUE_TYPE
name|offset
decl_stmt|;
name|rtx
name|limit
decl_stmt|,
name|lab1
decl_stmt|,
name|lab2
decl_stmt|,
name|insn
decl_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|REAL_VALUE_LDEXP
argument_list|(
name|dconst1
argument_list|,
name|bitsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|limit
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|offset
argument_list|,
name|fmode
argument_list|)
expr_stmt|;
name|lab1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|fmode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if we need to do the subtraction.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|from
argument_list|,
name|limit
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
comment|/* If not, do the signed "fix" and branch around fixup code.  */
name|expand_fix
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Otherwise, subtract 2**(N-1), convert to signed number, 	     then add 2**(N-1).  Do the addition using XOR since this 	     will often generate better code.  */
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|from
argument_list|,
name|limit
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|xor_optab
argument_list|,
name|to
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitsize
operator|-
literal|1
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|to
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|to
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* Make a place for a REG_NOTE and add it.  */
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|UNSIGNED_FIX
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* We can't do it with an insn, so use a library call.  But first ensure      that the mode of TO is at least as wide as SImode, since those are the      only library calls we know about.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunssfsi_libfunc
else|:
name|fixsfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunssfdi_libfunc
else|:
name|fixsfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunssfti_libfunc
else|:
name|fixsfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsdfsi_libfunc
else|:
name|fixdfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsdfdi_libfunc
else|:
name|fixdfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsdfti_libfunc
else|:
name|fixdfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|XFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsxfsi_libfunc
else|:
name|fixxfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsxfdi_libfunc
else|:
name|fixxfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsxfti_libfunc
else|:
name|fixxfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunstfsi_libfunc
else|:
name|fixtfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunstfdi_libfunc
else|:
name|fixtfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunstfti_libfunc
else|:
name|fixtfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|libfcn
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libfcn
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|unsignedp
condition|?
name|UNSIGNED_FIX
else|:
name|FIX
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|!=
name|to
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report whether we have an instruction to perform the operation    specified by CODE on operands of mode MODE.  */
end_comment

begin_function
name|int
name|have_insn_for
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|!=
literal|0
operator|&&
operator|(
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a blank optab.  */
end_comment

begin_function
specifier|static
name|optab
name|new_optab
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|optab
name|op
init|=
operator|(
name|optab
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|optab
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Same, but fill in its code as CODE, and write it into the    code_to_optab table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|optab
name|init_optab
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|optab
name|op
init|=
name|new_optab
argument_list|()
decl_stmt|;
name|op
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|=
name|op
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Same, but fill in its code as CODE, and do _not_ write it into    the code_to_optab table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|optab
name|init_optabv
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|optab
name|op
init|=
name|new_optab
argument_list|()
decl_stmt|;
name|op
operator|->
name|code
operator|=
name|code
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab.  Each entry is set equal to a string consisting of a leading    pair of underscores followed by a generic operation name followed by    a mode name (downshifted to lower case) followed by a single character    representing the number of operands for the given operation (which is    usually one of the characters '2', '3', or '4').     OPTABLE is the table in which libfunc fields are to be initialized.    FIRST_MODE is the first machine mode index in the given optab to      initialize.    LAST_MODE is the last machine mode index in the given optab to      initialize.    OPNAME is the generic (string) name of the operation.    SUFFIX is the character which specifies the number of operands for      the given generic operation. */
end_comment

begin_function
specifier|static
name|void
name|init_libfuncs
parameter_list|(
name|optable
parameter_list|,
name|first_mode
parameter_list|,
name|last_mode
parameter_list|,
name|opname
parameter_list|,
name|suffix
parameter_list|)
name|optab
name|optable
decl_stmt|;
name|int
name|first_mode
decl_stmt|;
name|int
name|last_mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|suffix
decl_stmt|;
block|{
name|int
name|mode
decl_stmt|;
name|unsigned
name|opname_len
init|=
name|strlen
argument_list|(
name|opname
argument_list|)
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|first_mode
init|;
operator|(
name|int
operator|)
name|mode
operator|<=
operator|(
name|int
operator|)
name|last_mode
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
specifier|const
name|char
modifier|*
name|mname
init|=
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|mname_len
init|=
name|strlen
argument_list|(
name|mname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|libfunc_name
init|=
name|alloca
argument_list|(
literal|2
operator|+
name|opname_len
operator|+
name|mname_len
operator|+
literal|1
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|libfunc_name
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|opname
init|;
operator|*
name|q
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|mname
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|TOLOWER
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|suffix
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|optable
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_alloc_string
argument_list|(
name|libfunc_name
argument_list|,
name|p
operator|-
name|libfunc_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab which correspond to all integer mode operations.  The parameters    have the same meaning as similarly named ones for the `init_libfuncs'    routine.  (See above).  */
end_comment

begin_function
specifier|static
name|void
name|init_integral_libfuncs
parameter_list|(
name|optable
parameter_list|,
name|opname
parameter_list|,
name|suffix
parameter_list|)
name|optab
name|optable
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|suffix
decl_stmt|;
block|{
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|SImode
argument_list|,
name|TImode
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab which correspond to all real mode operations.  The parameters    have the same meaning as similarly named ones for the `init_libfuncs'    routine.  (See above).  */
end_comment

begin_function
specifier|static
name|void
name|init_floating_libfuncs
parameter_list|(
name|optable
parameter_list|,
name|opname
parameter_list|,
name|suffix
parameter_list|)
name|optab
name|optable
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|suffix
decl_stmt|;
block|{
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|init_one_libfunc
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Create a FUNCTION_DECL that can be passed to ENCODE_SECTION_INFO.  */
comment|/* ??? We don't have any type information except for this is      a function.  Pretend this is "int foo()".  */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Return the symbol_ref from the mem rtx.  */
return|return
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark ARG (which is really an OPTAB *) for GC.  */
end_comment

begin_function
name|void
name|mark_optab
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|optab
name|o
init|=
operator|*
operator|(
name|optab
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
operator|++
name|i
control|)
name|ggc_mark_rtx
argument_list|(
name|o
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|libfunc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this once to initialize the contents of the optabs    appropriately for the current target machine.  */
end_comment

begin_function
name|void
name|init_optabs
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Start by initializing all tables to contain CODE_FOR_nothing.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|fixtab
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|fixtab
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ARRAY_SIZE
argument_list|(
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|k
operator|++
control|)
name|fixtab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|fixtrunctab
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|fixtrunctab
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ARRAY_SIZE
argument_list|(
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|k
operator|++
control|)
name|fixtrunctab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|floattab
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|floattab
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ARRAY_SIZE
argument_list|(
name|floattab
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|k
operator|++
control|)
name|floattab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|extendtab
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|extendtab
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ARRAY_SIZE
argument_list|(
name|extendtab
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|k
operator|++
control|)
name|extendtab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
name|setcc_gen_code
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_move
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
name|movcc_gen_code
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
endif|#
directive|endif
name|add_optab
operator|=
name|init_optab
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
name|addv_optab
operator|=
name|init_optabv
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
name|sub_optab
operator|=
name|init_optab
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
name|subv_optab
operator|=
name|init_optabv
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
name|smul_optab
operator|=
name|init_optab
argument_list|(
name|MULT
argument_list|)
expr_stmt|;
name|smulv_optab
operator|=
name|init_optabv
argument_list|(
name|MULT
argument_list|)
expr_stmt|;
name|smul_highpart_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|umul_highpart_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|smul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|umul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|sdiv_optab
operator|=
name|init_optab
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|sdivv_optab
operator|=
name|init_optabv
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|sdivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|udiv_optab
operator|=
name|init_optab
argument_list|(
name|UDIV
argument_list|)
expr_stmt|;
name|udivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|smod_optab
operator|=
name|init_optab
argument_list|(
name|MOD
argument_list|)
expr_stmt|;
name|umod_optab
operator|=
name|init_optab
argument_list|(
name|UMOD
argument_list|)
expr_stmt|;
name|ftrunc_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|and_optab
operator|=
name|init_optab
argument_list|(
name|AND
argument_list|)
expr_stmt|;
name|ior_optab
operator|=
name|init_optab
argument_list|(
name|IOR
argument_list|)
expr_stmt|;
name|xor_optab
operator|=
name|init_optab
argument_list|(
name|XOR
argument_list|)
expr_stmt|;
name|ashl_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFT
argument_list|)
expr_stmt|;
name|ashr_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFTRT
argument_list|)
expr_stmt|;
name|lshr_optab
operator|=
name|init_optab
argument_list|(
name|LSHIFTRT
argument_list|)
expr_stmt|;
name|rotl_optab
operator|=
name|init_optab
argument_list|(
name|ROTATE
argument_list|)
expr_stmt|;
name|rotr_optab
operator|=
name|init_optab
argument_list|(
name|ROTATERT
argument_list|)
expr_stmt|;
name|smin_optab
operator|=
name|init_optab
argument_list|(
name|SMIN
argument_list|)
expr_stmt|;
name|smax_optab
operator|=
name|init_optab
argument_list|(
name|SMAX
argument_list|)
expr_stmt|;
name|umin_optab
operator|=
name|init_optab
argument_list|(
name|UMIN
argument_list|)
expr_stmt|;
name|umax_optab
operator|=
name|init_optab
argument_list|(
name|UMAX
argument_list|)
expr_stmt|;
comment|/* These three have codes assigned exclusively for the sake of      have_insn_for.  */
name|mov_optab
operator|=
name|init_optab
argument_list|(
name|SET
argument_list|)
expr_stmt|;
name|movstrict_optab
operator|=
name|init_optab
argument_list|(
name|STRICT_LOW_PART
argument_list|)
expr_stmt|;
name|cmp_optab
operator|=
name|init_optab
argument_list|(
name|COMPARE
argument_list|)
expr_stmt|;
name|ucmp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|tst_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|neg_optab
operator|=
name|init_optab
argument_list|(
name|NEG
argument_list|)
expr_stmt|;
name|negv_optab
operator|=
name|init_optabv
argument_list|(
name|NEG
argument_list|)
expr_stmt|;
name|abs_optab
operator|=
name|init_optab
argument_list|(
name|ABS
argument_list|)
expr_stmt|;
name|absv_optab
operator|=
name|init_optabv
argument_list|(
name|ABS
argument_list|)
expr_stmt|;
name|one_cmpl_optab
operator|=
name|init_optab
argument_list|(
name|NOT
argument_list|)
expr_stmt|;
name|ffs_optab
operator|=
name|init_optab
argument_list|(
name|FFS
argument_list|)
expr_stmt|;
name|sqrt_optab
operator|=
name|init_optab
argument_list|(
name|SQRT
argument_list|)
expr_stmt|;
name|sin_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cos_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|strlen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cbranch_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cmov_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cstore_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|push_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|movstr_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|clrstr_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
name|reload_in_optab
index|[
name|i
index|]
operator|=
name|reload_out_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Fill in the optabs with the insns we support.  */
name|init_all_optabs
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXUNS_TRUNC_LIKE_FIX_TRUNC
comment|/* This flag says the same insns that convert to a signed fixnum      also convert validly to an unsigned one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
name|j
operator|++
control|)
name|fixtrunctab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
name|fixtrunctab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the optabs with the names of the library functions.  */
name|init_integral_libfuncs
argument_list|(
name|add_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|add_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|addv_optab
argument_list|,
literal|"addv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|addv_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sub_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|sub_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|subv_optab
argument_list|,
literal|"subv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|subv_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smul_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smul_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smulv_optab
argument_list|,
literal|"mulv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smulv_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sdiv_optab
argument_list|,
literal|"div"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|sdiv_optab
argument_list|,
literal|"div"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sdivv_optab
argument_list|,
literal|"divv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|udiv_optab
argument_list|,
literal|"udiv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sdivmod_optab
argument_list|,
literal|"divmod"
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|udivmod_optab
argument_list|,
literal|"udivmod"
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smod_optab
argument_list|,
literal|"mod"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|umod_optab
argument_list|,
literal|"umod"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|ftrunc_optab
argument_list|,
literal|"ftrunc"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|and_optab
argument_list|,
literal|"and"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ior_optab
argument_list|,
literal|"ior"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|xor_optab
argument_list|,
literal|"xor"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ashl_optab
argument_list|,
literal|"ashl"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ashr_optab
argument_list|,
literal|"ashr"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|lshr_optab
argument_list|,
literal|"lshr"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smin_optab
argument_list|,
literal|"min"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smin_optab
argument_list|,
literal|"min"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smax_optab
argument_list|,
literal|"max"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smax_optab
argument_list|,
literal|"max"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|umin_optab
argument_list|,
literal|"umin"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|umax_optab
argument_list|,
literal|"umax"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|neg_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|neg_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|negv_optab
argument_list|,
literal|"negv"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|negv_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|one_cmpl_optab
argument_list|,
literal|"one_cmpl"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ffs_optab
argument_list|,
literal|"ffs"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
comment|/* Comparison libcalls for integers MUST come in pairs, signed/unsigned.  */
name|init_integral_libfuncs
argument_list|(
name|cmp_optab
argument_list|,
literal|"cmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ucmp_optab
argument_list|,
literal|"ucmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|cmp_optab
argument_list|,
literal|"cmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULSI3_LIBCALL
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|MULSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MULDI3_LIBCALL
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|MULDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIVSI3_LIBCALL
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|DIVSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIVDI3_LIBCALL
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|DIVDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UDIVSI3_LIBCALL
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|UDIVSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UDIVDI3_LIBCALL
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|UDIVDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MODSI3_LIBCALL
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|MODSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MODDI3_LIBCALL
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|MODDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMODSI3_LIBCALL
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|UMODSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMODDI3_LIBCALL
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|UMODDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Use cabs for DC complex abs, since systems generally have cabs.      Don't define any libcall for SCmode, so that cabs will be used.  */
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DCmode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"cabs"
argument_list|)
expr_stmt|;
comment|/* The ffs function operates on `int'.  */
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode_for_size
argument_list|(
name|INT_TYPE_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"ffs"
argument_list|)
expr_stmt|;
name|extendsfdf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__extendsfdf2"
argument_list|)
expr_stmt|;
name|extendsfxf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__extendsfxf2"
argument_list|)
expr_stmt|;
name|extendsftf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__extendsftf2"
argument_list|)
expr_stmt|;
name|extenddfxf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__extenddfxf2"
argument_list|)
expr_stmt|;
name|extenddftf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__extenddftf2"
argument_list|)
expr_stmt|;
name|truncdfsf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__truncdfsf2"
argument_list|)
expr_stmt|;
name|truncxfsf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__truncxfsf2"
argument_list|)
expr_stmt|;
name|trunctfsf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__trunctfsf2"
argument_list|)
expr_stmt|;
name|truncxfdf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__truncxfdf2"
argument_list|)
expr_stmt|;
name|trunctfdf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__trunctfdf2"
argument_list|)
expr_stmt|;
name|memcpy_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memcpy"
argument_list|)
expr_stmt|;
name|memmove_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memmove"
argument_list|)
expr_stmt|;
name|bcopy_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"bcopy"
argument_list|)
expr_stmt|;
name|memcmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memcmp"
argument_list|)
expr_stmt|;
name|bcmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gcc_bcmp"
argument_list|)
expr_stmt|;
name|memset_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memset"
argument_list|)
expr_stmt|;
name|bzero_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"bzero"
argument_list|)
expr_stmt|;
name|unwind_resume_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"_Unwind_SjLj_Resume"
else|:
literal|"_Unwind_Resume"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DONT_USE_BUILTIN_SETJMP
name|setjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__builtin_setjmp"
argument_list|)
expr_stmt|;
name|longjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__builtin_longjmp"
argument_list|)
expr_stmt|;
else|#
directive|else
name|setjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"setjmp"
argument_list|)
expr_stmt|;
name|longjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"longjmp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unwind_sjlj_register_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"_Unwind_SjLj_Register"
argument_list|)
expr_stmt|;
name|unwind_sjlj_unregister_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"_Unwind_SjLj_Unregister"
argument_list|)
expr_stmt|;
name|eqhf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__eqhf2"
argument_list|)
expr_stmt|;
name|nehf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__nehf2"
argument_list|)
expr_stmt|;
name|gthf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gthf2"
argument_list|)
expr_stmt|;
name|gehf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gehf2"
argument_list|)
expr_stmt|;
name|lthf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__lthf2"
argument_list|)
expr_stmt|;
name|lehf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__lehf2"
argument_list|)
expr_stmt|;
name|unordhf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__unordhf2"
argument_list|)
expr_stmt|;
name|eqsf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__eqsf2"
argument_list|)
expr_stmt|;
name|nesf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__nesf2"
argument_list|)
expr_stmt|;
name|gtsf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gtsf2"
argument_list|)
expr_stmt|;
name|gesf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gesf2"
argument_list|)
expr_stmt|;
name|ltsf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__ltsf2"
argument_list|)
expr_stmt|;
name|lesf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__lesf2"
argument_list|)
expr_stmt|;
name|unordsf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__unordsf2"
argument_list|)
expr_stmt|;
name|eqdf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__eqdf2"
argument_list|)
expr_stmt|;
name|nedf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__nedf2"
argument_list|)
expr_stmt|;
name|gtdf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gtdf2"
argument_list|)
expr_stmt|;
name|gedf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gedf2"
argument_list|)
expr_stmt|;
name|ltdf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__ltdf2"
argument_list|)
expr_stmt|;
name|ledf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__ledf2"
argument_list|)
expr_stmt|;
name|unorddf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__unorddf2"
argument_list|)
expr_stmt|;
name|eqxf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__eqxf2"
argument_list|)
expr_stmt|;
name|nexf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__nexf2"
argument_list|)
expr_stmt|;
name|gtxf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gtxf2"
argument_list|)
expr_stmt|;
name|gexf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gexf2"
argument_list|)
expr_stmt|;
name|ltxf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__ltxf2"
argument_list|)
expr_stmt|;
name|lexf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__lexf2"
argument_list|)
expr_stmt|;
name|unordxf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__unordxf2"
argument_list|)
expr_stmt|;
name|eqtf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__eqtf2"
argument_list|)
expr_stmt|;
name|netf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__netf2"
argument_list|)
expr_stmt|;
name|gttf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gttf2"
argument_list|)
expr_stmt|;
name|getf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__getf2"
argument_list|)
expr_stmt|;
name|lttf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__lttf2"
argument_list|)
expr_stmt|;
name|letf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__letf2"
argument_list|)
expr_stmt|;
name|unordtf2_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__unordtf2"
argument_list|)
expr_stmt|;
name|floatsisf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatsisf"
argument_list|)
expr_stmt|;
name|floatdisf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatdisf"
argument_list|)
expr_stmt|;
name|floattisf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floattisf"
argument_list|)
expr_stmt|;
name|floatsidf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatsidf"
argument_list|)
expr_stmt|;
name|floatdidf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatdidf"
argument_list|)
expr_stmt|;
name|floattidf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floattidf"
argument_list|)
expr_stmt|;
name|floatsixf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatsixf"
argument_list|)
expr_stmt|;
name|floatdixf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatdixf"
argument_list|)
expr_stmt|;
name|floattixf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floattixf"
argument_list|)
expr_stmt|;
name|floatsitf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatsitf"
argument_list|)
expr_stmt|;
name|floatditf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floatditf"
argument_list|)
expr_stmt|;
name|floattitf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__floattitf"
argument_list|)
expr_stmt|;
name|fixsfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixsfsi"
argument_list|)
expr_stmt|;
name|fixsfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixsfdi"
argument_list|)
expr_stmt|;
name|fixsfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixsfti"
argument_list|)
expr_stmt|;
name|fixdfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixdfsi"
argument_list|)
expr_stmt|;
name|fixdfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixdfdi"
argument_list|)
expr_stmt|;
name|fixdfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixdfti"
argument_list|)
expr_stmt|;
name|fixxfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixxfsi"
argument_list|)
expr_stmt|;
name|fixxfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixxfdi"
argument_list|)
expr_stmt|;
name|fixxfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixxfti"
argument_list|)
expr_stmt|;
name|fixtfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixtfsi"
argument_list|)
expr_stmt|;
name|fixtfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixtfdi"
argument_list|)
expr_stmt|;
name|fixtfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixtfti"
argument_list|)
expr_stmt|;
name|fixunssfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunssfsi"
argument_list|)
expr_stmt|;
name|fixunssfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunssfdi"
argument_list|)
expr_stmt|;
name|fixunssfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunssfti"
argument_list|)
expr_stmt|;
name|fixunsdfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunsdfsi"
argument_list|)
expr_stmt|;
name|fixunsdfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunsdfdi"
argument_list|)
expr_stmt|;
name|fixunsdfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunsdfti"
argument_list|)
expr_stmt|;
name|fixunsxfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunsxfsi"
argument_list|)
expr_stmt|;
name|fixunsxfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunsxfdi"
argument_list|)
expr_stmt|;
name|fixunsxfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunsxfti"
argument_list|)
expr_stmt|;
name|fixunstfsi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunstfsi"
argument_list|)
expr_stmt|;
name|fixunstfdi_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunstfdi"
argument_list|)
expr_stmt|;
name|fixunstfti_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__fixunstfti"
argument_list|)
expr_stmt|;
comment|/* For function entry/exit instrumentation.  */
name|profile_function_entry_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__cyg_profile_func_enter"
argument_list|)
expr_stmt|;
name|profile_function_exit_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__cyg_profile_func_exit"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_trap
name|init_traps
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_TARGET_OPTABS
comment|/* Allow the target to add more libcalls or rename some, etc.  */
name|INIT_TARGET_OPTABS
expr_stmt|;
endif|#
directive|endif
comment|/* Add these GC roots.  */
name|ggc_add_root
argument_list|(
name|optab_table
argument_list|,
name|OTI_MAX
argument_list|,
sizeof|sizeof
argument_list|(
name|optab
argument_list|)
argument_list|,
name|mark_optab
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
name|libfunc_table
argument_list|,
name|LTI_MAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_trap
end_ifdef

begin_comment
comment|/* The insn generating function can not take an rtx_code argument.    TRAP_RTX is used as an rtx argument.  Its code is replaced with    the code to be used in the trap insn and all other fields are    ignored.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|trap_rtx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_traps
parameter_list|()
block|{
if|if
condition|(
name|HAVE_conditional_trap
condition|)
block|{
name|trap_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|EQ
argument_list|,
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|trap_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition    CODE.  Return 0 on failure.  */
end_comment

begin_function
name|rtx
name|gen_cond_trap
parameter_list|(
name|code
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|,
name|tcode
parameter_list|)
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op2
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|tcode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_conditional_trap
if|if
condition|(
name|HAVE_conditional_trap
operator|&&
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|trap_rtx
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_conditional_trap
argument_list|(
name|trap_rtx
argument_list|,
name|tcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

