begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions dealing with attribute handling, used by most front ends.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|init_attributes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of the tables of attributes (common, language, format, machine)    searched.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
modifier|*
name|attribute_tables
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|attributes_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default empty table of attributes.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
name|empty_attribute_table
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize attribute tables, and make some sanity checks    if --enable-checking.  */
end_comment

begin_function
specifier|static
name|void
name|init_attributes
parameter_list|()
block|{
name|size_t
name|i
decl_stmt|;
name|attribute_tables
index|[
literal|0
index|]
operator|=
name|lang_hooks
operator|.
name|common_attribute_table
expr_stmt|;
name|attribute_tables
index|[
literal|1
index|]
operator|=
name|lang_hooks
operator|.
name|attribute_table
expr_stmt|;
name|attribute_tables
index|[
literal|2
index|]
operator|=
name|lang_hooks
operator|.
name|format_attribute_table
expr_stmt|;
name|attribute_tables
index|[
literal|3
index|]
operator|=
name|targetm
operator|.
name|attribute_table
expr_stmt|;
comment|/* Translate NULL pointers to pointers to the empty table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|attribute_tables
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|attribute_tables
index|[
name|i
index|]
operator|=
name|empty_attribute_table
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Make some sanity checks on the attribute tables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|attribute_tables
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
comment|/* The name must not begin and end with __.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'_'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The minimum and maximum lengths must be consistent.  */
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|min_length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|max_length
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|max_length
operator|<
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|min_length
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* An attribute cannot require both a DECL and a TYPE.  */
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|decl_required
operator|&&
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|type_required
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an attribute requires a function type, in particular 	     it requires a type.  */
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|function_type_required
operator|&&
operator|!
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|type_required
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Check that each name occurs just once in each table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|attribute_tables
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Check that no name occurs in more than one table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|attribute_tables
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|attribute_tables
argument_list|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|k
operator|++
control|)
for|for
control|(
name|l
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|j
index|]
index|[
name|l
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|attribute_tables
index|[
name|j
index|]
index|[
name|l
index|]
operator|.
name|name
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|attributes_initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the attributes listed in ATTRIBUTES and install them in *NODE,    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,    it should be modified in place; if a TYPE, a copy should be created    unless ATTR_FLAG_TYPE_IN_PLACE is set in FLAGS.  FLAGS gives further    information, in the form of a bitwise OR of flags in enum attribute_flags    from tree.h.  Depending on these flags, some attributes may be    returned to be applied at a later stage (for example, to apply    a decl attribute to the declaration rather than to its type).  If    ATTR_FLAG_BUILT_IN is not set and *NODE is a DECL, then also consider    whether there might be some default attributes to apply to this DECL;    if so, decl_attributes will be called recursively with those attributes    and ATTR_FLAG_BUILT_IN set.  */
end_comment

begin_function
name|tree
name|decl_attributes
parameter_list|(
name|node
parameter_list|,
name|attributes
parameter_list|,
name|flags
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|,
name|attributes
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|a
decl_stmt|;
name|tree
name|returned_attrs
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|attributes_initialized
condition|)
name|init_attributes
argument_list|()
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|insert_attributes
call|)
argument_list|(
operator|*
name|node
argument_list|,
operator|&
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
call|(
modifier|*
name|lang_hooks
operator|.
name|insert_default_attributes
call|)
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|attributes
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|anode
init|=
name|node
decl_stmt|;
specifier|const
name|struct
name|attribute_spec
modifier|*
name|spec
init|=
name|NULL
decl_stmt|;
name|bool
name|no_add_attrs
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|attribute_tables
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|spec
operator|=
operator|&
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|spec
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute directive ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|list_length
argument_list|(
name|args
argument_list|)
operator|<
name|spec
operator|->
name|min_length
operator|||
operator|(
name|spec
operator|->
name|max_length
operator|>=
literal|0
operator|&&
name|list_length
argument_list|(
name|args
argument_list|)
operator|>
name|spec
operator|->
name|max_length
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of arguments specified for `%s' attribute"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|spec
operator|->
name|decl_required
operator|&&
operator|!
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
comment|/* Pass on this attribute to be tried again.  */
name|returned_attrs
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|returned_attrs
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute does not apply to types"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we require a type, but were passed a decl, set up to make a 	 new type and update the one in the decl.  ATTR_FLAG_TYPE_IN_PLACE 	 would have applied if we'd been passed a type, but we cannot modify 	 the decl's type in place here.  */
if|if
condition|(
name|spec
operator|->
name|type_required
operator|&&
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
block|{
name|anode
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
expr_stmt|;
block|}
if|if
condition|(
name|spec
operator|->
name|function_type_required
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|anode
operator|=
name|build_type_copy
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
name|anode
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
condition|)
block|{
comment|/* Pass on this attribute to be tried again.  */
name|returned_attrs
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|returned_attrs
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to function types"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|spec
operator|->
name|handler
operator|!=
name|NULL
condition|)
name|returned_attrs
operator|=
name|chainon
argument_list|(
call|(
modifier|*
name|spec
operator|->
name|handler
call|)
argument_list|(
name|anode
argument_list|,
name|name
argument_list|,
name|args
argument_list|,
name|flags
argument_list|,
operator|&
name|no_add_attrs
argument_list|)
argument_list|,
name|returned_attrs
argument_list|)
expr_stmt|;
comment|/* Layout the decl in case anything changed.  */
if|if
condition|(
name|spec
operator|->
name|type_required
operator|&&
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|RESULT_DECL
operator|)
condition|)
block|{
comment|/* Force a recalculation of mode and size.  */
name|DECL_MODE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|DECL_SIZE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_add_attrs
condition|)
block|{
name|tree
name|old_attrs
decl_stmt|;
name|tree
name|a
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
name|old_attrs
operator|=
name|DECL_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
else|else
name|old_attrs
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|lookup_attribute
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|old_attrs
argument_list|)
init|;
name|a
operator|!=
name|NULL_TREE
condition|;
name|a
operator|=
name|lookup_attribute
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|args
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* This attribute isn't already in the list.  */
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
name|DECL_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|old_attrs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
condition|)
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|old_attrs
argument_list|)
expr_stmt|;
else|else
operator|*
name|anode
operator|=
name|build_type_attribute_variant
argument_list|(
operator|*
name|anode
argument_list|,
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|old_attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|returned_attrs
return|;
block|}
end_function

begin_comment
comment|/* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two    lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).     The head of the declspec list is stored in DECLSPECS.    The head of the attribute list is stored in PREFIX_ATTRIBUTES.     Note that attributes in SPECS_ATTRS are stored in the TREE_PURPOSE of    the list elements.  We drop the containing TREE_LIST nodes and link the    resulting attributes together the way decl_attributes expects them.  */
end_comment

begin_function
name|void
name|split_specs_attrs
parameter_list|(
name|specs_attrs
parameter_list|,
name|declspecs
parameter_list|,
name|prefix_attributes
parameter_list|)
name|tree
name|specs_attrs
decl_stmt|;
name|tree
modifier|*
name|declspecs
decl_stmt|,
decl|*
name|prefix_attributes
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|t
decl_stmt|,
name|s
decl_stmt|,
name|a
decl_stmt|,
name|next
decl_stmt|,
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
comment|/* This can happen after an __extension__ in pedantic mode.  */
if|if
condition|(
name|specs_attrs
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|specs_attrs
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
operator|*
name|declspecs
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
comment|/* This can happen in c++ (eg: decl: typespec initdecls ';').  */
if|if
condition|(
name|specs_attrs
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|specs_attrs
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
operator|*
name|declspecs
operator|=
name|specs_attrs
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
comment|/* Remember to keep the lists in the same order, element-wise.  */
name|specs
operator|=
name|s
operator|=
name|NULL_TREE
expr_stmt|;
name|attrs
operator|=
name|a
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|specs_attrs
init|;
name|t
condition|;
name|t
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Declspecs have a non-NULL TREE_VALUE.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|specs
operator|==
name|NULL_TREE
condition|)
name|specs
operator|=
name|s
operator|=
name|t
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|t
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|/* The TREE_PURPOSE may also be empty in the case of 	 __attribute__(()).  */
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|attrs
operator|==
name|NULL_TREE
condition|)
name|attrs
operator|=
name|a
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|a
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* More attrs can be linked here, move A to the end.  */
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Terminate the lists.  */
if|if
condition|(
name|s
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* All done.  */
operator|*
name|declspecs
operator|=
name|specs
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|attrs
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Strip attributes from SPECS_ATTRS, a list of declspecs and attributes.    This function is used by the parser when a rule will accept attributes    in a particular position, but we don't want to support that just yet.     A warning is issued for every ignored attribute.  */
end_comment

begin_function
name|tree
name|strip_attrs
parameter_list|(
name|specs_attrs
parameter_list|)
name|tree
name|specs_attrs
decl_stmt|;
block|{
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|specs_attrs
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|attrs
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|attrs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|TREE_CHAIN
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
return|return
name|specs
return|;
block|}
end_function

end_unit

