begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions dealing with attribute handling, used by most front ends.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|init_attributes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of the tables of attributes (common, format, language, machine)    searched.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
modifier|*
name|attribute_tables
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|attributes_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_packed_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_nocommon_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_common_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_noreturn_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_noinline_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_used_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_unused_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_const_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_transparent_union_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_constructor_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_destructor_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_mode_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_section_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_aligned_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_weak_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_alias_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_no_instrument_function_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_malloc_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_no_limit_stack_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_pure_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_deprecated_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_vector_size_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vector_size_helper
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of machine-independent attributes common to all C-like languages.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
name|c_common_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"packed"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_packed_attribute
block|}
block|,
block|{
literal|"nocommon"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_nocommon_attribute
block|}
block|,
block|{
literal|"common"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_common_attribute
block|}
block|,
comment|/* FIXME: logically, noreturn attributes should be listed as      "false, true, true" and apply to function types.  But implementing this      would require all the places in the compiler that use TREE_THIS_VOLATILE      on a decl to identify non-returning functions to be located and fixed      to check the function type instead.  */
block|{
literal|"noreturn"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noreturn_attribute
block|}
block|,
block|{
literal|"volatile"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noreturn_attribute
block|}
block|,
block|{
literal|"noinline"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noinline_attribute
block|}
block|,
block|{
literal|"used"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_used_attribute
block|}
block|,
block|{
literal|"unused"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_unused_attribute
block|}
block|,
comment|/* The same comments as for noreturn attributes apply to const ones.  */
block|{
literal|"const"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_const_attribute
block|}
block|,
block|{
literal|"transparent_union"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_transparent_union_attribute
block|}
block|,
block|{
literal|"constructor"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_constructor_attribute
block|}
block|,
block|{
literal|"destructor"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_destructor_attribute
block|}
block|,
block|{
literal|"mode"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|handle_mode_attribute
block|}
block|,
block|{
literal|"section"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_section_attribute
block|}
block|,
block|{
literal|"aligned"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_aligned_attribute
block|}
block|,
block|{
literal|"weak"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_weak_attribute
block|}
block|,
block|{
literal|"alias"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_alias_attribute
block|}
block|,
block|{
literal|"no_instrument_function"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_no_instrument_function_attribute
block|}
block|,
block|{
literal|"malloc"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_malloc_attribute
block|}
block|,
block|{
literal|"no_stack_limit"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_no_limit_stack_attribute
block|}
block|,
block|{
literal|"pure"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_pure_attribute
block|}
block|,
block|{
literal|"deprecated"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_deprecated_attribute
block|}
block|,
block|{
literal|"vector_size"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|handle_vector_size_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default empty table of attributes.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
name|empty_attribute_table
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of machine-independent attributes for checking formats, if used.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
modifier|*
name|format_attribute_table
init|=
name|empty_attribute_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of machine-independent attributes for a particular language.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
modifier|*
name|lang_attribute_table
init|=
name|empty_attribute_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying whether common language attributes are to be supported.  */
end_comment

begin_decl_stmt
name|int
name|lang_attribute_common
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize attribute tables, and make some sanity checks    if --enable-checking.  */
end_comment

begin_function
specifier|static
name|void
name|init_attributes
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|attribute_tables
index|[
literal|0
index|]
operator|=
name|lang_attribute_common
condition|?
name|c_common_attribute_table
else|:
name|empty_attribute_table
expr_stmt|;
name|attribute_tables
index|[
literal|1
index|]
operator|=
name|lang_attribute_table
expr_stmt|;
name|attribute_tables
index|[
literal|2
index|]
operator|=
name|format_attribute_table
expr_stmt|;
name|attribute_tables
index|[
literal|3
index|]
operator|=
name|targetm
operator|.
name|attribute_table
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Make some sanity checks on the attribute tables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|attribute_tables
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|attribute_tables
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
comment|/* The name must not begin and end with __.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'_'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The minimum and maximum lengths must be consistent.  */
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|min_length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|max_length
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|max_length
operator|<
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|min_length
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* An attribute cannot require both a DECL and a TYPE.  */
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|decl_required
operator|&&
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|type_required
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an attribute requires a function type, in particular 	     it requires a type.  */
if|if
condition|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|function_type_required
operator|&&
operator|!
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|type_required
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Check that each name occurs just once in each table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|attribute_tables
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|attribute_tables
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Check that no name occurs in more than one table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|attribute_tables
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|attribute_tables
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
operator|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|attribute_tables
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|attribute_tables
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|k
operator|++
control|)
for|for
control|(
name|l
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|j
index|]
index|[
name|l
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|attribute_tables
index|[
name|j
index|]
index|[
name|l
index|]
operator|.
name|name
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|attributes_initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the attributes listed in ATTRIBUTES and install them in *NODE,    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,    it should be modified in place; if a TYPE, a copy should be created    unless ATTR_FLAG_TYPE_IN_PLACE is set in FLAGS.  FLAGS gives further    information, in the form of a bitwise OR of flags in enum attribute_flags    from tree.h.  Depending on these flags, some attributes may be    returned to be applied at a later stage (for example, to apply    a decl attribute to the declaration rather than to its type).  If    ATTR_FLAG_BUILT_IN is not set and *NODE is a DECL, then also consider    whether there might be some default attributes to apply to this DECL;    if so, decl_attributes will be called recursively with those attributes    and ATTR_FLAG_BUILT_IN set.  */
end_comment

begin_function
name|tree
name|decl_attributes
parameter_list|(
name|node
parameter_list|,
name|attributes
parameter_list|,
name|flags
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|,
name|attributes
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|a
decl_stmt|;
name|tree
name|returned_attrs
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|attributes_initialized
condition|)
name|init_attributes
argument_list|()
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|insert_attributes
call|)
argument_list|(
operator|*
name|node
argument_list|,
operator|&
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|insert_default_attributes
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|attributes
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|anode
init|=
name|node
decl_stmt|;
specifier|const
name|struct
name|attribute_spec
modifier|*
name|spec
init|=
name|NULL
decl_stmt|;
name|bool
name|no_add_attrs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|attribute_tables
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|attribute_tables
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|spec
operator|=
operator|&
name|attribute_tables
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|spec
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute directive ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|list_length
argument_list|(
name|args
argument_list|)
operator|<
name|spec
operator|->
name|min_length
operator|||
operator|(
name|spec
operator|->
name|max_length
operator|>=
literal|0
operator|&&
name|list_length
argument_list|(
name|args
argument_list|)
operator|>
name|spec
operator|->
name|max_length
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of arguments specified for `%s' attribute"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|spec
operator|->
name|decl_required
operator|&&
operator|!
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
comment|/* Pass on this attribute to be tried again.  */
name|returned_attrs
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|returned_attrs
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute does not apply to types"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we require a type, but were passed a decl, set up to make a 	 new type and update the one in the decl.  ATTR_FLAG_TYPE_IN_PLACE 	 would have applied if we'd been passed a type, but we cannot modify 	 the decl's type in place here.  */
if|if
condition|(
name|spec
operator|->
name|type_required
operator|&&
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
block|{
name|anode
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
expr_stmt|;
block|}
if|if
condition|(
name|spec
operator|->
name|function_type_required
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|anode
operator|=
name|build_type_copy
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
name|anode
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
condition|)
block|{
comment|/* Pass on this attribute to be tried again.  */
name|returned_attrs
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|returned_attrs
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|anode
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to function types"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|spec
operator|->
name|handler
operator|!=
name|NULL
condition|)
name|returned_attrs
operator|=
name|chainon
argument_list|(
call|(
modifier|*
name|spec
operator|->
name|handler
call|)
argument_list|(
name|anode
argument_list|,
name|name
argument_list|,
name|args
argument_list|,
name|flags
argument_list|,
operator|&
name|no_add_attrs
argument_list|)
argument_list|,
name|returned_attrs
argument_list|)
expr_stmt|;
comment|/* Layout the decl in case anything changed.  */
if|if
condition|(
name|spec
operator|->
name|type_required
operator|&&
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Force a recalculation of mode and size.  */
name|DECL_MODE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|DECL_SIZE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_add_attrs
condition|)
block|{
name|tree
name|old_attrs
decl_stmt|;
name|tree
name|a
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
name|old_attrs
operator|=
name|DECL_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
else|else
name|old_attrs
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|lookup_attribute
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|old_attrs
argument_list|)
init|;
name|a
operator|!=
name|NULL_TREE
condition|;
name|a
operator|=
name|lookup_attribute
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|args
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* This attribute isn't already in the list.  */
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|anode
argument_list|)
condition|)
name|DECL_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|old_attrs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
condition|)
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|anode
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|old_attrs
argument_list|)
expr_stmt|;
else|else
operator|*
name|anode
operator|=
name|build_type_attribute_variant
argument_list|(
operator|*
name|anode
argument_list|,
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|old_attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|returned_attrs
return|;
block|}
end_function

begin_comment
comment|/* Handle a "packed" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_packed_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_PACKED
argument_list|(
operator|*
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|DECL_PACKED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can't set DECL_PACKED for a VAR_DECL, because the bit is      used for DECL_REGISTER.  It wouldn't mean anything anyway.  */
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "nocommon" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_nocommon_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "common" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_common_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "noreturn" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_noreturn_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
comment|/* See FIXME comment in c_common_attribute_table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "noinline" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_noinline_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_UNINLINABLE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "used" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_used_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|=
name|TREE_USED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "unused" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_unused_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "const" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_const_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
comment|/* See FIXME comment on noreturn in c_common_attribute_table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_READONLY
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "transparent_union" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_transparent_union_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|int
name|is_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|decl
operator|=
operator|*
name|node
expr_stmt|;
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
name|type
operator|=
name|node
operator|,
name|is_type
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_type
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|decl
operator|==
literal|0
operator|||
operator|(
name|TYPE_FIELDS
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_TRANSPARENT_UNION
argument_list|(
operator|*
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
condition|)
name|DECL_TRANSPARENT_UNION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "constructor" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_constructor_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "destructor" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_destructor_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "mode" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_mode_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|typefm
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|newp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|-
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newp
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|newp
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|newp
expr_stmt|;
block|}
comment|/* Change this type to have a type with the specified mode. 	 First check for the special modes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"byte"
argument_list|)
condition|)
name|mode
operator|=
name|byte_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"word"
argument_list|)
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pointer"
argument_list|)
condition|)
name|mode
operator|=
name|ptr_mode
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
name|j
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|error
argument_list|(
literal|"unknown machine mode `%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
operator|(
name|typefm
operator|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"no data type for mode `%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
operator|*
name|node
operator|=
name|typefm
expr_stmt|;
comment|/* No need to layout the type here.  The caller should do this.  */
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "section" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_section_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section attribute cannot be specified for local variables"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* The decl may have already been given a section attribute 	     from a previous declaration.  Ensure they match.  */
elseif|else
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|"section of `%s' conflicts with previous declaration"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_with_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|"section attribute not allowed for `%s'"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|error_with_decl
argument_list|(
operator|*
name|node
argument_list|,
literal|"section attributes are not supported for this target"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "aligned" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_aligned_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|int
name|is_type
init|=
literal|0
decl_stmt|;
name|tree
name|align_expr
init|=
operator|(
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
name|size_int
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|decl
operator|=
operator|*
name|node
expr_stmt|;
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
name|type
operator|=
name|node
operator|,
name|is_type
operator|=
literal|1
expr_stmt|;
comment|/* Strip any NOPs of any kind.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|align_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|align_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is not a constant"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|tree_log2
argument_list|(
name|align_expr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is not a power of 2"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|HOST_BITS_PER_INT
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is too large"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_type
condition|)
block|{
comment|/* If we have a TYPE_DECL, then copy the type, so that we 	 don't accidentally modify a builtin type.  See pushdecl.  */
if|if
condition|(
name|decl
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|tt
expr_stmt|;
name|TYPE_NAME
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_USED
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
operator|*
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|type
operator|=
name|build_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
operator|*
name|type
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
operator|*
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment may not be specified for `%s'"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "weak" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_weak_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|declare_weak
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "alias" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_alias_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' defined both normally and as an alias"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"alias arg not a string"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|id
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This counts as a use of the object pointed to.  */
name|TREE_USED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "no_instrument_function" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_no_instrument_function_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' attribute applies only to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"can't set `%s' attribute after definition"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "malloc" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_malloc_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_IS_MALLOC
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? TODO: Support types.  */
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "no_limit_stack" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_no_limit_stack_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' attribute applies only to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"can't set `%s' attribute after definition"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_NO_LIMIT_STACK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "pure" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_pure_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_IS_PURE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? TODO: Support types.  */
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "deprecated" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_deprecated_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|warn
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|warn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_DEPRECATED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
operator|*
name|node
expr_stmt|;
block|}
else|else
name|warn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
literal|"`%s' attribute ignored for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "vector_size" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_vector_size_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|vecsize
decl_stmt|,
name|nunits
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|orig_mode
decl_stmt|,
name|new_mode
decl_stmt|;
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|,
name|new_type
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Get the vector size (in bytes).  */
name|vecsize
operator|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We need to provide for vector pointers, vector arrays, and      functions returning vectors.  For example:         __attribute__((vector_size(16))) short *foo;       In this case, the mode is SI, but the type being modified is      HI, so we need to look further.  */
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Get the mode of the type being modified.  */
name|orig_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|orig_mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|orig_mode
argument_list|)
operator|!=
name|MODE_INT
operator|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid vector type for attribute `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Calculate how many units fit in the vector.  */
name|nunits
operator|=
name|vecsize
operator|/
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Find a suitably sized vector.  */
name|new_mode
operator|=
name|VOIDmode
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|orig_mode
argument_list|)
operator|==
name|MODE_INT
condition|?
name|MODE_VECTOR_INT
else|:
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|vecsize
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|nunits
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|new_mode
operator|=
name|mode
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new_mode
operator|==
name|VOIDmode
condition|)
name|error
argument_list|(
literal|"no vector mode with the size and type specified could be found"
argument_list|)
expr_stmt|;
else|else
block|{
name|new_type
operator|=
name|type_for_mode
argument_list|(
name|new_mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_type
condition|)
name|error
argument_list|(
literal|"no vector mode with the size and type specified could be found"
argument_list|)
expr_stmt|;
else|else
comment|/* Build back pointers if needed.  */
operator|*
name|node
operator|=
name|vector_size_helper
argument_list|(
operator|*
name|node
argument_list|,
name|new_type
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* HACK.  GROSS.  This is absolutely disgusting.  I wish there was a    better way.     If we requested a pointer to a vector, build up the pointers that    we stripped off while looking for the inner type.  Similarly for    return values from functions.     The argument "type" is the top of the chain, and "bottom" is the    new type which we will point to.  */
end_comment

begin_function
specifier|static
name|tree
name|vector_size_helper
parameter_list|(
name|type
parameter_list|,
name|bottom
parameter_list|)
name|tree
name|type
decl_stmt|,
name|bottom
decl_stmt|;
block|{
name|tree
name|inner
decl_stmt|,
name|outer
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|inner
operator|=
name|vector_size_helper
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_pointer_type
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|inner
operator|=
name|vector_size_helper
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_array_type
argument_list|(
name|inner
argument_list|,
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|inner
operator|=
name|vector_size_helper
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_function_type
argument_list|(
name|inner
argument_list|,
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|bottom
return|;
name|TREE_READONLY
argument_list|(
name|outer
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|outer
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|outer
return|;
block|}
end_function

begin_comment
comment|/* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two    lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).     The head of the declspec list is stored in DECLSPECS.    The head of the attribute list is stored in PREFIX_ATTRIBUTES.     Note that attributes in SPECS_ATTRS are stored in the TREE_PURPOSE of    the list elements.  We drop the containing TREE_LIST nodes and link the    resulting attributes together the way decl_attributes expects them.  */
end_comment

begin_function
name|void
name|split_specs_attrs
parameter_list|(
name|specs_attrs
parameter_list|,
name|declspecs
parameter_list|,
name|prefix_attributes
parameter_list|)
name|tree
name|specs_attrs
decl_stmt|;
name|tree
modifier|*
name|declspecs
decl_stmt|,
decl|*
name|prefix_attributes
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|t
decl_stmt|,
name|s
decl_stmt|,
name|a
decl_stmt|,
name|next
decl_stmt|,
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
comment|/* This can happen after an __extension__ in pedantic mode.  */
if|if
condition|(
name|specs_attrs
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|specs_attrs
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
operator|*
name|declspecs
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
comment|/* This can happen in c++ (eg: decl: typespec initdecls ';').  */
if|if
condition|(
name|specs_attrs
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|specs_attrs
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
operator|*
name|declspecs
operator|=
name|specs_attrs
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
comment|/* Remember to keep the lists in the same order, element-wise.  */
name|specs
operator|=
name|s
operator|=
name|NULL_TREE
expr_stmt|;
name|attrs
operator|=
name|a
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|specs_attrs
init|;
name|t
condition|;
name|t
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Declspecs have a non-NULL TREE_VALUE.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|specs
operator|==
name|NULL_TREE
condition|)
name|specs
operator|=
name|s
operator|=
name|t
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|t
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|/* The TREE_PURPOSE may also be empty in the case of 	 __attribute__(()).  */
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|attrs
operator|==
name|NULL_TREE
condition|)
name|attrs
operator|=
name|a
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|a
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* More attrs can be linked here, move A to the end.  */
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Terminate the lists.  */
if|if
condition|(
name|s
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* All done.  */
operator|*
name|declspecs
operator|=
name|specs
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|attrs
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Strip attributes from SPECS_ATTRS, a list of declspecs and attributes.    This function is used by the parser when a rule will accept attributes    in a particular position, but we don't want to support that just yet.     A warning is issued for every ignored attribute.  */
end_comment

begin_function
name|tree
name|strip_attrs
parameter_list|(
name|specs_attrs
parameter_list|)
name|tree
name|specs_attrs
decl_stmt|;
block|{
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|specs_attrs
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|attrs
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|attrs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|TREE_CHAIN
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
return|return
name|specs
return|;
block|}
end_function

end_unit

