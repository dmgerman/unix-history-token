begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Procedure integration for GNU CC.    Copyright (C) 1988, 91, 93-98, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but round to the next highest integer that meets the    alignment.  */
end_comment

begin_define
define|#
directive|define
name|CEIL_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|(((VALUE) + (ALIGN) - 1)& ~((ALIGN)- 1))
end_define

begin_comment
comment|/* Default max number of insns a function can have and still be inline.    This is overridden on RISC machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATE_THRESHOLD
end_ifndef

begin_comment
comment|/* Inlining small functions might save more space then not inlining at    all.  Assume 1 instruction for the call and 1.5 insns per argument.  */
end_comment

begin_define
define|#
directive|define
name|INTEGRATE_THRESHOLD
parameter_list|(
name|DECL
parameter_list|)
define|\
value|(optimize_size \    ? (1 + (3 * list_length (DECL_ARGUMENTS (DECL))) / 2) \    : (8 * (8 + list_length (DECL_ARGUMENTS (DECL)))))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|rtx
name|initialize_for_inline
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_inline
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_copied_decl_tree
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_decl_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_decl_tree
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_decl_rtls
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_constants
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_modified_parmregs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|copy_for_inline
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|integrate_parm_decls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|inline_remap
operator|*
operator|,
name|rtvec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|integrate_decl_tree
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
expr|struct
name|inline_remap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_constants_in_decl_trees
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_constants
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
expr|struct
name|inline_remap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_constants
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_block_origin_self
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_decl_origin_self
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_block_abstract_flags
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_reg_param
name|PROTO
argument_list|(
operator|(
expr|struct
name|inline_remap
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_decl_abstract_flags
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_and_set_decl_abstract_origin
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of instructions accepted for inlining a    function.  Increasing values mean more agressive inlining.    This affects currently only functions explicitly marked as    inline (or methods defined within the class definition for C++).    The default value of 10000 is arbitrary but high to match the    previously unlimited gcc capabilities.  */
end_comment

begin_decl_stmt
name|int
name|inline_max_insns
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns the Ith entry in the label_map contained in MAP.  If the    Ith entry has not yet been set, return a fresh label.  This function    performs a lazy initialization of label_map, thereby avoiding huge memory    explosions when the label_map gets very large.  */
end_comment

begin_function
name|rtx
name|get_label_from_map
parameter_list|(
name|map
parameter_list|,
name|i
parameter_list|)
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|map
operator|->
name|label_map
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
name|x
operator|=
name|map
operator|->
name|label_map
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Zero if the current function (whose FUNCTION_DECL is FNDECL)    is safe and reasonable to integrate into other functions.    Nonzero means value is a warning msgid with a single %s    for the function's name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|function_cannot_inline_p
parameter_list|(
name|fndecl
parameter_list|)
specifier|register
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For functions marked as inline increase the maximum size to      inline_max_insns (-finline-limit-<n>).  For regular functions      use the limit given by INTEGRATE_THRESHOLD.  */
name|int
name|max_insns
init|=
operator|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|?
operator|(
name|inline_max_insns
operator|+
literal|8
operator|*
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
else|:
name|INTEGRATE_THRESHOLD
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ninsns
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|parms
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* No inlines with varargs.  */
if|if
condition|(
operator|(
name|last
operator|&&
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|||
name|current_function_varargs
condition|)
return|return
name|N_
argument_list|(
literal|"varargs function cannot be inline"
argument_list|)
return|;
if|if
condition|(
name|current_function_calls_alloca
condition|)
return|return
name|N_
argument_list|(
literal|"function using alloca cannot be inline"
argument_list|)
return|;
if|if
condition|(
name|current_function_contains_functions
condition|)
return|return
name|N_
argument_list|(
literal|"function with nested functions cannot be inline"
argument_list|)
return|;
if|if
condition|(
name|current_function_cannot_inline
condition|)
return|return
name|current_function_cannot_inline
return|;
comment|/* If its not even close, don't even look.  */
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
literal|3
operator|*
name|max_insns
condition|)
return|return
name|N_
argument_list|(
literal|"function too large to be inline"
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* Don't inline functions which do not specify a function prototype and      have BLKmode argument or take the address of a parameter.  */
block|for (parms = DECL_ARGUMENTS (fndecl); parms; parms = TREE_CHAIN (parms))     {       if (TYPE_MODE (TREE_TYPE (parms)) == BLKmode) 	TREE_ADDRESSABLE (parms) = 1;       if (last == NULL_TREE&& TREE_ADDRESSABLE (parms)) 	return N_("no prototype, and parameter address used; cannot be inline");     }
endif|#
directive|endif
comment|/* We can't inline functions that return structures      the old-fashioned PCC way, copying into a static block.  */
if|if
condition|(
name|current_function_returns_pcc_struct
condition|)
return|return
name|N_
argument_list|(
literal|"inline functions not supported for this return value type"
argument_list|)
return|;
comment|/* We can't inline functions that return structures of varying size.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|N_
argument_list|(
literal|"function with varying-size return value cannot be inline"
argument_list|)
return|;
comment|/* Cannot inline a function with a varying size argument or one that      receives a transparent union.  */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|N_
argument_list|(
literal|"function with varying-size parameter cannot be inline"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
return|return
name|N_
argument_list|(
literal|"function with transparent unit parameter cannot be inline"
argument_list|)
return|;
block|}
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
name|max_insns
condition|)
block|{
for|for
control|(
name|ninsns
operator|=
literal|0
operator|,
name|insn
operator|=
name|get_first_nonparm_insn
argument_list|()
init|;
name|insn
operator|&&
name|ninsns
operator|<
name|max_insns
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|ninsns
operator|++
expr_stmt|;
if|if
condition|(
name|ninsns
operator|>=
name|max_insns
condition|)
return|return
name|N_
argument_list|(
literal|"function too large to be inline"
argument_list|)
return|;
block|}
comment|/* We will not inline a function which uses computed goto.  The addresses of      its local labels, which may be tucked into global storage, are of course      not constant across instantiations, which causes unexpected behaviour.  */
if|if
condition|(
name|current_function_has_computed_jump
condition|)
return|return
name|N_
argument_list|(
literal|"function with computed jump cannot inline"
argument_list|)
return|;
comment|/* We cannot inline a nested function that jumps to a nonlocal label.  */
if|if
condition|(
name|current_function_has_nonlocal_goto
condition|)
return|return
name|N_
argument_list|(
literal|"function with nonlocal goto cannot be inline"
argument_list|)
return|;
comment|/* This is a hack, until the inliner is taught about eh regions at      the start of the function.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
operator|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
return|return
name|N_
argument_list|(
literal|"function with complex parameters cannot be inline"
argument_list|)
return|;
block|}
comment|/* We can't inline functions that return a PARALLEL rtx.  */
name|result
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
name|N_
argument_list|(
literal|"inline functions not supported for this return value type"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variables used within save_for_inline.  */
end_comment

begin_comment
comment|/* Mapping from old pseudo-register to new pseudo-registers.    The first element of this map is reg_map[FIRST_PSEUDO_REGISTER].    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from old code-labels to new code-labels.    The first element of this map is label_map[min_labelno].    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|label_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from old insn uid's to copied insns.    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|insn_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map pseudo reg number into the PARM_DECL for the parm living in the reg.    Zero for a reg that isn't a parm's home.    Only reg numbers less than max_parm_reg are mapped here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|parmdecl_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of first pseudo-register beyond those that are parms.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|max_parm_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
modifier|*
name|parm_reg_stack_loc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_for_inline,    this is nonzero if we have copied an ASM_OPERANDS.    In that case, it is the original input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|orig_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_for_inline,    this is nonzero if we have copied an ASM_OPERANDS.    In that case, it is the copied input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, this is the copied constraints vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_constraints_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In save_for_inline, nonzero if past the parm-initialization insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_nonparm_insns
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* subroutines passed to duplicate_eh_handlers to map exception labels */
end_comment

begin_function
specifier|static
name|rtx
name|save_for_inline_eh_labelmap
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|int
name|index
init|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
decl_stmt|;
return|return
name|label_map
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for `save_for_inline{copying,nocopy}'.  Performs initialization    needed to save FNDECL's insns and info for future inline expansion.  */
end_comment

begin_function
specifier|static
name|rtx
name|initialize_for_inline
parameter_list|(
name|fndecl
parameter_list|,
name|min_labelno
parameter_list|,
name|max_labelno
parameter_list|,
name|max_reg
parameter_list|,
name|copy
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|min_labelno
decl_stmt|;
name|int
name|max_labelno
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|copy
decl_stmt|;
block|{
name|int
name|function_flags
decl_stmt|,
name|i
decl_stmt|;
name|rtvec
name|arg_vector
decl_stmt|;
name|tree
name|parms
decl_stmt|;
comment|/* Compute the values of any flags we must restore when inlining this.  */
name|function_flags
operator|=
operator|(
name|current_function_calls_alloca
operator|*
name|FUNCTION_FLAGS_CALLS_ALLOCA
operator|+
name|current_function_calls_setjmp
operator|*
name|FUNCTION_FLAGS_CALLS_SETJMP
operator|+
name|current_function_calls_longjmp
operator|*
name|FUNCTION_FLAGS_CALLS_LONGJMP
operator|+
name|current_function_returns_struct
operator|*
name|FUNCTION_FLAGS_RETURNS_STRUCT
operator|+
operator|(
name|current_function_returns_pcc_struct
operator|*
name|FUNCTION_FLAGS_RETURNS_PCC_STRUCT
operator|)
operator|+
name|current_function_needs_context
operator|*
name|FUNCTION_FLAGS_NEEDS_CONTEXT
operator|+
operator|(
name|current_function_has_nonlocal_label
operator|*
name|FUNCTION_FLAGS_HAS_NONLOCAL_LABEL
operator|)
operator|+
name|current_function_returns_pointer
operator|*
name|FUNCTION_FLAGS_RETURNS_POINTER
operator|+
name|current_function_uses_const_pool
operator|*
name|FUNCTION_FLAGS_USES_CONST_POOL
operator|+
operator|(
name|current_function_uses_pic_offset_table
operator|*
name|FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE
operator|)
operator|+
name|current_function_has_computed_jump
operator|*
name|FUNCTION_FLAGS_HAS_COMPUTED_JUMP
operator|)
expr_stmt|;
comment|/* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parmdecl_map
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|arg_vector
operator|=
name|rtvec_alloc
argument_list|(
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|rtx
name|p
init|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|copied_incoming
init|=
literal|0
decl_stmt|;
comment|/* If we have (mem (addressof (mem ...))), use the inner MEM since 	 otherwise the copy_rtx call below will not unshare the MEM since 	 it shares ADDRESSOF.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|MEM
operator|&&
name|copy
condition|)
block|{
comment|/* Copy the rtl so that modifications of the addresses 	     later in compilation won't affect this arg_vector. 	     Virtual register instantiation can screw the address 	     of the rtl.  */
name|rtx
name|new
init|=
name|copy_rtx
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Don't leave the old copy anywhere in this decl.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
operator|==
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|new
operator|,
name|copied_incoming
operator|=
literal|1
expr_stmt|;
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|REG
condition|)
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|p
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|rtx
name|preal
init|=
name|gen_realpart
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|rtx
name|pimag
init|=
name|gen_imagpart
argument_list|(
name|GET_MODE
argument_list|(
name|preal
argument_list|)
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|preal
argument_list|)
operator|==
name|REG
condition|)
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|preal
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pimag
argument_list|)
operator|==
name|REG
condition|)
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|pimag
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
block|}
comment|/* This flag is cleared later 	 if the function ever modifies the value of the parm.  */
name|TREE_READONLY
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Copy DECL_INCOMING_RTL if not done already.  This can 	 happen if DECL_RTL is a reg.  */
if|if
condition|(
name|copy
operator|&&
operator|!
name|copied_incoming
condition|)
block|{
name|p
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* If we have (mem (addressof (mem ...))), use the inner MEM since 	     otherwise the copy_rtx call below will not unshare the MEM since 	     it shares ADDRESSOF.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|MEM
condition|)
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Assume we start out in the insns that set up the parameters.  */
name|in_nonparm_insns
operator|=
literal|0
expr_stmt|;
comment|/* The list of DECL_SAVED_INSNS, starts off with a header which      contains the following information:       the first insn of the function (not including the insns that copy      parameters into registers).      the first parameter insn of the function,      the first label used by that function,      the last label used by that function,      the highest register number used for parameters,      the total number of registers used,      the size of the incoming stack area for parameters,      the number of bytes popped on return,      the stack slot list,      the labels that are forced to exist,      some flags that are used to restore compiler globals,      the value of current_function_outgoing_args_size,      the original argument vector,      the original DECL_INITIAL,      and pointers to the table of pseudo regs, pointer flags, and alignment. */
return|return
name|gen_inline_header_rtx
argument_list|(
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|min_labelno
argument_list|,
name|max_labelno
argument_list|,
name|max_parm_reg
argument_list|,
name|max_reg
argument_list|,
name|current_function_args_size
argument_list|,
name|current_function_pops_args
argument_list|,
name|stack_slot_list
argument_list|,
name|forced_labels
argument_list|,
name|function_flags
argument_list|,
name|current_function_outgoing_args_size
argument_list|,
name|arg_vector
argument_list|,
operator|(
name|rtx
operator|)
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
operator|(
name|rtvec
operator|)
name|regno_reg_rtx
argument_list|,
name|regno_pointer_flag
argument_list|,
name|regno_pointer_align
argument_list|,
operator|(
name|rtvec
operator|)
name|parm_reg_stack_loc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for `save_for_inline{copying,nocopy}'.  Finishes up the    things that must be done to make FNDECL expandable as an inline function.    HEAD contains the chain of insns to which FNDECL will expand.  */
end_comment

begin_function
specifier|static
name|void
name|finish_inline
parameter_list|(
name|fndecl
parameter_list|,
name|head
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|rtx
name|head
decl_stmt|;
block|{
name|FIRST_FUNCTION_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|head
expr_stmt|;
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust the BLOCK_END_NOTE pointers in a given copied DECL tree so that    they all point to the new (copied) rtxs.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_copied_decl_tree
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|subblock
decl_stmt|;
specifier|register
name|rtx
name|original_end
decl_stmt|;
name|original_end
operator|=
name|BLOCK_END_NOTE
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|original_end
condition|)
block|{
name|BLOCK_END_NOTE
argument_list|(
name|block
argument_list|)
operator|=
operator|(
name|rtx
operator|)
name|NOTE_SOURCE_FILE
argument_list|(
name|original_end
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|original_end
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Process all subblocks.  */
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|subblock
condition|;
name|subblock
operator|=
name|TREE_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|adjust_copied_decl_tree
argument_list|(
name|subblock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the insns and PARM_DECLs of the current function permanent    and record other information in DECL_SAVED_INSNS to allow inlining    of this function in subsequent calls.     This function is called when we are going to immediately compile    the insns for FNDECL.  The insns in maybepermanent_obstack cannot be    modified by the compilation process, so we copy all of them to    new storage and consider the new insns to be the insn chain to be    compiled.  Our caller (rest_of_compilation) saves the original    DECL_INITIAL and DECL_ARGUMENTS; here we copy them.  */
end_comment

begin_comment
comment|/* ??? The nonlocal_label list should be adjusted also.  However, since    a function that contains a nested function never gets inlined currently,    the nonlocal_label list will always be empty, so we don't worry about    it for now.  */
end_comment

begin_function
name|void
name|save_for_inline_copying
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|first_insn
decl_stmt|,
name|last_insn
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|copy
decl_stmt|;
name|int
name|max_labelno
decl_stmt|,
name|min_labelno
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|new1
decl_stmt|;
name|rtx
modifier|*
name|new_parm_reg_stack_loc
decl_stmt|;
name|rtx
modifier|*
name|new2
decl_stmt|;
comment|/* Make and emit a return-label if we have not already done so.       Do this before recording the bounds on label numbers.  */
if|if
condition|(
name|return_label
operator|==
literal|0
condition|)
block|{
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
comment|/* Get some bounds on the labels and registers used.  */
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.      Later we set TREE_READONLY to 0 if the parm is modified inside the fn.      Also set up ARG_VECTOR, which holds the unmodified DECL_RTX values      for the parms, prior to elimination of virtual registers.      These values are needed for substituting parms properly.  */
name|parmdecl_map
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|initialize_for_inline
argument_list|(
name|fndecl
argument_list|,
name|min_labelno
argument_list|,
name|max_labelno
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_uses_const_pool
condition|)
block|{
comment|/* Replace any constant pool references with the actual constant.  We 	 will put the constants back in the copy made below.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|save_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|save_constants
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Also scan all decls, and replace any constant pool references with the 	 actual constant.  */
name|save_constants_in_decl_trees
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear out the constant pool so that we can recreate it with the 	 copied constants below.  */
name|init_const_rtx_hash_table
argument_list|()
expr_stmt|;
name|clear_const_double_mem
argument_list|()
expr_stmt|;
block|}
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* We have now allocated all that needs to be allocated permanently      on the rtx obstack.  Set our high-water mark, so that we      can free the rest of this when the time comes.  */
name|preserve_data
argument_list|()
expr_stmt|;
comment|/* Copy the chain insns of this function.      Install the copied chain as the insns of this function,      for continued compilation;      the original chain is recorded as the DECL_SAVED_INSNS      for inlining future calls.  */
comment|/* If there are insns that copy parms from the stack into pseudo registers,      those insns are not copied.  `expand_inline_function' must      emit the correct code to handle such things.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|first_insn
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|first_insn
expr_stmt|;
comment|/* Each pseudo-reg in the old insn chain must have a unique rtx in the copy.      Make these new rtx's now, and install them in regno_reg_rtx, so they      will be the official pseudo-reg rtx's for the rest of compilation.  */
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|+
operator|(
name|GET_RTX_LENGTH
argument_list|(
name|REG
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|max_reg
operator|-
literal|1
init|;
name|i
operator|>
name|LAST_VIRTUAL_REGISTER
condition|;
name|i
operator|--
control|)
name|reg_map
index|[
name|i
index|]
operator|=
operator|(
name|rtx
operator|)
name|obstack_copy
argument_list|(
name|function_maybepermanent_obstack
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
name|reg_map
expr_stmt|;
comment|/* Put copies of all the virtual register rtx into the new regno_reg_rtx.  */
name|init_virtual_regs
argument_list|()
expr_stmt|;
comment|/* Likewise each label rtx must have a unique rtx as its copy.  */
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause unpredictable core dumps.  Some examples were> 2Mb in size.  */
name|label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|max_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_labelno
init|;
name|i
operator|<
name|max_labelno
condition|;
name|i
operator|++
control|)
name|label_map
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Likewise for parm_reg_stack_slot.  */
name|new_parm_reg_stack_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|savealloc
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_parm_reg
condition|;
name|i
operator|++
control|)
name|new_parm_reg_stack_loc
index|[
name|i
index|]
operator|=
name|copy_for_inline
argument_list|(
name|parm_reg_stack_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|new_parm_reg_stack_loc
expr_stmt|;
comment|/* Record the mapping of old insns to copied insns.  */
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_map
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the insn which signals the end of parameter setup code.  */
name|first_nonparm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
comment|/* Copy any entries in regno_reg_rtx or DECL_RTLs that reference MEM      (the former occurs when a variable has its address taken)      since these may be shared and can be changed by virtual      register instantiation.  DECL_RTL values for our arguments      have already been copied by initialize_for_inline.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the parm_reg_stack_loc array, and substitute for all of the rtx      contained in it.  */
name|new2
operator|=
operator|(
name|rtx
operator|*
operator|)
name|savealloc
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm_reg_stack_loc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new2
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|new2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_parm_reg
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|parm_reg_stack_loc
index|[
name|i
index|]
condition|)
name|parm_reg_stack_loc
index|[
name|i
index|]
operator|=
name|copy_for_inline
argument_list|(
name|parm_reg_stack_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Copy the tree of subblocks of the function, and the decls in them.      We will use the copy for compiling this function, then restore the original      subblocks and decls for use when inlining this function.       Several parts of the compiler modify BLOCK trees.  In particular,      instantiate_virtual_regs will instantiate any virtual regs      mentioned in the DECL_RTLs of the decls, and loop      unrolling will replicate any BLOCK trees inside an unrolled loop.       The modified subblocks or DECL_RTLs would be incorrect for the original rtl      which we will use for inlining.  The rtl might even contain pseudoregs      whose space has been freed.  */
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|copy_decl_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|copy_decl_list
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy each DECL_RTL which is a MEM,      so it is safe to modify their addresses.  */
name|copy_decl_rtls
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The fndecl node acts as its own progenitor, so mark it as such.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fndecl
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Now copy the chain of insns.  Do this twice.  The first copy the insn      itself and its body.  The second time copy of REG_NOTES.  This is because      a REG_NOTE may have a forward pointer to another insn.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|first_nonparm_insn
condition|)
name|in_nonparm_insns
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
comment|/* No need to keep these.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
condition|)
continue|continue;
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BLOCK_END
condition|)
name|NOTE_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|copy
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
name|int
name|new_region
init|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label_map
index|[
name|NOTE_BLOCK_NUMBER
argument_list|(
name|copy
argument_list|)
index|]
argument_list|)
decl_stmt|;
comment|/* we have to duplicate the handlers for the original */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
name|duplicate_eh_handlers
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|copy
argument_list|)
argument_list|,
name|new_region
argument_list|,
name|save_for_inline_eh_labelmap
argument_list|)
expr_stmt|;
comment|/* We have to forward these both to match the new exception 		 region.  */
name|NOTE_BLOCK_NUMBER
argument_list|(
name|copy
argument_list|)
operator|=
name|new_region
expr_stmt|;
block|}
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|copy
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|copy
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|copy
operator|=
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|INSN_UID
argument_list|(
name|copy
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|copy
expr_stmt|;
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
operator|=
name|last_insn
expr_stmt|;
name|last_insn
operator|=
name|copy
expr_stmt|;
block|}
name|adjust_copied_decl_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy the REG_NOTES.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
name|REG_NOTES
argument_list|(
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|finish_inline
argument_list|(
name|fndecl
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* Make new versions of the register tables.  */
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regno_pointer_flag
argument_list|,
name|new
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|new1
operator|=
operator|(
name|char
operator|*
operator|)
name|savealloc
argument_list|(
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regno_pointer_align
argument_list|,
name|new1
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|regno_pointer_flag
operator|=
name|new
expr_stmt|;
name|regno_pointer_align
operator|=
name|new1
expr_stmt|;
name|set_new_first_and_last_insn
argument_list|(
name|first_insn
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_map
condition|)
name|free
argument_list|(
name|label_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy NODE (as with copy_node).  NODE must be a DECL.  Set the    DECL_ABSTRACT_ORIGIN for the new accordinly.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_and_set_decl_abstract_origin
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|copy
init|=
name|copy_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|copy
argument_list|)
operator|!=
name|NULL_TREE
condition|)
comment|/* That means that NODE already had a DECL_ABSTRACT_ORIGIN.  (This        situation occurs if we inline a function which itself made        calls to inline functions.)  Since DECL_ABSTRACT_ORIGIN is the        most distant ancestor, we don't have to do anything here.  */
empty_stmt|;
else|else
comment|/* The most distant ancestor must be NODE.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|copy
argument_list|)
operator|=
name|node
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.    For example, this can copy a list made of TREE_LIST nodes.  While copying,    set DECL_ABSTRACT_ORIGIN appropriately.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_decl_list
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|head
decl_stmt|;
specifier|register
name|tree
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|prev
operator|=
name|copy_and_set_decl_abstract_origin
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
specifier|register
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_and_set_decl_abstract_origin
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|copy
expr_stmt|;
name|prev
operator|=
name|copy
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of the entire tree of blocks BLOCK, and return it.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_decl_tree
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|vars
decl_stmt|,
name|subblocks
decl_stmt|;
name|vars
operator|=
name|copy_decl_list
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|subblocks
operator|=
literal|0
expr_stmt|;
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|copy
init|=
name|copy_decl_tree
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|copy
argument_list|)
operator|=
name|subblocks
expr_stmt|;
name|subblocks
operator|=
name|copy
expr_stmt|;
block|}
name|t
operator|=
name|copy_node
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|t
argument_list|)
operator|=
name|vars
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|subblocks
argument_list|)
expr_stmt|;
comment|/* If the BLOCK being cloned is already marked as having been instantiated      from something else, then leave that `origin' marking alone.  Otherwise,      mark the clone as having originated from the BLOCK we are cloning.  */
if|if
condition|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
operator|=
name|block
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Copy DECL_RTLs in all decls in the given BLOCK node.  */
end_comment

begin_function
specifier|static
name|void
name|copy_decl_rtls
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|copy_decl_rtls
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the insns and PARM_DECLs of the current function permanent    and record other information in DECL_SAVED_INSNS to allow inlining    of this function in subsequent calls.     This routine need not copy any insns because we are not going    to immediately compile the insns in the insn chain.  There    are two cases when we would compile the insns for FNDECL:    (1) when FNDECL is expanded inline, and (2) when FNDECL needs to    be output at the end of other compilation, because somebody took    its address.  In the first case, the insns of FNDECL are copied    as it is expanded inline, so FNDECL's saved insns are not    modified.  In the second case, FNDECL is used for the last time,    so modifying the rtl is not a problem.     We don't have to worry about FNDECL being inline expanded by    other functions which are written at the end of compilation    because flag_no_inline is turned on when we begin writing    functions at the end of compilation.  */
end_comment

begin_function
name|void
name|save_for_inline_nocopy
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
comment|/* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.      Later we set TREE_READONLY to 0 if the parm is modified inside the fn.      Also set up ARG_VECTOR, which holds the unmodified DECL_RTX values      for the parms, prior to elimination of virtual registers.      These values are needed for substituting parms properly.  */
name|parmdecl_map
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make and emit a return-label if we have not already done so.  */
if|if
condition|(
name|return_label
operator|==
literal|0
condition|)
block|{
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|initialize_for_inline
argument_list|(
name|fndecl
argument_list|,
name|get_first_label_num
argument_list|()
argument_list|,
name|max_label_num
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are insns that copy parms from the stack into pseudo registers,      those insns are not copied.  `expand_inline_function' must      emit the correct code to handle such things.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the insn which signals the end of parameter setup code.  */
name|first_nonparm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
comment|/* Now just scan the chain of insns to see what happens to our      PARM_DECLs.  If a PARM_DECL is used but never modified, we      can substitute its rtl directly when expanding inline (and      perform constant folding when its incoming value is constant).      Otherwise, we have to copy its value into a new register and track      the new register's life.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|first_nonparm_insn
condition|)
name|in_nonparm_insns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|current_function_uses_const_pool
condition|)
block|{
comment|/* Replace any constant pool references with the actual constant. 		 We will put the constant back if we need to write the 		 function out after all.  */
name|save_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|save_constants
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record what interesting things happen to our parameters.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_modified_parmregs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Also scan all decls, and replace any constant pool references with the      actual constant.  */
name|save_constants_in_decl_trees
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have now allocated all that needs to be allocated permanently      on the rtx obstack.  Set our high-water mark, so that we      can free the rest of this when the time comes.  */
name|preserve_data
argument_list|()
expr_stmt|;
name|finish_inline
argument_list|(
name|fndecl
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given PX, a pointer into an insn, search for references to the constant    pool.  Replace each with a CONST that has the mode of the original    constant, contains the constant, and has RTX_INTEGRATED_P set.    Similarly, constant pool addresses not enclosed in a MEM are replaced    with an ADDRESS and CONST rtx which also gives the constant, its    mode, the mode of the address, and has RTX_INTEGRATED_P set.  */
end_comment

begin_function
specifier|static
name|void
name|save_constants
parameter_list|(
name|px
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|again
label|:
name|x
operator|=
operator|*
name|px
expr_stmt|;
comment|/* If this is a CONST_DOUBLE, don't try to fix things up in       CONST_DOUBLE_MEM, because this is an infinite recursion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|const_mode
init|=
name|get_pool_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|gen_rtx_CONST
argument_list|(
name|const_mode
argument_list|,
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If the MEM was in a different mode than the constant (perhaps we 	 were only looking at the low-order part), surround it with a  	 SUBREG so we can save both modes.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|const_mode
condition|)
block|{
name|new
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|px
operator|=
name|new
expr_stmt|;
name|save_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|px
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|px
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|get_pool_mode
argument_list|(
name|x
argument_list|)
argument_list|,
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|save_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|px
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
operator|*
name|px
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|save_constants
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Hack tail-recursion here.  */
name|px
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|save_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note whether a parameter is modified or not.  */
end_comment

begin_function
specifier|static
name|void
name|note_modified_parmregs
parameter_list|(
name|reg
parameter_list|,
name|x
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|in_nonparm_insns
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|max_parm_reg
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|TREE_READONLY
argument_list|(
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the rtx ORIG recursively, replacing pseudo-regs and labels    according to `reg_map' and `label_map'.  The original rtl insns    will be saved for inlining; this is used to make a copy    which is used to finish compiling the inline function itself.     If we find a "saved" constant pool entry, one which was replaced with    the value of the constant, convert it back to a constant pool entry.    Since the pool wasn't touched, this should simply restore the old    address.     All other kinds of rtx are copied except those that can never be    changed during compilation.  */
end_comment

begin_function
specifier|static
name|rtx
name|copy_for_inline
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|orig
decl_stmt|;
specifier|register
name|rtx
name|new
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
return|;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|SYMBOL_REF_NEED_ADJUST
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|rethrow_symbol_map
argument_list|(
name|x
argument_list|,
name|save_for_inline_eh_labelmap
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* We have to make a new CONST_DOUBLE to ensure that we account for 	 it correctly.  Using the old CONST_DOUBLE_MEM data is wrong.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|immed_double_const
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|CONST
case|:
comment|/* Get constant pool entry for constant in the pool.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SUBREG
case|:
comment|/* Get constant pool entry, but access in different mode.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|new
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|validize_mem
argument_list|(
name|new
argument_list|)
return|;
block|}
break|break;
case|case
name|ADDRESS
case|:
comment|/* If not special for constant pool error.  Else get constant pool 	 address.  */
if|if
condition|(
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|new
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|new
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* If a single asm insn contains multiple output operands 	 then it contains multiple ASM_OPERANDS rtx's that share operand 3. 	 We must make sure that the copied insn continues to share it.  */
if|if
condition|(
name|orig_asm_operands_vector
operator|==
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|x
operator|=
name|rtx_alloc
argument_list|(
name|ASM_OPERANDS
argument_list|)
expr_stmt|;
name|x
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
operator|=
name|copy_asm_operands_vector
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
operator|=
name|copy_asm_constraints_vector
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|5
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|x
argument_list|,
literal|6
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
break|break;
case|case
name|MEM
case|:
comment|/* A MEM is usually allowed to be shared if its address is constant 	 or is a constant plus one of the special registers.  	 We do not allow sharing of addresses that are either a special 	 register or the sum of a constant and a special register because 	 it is possible for unshare_all_rtl to copy the address, into memory 	 that won't be saved.  Although the MEM can safely be shared, and 	 won't be copied there, the address itself cannot be shared, and may 	 need to be copied.   	 There are also two exceptions with constants: The first is if the 	 constant is a LABEL_REF or the sum of the LABEL_REF 	 and an integer.  This case can happen if we have an inline 	 function that supplies a constant operand to the call of another 	 inline function that uses it in a switch statement.  In this case, 	 we will be replacing the LABEL_REF, so we have to replace this MEM 	 as well.  	 The second case is if we have a (const (plus (address ..) ...)). 	 In that case we need to put back the address of the constant pool 	 entry.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESS
operator|)
operator|)
operator|)
operator|)
condition|)
return|return
name|x
return|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* If this is a non-local label, just make a new LABEL_REF. 	 Otherwise, use the new label as well.  */
name|x
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
condition|?
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
else|:
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
operator|=
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|x
argument_list|)
operator|=
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|x
return|;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
else|else
return|return
name|x
return|;
case|case
name|SET
case|:
comment|/* If a parm that gets modified lives in a pseudo-reg, 	 clear its TREE_READONLY to prevent certain optimizations.  */
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|max_parm_reg
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|!=
literal|0
comment|/* The insn to load an arg pseudo from a stack slot 	       does not count as modifying it.  */
operator|&&
name|in_nonparm_insns
condition|)
name|TREE_READONLY
argument_list|(
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
comment|/* This is a good idea, but here is the wrong place for it.  */
comment|/* Arrange that CONST_INTs always appear as the second operand 	 if they appear, and that `frame_pointer_rtx' or `arg_pointer_rtx' 	 always appear as the first.  */
block|case PLUS:       if (GET_CODE (XEXP (x, 0)) == CONST_INT 	  || (XEXP (x, 1) == frame_pointer_rtx 	      || (ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM&& XEXP (x, 1) == arg_pointer_rtx))) 	{ 	  rtx t = XEXP (x, 0); 	  XEXP (x, 0) = XEXP (x, 1); 	  XEXP (x, 1) = t; 	}       break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* Replace this rtx with a copy of itself.  */
name|x
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|orig
argument_list|,
operator|(
name|char
operator|*
operator|)
name|x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|x
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Now scan the subexpressions recursively.      We can store any replaced subexpressions directly into X      since we know X is not shared!  Any vectors in X      must be copied if X was copied.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtvec_vv
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|->
name|elem
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
operator|&&
name|orig_asm_operands_vector
operator|==
literal|0
condition|)
block|{
name|orig_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
name|XVEC
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Unfortunately, we need a global copy of const_equiv map for communication    with a function called from note_stores.  Be *very* careful that this    is used properly in the presence of recursion.  */
end_comment

begin_decl_stmt
name|varray_type
name|global_const_equiv_varray
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|FIXED_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT	\&& GET_CODE (XEXP (X, 0)) == REG				\&& REGNO (XEXP (X, 0))>= FIRST_VIRTUAL_REGISTER		\&& REGNO (XEXP (X, 0))<= LAST_VIRTUAL_REGISTER)
end_define

begin_comment
comment|/* Called to set up a mapping for the case where a parameter is in a    register.  If it is read-only and our argument is a constant, set up the    constant equivalence.     If LOC is REG_USERVAR_P, the usual case, COPY must also have that flag set    if it is a register.     Also, don't allow hard registers here; they might not be valid when    substituted into insns.  */
end_comment

begin_function
specifier|static
name|void
name|process_reg_param
parameter_list|(
name|map
parameter_list|,
name|loc
parameter_list|,
name|copy
parameter_list|)
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtx
name|loc
decl_stmt|,
name|copy
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|SUBREG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|REG
operator|&&
name|REG_USERVAR_P
argument_list|(
name|loc
argument_list|)
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|copy
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|copy
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|copy_to_mode_reg
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|copy
argument_list|)
decl_stmt|;
name|REG_USERVAR_P
argument_list|(
name|temp
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|copy
argument_list|)
condition|)
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|copy
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|copy
operator|=
name|temp
expr_stmt|;
block|}
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used by duplicate_eh_handlers to map labels for the exception table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|inline_remap
modifier|*
name|eif_eh_map
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|expand_inline_function_eh_labelmap
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|int
name|index
init|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
decl_stmt|;
return|return
name|get_label_from_map
argument_list|(
name|eif_eh_map
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Integrate the procedure defined by FNDECL.  Note that this function    may wind up calling itself.  Since the static variables are not    reentrant, we do not assign them until after the possibility    of recursion is eliminated.     If IGNORE is nonzero, do not produce a value.    Otherwise store the value in TARGET if it is nonzero and that is convenient.     Value is:    (rtx)-1 if we could not substitute the function    0 if we substituted it and it does not produce a value    else an rtx for where the value is stored.  */
end_comment

begin_function
name|rtx
name|expand_inline_function
parameter_list|(
name|fndecl
parameter_list|,
name|parms
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|,
name|type
parameter_list|,
name|structure_value_addr
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|parms
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|structure_value_addr
decl_stmt|;
block|{
name|tree
name|formal
decl_stmt|,
name|actual
decl_stmt|,
name|block
decl_stmt|;
name|rtx
name|header
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|insns
init|=
name|FIRST_FUNCTION_INSN
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|rtx
name|parm_insns
init|=
name|FIRST_PARM_INSN
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|arg_trees
decl_stmt|;
name|rtx
modifier|*
name|arg_vals
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|max_regno
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|min_labelno
init|=
name|FIRST_LABELNO
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|int
name|max_labelno
init|=
name|LAST_LABELNO
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|rtx
name|local_return_label
init|=
literal|0
decl_stmt|;
name|rtx
name|loc
decl_stmt|;
name|rtx
name|stack_save
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|cc0_insn
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|rtvec
name|arg_vector
init|=
name|ORIGINAL_ARG_VECTOR
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|rtx
name|static_chain_value
init|=
literal|0
decl_stmt|;
comment|/* The pointer used to track the true location of the memory used      for MAP->LABEL_MAP.  */
name|rtx
modifier|*
name|real_label_map
init|=
literal|0
decl_stmt|;
comment|/* Allow for equivalences of the pseudos we make for virtual fp and ap.  */
name|max_regno
operator|=
name|MAX_REGNUM
argument_list|(
name|header
argument_list|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|max_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nargs
operator|=
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that the parms type match and that sufficient arguments were      passed.  Since the appropriate conversions or default promotions have      already been applied, the machine modes should match exactly.  */
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
control|)
block|{
name|tree
name|arg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|-
literal|1
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
comment|/* If they are block mode, the types should match exactly. 	     They don't match exactly if TREE_TYPE (FORMAL) == ERROR_MARK_NODE, 	     which could happen if the parameter has incomplete type.  */
operator|||
operator|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|-
literal|1
return|;
block|}
comment|/* Extra arguments are valid, but will be ignored below, so we must      evaluate them here for side-effects.  */
for|for
control|(
init|;
name|actual
condition|;
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a binding contour to keep inline cleanups called at      outer function-scope level from looking like they are shadowing      parameter declarations.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Expand the function arguments.  Do this first so that any      new registers get created before we allocate the maps.  */
name|arg_vals
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|arg_trees
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Actual parameter, converted to the type of the argument within the 	 function.  */
name|tree
name|arg
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Mode of the variable used within the function.  */
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|invisiref
init|=
literal|0
decl_stmt|;
name|arg_trees
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If this is an object passed by invisible reference, we copy the 	 object into a stack slot and save its address.  If this will go 	 into memory, we do nothing now.  Otherwise, we just expand the 	 argument.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|rtx
name|stack_slot
init|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|stack_slot
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|arg
argument_list|,
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_vals
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|invisiref
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
comment|/* The mode if LOC and ARG can differ if LOC was a variable 	       that had its mode promoted via PROMOTED_MODE.  */
name|arg_vals
index|[
name|i
index|]
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_SUM
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg_vals
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
block|}
else|else
name|arg_vals
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg_vals
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|TREE_READONLY
argument_list|(
name|formal
argument_list|)
comment|/* If the parameter is not read-only, copy our argument through 		 a register.  Also, we cannot use ARG_VALS[I] if it overlaps 		 TARGET in any way.  In the inline function, they will likely 		 be two different pseudos, and `safe_from_p' will make all 		 sorts of smart assumptions about their not conflicting. 		 But if ARG_VALS[I] overlaps TARGET, these assumptions are 		 wrong, so put ARG_VALS[I] into a fresh register. 		 Don't worry about invisible references, since their stack 		 temps will never overlap the target.  */
operator|||
operator|(
name|target
operator|!=
literal|0
operator|&&
operator|!
name|invisiref
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|,
name|target
argument_list|)
operator|)
comment|/* ??? We must always copy a SUBREG into a REG, because it might 		 get substituted into an address, and not all ports correctly 		 handle SUBREGs in addresses.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
operator|)
condition|)
name|arg_vals
index|[
name|i
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|arg_vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_vals
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|,
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the structures we use to remap things.  */
name|map
operator|=
operator|(
expr|struct
name|inline_remap
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|inline_remap
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|fndecl
operator|=
name|fndecl
expr_stmt|;
name|map
operator|->
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
operator|->
name|reg_map
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause unpredictable core dumps.  */
name|real_label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|max_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|label_map
operator|=
name|real_label_map
expr_stmt|;
name|map
operator|->
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|INSN_UID
argument_list|(
name|header
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
operator|->
name|insn_map
argument_list|,
name|INSN_UID
argument_list|(
name|header
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|min_insnno
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|max_insnno
operator|=
name|INSN_UID
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|map
operator|->
name|integrating
operator|=
literal|1
expr_stmt|;
comment|/* const_equiv_varray maps pseudos in our routine to constants, so      it needs to be large enough for all our pseudos.  This is the      number we are currently using plus the number in the called      routine, plus 15 for each arg, five to compute the virtual frame      pointer, and five for the return value.  This should be enough      for most cases.  We do not reference entries outside the range of      the map.       ??? These numbers are quite arbitrary and were obtained by      experimentation.  At some point, we should try to allocate the      table after all the parameters are set up so we an more accurately      estimate the number of pseudos we will need.  */
name|VARRAY_CONST_EQUIV_INIT
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
operator|(
name|max_reg_num
argument_list|()
operator|+
operator|(
name|max_regno
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|+
literal|15
operator|*
name|nargs
operator|+
literal|10
operator|)
argument_list|,
literal|"expand_inline_function"
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|=
literal|0
expr_stmt|;
comment|/* Record the current insn in case we have to set up pointers to frame      and argument memory blocks.  If there are no insns yet, add a dummy      insn that can be used as an insertion point.  */
name|map
operator|->
name|insns_at_start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|insns_at_start
operator|==
literal|0
condition|)
name|map
operator|->
name|insns_at_start
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|map
operator|->
name|regno_pointer_flag
operator|=
name|INLINE_REGNO_POINTER_FLAG
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|map
operator|->
name|regno_pointer_align
operator|=
name|INLINE_REGNO_POINTER_ALIGN
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* Update the outgoing argument size to allow for those in the inlined      function.  */
if|if
condition|(
name|OUTGOING_ARGS_SIZE
argument_list|(
name|header
argument_list|)
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|OUTGOING_ARGS_SIZE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* If the inline function needs to make PIC references, that means      that this function's PIC offset table must be used.  */
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|header
argument_list|)
operator|&
name|FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE
condition|)
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
comment|/* If this function needs a context, set it up.  */
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|header
argument_list|)
operator|&
name|FUNCTION_FLAGS_NEEDS_CONTEXT
condition|)
name|static_chain_value
operator|=
name|lookup_static_chain
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|parm_insns
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|parm_insns
argument_list|)
operator|>
literal|0
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|parm_insns
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|parm_insns
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Process each argument.  For each, set up things so that the function's      reference to the argument will refer to the argument being passed.      We only replace REG with REG here.  Any simplifications are done      via const_equiv_map.       We make two passes:  In the first, we deal with parameters that will      be placed into registers, since we need to ensure that the allocated      register number fits in const_equiv_map.  Then we store all non-register      parameters into their memory location.  */
comment|/* Don't try to free temp stack slots here, because we may put one of the      parameters into a temp stack slot.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|copy
init|=
name|arg_vals
index|[
name|i
index|]
decl_stmt|;
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* There are three cases, each handled separately.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
comment|/* This must be an object passed by invisible reference (it could 	     also be a variable-sized object, but we forbid inlining functions 	     with variable-sized arguments).  COPY is the address of the 	     actual value (this computation will cause it to be copied).  We 	     map that address for the register, noting the actual address as 	     an equivalent in case it can be substituted into the insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|temp
operator|=
name|copy_addr_to_reg
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|copy
argument_list|)
condition|)
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|copy
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|copy
operator|=
name|temp
expr_stmt|;
block|}
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is the case of a parameter that lives in memory. 	     It will live in the block we allocate in the called routine's 	     frame that simulates the incoming argument area.  Do nothing 	     now; we will call store_expr later.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
name|process_reg_param
argument_list|(
name|map
argument_list|,
name|loc
argument_list|,
name|copy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|rtx
name|locreal
init|=
name|gen_realpart
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|rtx
name|locimag
init|=
name|gen_imagpart
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|rtx
name|copyreal
init|=
name|gen_realpart
argument_list|(
name|GET_MODE
argument_list|(
name|locreal
argument_list|)
argument_list|,
name|copy
argument_list|)
decl_stmt|;
name|rtx
name|copyimag
init|=
name|gen_imagpart
argument_list|(
name|GET_MODE
argument_list|(
name|locimag
argument_list|)
argument_list|,
name|copy
argument_list|)
decl_stmt|;
name|process_reg_param
argument_list|(
name|map
argument_list|,
name|locreal
argument_list|,
name|copyreal
argument_list|)
expr_stmt|;
name|process_reg_param
argument_list|(
name|map
argument_list|,
name|locimag
argument_list|,
name|copyimag
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now do the parameters that will be placed in memory.  */
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
comment|/* Exclude case handled above.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the address in the area we reserved and store the 	     value there.  */
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|change_address
argument_list|(
name|temp
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|arg_trees
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deal with the places that the function puts its result.      We are driven by what is placed into DECL_RESULT.       Initially, we assume that we don't have anything special handling for      REG_FUNCTION_RETURN_VALUE_P.  */
name|map
operator|->
name|inline_target
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* There is no return value to worry about.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|target
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|structure_value_addr
operator|||
operator|!
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Pass the function the address in which to return a structure 	     value.  Note that a constructor can cause someone to call us 	     with STRUCTURE_VALUE_ADDR, but the initialization takes place 	     via the first parameter, rather than the struct return address.  	     We have two cases: If the address is a simple register 	     indirect, use the mapping mechanism to point that register to 	     our structure return address.  Otherwise, store the structure 	     return value into the place that it will be referenced from.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|force_operand
argument_list|(
name|structure_value_addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|structure_value_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|==
name|ADDRESSOF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|structure_value_addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|structure_value_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|structure_value_addr
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ignore
condition|)
comment|/* We will ignore the result value, so don't look at its structure.        Note that preparations for an aggregate return value        do need to be made (above) even if it will be ignored.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* The function returns an object in a register and we use the return 	 value.  Set up our target for remapping.  */
comment|/* Machine mode function was declared to return.   */
name|enum
name|machine_mode
name|departing_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* (Possibly wider) machine mode it actually computes 	 (for the sake of callers that fail to declare it right). 	 We have to use the mode of the result's RTL, rather than 	 its type, since expand_function_start may have promoted it.  */
name|enum
name|machine_mode
name|arriving_mode
init|=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg_to_map
decl_stmt|;
comment|/* Don't use MEMs as direct targets because on some machines 	 substituting a MEM for a REG makes invalid insns. 	 Let the combiner substitute the MEM if that is valid.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|departing_mode
condition|)
block|{
comment|/* Don't make BLKmode registers.  If this looks like 	     a BLKmode object being returned in a register, get 	     the mode from that, otherwise abort. */
if|if
condition|(
name|departing_mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|REG
operator|==
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|departing_mode
operator|=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arriving_mode
operator|=
name|departing_mode
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|departing_mode
argument_list|)
expr_stmt|;
block|}
comment|/* If function's value was promoted before return, 	 avoid machine mode mismatch when we substitute INLINE_TARGET. 	 But TARGET is what we will return to the caller.  */
if|if
condition|(
name|arriving_mode
operator|!=
name|departing_mode
condition|)
block|{
comment|/* Avoid creating a paradoxical subreg wider than 	     BITS_PER_WORD, since that is illegal.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|arriving_mode
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|!
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|departing_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|arriving_mode
argument_list|)
argument_list|)
condition|)
comment|/* Maybe could be handled by using convert_move () ?  */
name|abort
argument_list|()
expr_stmt|;
name|reg_to_map
operator|=
name|gen_reg_rtx
argument_list|(
name|arriving_mode
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_lowpart
argument_list|(
name|departing_mode
argument_list|,
name|reg_to_map
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_to_map
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|arriving_mode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_to_map
operator|=
name|target
expr_stmt|;
comment|/* Usually, the result value is the machine's return register. 	 Sometimes it may be a pseudo. Handle both cases.  */
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|loc
argument_list|)
condition|)
name|map
operator|->
name|inline_target
operator|=
name|reg_to_map
expr_stmt|;
else|else
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
operator|=
name|reg_to_map
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Make a fresh binding contour that we can easily remove.  Do this after      expanding our arguments so cleanups are properly scoped.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize label_map.  get_label_from_map will actually make      the labels.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|map
operator|->
name|label_map
index|[
name|min_labelno
index|]
argument_list|,
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Clean up stack so that variables might have smaller offsets.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Save a copy of the location of const_equiv_varray for      mark_stores, called via note_stores.  */
name|global_const_equiv_varray
operator|=
name|map
operator|->
name|const_equiv_varray
expr_stmt|;
comment|/* If the called function does an alloca, save and restore the      stack pointer around the call.  This saves stack space, but      also is required if this inline is being done between two      pushes.  */
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|header
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_ALLOCA
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Now copy the insns one by one.  Do this in two passes, first the insns and      then their REG_NOTES, just like save_for_inline.  */
comment|/* This loop is very similar to the loop in copy_loop_body in unroll.c.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|copy
decl_stmt|,
name|pattern
decl_stmt|,
name|set
decl_stmt|;
name|map
operator|->
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* The (USE (REG n)) at return from the function should 	       be ignored since we are changing (REG n) into 	       inline_target.  */
break|break;
comment|/* If the inline fn needs eh context, make sure that 	     the current fn has one. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|USE
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_CONTEXT
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|get_eh_context
argument_list|()
expr_stmt|;
comment|/* Ignore setting a function value that we don't want to use.  */
if|if
condition|(
name|map
operator|->
name|inline_target
operator|==
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|new_set
decl_stmt|;
comment|/* If we must not delete the source, 		     load it into a new temporary.  */
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|new_set
operator|=
name|single_set
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_set
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_DEST
argument_list|(
name|new_set
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|new_set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the source and destination are the same and it 		 has a note on it, keep the insn.  */
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* If this is setting the static chain rtx, omit it.  */
elseif|else
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
condition|)
break|break;
comment|/* If this is setting the static chain pseudo, set it from 	     the value we want to give it instead.  */
elseif|else
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
condition|)
block|{
name|rtx
name|newdest
init|=
name|copy_rtx_and_substitute
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|copy
operator|=
name|emit_move_insn
argument_list|(
name|newdest
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
name|static_chain_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* REG_NOTES will be copied later.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this insn is setting CC0, it may need to look at 	     the insn that uses CC0 to see what type of insn it is. 	     In that case, the call to recog via validate_change will 	     fail.  So don't substitute constants here.  Instead, 	     do it when we emit the following insn.  	     For example, see the pyr.md file.  That machine has signed and 	     unsigned compares.  The compare patterns must check the 	     following branch insn to see which what kind of compare to 	     emit.  	     If the previous insn set CC0, substitute constants on it as 	     well.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|cc0_insn
operator|=
name|copy
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
block|{
if|if
condition|(
name|local_return_label
operator|==
literal|0
condition|)
name|local_return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pattern
operator|=
name|gen_jump
argument_list|(
name|local_return_label
argument_list|)
expr_stmt|;
block|}
else|else
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_jump_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* If this used to be a conditional jump insn but whose branch 	     direction is now know, we must do something special.  */
if|if
condition|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|map
operator|->
name|last_pc_value
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The previous insn set cc0 for us.  So delete it.  */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is now a no-op, delete it.  */
if|if
condition|(
name|map
operator|->
name|last_pc_value
operator|==
name|pc_rtx
condition|)
block|{
name|delete_insn
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Otherwise, this is unconditional jump so we must put a 		   BARRIER after it.  We could do some dead code elimination 		   here, but jump.c will do it just as well.  */
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CALL_INSN
case|:
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_call_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially contains objects other 	     than hard registers, we need to copy it.  */
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Be lazy and assume CALL_INSNs clobber all hard registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|i
argument_list|)
operator|.
name|rtx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|copy
operator|=
name|emit_label
argument_list|(
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|copy
operator|=
name|emit_barrier
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
comment|/* It is important to discard function-end and function-beg notes, 	     so we have only one of each in the current function. 	     Also, NOTE_INSN_DELETED notes aren't useful (save_for_inline 	     deleted these in the copy used for continuing compilation, 	     not the copy used for inlining).  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
block|{
name|copy
operator|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|NOTE_BLOCK_NUMBER
argument_list|(
name|copy
argument_list|)
argument_list|)
decl_stmt|;
comment|/* we have to duplicate the handlers for the original */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
block|{
comment|/* We need to duplicate the handlers for the EH region                          and we need to indicate where the label map is */
name|eif_eh_map
operator|=
name|map
expr_stmt|;
name|duplicate_eh_handlers
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|copy
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|,
name|expand_inline_function_eh_labelmap
argument_list|)
expr_stmt|;
block|}
comment|/* We have to forward these both to match the new exception 		     region.  */
name|NOTE_BLOCK_NUMBER
argument_list|(
name|copy
argument_list|)
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|copy
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copy
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
comment|/* Now copy the REG_NOTES.  Increment const_age, so that only constants      from parameters can be substituted in.  These are the only ones that      are valid across the entire function.  */
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
name|copy_rtx_and_substitute
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
decl_stmt|;
comment|/* We must also do subst_constants, in case one of our parameters 	   has const type and constant value.  */
name|subst_constants
argument_list|(
operator|&
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
name|local_return_label
condition|)
name|emit_label
argument_list|(
name|local_return_label
argument_list|)
expr_stmt|;
comment|/* Restore the stack pointer if we saved it above.  */
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|header
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_ALLOCA
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Make copies of the decls of the symbols in the inline function, so that      the copies of the variables get declared in the current function.  Set      up things so that lookup_static_chain knows that to interpret registers      in SAVE_EXPRs for TYPE_SIZEs as local.  */
name|inline_function_decl
operator|=
name|fndecl
expr_stmt|;
name|integrate_parm_decls
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|map
argument_list|,
name|arg_vector
argument_list|)
expr_stmt|;
name|integrate_decl_tree
argument_list|(
operator|(
name|tree
operator|)
name|ORIGINAL_DECL_INITIAL
argument_list|(
name|header
argument_list|)
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|inline_function_decl
operator|=
literal|0
expr_stmt|;
comment|/* End the scope containing the copied formal parameter variables      and copied LABEL_DECLs.  */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
operator|=
operator|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL
condition|?
name|fndecl
else|:
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fndecl
argument_list|)
operator|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Must mark the line number note after inlined functions as a repeat, so      that the test coverage code can avoid counting the call twice.  This      just tells the code to ignore the immediately following line note, since      there already exists a copy of this note before the expanded inline call.      This line number note is still needed for debugging though, so we can't      delete it.  */
if|if
condition|(
name|flag_test_coverage
condition|)
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_REPEATED_LINE_NUMBER
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* If the function returns a BLKmode object in a register, copy it      out of the temp register into a BLKmode memory object. */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|target
operator|=
name|copy_blkmode_from_reg
argument_list|(
literal|0
argument_list|,
name|target
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|structure_value_addr
condition|)
block|{
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we free the things we explicitly allocated with xmalloc.  */
if|if
condition|(
name|real_label_map
condition|)
name|free
argument_list|(
name|real_label_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
name|VARRAY_FREE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of PARM_DECLs, ARGS, copy each decl into a VAR_DECL,    push all of those decls and give each one the corresponding home.  */
end_comment

begin_function
specifier|static
name|void
name|integrate_parm_decls
parameter_list|(
name|args
parameter_list|,
name|map
parameter_list|,
name|arg_vector
parameter_list|)
name|tree
name|args
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtvec
name|arg_vector
decl_stmt|;
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|args
operator|,
name|i
operator|=
literal|0
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new_decl_rtl
init|=
name|copy_rtx_and_substitute
argument_list|(
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* We really should be setting DECL_INCOMING_RTL to something reasonable 	 here, but that's going to require some more work.  */
comment|/* DECL_INCOMING_RTL (decl) = ?; */
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Prevent warning for shadowing with these.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Fully instantiate the address with the equivalent form so that the 	 debugging information contains the actual register, instead of the 	 virtual register.   Do this by not passing an insn to 	 subst_constants.  */
name|subst_constants
argument_list|(
operator|&
name|new_decl_rtl
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|new_decl_rtl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a BLOCK node LET, push decls and levels so as to construct in the    current function a tree of contexts isomorphic to the one that is given.     LEVEL indicates how far down into the BLOCK tree is the node we are    currently traversing.  It is always zero except for recursive calls.     MAP, if nonzero, is a pointer to an inline_remap map which indicates how    registers used in the DECL_RTL field should be remapped.  If it is zero,    no mapping is necessary.  */
end_comment

begin_function
specifier|static
name|void
name|integrate_decl_tree
parameter_list|(
name|let
parameter_list|,
name|level
parameter_list|,
name|map
parameter_list|)
name|tree
name|let
decl_stmt|;
name|int
name|level
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|node
decl_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|d
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|saveable_allocation
argument_list|()
expr_stmt|;
name|d
operator|=
name|copy_and_set_decl_abstract_origin
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|d
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Fully instantiate the address with the equivalent form so that the 	     debugging information contains the actual register, instead of the 	     virtual register.   Do this by not passing an insn to 	     subst_constants.  */
name|subst_constants
argument_list|(
operator|&
name|DECL_RTL
argument_list|(
name|d
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
block|}
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|d
argument_list|)
condition|)
name|copy_lang_decl
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|integrate_decl_tree
argument_list|(
name|t
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|node
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|TREE_USED
argument_list|(
name|node
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|let
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|node
argument_list|)
operator|=
name|let
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a BLOCK node LET, search for all DECL_RTL fields, and pass them    through save_constants.  */
end_comment

begin_function
specifier|static
name|void
name|save_constants_in_decl_trees
parameter_list|(
name|let
parameter_list|)
name|tree
name|let
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
name|save_constants
argument_list|(
operator|&
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|save_constants_in_decl_trees
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.     We always return an rtx that is similar to that incoming rtx, with the    exception of possibly changing a REG to a SUBREG or vice versa.  No    rtl is ever emitted.     Handle constants that need to be placed in the constant pool by    calling `force_const_mem'.  */
end_comment

begin_function
name|rtx
name|copy_rtx_and_substitute
parameter_list|(
name|orig
parameter_list|,
name|map
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|orig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If the stack pointer register shows up, it must be part of 	 stack-adjustments (*not* because we eliminated the frame pointer!). 	 Small hard registers are returned as-is.  Pseudo-registers 	 go through their `reg_map'.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
comment|/* Some hard registers are also mapped, 	     but others are not translated.  */
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
return|return
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
return|;
comment|/* If this is the virtual frame pointer, make space in current 	     function's stack frame for the stack frame of the inline function.  	     Copy the address of this area into a pseudo.  Map 	     virtual_stack_vars_rtx to this pseudo and set up a constant 	     equivalence for it to be the address.  This will substitute the 	     address into insns where it can be substituted and use the new 	     pseudo where it can't.  */
if|if
condition|(
name|regno
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
condition|)
block|{
name|rtx
name|loc
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|size
init|=
name|DECL_FRAME_SIZE
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
comment|/* In this case, virtual_stack_vars_rtx points to one byte 		 higher than the top of the frame area.  So make sure we 		 allocate a big enough chunk to keep the frame pointer 		 aligned like a real one.  */
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|start_sequence
argument_list|()
expr_stmt|;
name|loc
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|loc
operator|=
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
comment|/* In this case, virtual_stack_vars_rtx points to one byte 		 higher than the top of the frame area.  So compute the offset 		 to one byte higher than our substitute frame.  */
name|loc
operator|=
name|plus_constant
argument_list|(
name|loc
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|loc
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|loc
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|map
operator|->
name|insns_at_start
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
condition|)
block|{
comment|/* Do the same for a block to contain any arguments referenced 		 in memory.  */
name|rtx
name|loc
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|size
init|=
name|FUNCTION_ARGS_SIZE
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|loc
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|loc
operator|=
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When arguments grow downward, the virtual incoming  		 args pointer points to the top of the argument block, 		 so the remapped location better do the same.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|loc
operator|=
name|plus_constant
argument_list|(
name|loc
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|loc
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|loc
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|map
operator|->
name|insns_at_start
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
comment|/* This is a reference to the function return value.  If 		 the function doesn't have a return value, error.  If the 		 mode doesn't agree, and it ain't BLKmode, make a SUBREG.  */
if|if
condition|(
name|map
operator|->
name|inline_target
operator|==
literal|0
condition|)
comment|/* Must be unrolling loops or replicating code if we 		   reach here, so return the register unchanged.  */
return|return
name|orig
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|map
operator|->
name|inline_target
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|map
operator|->
name|inline_target
argument_list|)
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|map
operator|->
name|inline_target
argument_list|)
return|;
else|else
return|return
name|map
operator|->
name|inline_target
return|;
block|}
return|return
name|orig
return|;
block|}
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|==
name|NULL
condition|)
block|{
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|REG_LOOP_TEST_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_LOOP_TEST_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */
if|if
condition|(
name|map
operator|->
name|regno_pointer_flag
index|[
name|regno
index|]
condition|)
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|map
operator|->
name|regno_pointer_align
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
return|;
case|case
name|SUBREG
case|:
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* SUBREG is ordinary, but don't make nested SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|copy
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|orig
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|copy
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|rtx
name|retval
init|=
name|subreg_realpart_p
argument_list|(
name|orig
argument_list|)
condition|?
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
else|:
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|retval
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|retval
return|;
else|else
return|return
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|retval
argument_list|,
operator|(
name|SUBREG_WORD
argument_list|(
name|orig
argument_list|)
operator|%
operator|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|)
operator|/
operator|(
name|unsigned
operator|)
name|UNITS_PER_WORD
operator|)
operator|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy
argument_list|,
name|SUBREG_WORD
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
case|case
name|ADDRESSOF
case|:
name|copy
operator|=
name|gen_rtx_ADDRESSOF
argument_list|(
name|mode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_ADDRESSOF_DECL
argument_list|(
name|copy
argument_list|,
name|ADDRESSOF_DECL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|ADDRESSOF_REGNO
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|REG_LOOP_TEST_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_LOOP_TEST_P
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */
if|if
condition|(
name|map
operator|->
name|regno_pointer_flag
index|[
name|regno
index|]
condition|)
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|map
operator|->
name|regno_pointer_align
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
name|ADDRESSOF_REGNO
argument_list|(
name|copy
argument_list|)
operator|=
name|regno
expr_stmt|;
return|return
name|copy
return|;
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* USE and CLOBBER are ordinary, but we convert (use (subreg foo)) 	 to (use foo) if the original insn didn't have a subreg. 	 Removing the subreg distorts the VAX movstrhi pattern 	 by changing the mode of an operand.  */
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SUBREG
condition|)
name|copy
operator|=
name|SUBREG_REG
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|copy
argument_list|)
return|;
case|case
name|CODE_LABEL
case|:
name|LABEL_PRESERVE_P
argument_list|(
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|)
operator|=
name|LABEL_PRESERVE_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
name|copy
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|mode
argument_list|,
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
condition|?
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
else|:
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* The fact that this label was previously nonlocal does not mean 	 it still is, so we must check if it is within the range of 	 this function's labels.  */
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|copy
argument_list|)
operator|=
operator|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
operator|&&
operator|!
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|get_first_label_num
argument_list|()
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|max_label_num
argument_list|()
operator|)
operator|)
expr_stmt|;
comment|/* If we have made a nonlocal label local, it means that this 	 inlined call will be referring to our nonlocal goto handler. 	 So make sure we create one for this block; we normally would 	 not since this is not otherwise considered a "call".  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|copy
argument_list|)
condition|)
name|function_call_count
operator|++
expr_stmt|;
return|return
name|copy
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
return|return
name|orig
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* Symbols which represent the address of a label stored in the constant 	 pool must be modified to point to a constant pool entry for the 	 remapped label.  Otherwise, symbols are returned unchanged.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|orig
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|constant
argument_list|,
name|map
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_REF_NEED_ADJUST
argument_list|(
name|orig
argument_list|)
condition|)
block|{
name|eif_eh_map
operator|=
name|map
expr_stmt|;
return|return
name|rethrow_symbol_map
argument_list|(
name|orig
argument_list|,
name|expand_inline_function_eh_labelmap
argument_list|)
return|;
block|}
return|return
name|orig
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* We have to make a new copy of this CONST_DOUBLE because don't want 	 to use the old value of CONST_DOUBLE_MEM.  Also, this may be a 	 duplicate of a CONST_DOUBLE we have already seen.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|immed_double_const
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|orig
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|orig
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|CONST
case|:
comment|/* Make new constant pool entry for a constant 	 that was in the pool of the inline function.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
comment|/* If this was an address of a constant pool entry that itself 	     had to be placed in the constant pool, it might not be a 	     valid address.  So the recursive call below might turn it 	     into a register.  In that case, it isn't a constant any 	     more, so return it.  This has the potential of changing a 	     MEM into a REG, but we'll assume that it safe.  */
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|temp
return|;
return|return
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|ADDRESS
case|:
comment|/* If from constant pool address, make new constant pool entry and 	 return its address.  */
if|if
condition|(
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|orig
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Legitimizing the address here is incorrect.  	 The only ADDRESS rtx's that can reach here are ones created by 	 save_constants.  Hence the operand of the ADDRESS is always valid 	 in this position of the instruction, since the original rtx without 	 the ADDRESS was valid.  	 The reason we don't legitimize the address here is that on the 	 Sparc, the caller may have a (high ...) surrounding this ADDRESS. 	 This code forces the operand of the address to a register, which 	 fails because we can not take the HIGH part of a register.  	 Also, change_address may create new registers.  These registers 	 will not have valid reg_map entries.  This can cause try_constants() 	 to fail because assumes that all registers in the rtx have valid 	 reg_map entries, and it may end up replacing one of these new 	 registers with junk.  */
block|if (! memory_address_p (GET_MODE (temp), XEXP (temp, 0))) 	temp = change_address (temp, GET_MODE (temp), XEXP (temp, 0));
endif|#
directive|endif
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|orig
argument_list|)
condition|)
name|temp
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* If a single asm insn contains multiple output operands 	 then it contains multiple ASM_OPERANDS rtx's that share operand 3. 	 We must make sure that the copied insn continues to share it.  */
if|if
condition|(
name|map
operator|->
name|orig_asm_operands_vector
operator|==
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|ASM_OPERANDS
argument_list|)
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|copy
argument_list|,
literal|2
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|3
argument_list|)
operator|=
name|map
operator|->
name|copy_asm_operands_vector
expr_stmt|;
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|4
argument_list|)
operator|=
name|map
operator|->
name|copy_asm_constraints_vector
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|5
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|copy
argument_list|,
literal|6
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
break|break;
case|case
name|CALL
case|:
comment|/* This is given special treatment because the first 	 operand of a CALL is a (MEM ...) which may get 	 forced into a register for cse.  This is undesirable 	 if function-address cse isn't wanted or if we won't do cse.  */
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
operator|!
operator|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
operator|)
condition|)
endif|#
directive|endif
return|return
name|gen_rtx_CALL
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|)
return|;
break|break;
if|#
directive|if
literal|0
comment|/* Must be ifdefed out for loop unrolling to work.  */
block|case RETURN:       abort ();
endif|#
directive|endif
case|case
name|SET
case|:
comment|/* If this is setting fp or ap, it means that we have a nonlocal goto. 	 Adjust the setting by the offset of the area we made. 	 If the nonlocal goto is into the current function, 	 this will result in unnecessarily bad code, but should work.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|SET_DEST
argument_list|(
name|orig
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
block|{
comment|/* In case a translation hasn't occurred already, make one now. */
name|rtx
name|equiv_reg
decl_stmt|;
name|rtx
name|equiv_loc
decl_stmt|;
name|HOST_WIDE_INT
name|loc_offset
decl_stmt|;
name|copy_rtx_and_substitute
argument_list|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|equiv_reg
operator|=
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|equiv_loc
operator|=
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|REGNO
argument_list|(
name|equiv_reg
argument_list|)
argument_list|)
operator|.
name|rtx
expr_stmt|;
name|loc_offset
operator|=
name|GET_CODE
argument_list|(
name|equiv_loc
argument_list|)
operator|==
name|REG
condition|?
literal|0
else|:
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|equiv_loc
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|SET_SRC
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|,
operator|-
name|loc_offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|MEM
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|MEM
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|copy
argument_list|,
name|orig
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|copy
argument_list|)
operator|=
name|MEM_ALIAS_SET
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* If doing function inlining, this MEM might not be const in the 	 function that it is being inlined into, and thus may not be 	 unchanging after function inlining.  Constant pool references are 	 handled elsewhere, so this doesn't lose RTX_UNCHANGING_P bits 	 for them.  */
if|if
condition|(
operator|!
name|map
operator|->
name|integrating
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|copy
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
operator|&&
name|map
operator|->
name|orig_asm_operands_vector
operator|==
literal|0
condition|)
block|{
name|map
operator|->
name|orig_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|map
operator|->
name|copy_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|map
operator|->
name|copy_asm_constraints_vector
operator|=
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute known constant values into INSN, if that is valid.  */
end_comment

begin_function
name|void
name|try_constants
parameter_list|(
name|insn
parameter_list|,
name|map
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|map
operator|->
name|num_sets
operator|=
literal|0
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Apply the changes if they are valid; otherwise discard them.  */
name|apply_change_group
argument_list|()
expr_stmt|;
comment|/* Show we don't know the value of anything stored or clobbered.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_stores
argument_list|)
expr_stmt|;
name|map
operator|->
name|last_pc_value
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|map
operator|->
name|last_cc0_value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set up any constant equivalences made in this insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|num_sets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
decl_stmt|;
name|MAYBE_EXTEND_CONST_EQUIV_VARRAY
argument_list|(
name|map
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|.
name|rtx
operator|==
literal|0
comment|/* Following clause is a hack to make case work where GNU C++ 		 reassigns a variable to make cse work right.  */
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|.
name|rtx
argument_list|,
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
argument_list|)
condition|)
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|,
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
argument_list|,
name|map
operator|->
name|const_age
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
operator|==
name|pc_rtx
condition|)
name|map
operator|->
name|last_pc_value
operator|=
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
elseif|else
if|if
condition|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
operator|==
name|cc0_rtx
condition|)
name|map
operator|->
name|last_cc0_value
operator|=
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute known constants for pseudo regs in the contents of LOC,    which are part of INSN.    If INSN is zero, the substitution should always be done (this is used to    update DECL_RTL).    These changes are taken out by try_constants if the result is not valid.     Note that we are more concerned with determining when the result of a SET    is a constant, for further propagation, than actually inserting constants    into insns; cse will do the latter task better.     This function is also used to adjust address of items previously addressed    via the virtual stack variable or virtual incoming arguments registers.  */
end_comment

begin_function
specifier|static
name|void
name|subst_constants
parameter_list|(
name|loc
parameter_list|,
name|insn
parameter_list|,
name|map
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|num_changes
init|=
name|num_validated_changes
argument_list|()
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|op0_mode
init|=
name|MAX_MACHINE_MODE
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDRESS
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|map
operator|->
name|last_cc0_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* The only thing we can do with a USE or CLOBBER is possibly do 	 some substitutions in a MEM within it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
comment|/* Substitute for parms and known constants.  Don't replace 	 hard regs used as user variables with constants.  */
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|const_equiv_data
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_USERVAR_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|regno
operator|<
name|VARRAY_SIZE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
operator|&&
operator|(
name|p
operator|=
operator|&
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|,
name|p
operator|->
name|rtx
operator|!=
literal|0
operator|)
operator|&&
name|p
operator|->
name|age
operator|>=
name|map
operator|->
name|const_age
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|p
operator|->
name|rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|SUBREG
case|:
comment|/* SUBREG applied to something other than a reg 	 should be treated as ordinary, since that must 	 be a special hack and we don't know how to treat it specially. 	 Consider for example mulsidi3 in m68k.md. 	 Ordinary SUBREG of a REG needs this special treatment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
comment|/* We can't call subst_constants on&SUBREG_REG (x) because any 	     constant or SUBREG wouldn't be valid inside our SUBEG.  Instead, 	     see what is inside, try to form the new SUBREG and see if that is 	     valid.  We handle two cases: extracting a full word in an  	     integral mode and extracting the low part.  */
name|subst_constants
argument_list|(
operator|&
name|inner
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|new
operator|=
name|operand_subword
argument_list|(
name|inner
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cancel_changes
argument_list|(
name|num_changes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
name|new
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MEM
case|:
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* If a memory address got spoiled, change it back.  */
if|if
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|num_validated_changes
argument_list|()
operator|!=
name|num_changes
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|cancel_changes
argument_list|(
name|num_changes
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
comment|/* Substitute constants in our source, and in any arguments to a 	   complex (e..g, ZERO_EXTRACT) destination, but not in the destination 	   itself.  */
name|rtx
modifier|*
name|dest_loc
init|=
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
operator|*
name|dest_loc
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|tem
decl_stmt|;
name|subst_constants
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|dest_loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do substitute in the address of a destination in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|MEM
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Check for the case of DEST a SUBREG, both it and the underlying 	   register are less than one word, and the SUBREG has the wider mode. 	   In the case, we are really setting the underlying register to the 	   source converted to the mode of DEST.  So indicate that.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|src
argument_list|)
operator|)
condition|)
name|src
operator|=
name|tem
operator|,
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If storing a recognizable value save it for later recording.  */
if|if
condition|(
operator|(
name|map
operator|->
name|num_sets
operator|<
name|MAX_RECOG_OPERANDS
operator|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
operator|||
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|dest
operator|==
name|cc0_rtx
endif|#
directive|endif
operator|||
operator|(
name|dest
operator|==
name|pc_rtx
operator|&&
operator|(
name|src
operator|==
name|pc_rtx
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|RETURN
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Normally, this copy won't do anything.  But, if SRC is a COMPARE 	       it will cause us to save the COMPARE with any constants 	       substituted, which is what we want for later.  */
name|map
operator|->
name|equiv_sets
index|[
name|map
operator|->
name|num_sets
index|]
operator|.
name|equiv
operator|=
name|copy_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|map
operator|->
name|equiv_sets
index|[
name|map
operator|->
name|num_sets
operator|++
index|]
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
block|}
block|}
return|return;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* If the first operand is an expression, save its mode for later.  */
if|if
condition|(
operator|*
name|format_ptr
operator|==
literal|'e'
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|subst_constants
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If this is a commutative operation, move a constant to the second      operand unless the second operand is already a CONST_INT.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Simplify the expression in case we put in some constants.  */
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
if|if
condition|(
name|op0_mode
operator|==
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0_mode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|op_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|new
operator|=
operator|(
operator|(
name|new
operator|==
name|const0_rtx
operator|)
condition|?
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'3'
case|:
if|if
condition|(
name|op0_mode
operator|==
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show that register modified no longer contain known constants.  We are    called from note_stores with parts of the new insn.  */
end_comment

begin_function
name|void
name|mark_stores
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* DEST is always the innermost thing set, except in the case of      SUBREGs of hard registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|,
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|int
name|last_reg
init|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Ignore virtual stack var or virtual arg register since those 	 are handled separately.  */
if|if
condition|(
name|regno
operator|!=
name|VIRTUAL_INCOMING_ARGS_REGNUM
operator|&&
name|regno
operator|!=
name|VIRTUAL_STACK_VARS_REGNUM
condition|)
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<=
name|last_reg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|VARRAY_SIZE
argument_list|(
name|global_const_equiv_varray
argument_list|)
condition|)
name|VARRAY_CONST_EQUIV
argument_list|(
name|global_const_equiv_varray
argument_list|,
name|i
argument_list|)
operator|.
name|rtx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If any CONST expressions with RTX_INTEGRATED_P are present in the rtx    pointed to by PX, they represent constants in the constant pool.    Replace these with a new memory reference obtained from force_const_mem.    Similarly, ADDRESS expressions with RTX_INTEGRATED_P represent the    address of a constant pool entry.  Replace them with the address of    a new constant pool entry obtained from force_const_mem.  */
end_comment

begin_function
specifier|static
name|void
name|restore_constants
parameter_list|(
name|px
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* We have to make a new CONST_DOUBLE to ensure that we account for 	 it correctly.  Using the old CONST_DOUBLE_MEM data is wrong.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|px
operator|=
name|immed_double_const
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|restore_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* This must be (subreg/i:M1 (const/i:M2 ...) 0).  */
name|rtx
name|new
init|=
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|restore_constants
argument_list|(
operator|&
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|validize_mem
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESS
condition|)
block|{
name|rtx
name|new
init|=
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|new
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|px
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|restore_constants
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|restore_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so    that it points to the node itself, thus indicating that the node is its    own (abstract) origin.  Additionally, if the BLOCK_ABSTRACT_ORIGIN for    the given node is NULL, recursively descend the decl/block tree which    it is the root of, and for each other ..._DECL or BLOCK node contained    therein whose DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also    still NULL, set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN    values to point to themselves.  */
end_comment

begin_function
specifier|static
name|void
name|set_block_origin_self
parameter_list|(
name|stmt
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
block|{
if|if
condition|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|stmt
expr_stmt|;
block|{
specifier|register
name|tree
name|local_decl
decl_stmt|;
for|for
control|(
name|local_decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|local_decl
operator|!=
name|NULL_TREE
condition|;
name|local_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|local_decl
argument_list|)
control|)
name|set_decl_origin_self
argument_list|(
name|local_decl
argument_list|)
expr_stmt|;
comment|/* Potential recursion.  */
block|}
block|{
specifier|register
name|tree
name|subblock
decl_stmt|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblock
operator|!=
name|NULL_TREE
condition|;
name|subblock
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|set_block_origin_self
argument_list|(
name|subblock
argument_list|)
expr_stmt|;
comment|/* Recurse.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL node, if the DECL_ABSTRACT_ORIGIN for    the given ..._DECL node is NULL, set the DECL_ABSTRACT_ORIGIN for the    node to so that it points to the node itself, thus indicating that the    node represents its own (abstract) origin.  Additionally, if the    DECL_ABSTRACT_ORIGIN for the given node is NULL, recursively descend    the decl/block tree of which the given node is the root of, and for    each other ..._DECL or BLOCK node contained therein whose    DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also still NULL,    set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN values to    point to themselves.  */
end_comment

begin_function
specifier|static
name|void
name|set_decl_origin_self
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|register
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|arg
argument_list|)
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|set_block_origin_self
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to some BLOCK node, and a boolean value to set the    "abstract" flags to, set that value into the BLOCK_ABSTRACT flag for    the given block, and for all local decls and all local sub-blocks    (recursively) which are contained therein.  */
end_comment

begin_function
specifier|static
name|void
name|set_block_abstract_flags
parameter_list|(
name|stmt
parameter_list|,
name|setting
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
specifier|register
name|int
name|setting
decl_stmt|;
block|{
specifier|register
name|tree
name|local_decl
decl_stmt|;
specifier|register
name|tree
name|subblock
decl_stmt|;
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
operator|=
name|setting
expr_stmt|;
for|for
control|(
name|local_decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|local_decl
operator|!=
name|NULL_TREE
condition|;
name|local_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|local_decl
argument_list|)
control|)
name|set_decl_abstract_flags
argument_list|(
name|local_decl
argument_list|,
name|setting
argument_list|)
expr_stmt|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblock
operator|!=
name|NULL_TREE
condition|;
name|subblock
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|set_block_abstract_flags
argument_list|(
name|subblock
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL node, and a boolean value to set the    "abstract" flags to, set that value into the DECL_ABSTRACT flag for the    given decl, and (in the case where the decl is a FUNCTION_DECL) also    set the abstract flags for all of the parameters, local vars, local    blocks and sub-blocks (recursively) to the same setting.  */
end_comment

begin_function
name|void
name|set_decl_abstract_flags
parameter_list|(
name|decl
parameter_list|,
name|setting
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|int
name|setting
decl_stmt|;
block|{
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|register
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|DECL_ABSTRACT
argument_list|(
name|arg
argument_list|)
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|set_block_abstract_flags
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the assembly language code for the function FNDECL    from its DECL_SAVED_INSNS.  Used for inline functions that are output    at end of compilation instead of where they came in the source.  */
end_comment

begin_function
name|void
name|output_inline_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|head
decl_stmt|;
name|rtx
name|last
decl_stmt|;
comment|/* Things we allocate from here on are part of this function, not      permanent.  */
name|temporary_allocation
argument_list|()
expr_stmt|;
name|head
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
comment|/* This call is only used to initialize global variables.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
literal|"lossage"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Redo parameter determinations in case the FUNCTION_...      macros took machine-specific actions that need to be redone.  */
name|assign_parms
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set stack frame size.  */
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The first is a bit of a lie (the array may be larger), but doesn't      matter too much and it isn't worth saving the actual bound.  */
name|reg_rtx_no
operator|=
name|regno_pointer_flag_length
operator|=
name|MAX_REGNUM
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
operator|(
name|rtx
operator|*
operator|)
name|INLINE_REGNO_REG_RTX
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|regno_pointer_flag
operator|=
name|INLINE_REGNO_POINTER_FLAG
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|regno_pointer_align
operator|=
name|INLINE_REGNO_POINTER_ALIGN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|max_parm_reg
operator|=
name|MAX_PARMREG
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|PARMREG_STACK_LOC
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|STACK_SLOT_LIST
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|forced_labels
operator|=
name|FORCED_LABELS
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_HAS_COMPUTED_JUMP
condition|)
name|current_function_has_computed_jump
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_ALLOCA
condition|)
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_SETJMP
condition|)
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_LONGJMP
condition|)
name|current_function_calls_longjmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_RETURNS_STRUCT
condition|)
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_RETURNS_PCC_STRUCT
condition|)
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_NEEDS_CONTEXT
condition|)
name|current_function_needs_context
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_HAS_NONLOCAL_LABEL
condition|)
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_RETURNS_POINTER
condition|)
name|current_function_returns_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_USES_CONST_POOL
condition|)
name|current_function_uses_const_pool
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE
condition|)
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|current_function_outgoing_args_size
operator|=
name|OUTGOING_ARGS_SIZE
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|current_function_pops_args
operator|=
name|POPS_ARGS
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* This is the only thing the expand_function_end call that uses to be here      actually does and that call can cause problems.  */
name|immediate_size_expand
operator|--
expr_stmt|;
comment|/* Find last insn and rebuild the constant pool.  */
for|for
control|(
name|last
operator|=
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|restore_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|restore_constants
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|set_new_first_and_last_insn
argument_list|(
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|set_new_first_and_last_label_num
argument_list|(
name|FIRST_LABELNO
argument_list|(
name|head
argument_list|)
argument_list|,
name|LAST_LABELNO
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must have already output DWARF debugging information for the      original (abstract) inline function declaration/definition, so      we want to make sure that the debugging information we generate      for this special instance of the inline function refers back to      the information we already generated.  To make sure that happens,      we simply have to set the DECL_ABSTRACT_ORIGIN for the function      node (and for all of the local ..._DECL nodes which are its children)      so that they all point to themselves.  */
name|set_decl_origin_self
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* We're not deferring this any longer.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We can't inline this anymore.  */
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Compile this function all the way down to assembly code.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

