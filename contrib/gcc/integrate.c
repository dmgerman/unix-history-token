begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Procedure integration for GCC.    Copyright (C) 1988, 1991, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but round to the next highest integer that meets the    alignment.  */
end_comment

begin_define
define|#
directive|define
name|CEIL_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|(((VALUE) + (ALIGN) - 1)& ~((ALIGN)- 1))
end_define

begin_comment
comment|/* Default max number of insns a function can have and still be inline.    This is overridden on RISC machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATE_THRESHOLD
end_ifndef

begin_comment
comment|/* Inlining small functions might save more space then not inlining at    all.  Assume 1 instruction for the call and 1.5 insns per argument.  */
end_comment

begin_define
define|#
directive|define
name|INTEGRATE_THRESHOLD
parameter_list|(
name|DECL
parameter_list|)
define|\
value|(optimize_size \    ? (1 + (3 * list_length (DECL_ARGUMENTS (DECL))) / 2) \    : (8 * (8 + list_length (DECL_ARGUMENTS (DECL)))))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Private type used by {get/has}_func_hard_reg_initial_val.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|initial_value_pair
block|{
name|rtx
name|hard_reg
decl_stmt|;
name|rtx
name|pseudo
decl_stmt|;
block|}
name|initial_value_pair
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|initial_value_struct
block|{
name|int
name|num_entries
decl_stmt|;
name|int
name|max_entries
decl_stmt|;
name|initial_value_pair
modifier|*
name|entries
decl_stmt|;
block|}
name|initial_value_struct
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|setup_initial_hard_reg_value_integration
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|,
expr|struct
name|inline_remap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtvec
name|initialize_for_inline
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_modified_parmregs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|integrate_parm_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|inline_remap
operator|*
operator|,
name|rtvec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|integrate_decl_tree
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|inline_remap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subst_constants
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
expr|struct
name|inline_remap
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_block_origin_self
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_block_abstract_flags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_reg_param
name|PARAMS
argument_list|(
operator|(
expr|struct
name|inline_remap
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_decl_abstract_flags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_stores
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_parm_insns
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_insn_list
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|inline_remap
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_insn_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|inline_remap
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_blocks
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_block
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by copy_rtx_and_substitute; this indicates whether the function is    called for the purpose of inlining or some other purpose (i.e. loop    unrolling).  This affects how constant pool references are handled.    This variable contains the FUNCTION_DECL for the inlined function.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|function
modifier|*
name|inlining
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns the Ith entry in the label_map contained in MAP.  If the    Ith entry has not yet been set, return a fresh label.  This function    performs a lazy initialization of label_map, thereby avoiding huge memory    explosions when the label_map gets very large.  */
end_comment

begin_function
name|rtx
name|get_label_from_map
parameter_list|(
name|map
parameter_list|,
name|i
parameter_list|)
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|map
operator|->
name|label_map
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
name|x
operator|=
name|map
operator|->
name|label_map
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return false if the function FNDECL cannot be inlined on account of its    attributes, true otherwise.  */
end_comment

begin_function
name|bool
name|function_attribute_inlinable_p
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|bool
name|has_machine_attr
init|=
name|false
decl_stmt|;
name|tree
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|fndecl
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|targetm
operator|.
name|attribute_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
name|targetm
operator|.
name|attribute_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|has_machine_attr
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|has_machine_attr
condition|)
break|break;
block|}
if|if
condition|(
name|has_machine_attr
condition|)
return|return
call|(
modifier|*
name|targetm
operator|.
name|function_attribute_inlinable_p
call|)
argument_list|(
name|fndecl
argument_list|)
return|;
else|else
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Zero if the current function (whose FUNCTION_DECL is FNDECL)    is safe and reasonable to integrate into other functions.    Nonzero means value is a warning msgid with a single %s    for the function's name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|function_cannot_inline_p
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For functions marked as inline increase the maximum size to      MAX_INLINE_INSNS (-finline-limit-<n>).  For regular functions      use the limit given by INTEGRATE_THRESHOLD.  */
name|int
name|max_insns
init|=
operator|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|?
operator|(
name|MAX_INLINE_INSNS
operator|+
literal|8
operator|*
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
else|:
name|INTEGRATE_THRESHOLD
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|int
name|ninsns
init|=
literal|0
decl_stmt|;
name|tree
name|parms
decl_stmt|;
if|if
condition|(
name|DECL_UNINLINABLE
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|N_
argument_list|(
literal|"function cannot be inline"
argument_list|)
return|;
comment|/* No inlines with varargs.  */
if|if
condition|(
operator|(
name|last
operator|&&
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|||
name|current_function_varargs
condition|)
return|return
name|N_
argument_list|(
literal|"varargs function cannot be inline"
argument_list|)
return|;
if|if
condition|(
name|current_function_calls_alloca
condition|)
return|return
name|N_
argument_list|(
literal|"function using alloca cannot be inline"
argument_list|)
return|;
if|if
condition|(
name|current_function_calls_setjmp
condition|)
return|return
name|N_
argument_list|(
literal|"function using setjmp cannot be inline"
argument_list|)
return|;
if|if
condition|(
name|current_function_calls_eh_return
condition|)
return|return
name|N_
argument_list|(
literal|"function uses __builtin_eh_return"
argument_list|)
return|;
if|if
condition|(
name|current_function_contains_functions
condition|)
return|return
name|N_
argument_list|(
literal|"function with nested functions cannot be inline"
argument_list|)
return|;
if|if
condition|(
name|forced_labels
condition|)
return|return
name|N_
argument_list|(
literal|"function with label addresses used in initializers cannot inline"
argument_list|)
return|;
if|if
condition|(
name|current_function_cannot_inline
condition|)
return|return
name|current_function_cannot_inline
return|;
comment|/* If its not even close, don't even look.  */
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
literal|3
operator|*
name|max_insns
condition|)
return|return
name|N_
argument_list|(
literal|"function too large to be inline"
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* Don't inline functions which do not specify a function prototype and      have BLKmode argument or take the address of a parameter.  */
block|for (parms = DECL_ARGUMENTS (fndecl); parms; parms = TREE_CHAIN (parms))     {       if (TYPE_MODE (TREE_TYPE (parms)) == BLKmode) 	TREE_ADDRESSABLE (parms) = 1;       if (last == NULL_TREE&& TREE_ADDRESSABLE (parms)) 	return N_("no prototype, and parameter address used; cannot be inline");     }
endif|#
directive|endif
comment|/* We can't inline functions that return structures      the old-fashioned PCC way, copying into a static block.  */
if|if
condition|(
name|current_function_returns_pcc_struct
condition|)
return|return
name|N_
argument_list|(
literal|"inline functions not supported for this return value type"
argument_list|)
return|;
comment|/* We can't inline functions that return structures of varying size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|N_
argument_list|(
literal|"function with varying-size return value cannot be inline"
argument_list|)
return|;
comment|/* Cannot inline a function with a varying size argument or one that      receives a transparent union.  */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|N_
argument_list|(
literal|"function with varying-size parameter cannot be inline"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
return|return
name|N_
argument_list|(
literal|"function with transparent unit parameter cannot be inline"
argument_list|)
return|;
block|}
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
name|max_insns
condition|)
block|{
for|for
control|(
name|ninsns
operator|=
literal|0
operator|,
name|insn
operator|=
name|get_first_nonparm_insn
argument_list|()
init|;
name|insn
operator|&&
name|ninsns
operator|<
name|max_insns
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|ninsns
operator|++
expr_stmt|;
if|if
condition|(
name|ninsns
operator|>=
name|max_insns
condition|)
return|return
name|N_
argument_list|(
literal|"function too large to be inline"
argument_list|)
return|;
block|}
comment|/* We will not inline a function which uses computed goto.  The addresses of      its local labels, which may be tucked into global storage, are of course      not constant across instantiations, which causes unexpected behaviour.  */
if|if
condition|(
name|current_function_has_computed_jump
condition|)
return|return
name|N_
argument_list|(
literal|"function with computed jump cannot inline"
argument_list|)
return|;
comment|/* We cannot inline a nested function that jumps to a nonlocal label.  */
if|if
condition|(
name|current_function_has_nonlocal_goto
condition|)
return|return
name|N_
argument_list|(
literal|"function with nonlocal goto cannot be inline"
argument_list|)
return|;
comment|/* We can't inline functions that return a PARALLEL rtx.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|result
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
name|N_
argument_list|(
literal|"inline functions not supported for this return value type"
argument_list|)
return|;
block|}
comment|/* If the function has a target specific attribute attached to it,      then we assume that we should not inline it.  This can be overriden      by the target if it defines TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P.  */
if|if
condition|(
operator|!
name|function_attribute_inlinable_p
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|N_
argument_list|(
literal|"function with target specific attribute(s) cannot be inlined"
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Map pseudo reg number into the PARM_DECL for the parm living in the reg.    Zero for a reg that isn't a parm's home.    Only reg numbers less than max_parm_reg are mapped here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|parmdecl_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In save_for_inline, nonzero if past the parm-initialization insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_nonparm_insns
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Subroutine for `save_for_inline'.  Performs initialization    needed to save FNDECL's insns and info for future inline expansion.  */
end_comment

begin_function
specifier|static
name|rtvec
name|initialize_for_inline
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtvec
name|arg_vector
decl_stmt|;
name|tree
name|parms
decl_stmt|;
comment|/* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parmdecl_map
argument_list|,
literal|0
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|arg_vector
operator|=
name|rtvec_alloc
argument_list|(
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|rtx
name|p
init|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
decl_stmt|;
comment|/* If we have (mem (addressof (mem ...))), use the inner MEM since 	 otherwise the copy_rtx call below will not unshare the MEM since 	 it shares ADDRESSOF.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|REG
condition|)
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|p
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|rtx
name|preal
init|=
name|gen_realpart
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|rtx
name|pimag
init|=
name|gen_imagpart
argument_list|(
name|GET_MODE
argument_list|(
name|preal
argument_list|)
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|preal
argument_list|)
operator|==
name|REG
condition|)
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|preal
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pimag
argument_list|)
operator|==
name|REG
condition|)
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|pimag
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
block|}
comment|/* This flag is cleared later 	 if the function ever modifies the value of the parm.  */
name|TREE_READONLY
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|arg_vector
return|;
block|}
end_function

begin_comment
comment|/* Copy NODE (which must be a DECL, but not a PARM_DECL).  The DECL    originally was in the FROM_FN, but now it will be in the    TO_FN.  */
end_comment

begin_function
name|tree
name|copy_decl_for_inlining
parameter_list|(
name|decl
parameter_list|,
name|from_fn
parameter_list|,
name|to_fn
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|from_fn
decl_stmt|;
name|tree
name|to_fn
decl_stmt|;
block|{
name|tree
name|copy
decl_stmt|;
comment|/* Copy the declaration.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
comment|/* For a parameter, we must make an equivalent VAR_DECL, not a 	 new PARM_DECL.  */
name|copy
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|copy
argument_list|)
condition|)
name|copy_lang_decl
argument_list|(
name|copy
argument_list|)
expr_stmt|;
comment|/* TREE_ADDRESSABLE isn't used to indicate that a label's 	 address has been taken; it's for internal bookkeeping in 	 expand_goto_internal.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|copy
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set the DECL_ABSTRACT_ORIGIN so the debugging routines know what      declaration inspired this copy.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The new variable/label has no RTL, yet.  */
name|SET_DECL_RTL
argument_list|(
name|copy
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Set the context for the new declaration.  */
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Globals stay global.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|from_fn
condition|)
comment|/* Things that weren't in the scope of the function we're inlining        from aren't in the scope we're inlining too, either.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Function-scoped static variables should say in the original        function.  */
empty_stmt|;
else|else
comment|/* Ordinary automatic local variables are now in the scope of the        new function.  */
name|DECL_CONTEXT
argument_list|(
name|copy
argument_list|)
operator|=
name|to_fn
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Make the insns and PARM_DECLs of the current function permanent    and record other information in DECL_SAVED_INSNS to allow inlining    of this function in subsequent calls.     This routine need not copy any insns because we are not going    to immediately compile the insns in the insn chain.  There    are two cases when we would compile the insns for FNDECL:    (1) when FNDECL is expanded inline, and (2) when FNDECL needs to    be output at the end of other compilation, because somebody took    its address.  In the first case, the insns of FNDECL are copied    as it is expanded inline, so FNDECL's saved insns are not    modified.  In the second case, FNDECL is used for the last time,    so modifying the rtl is not a problem.     We don't have to worry about FNDECL being inline expanded by    other functions which are written at the end of compilation    because flag_no_inline is turned on when we begin writing    functions at the end of compilation.  */
end_comment

begin_function
name|void
name|save_for_inline
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtvec
name|argvec
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
comment|/* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.      Later we set TREE_READONLY to 0 if the parm is modified inside the fn.      Also set up ARG_VECTOR, which holds the unmodified DECL_RTX values      for the parms, prior to elimination of virtual registers.      These values are needed for substituting parms properly.  */
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
name|parmdecl_map
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make and emit a return-label if we have not already done so.  */
if|if
condition|(
name|return_label
operator|==
literal|0
condition|)
block|{
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
name|argvec
operator|=
name|initialize_for_inline
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|argvec
operator|=
name|NULL
expr_stmt|;
comment|/* Delete basic block notes created by early run of find_basic_block.      The notes would be later used by find_basic_blocks to reuse the memory      for basic_block structures on already freed obstack.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If there are insns that copy parms from the stack into pseudo registers,      those insns are not copied.  `expand_inline_function' must      emit the correct code to handle such things.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
block|{
comment|/* Get the insn which signals the end of parameter setup code.  */
name|first_nonparm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
comment|/* Now just scan the chain of insns to see what happens to our 	 PARM_DECLs.  If a PARM_DECL is used but never modified, we 	 can substitute its rtl directly when expanding inline (and 	 perform constant folding when its incoming value is 	 constant).  Otherwise, we have to copy its value into a new 	 register and track the new register's life.  */
name|in_nonparm_insns
operator|=
literal|0
expr_stmt|;
name|save_parm_insns
argument_list|(
name|insn
argument_list|,
name|first_nonparm_insn
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|inl_max_label_num
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|inl_last_parm_insn
operator|=
name|cfun
operator|->
name|x_last_parm_insn
expr_stmt|;
name|cfun
operator|->
name|original_arg_vector
operator|=
name|argvec
expr_stmt|;
block|}
name|cfun
operator|->
name|original_decl_initial
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|no_debugging_symbols
operator|=
operator|(
name|write_symbols
operator|==
name|NO_DEBUG
operator|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|cfun
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
name|free
argument_list|(
name|parmdecl_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the chain of insns to see what happens to our PARM_DECLs.  If a    PARM_DECL is used but never modified, we can substitute its rtl directly    when expanding inline (and perform constant folding when its incoming    value is constant). Otherwise, we have to copy its value into a new    register and track the new register's life.  */
end_comment

begin_function
specifier|static
name|void
name|save_parm_insns
parameter_list|(
name|insn
parameter_list|,
name|first_nonparm_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
return|return;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|first_nonparm_insn
condition|)
name|in_nonparm_insns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Record what interesting things happen to our parameters.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_modified_parmregs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a CALL_PLACEHOLDER insn then we need to look into the 	     three attached sequences: normal call, sibling call and tail 	     recursion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|save_parm_insns
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|first_nonparm_insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note whether a parameter is modified or not.  */
end_comment

begin_function
specifier|static
name|void
name|note_modified_parmregs
parameter_list|(
name|reg
parameter_list|,
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|in_nonparm_insns
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|max_parm_reg
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|TREE_READONLY
argument_list|(
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unfortunately, we need a global copy of const_equiv map for communication    with a function called from note_stores.  Be *very* careful that this    is used properly in the presence of recursion.  */
end_comment

begin_decl_stmt
name|varray_type
name|global_const_equiv_varray
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|FIXED_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT	\&& GET_CODE (XEXP (X, 0)) == REG				\&& REGNO (XEXP (X, 0))>= FIRST_VIRTUAL_REGISTER		\&& REGNO (XEXP (X, 0))<= LAST_VIRTUAL_REGISTER)
end_define

begin_comment
comment|/* Called to set up a mapping for the case where a parameter is in a    register.  If it is read-only and our argument is a constant, set up the    constant equivalence.     If LOC is REG_USERVAR_P, the usual case, COPY must also have that flag set    if it is a register.     Also, don't allow hard registers here; they might not be valid when    substituted into insns.  */
end_comment

begin_function
specifier|static
name|void
name|process_reg_param
parameter_list|(
name|map
parameter_list|,
name|loc
parameter_list|,
name|copy
parameter_list|)
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtx
name|loc
decl_stmt|,
name|copy
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|SUBREG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|REG
operator|&&
name|REG_USERVAR_P
argument_list|(
name|loc
argument_list|)
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|copy
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|copy
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|copy_to_mode_reg
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|copy
argument_list|)
decl_stmt|;
name|REG_USERVAR_P
argument_list|(
name|temp
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|copy
argument_list|)
condition|)
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|copy
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|copy
operator|=
name|temp
expr_stmt|;
block|}
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare two BLOCKs for qsort.  The key we sort on is the    BLOCK_ABSTRACT_ORIGIN of the blocks.  */
end_comment

begin_function
specifier|static
name|int
name|compare_blocks
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
specifier|const
name|PTR
name|v1
decl_stmt|;
specifier|const
name|PTR
name|v2
decl_stmt|;
block|{
name|tree
name|b1
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|v1
operator|)
decl_stmt|;
name|tree
name|b2
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|v2
operator|)
decl_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|b1
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|b2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two BLOCKs for bsearch.  The first pointer corresponds to    an original block; the second to a remapped equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|find_block
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
specifier|const
name|PTR
name|v1
decl_stmt|;
specifier|const
name|PTR
name|v2
decl_stmt|;
block|{
specifier|const
name|union
name|tree_node
modifier|*
name|b1
init|=
operator|(
specifier|const
expr|union
name|tree_node
operator|*
operator|)
name|v1
decl_stmt|;
name|tree
name|b2
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|v2
operator|)
decl_stmt|;
return|return
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|b1
operator|-
operator|(
name|char
operator|*
operator|)
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|b2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Integrate the procedure defined by FNDECL.  Note that this function    may wind up calling itself.  Since the static variables are not    reentrant, we do not assign them until after the possibility    of recursion is eliminated.     If IGNORE is nonzero, do not produce a value.    Otherwise store the value in TARGET if it is nonzero and that is convenient.     Value is:    (rtx)-1 if we could not substitute the function    0 if we substituted it and it does not produce a value    else an rtx for where the value is stored.  */
end_comment

begin_function
name|rtx
name|expand_inline_function
parameter_list|(
name|fndecl
parameter_list|,
name|parms
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|,
name|type
parameter_list|,
name|structure_value_addr
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|parms
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|structure_value_addr
decl_stmt|;
block|{
name|struct
name|function
modifier|*
name|inlining_previous
decl_stmt|;
name|struct
name|function
modifier|*
name|inl_f
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|formal
decl_stmt|,
name|actual
decl_stmt|,
name|block
decl_stmt|;
name|rtx
name|parm_insns
init|=
name|inl_f
operator|->
name|emit
operator|->
name|x_first_insn
decl_stmt|;
name|rtx
name|insns
init|=
operator|(
name|inl_f
operator|->
name|inl_last_parm_insn
condition|?
name|NEXT_INSN
argument_list|(
name|inl_f
operator|->
name|inl_last_parm_insn
argument_list|)
else|:
name|parm_insns
operator|)
decl_stmt|;
name|tree
modifier|*
name|arg_trees
decl_stmt|;
name|rtx
modifier|*
name|arg_vals
decl_stmt|;
name|int
name|max_regno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|min_labelno
init|=
name|inl_f
operator|->
name|emit
operator|->
name|x_first_label_num
decl_stmt|;
name|int
name|max_labelno
init|=
name|inl_f
operator|->
name|inl_max_label_num
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|rtx
name|loc
decl_stmt|;
name|rtx
name|stack_save
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
init|=
literal|0
decl_stmt|;
name|rtvec
name|arg_vector
init|=
operator|(
name|rtvec
operator|)
name|inl_f
operator|->
name|original_arg_vector
decl_stmt|;
name|rtx
name|static_chain_value
init|=
literal|0
decl_stmt|;
name|int
name|inl_max_uid
decl_stmt|;
name|int
name|eh_region_offset
decl_stmt|;
comment|/* The pointer used to track the true location of the memory used      for MAP->LABEL_MAP.  */
name|rtx
modifier|*
name|real_label_map
init|=
literal|0
decl_stmt|;
comment|/* Allow for equivalences of the pseudos we make for virtual fp and ap.  */
name|max_regno
operator|=
name|inl_f
operator|->
name|emit
operator|->
name|x_reg_rtx_no
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|max_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Pull out the decl for the function definition; fndecl may be a      local declaration, which would break DECL_ABSTRACT_ORIGIN.  */
name|fndecl
operator|=
name|inl_f
operator|->
name|decl
expr_stmt|;
name|nargs
operator|=
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|preferred_stack_boundary
operator|<
name|inl_f
operator|->
name|preferred_stack_boundary
condition|)
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|inl_f
operator|->
name|preferred_stack_boundary
expr_stmt|;
comment|/* Check that the parms type match and that sufficient arguments were      passed.  Since the appropriate conversions or default promotions have      already been applied, the machine modes should match exactly.  */
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
control|)
block|{
name|tree
name|arg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
operator|||
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
comment|/* If they are block mode, the types should match exactly. 	     They don't match exactly if TREE_TYPE (FORMAL) == ERROR_MARK_NODE, 	     which could happen if the parameter has incomplete type.  */
operator|||
operator|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
return|;
block|}
comment|/* Extra arguments are valid, but will be ignored below, so we must      evaluate them here for side-effects.  */
for|for
control|(
init|;
name|actual
condition|;
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Expand the function arguments.  Do this first so that any      new registers get created before we allocate the maps.  */
name|arg_vals
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|arg_trees
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Actual parameter, converted to the type of the argument within the 	 function.  */
name|tree
name|arg
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Mode of the variable used within the function.  */
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|invisiref
init|=
literal|0
decl_stmt|;
name|arg_trees
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If this is an object passed by invisible reference, we copy the 	 object into a stack slot and save its address.  If this will go 	 into memory, we do nothing now.  Otherwise, we just expand the 	 argument.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|rtx
name|stack_slot
init|=
name|assign_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|store_expr
argument_list|(
name|arg
argument_list|,
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_vals
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|invisiref
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|pmode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
name|pmode
operator|=
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|pmode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|pmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The mode if LOC and ARG can differ if LOC was a variable 		 that had its mode promoted via PROMOTED_MODE.  */
name|arg_vals
index|[
name|i
index|]
operator|=
name|convert_modes
argument_list|(
name|pmode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_SUM
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
name|arg_vals
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
block|}
else|else
name|arg_vals
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg_vals
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|TREE_READONLY
argument_list|(
name|formal
argument_list|)
comment|/* If the parameter is not read-only, copy our argument through 		 a register.  Also, we cannot use ARG_VALS[I] if it overlaps 		 TARGET in any way.  In the inline function, they will likely 		 be two different pseudos, and `safe_from_p' will make all 		 sorts of smart assumptions about their not conflicting. 		 But if ARG_VALS[I] overlaps TARGET, these assumptions are 		 wrong, so put ARG_VALS[I] into a fresh register. 		 Don't worry about invisible references, since their stack 		 temps will never overlap the target.  */
operator|||
operator|(
name|target
operator|!=
literal|0
operator|&&
operator|!
name|invisiref
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|,
name|target
argument_list|)
operator|)
comment|/* ??? We must always copy a SUBREG into a REG, because it might 		 get substituted into an address, and not all ports correctly 		 handle SUBREGs in addresses.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
operator|)
condition|)
name|arg_vals
index|[
name|i
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|arg_vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_vals
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the structures we use to remap things.  */
name|map
operator|=
operator|(
expr|struct
name|inline_remap
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inline_remap
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|fndecl
operator|=
name|fndecl
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|map
operator|->
name|block_map
argument_list|,
literal|10
argument_list|,
literal|"block_map"
argument_list|)
expr_stmt|;
name|map
operator|->
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause unpredictable core dumps.  */
name|real_label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|max_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|label_map
operator|=
name|real_label_map
expr_stmt|;
name|map
operator|->
name|local_return_label
operator|=
name|NULL_RTX
expr_stmt|;
name|inl_max_uid
operator|=
operator|(
name|inl_f
operator|->
name|emit
operator|->
name|x_cur_insn_uid
operator|+
literal|1
operator|)
expr_stmt|;
name|map
operator|->
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|inl_max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|min_insnno
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|max_insnno
operator|=
name|inl_max_uid
expr_stmt|;
name|map
operator|->
name|integrating
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|compare_src
operator|=
name|NULL_RTX
expr_stmt|;
name|map
operator|->
name|compare_mode
operator|=
name|VOIDmode
expr_stmt|;
comment|/* const_equiv_varray maps pseudos in our routine to constants, so      it needs to be large enough for all our pseudos.  This is the      number we are currently using plus the number in the called      routine, plus 15 for each arg, five to compute the virtual frame      pointer, and five for the return value.  This should be enough      for most cases.  We do not reference entries outside the range of      the map.       ??? These numbers are quite arbitrary and were obtained by      experimentation.  At some point, we should try to allocate the      table after all the parameters are set up so we an more accurately      estimate the number of pseudos we will need.  */
name|VARRAY_CONST_EQUIV_INIT
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
operator|(
name|max_reg_num
argument_list|()
operator|+
operator|(
name|max_regno
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|+
literal|15
operator|*
name|nargs
operator|+
literal|10
operator|)
argument_list|,
literal|"expand_inline_function"
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|=
literal|0
expr_stmt|;
comment|/* Record the current insn in case we have to set up pointers to frame      and argument memory blocks.  If there are no insns yet, add a dummy      insn that can be used as an insertion point.  */
name|map
operator|->
name|insns_at_start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|insns_at_start
operator|==
literal|0
condition|)
name|map
operator|->
name|insns_at_start
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|map
operator|->
name|regno_pointer_align
operator|=
name|inl_f
operator|->
name|emit
operator|->
name|regno_pointer_align
expr_stmt|;
name|map
operator|->
name|x_regno_reg_rtx
operator|=
name|inl_f
operator|->
name|emit
operator|->
name|x_regno_reg_rtx
expr_stmt|;
comment|/* Update the outgoing argument size to allow for those in the inlined      function.  */
if|if
condition|(
name|inl_f
operator|->
name|outgoing_args_size
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|inl_f
operator|->
name|outgoing_args_size
expr_stmt|;
comment|/* If the inline function needs to make PIC references, that means      that this function's PIC offset table must be used.  */
if|if
condition|(
name|inl_f
operator|->
name|uses_pic_offset_table
condition|)
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
comment|/* If this function needs a context, set it up.  */
if|if
condition|(
name|inl_f
operator|->
name|needs_context
condition|)
name|static_chain_value
operator|=
name|lookup_static_chain
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|parm_insns
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|parm_insns
argument_list|)
operator|>
literal|0
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|parm_insns
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|parm_insns
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Process each argument.  For each, set up things so that the function's      reference to the argument will refer to the argument being passed.      We only replace REG with REG here.  Any simplifications are done      via const_equiv_map.       We make two passes:  In the first, we deal with parameters that will      be placed into registers, since we need to ensure that the allocated      register number fits in const_equiv_map.  Then we store all non-register      parameters into their memory location.  */
comment|/* Don't try to free temp stack slots here, because we may put one of the      parameters into a temp stack slot.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|copy
init|=
name|arg_vals
index|[
name|i
index|]
decl_stmt|;
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* There are three cases, each handled separately.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
comment|/* This must be an object passed by invisible reference (it could 	     also be a variable-sized object, but we forbid inlining functions 	     with variable-sized arguments).  COPY is the address of the 	     actual value (this computation will cause it to be copied).  We 	     map that address for the register, noting the actual address as 	     an equivalent in case it can be substituted into the insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|temp
operator|=
name|copy_addr_to_reg
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|copy
argument_list|)
condition|)
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|copy
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|copy
operator|=
name|temp
expr_stmt|;
block|}
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is the case of a parameter that lives in memory.  It 	     will live in the block we allocate in the called routine's 	     frame that simulates the incoming argument area.  Do nothing 	     with the parameter now; we will call store_expr later.  In 	     this case, however, we must ensure that the virtual stack and 	     incoming arg rtx values are expanded now so that we can be 	     sure we have enough slots in the const equiv map since the 	     store_expr call can easily blow the size estimate.  */
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|->
name|args_size
operator|!=
literal|0
condition|)
name|copy_rtx_and_substitute
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
name|process_reg_param
argument_list|(
name|map
argument_list|,
name|loc
argument_list|,
name|copy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|rtx
name|locreal
init|=
name|gen_realpart
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|rtx
name|locimag
init|=
name|gen_imagpart
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|rtx
name|copyreal
init|=
name|gen_realpart
argument_list|(
name|GET_MODE
argument_list|(
name|locreal
argument_list|)
argument_list|,
name|copy
argument_list|)
decl_stmt|;
name|rtx
name|copyimag
init|=
name|gen_imagpart
argument_list|(
name|GET_MODE
argument_list|(
name|locimag
argument_list|)
argument_list|,
name|copy
argument_list|)
decl_stmt|;
name|process_reg_param
argument_list|(
name|map
argument_list|,
name|locreal
argument_list|,
name|copyreal
argument_list|)
expr_stmt|;
name|process_reg_param
argument_list|(
name|map
argument_list|,
name|locimag
argument_list|,
name|copyimag
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Tell copy_rtx_and_substitute to handle constant pool SYMBOL_REFs      specially.  This function can be called recursively, so we need to      save the previous value.  */
name|inlining_previous
operator|=
name|inlining
expr_stmt|;
name|inlining
operator|=
name|inl_f
expr_stmt|;
comment|/* Now do the parameters that will be placed in memory.  */
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
comment|/* Exclude case handled above.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the address in the area we reserved and store the 	     value there.  */
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|change_address
argument_list|(
name|temp
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|arg_trees
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deal with the places that the function puts its result.      We are driven by what is placed into DECL_RESULT.       Initially, we assume that we don't have anything special handling for      REG_FUNCTION_RETURN_VALUE_P.  */
name|map
operator|->
name|inline_target
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|?
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* There is no return value to worry about.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|target
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|structure_value_addr
operator|||
operator|!
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Pass the function the address in which to return a structure 	     value.  Note that a constructor can cause someone to call us 	     with STRUCTURE_VALUE_ADDR, but the initialization takes place 	     via the first parameter, rather than the struct return address.  	     We have two cases: If the address is a simple register 	     indirect, use the mapping mechanism to point that register to 	     our structure return address.  Otherwise, store the structure 	     return value into the place that it will be referenced from.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|force_operand
argument_list|(
name|structure_value_addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* A virtual register might be invalid in an insn, because 		 it can cause trouble in reload.  Since we don't have access 		 to the expanders at map translation time, make sure we have 		 a proper register now. 		 If a virtual register is actually valid, cse or combine 		 can put it into the mapped insns.  */
if|if
condition|(
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
name|temp
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|structure_value_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|==
name|ADDRESSOF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|structure_value_addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|structure_value_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|structure_value_addr
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ignore
condition|)
comment|/* We will ignore the result value, so don't look at its structure.        Note that preparations for an aggregate return value        do need to be made (above) even if it will be ignored.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* The function returns an object in a register and we use the return 	 value.  Set up our target for remapping.  */
comment|/* Machine mode function was declared to return.  */
name|enum
name|machine_mode
name|departing_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* (Possibly wider) machine mode it actually computes 	 (for the sake of callers that fail to declare it right). 	 We have to use the mode of the result's RTL, rather than 	 its type, since expand_function_start may have promoted it.  */
name|enum
name|machine_mode
name|arriving_mode
init|=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg_to_map
decl_stmt|;
comment|/* Don't use MEMs as direct targets because on some machines 	 substituting a MEM for a REG makes invalid insns. 	 Let the combiner substitute the MEM if that is valid.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|departing_mode
condition|)
block|{
comment|/* Don't make BLKmode registers.  If this looks like 	     a BLKmode object being returned in a register, get 	     the mode from that, otherwise abort.  */
if|if
condition|(
name|departing_mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|REG
operator|==
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|departing_mode
operator|=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arriving_mode
operator|=
name|departing_mode
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|departing_mode
argument_list|)
expr_stmt|;
block|}
comment|/* If function's value was promoted before return, 	 avoid machine mode mismatch when we substitute INLINE_TARGET. 	 But TARGET is what we will return to the caller.  */
if|if
condition|(
name|arriving_mode
operator|!=
name|departing_mode
condition|)
block|{
comment|/* Avoid creating a paradoxical subreg wider than 	     BITS_PER_WORD, since that is illegal.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|arriving_mode
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|!
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|departing_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|arriving_mode
argument_list|)
argument_list|)
condition|)
comment|/* Maybe could be handled by using convert_move () ?  */
name|abort
argument_list|()
expr_stmt|;
name|reg_to_map
operator|=
name|gen_reg_rtx
argument_list|(
name|arriving_mode
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_lowpart
argument_list|(
name|departing_mode
argument_list|,
name|reg_to_map
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_to_map
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|arriving_mode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_to_map
operator|=
name|target
expr_stmt|;
comment|/* Usually, the result value is the machine's return register. 	 Sometimes it may be a pseudo. Handle both cases.  */
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|loc
argument_list|)
condition|)
name|map
operator|->
name|inline_target
operator|=
name|reg_to_map
expr_stmt|;
else|else
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
operator|=
name|reg_to_map
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|departing_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|arriving_mode
init|=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|departing_mode
operator|!=
name|arriving_mode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't use MEMs as direct targets because on some machines 	 substituting a MEM for a REG makes invalid insns. 	 Let the combiner substitute the MEM if that is valid.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|departing_mode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|departing_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONCAT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Remap the exception handler data pointer from one to the other.  */
name|temp
operator|=
name|get_exception_pointer
argument_list|(
name|inl_f
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|get_exception_pointer
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
comment|/* Initialize label_map.  get_label_from_map will actually make      the labels.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|map
operator|->
name|label_map
index|[
name|min_labelno
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make copies of the decls of the symbols in the inline function, so that      the copies of the variables get declared in the current function.  Set      up things so that lookup_static_chain knows that to interpret registers      in SAVE_EXPRs for TYPE_SIZEs as local.  */
name|inline_function_decl
operator|=
name|fndecl
expr_stmt|;
name|integrate_parm_decls
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|map
argument_list|,
name|arg_vector
argument_list|)
expr_stmt|;
name|block
operator|=
name|integrate_decl_tree
argument_list|(
name|inl_f
operator|->
name|original_decl_initial
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|inline_function_decl
operator|=
literal|0
expr_stmt|;
comment|/* Make a fresh binding contour that we can easily remove.  Do this after      expanding our arguments so cleanups are properly scoped.  */
name|expand_start_bindings_and_block
argument_list|(
literal|0
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* Sort the block-map so that it will be easy to find remapped      blocks later.  */
name|qsort
argument_list|(
operator|&
name|VARRAY_TREE
argument_list|(
name|map
operator|->
name|block_map
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
operator|->
name|block_map
operator|->
name|elements_used
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|compare_blocks
argument_list|)
expr_stmt|;
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Clean up stack so that variables might have smaller offsets.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Save a copy of the location of const_equiv_varray for      mark_stores, called via note_stores.  */
name|global_const_equiv_varray
operator|=
name|map
operator|->
name|const_equiv_varray
expr_stmt|;
comment|/* If the called function does an alloca, save and restore the      stack pointer around the call.  This saves stack space, but      also is required if this inline is being done between two      pushes.  */
if|if
condition|(
name|inl_f
operator|->
name|calls_alloca
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Map pseudos used for initial hard reg values.  */
name|setup_initial_hard_reg_value_integration
argument_list|(
name|inl_f
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Now copy the insns one by one.  */
name|copy_insn_list
argument_list|(
name|insns
argument_list|,
name|map
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
comment|/* Duplicate the EH regions.  This will create an offset from the      region numbers in the function we're inlining to the region      numbers in the calling function.  This must wait until after      copy_insn_list, as we need the insn map to be complete.  */
name|eh_region_offset
operator|=
name|duplicate_eh_regions
argument_list|(
name|inl_f
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Now copy the REG_NOTES for those insns.  */
name|copy_insn_notes
argument_list|(
name|insns
argument_list|,
name|map
argument_list|,
name|eh_region_offset
argument_list|)
expr_stmt|;
comment|/* If the insn sequence required one, emit the return label.  */
if|if
condition|(
name|map
operator|->
name|local_return_label
condition|)
name|emit_label
argument_list|(
name|map
operator|->
name|local_return_label
argument_list|)
expr_stmt|;
comment|/* Restore the stack pointer if we saved it above.  */
if|if
condition|(
name|inl_f
operator|->
name|calls_alloca
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
comment|/* In statement-at-a-time mode, we just tell the front-end to add        this block to the list of blocks at this binding level.  We        can't do it the way it's done for function-at-a-time mode the        superblocks have not been created yet.  */
name|insert_block
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
block|{
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_CHAIN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
comment|/* End the scope containing the copied formal parameter variables      and copied LABEL_DECLs.  We pass NULL_TREE for the variables list      here so that expand_end_bindings will not check for unused      variables.  That's already been checked for when the inlined      function was defined.  */
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Must mark the line number note after inlined functions as a repeat, so      that the test coverage code can avoid counting the call twice.  This      just tells the code to ignore the immediately following line note, since      there already exists a copy of this note before the expanded inline call.      This line number note is still needed for debugging though, so we can't      delete it.  */
if|if
condition|(
name|flag_test_coverage
condition|)
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_REPEATED_LINE_NUMBER
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* If the function returns a BLKmode object in a register, copy it      out of the temp register into a BLKmode memory object.  */
if|if
condition|(
name|target
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|target
operator|=
name|copy_blkmode_from_reg
argument_list|(
literal|0
argument_list|,
name|target
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|structure_value_addr
condition|)
block|{
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|target
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we free the things we explicitly allocated with xmalloc.  */
if|if
condition|(
name|real_label_map
condition|)
name|free
argument_list|(
name|real_label_map
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
operator|->
name|reg_map
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|map
operator|->
name|block_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
operator|->
name|insn_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg_vals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg_trees
argument_list|)
expr_stmt|;
name|inlining
operator|=
name|inlining_previous
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Make copies of each insn in the given list using the mapping    computed in expand_inline_function. This function may call itself for    insns containing sequences.     Copying is done in two passes, first the insns and then their REG_NOTES.     If static_chain_value is non-zero, it represents the context-pointer    register for the function.  */
end_comment

begin_function
specifier|static
name|void
name|copy_insn_list
parameter_list|(
name|insns
parameter_list|,
name|map
parameter_list|,
name|static_chain_value
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtx
name|static_chain_value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|cc0_insn
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|rtx
name|static_chain_mem
init|=
literal|0
decl_stmt|;
comment|/* Copy the insns one by one.  Do this in two passes, first the insns and      then their REG_NOTES.  */
comment|/* This loop is very similar to the loop in copy_loop_body in unroll.c.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|copy
decl_stmt|,
name|pattern
decl_stmt|,
name|set
decl_stmt|;
name|map
operator|->
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* The (USE (REG n)) at return from the function should 	       be ignored since we are changing (REG n) into 	       inline_target.  */
break|break;
comment|/* Ignore setting a function value that we don't want to use.  */
if|if
condition|(
name|map
operator|->
name|inline_target
operator|==
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|new_set
decl_stmt|;
comment|/* If we must not delete the source, 		     load it into a new temporary.  */
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new_set
operator|=
name|single_set
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_set
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_DEST
argument_list|(
name|new_set
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|new_set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the source and destination are the same and it 		 has a note on it, keep the insn.  */
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* Similarly if an ignored return value is clobbered.  */
elseif|else
if|if
condition|(
name|map
operator|->
name|inline_target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Look for the address of the static chain slot. The              rtx_equal_p comparisons against the              static_chain_incoming_rtx below may fail if the static              chain is in memory and the address specified is not              "legitimate".  This happens on Xtensa where the static              chain is at a negative offset from argp and where only              positive offsets are legitimate.  When the RTL is              generated, the address is "legitimized" by copying it              into a register, causing the rtx_equal_p comparisons to              fail.  This workaround looks for code that sets a              register to the address of the static chain.  Subsequent              memory references via that register can then be              identified as static chain references.  We assume that              the register is only assigned once, and that the static              chain address is only live in one register at a time. */
elseif|else
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|static_chain_incoming_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|static_chain_mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* emit the instruction in case it is used for something 		 other than setting the static chain; if it's not used, 		 it can always be removed as dead code */
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is setting the static chain rtx, omit it.  */
elseif|else
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
operator|||
operator|(
name|static_chain_mem
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|static_chain_mem
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* If this is setting the static chain pseudo, set it from 	     the value we want to give it instead.  */
elseif|else
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
operator|||
operator|(
name|static_chain_mem
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|static_chain_mem
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|newdest
init|=
name|copy_rtx_and_substitute
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|copy
operator|=
name|emit_move_insn
argument_list|(
name|newdest
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|!=
name|MEM
condition|)
name|static_chain_value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is setting the virtual stack vars register, this must 	     be the code at the handler for a builtin longjmp.  The value 	     saved in the setjmp buffer will be the address of the frame 	     we've made for this inlined instance within our frame.  But we 	     know the offset of that value so we can use it to reconstruct 	     our virtual stack vars register from that value.  If we are 	     copying it from the stack pointer, leave it unchanged.  */
elseif|else
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|temp
operator|=
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|temp
operator|=
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|.
name|rtx
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|virtual_stack_vars_rtx
argument_list|)
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|)
condition|)
name|temp
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|-
name|offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* REG_NOTES will be copied later.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this insn is setting CC0, it may need to look at 	     the insn that uses CC0 to see what type of insn it is. 	     In that case, the call to recog via validate_change will 	     fail.  So don't substitute constants here.  Instead, 	     do it when we emit the following insn.  	     For example, see the pyr.md file.  That machine has signed and 	     unsigned compares.  The compare patterns must check the 	     following branch insn to see which what kind of compare to 	     emit.  	     If the previous insn set CC0, substitute constants on it as 	     well.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|cc0_insn
operator|=
name|copy
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
name|map
operator|->
name|integrating
operator|&&
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|local_return_label
operator|==
literal|0
condition|)
name|map
operator|->
name|local_return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pattern
operator|=
name|gen_jump
argument_list|(
name|map
operator|->
name|local_return_label
argument_list|)
expr_stmt|;
block|}
else|else
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_jump_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* If this used to be a conditional jump insn but whose branch 	     direction is now know, we must do something special.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|map
operator|->
name|last_pc_value
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If the previous insn set cc0 for us, delete it.  */
if|if
condition|(
name|only_sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|)
name|delete_related_insns
argument_list|(
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is now a no-op, delete it.  */
if|if
condition|(
name|map
operator|->
name|last_pc_value
operator|==
name|pc_rtx
condition|)
block|{
name|delete_related_insns
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Otherwise, this is unconditional jump so we must put a 		   BARRIER after it.  We could do some dead code elimination 		   here, but jump.c will do it just as well.  */
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CALL_INSN
case|:
comment|/* If this is a CALL_PLACEHOLDER insn then we need to copy the 	     three attached sequences: normal call, sibling call and tail 	     recursion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|rtx
name|sequence
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|tail_label
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|seq
decl_stmt|;
name|sequence
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|seq
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|copy_insn_list
argument_list|(
name|seq
argument_list|,
name|map
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
name|sequence
index|[
name|i
index|]
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Find the new tail recursion label. 	         It will already be substituted into sequence[2].  */
name|tail_label
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_call_insn
argument_list|(
name|gen_rtx_CALL_PLACEHOLDER
argument_list|(
name|VOIDmode
argument_list|,
name|sequence
index|[
literal|0
index|]
argument_list|,
name|sequence
index|[
literal|1
index|]
argument_list|,
name|sequence
index|[
literal|2
index|]
argument_list|,
name|tail_label
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_call_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|copy
argument_list|)
operator|=
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|copy
argument_list|)
operator|=
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially contains objects other 	     than hard registers, we need to copy it.  */
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Be lazy and assume CALL_INSNs clobber all hard registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|i
argument_list|)
operator|.
name|rtx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|copy
operator|=
name|emit_label
argument_list|(
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|copy
operator|=
name|emit_barrier
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
condition|)
block|{
name|copy
operator|=
name|emit_label
argument_list|(
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
break|break;
block|}
comment|/* NOTE_INSN_FUNCTION_END and NOTE_INSN_FUNCTION_BEG are 	     discarded because it is important to have only one of 	     each in the current function.  	     NOTE_INSN_DELETED notes aren't useful.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
block|{
name|copy
operator|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|)
operator|&&
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|mapped_block_p
decl_stmt|;
name|mapped_block_p
operator|=
operator|(
name|tree
operator|*
operator|)
name|bsearch
argument_list|(
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|VARRAY_TREE
argument_list|(
name|map
operator|->
name|block_map
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
operator|->
name|block_map
operator|->
name|elements_used
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|find_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapped_block_p
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|NOTE_BLOCK
argument_list|(
name|copy
argument_list|)
operator|=
operator|*
name|mapped_block_p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copy
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|==
name|NOTE_INSN_EXPECTED_VALUE
condition|)
name|NOTE_EXPECTED_VALUE
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|NOTE_EXPECTED_VALUE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|copy
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|copy
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the REG_NOTES.  Increment const_age, so that only constants    from parameters can be substituted in.  These are the only ones    that are valid across the entire function.  */
end_comment

begin_function
specifier|static
name|void
name|copy_insn_notes
parameter_list|(
name|insns
parameter_list|,
name|map
parameter_list|,
name|eh_region_offset
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|int
name|eh_region_offset
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|new_insn
decl_stmt|;
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|new_insn
operator|=
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|new_insn
condition|)
continue|continue;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|next
decl_stmt|,
name|note
init|=
name|copy_rtx_and_substitute
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We must also do subst_constants, in case one of our parameters 	     has const type and constant value.  */
name|subst_constants
argument_list|(
operator|&
name|note
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|new_insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* Delete any REG_LABEL notes from the chain.  Remap any              REG_EH_REGION notes.  */
for|for
control|(
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|remove_note
argument_list|(
name|new_insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_EH_REGION
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
name|eh_region_offset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|copy_insn_notes
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|map
argument_list|,
name|eh_region_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RESX
condition|)
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|new_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+=
name|eh_region_offset
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of PARM_DECLs, ARGS, copy each decl into a VAR_DECL,    push all of those decls and give each one the corresponding home.  */
end_comment

begin_function
specifier|static
name|void
name|integrate_parm_decls
parameter_list|(
name|args
parameter_list|,
name|map
parameter_list|,
name|arg_vector
parameter_list|)
name|tree
name|args
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtvec
name|arg_vector
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|args
operator|,
name|i
operator|=
literal|0
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|decl
init|=
name|copy_decl_for_inlining
argument_list|(
name|tail
argument_list|,
name|map
operator|->
name|fndecl
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
name|rtx
name|new_decl_rtl
init|=
name|copy_rtx_and_substitute
argument_list|(
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We really should be setting DECL_INCOMING_RTL to something reasonable 	 here, but that's going to require some more work.  */
comment|/* DECL_INCOMING_RTL (decl) = ?; */
comment|/* Fully instantiate the address with the equivalent form so that the 	 debugging information contains the actual register, instead of the 	 virtual register.   Do this by not passing an insn to 	 subst_constants.  */
name|subst_constants
argument_list|(
operator|&
name|new_decl_rtl
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|new_decl_rtl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a BLOCK node LET, push decls and levels so as to construct in the    current function a tree of contexts isomorphic to the one that is given.     MAP, if nonzero, is a pointer to an inline_remap map which indicates how    registers used in the DECL_RTL field should be remapped.  If it is zero,    no mapping is necessary.  */
end_comment

begin_function
specifier|static
name|tree
name|integrate_decl_tree
parameter_list|(
name|let
parameter_list|,
name|map
parameter_list|)
name|tree
name|let
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|new_block
decl_stmt|;
name|tree
modifier|*
name|next
decl_stmt|;
name|new_block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_TREE
argument_list|(
name|map
operator|->
name|block_map
argument_list|,
name|new_block
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|BLOCK_VARS
argument_list|(
name|new_block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|d
decl_stmt|;
name|d
operator|=
name|copy_decl_for_inlining
argument_list|(
name|t
argument_list|,
name|map
operator|->
name|fndecl
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|rtx
name|r
decl_stmt|;
name|SET_DECL_RTL
argument_list|(
name|d
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fully instantiate the address with the equivalent form so that the 	     debugging information contains the actual register, instead of the 	     virtual register.   Do this by not passing an insn to 	     subst_constants.  */
name|r
operator|=
name|DECL_RTL
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|r
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|d
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
name|REGNO_DECL
argument_list|(
name|REGNO
argument_list|(
name|r
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|REGNO_DECL
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|REGNO_DECL
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
block|}
name|apply_change_group
argument_list|()
expr_stmt|;
block|}
comment|/* Add this declaration to the list of variables in the new 	 block.  */
operator|*
name|next
operator|=
name|d
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
operator|&
name|BLOCK_SUBBLOCKS
argument_list|(
name|new_block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|BLOCK_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
operator|*
name|next
operator|=
name|integrate_decl_tree
argument_list|(
name|t
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
operator|*
name|next
argument_list|)
operator|=
name|new_block
expr_stmt|;
name|next
operator|=
operator|&
name|BLOCK_CHAIN
argument_list|(
operator|*
name|next
argument_list|)
expr_stmt|;
block|}
name|TREE_USED
argument_list|(
name|new_block
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|let
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|let
expr_stmt|;
return|return
name|new_block
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx. Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.     We always return an rtx that is similar to that incoming rtx, with the    exception of possibly changing a REG to a SUBREG or vice versa.  No    rtl is ever emitted.     If FOR_LHS is nonzero, if means we are processing something that will    be the LHS of a SET.  In that case, we copy RTX_UNCHANGING_P even if    inlining since we need to be conservative in how it is set for    such cases.     Handle constants that need to be placed in the constant pool by    calling `force_const_mem'.  */
end_comment

begin_function
name|rtx
name|copy_rtx_and_substitute
parameter_list|(
name|orig
parameter_list|,
name|map
parameter_list|,
name|for_lhs
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|int
name|for_lhs
decl_stmt|;
block|{
name|rtx
name|copy
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|orig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If the stack pointer register shows up, it must be part of 	 stack-adjustments (*not* because we eliminated the frame pointer!). 	 Small hard registers are returned as-is.  Pseudo-registers 	 go through their `reg_map'.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|||
operator|(
name|map
operator|->
name|integrating
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
operator|->
name|internal_arg_pointer
operator|==
name|orig
operator|)
condition|)
block|{
comment|/* Some hard registers are also mapped, 	     but others are not translated.  */
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
return|return
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
return|;
comment|/* If this is the virtual frame pointer, make space in current 	     function's stack frame for the stack frame of the inline function.  	     Copy the address of this area into a pseudo.  Map 	     virtual_stack_vars_rtx to this pseudo and set up a constant 	     equivalence for it to be the address.  This will substitute the 	     address into insns where it can be substituted and use the new 	     pseudo where it can't.  */
elseif|else
if|if
condition|(
name|regno
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
condition|)
block|{
name|rtx
name|loc
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|size
init|=
name|get_func_frame_size
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|int
name|alignment
init|=
operator|(
name|DECL_SAVED_INSNS
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
operator|->
name|stack_alignment_needed
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
comment|/* In this case, virtual_stack_vars_rtx points to one byte 		 higher than the top of the frame area.  So make sure we 		 allocate a big enough chunk to keep the frame pointer 		 aligned like a real one.  */
if|if
condition|(
name|alignment
condition|)
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|start_sequence
argument_list|()
expr_stmt|;
name|loc
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|loc
operator|=
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
comment|/* In this case, virtual_stack_vars_rtx points to one byte 		 higher than the top of the frame area.  So compute the offset 		 to one byte higher than our substitute frame.  */
name|loc
operator|=
name|plus_constant
argument_list|(
name|loc
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|loc
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|STACK_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|loc
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|map
operator|->
name|insns_at_start
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
operator|||
operator|(
name|map
operator|->
name|integrating
operator|&&
operator|(
name|DECL_SAVED_INSNS
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
operator|->
name|internal_arg_pointer
operator|==
name|orig
operator|)
operator|)
condition|)
block|{
comment|/* Do the same for a block to contain any arguments referenced 		 in memory.  */
name|rtx
name|loc
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|size
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
operator|->
name|args_size
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|loc
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|loc
operator|=
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When arguments grow downward, the virtual incoming 		 args pointer points to the top of the argument block, 		 so the remapped location better do the same.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|loc
operator|=
name|plus_constant
argument_list|(
name|loc
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|loc
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|STACK_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|temp
argument_list|,
name|loc
argument_list|,
name|CONST_AGE_PARM
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|map
operator|->
name|insns_at_start
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
comment|/* This is a reference to the function return value.  If 		 the function doesn't have a return value, error.  If the 		 mode doesn't agree, and it ain't BLKmode, make a SUBREG.  */
if|if
condition|(
name|map
operator|->
name|inline_target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rtx_equal_function_value_matters
condition|)
comment|/* This is an ignored return value.  We must not 		       leave it in with REG_FUNCTION_VALUE_P set, since 		       that would confuse subsequent inlining of the 		       current function into a later function.  */
return|return
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|regno
argument_list|)
return|;
else|else
comment|/* Must be unrolling loops or replicating code if we 		       reach here, so return the register unchanged.  */
return|return
name|orig
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|map
operator|->
name|inline_target
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|map
operator|->
name|inline_target
argument_list|)
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|map
operator|->
name|inline_target
argument_list|)
return|;
else|else
return|return
name|map
operator|->
name|inline_target
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LEAF_REGISTERS
argument_list|)
operator|&&
name|defined
argument_list|(
name|LEAF_REG_REMAP
argument_list|)
comment|/* If leaf_renumber_regs_insn() might remap this register to 	     some other number, make sure we don't share it with the 	     inlined function, otherwise delayed optimization of the 	     inlined function may change it in place, breaking our 	     reference to it.  We may still shared it within the 	     function, so create an entry for this register in the 	     reg_map.  */
if|if
condition|(
name|map
operator|->
name|integrating
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|LEAF_REGISTERS
index|[
name|regno
index|]
operator|&&
name|LEAF_REG_REMAP
argument_list|(
name|regno
argument_list|)
operator|!=
name|regno
condition|)
block|{
if|if
condition|(
operator|!
name|map
operator|->
name|leaf_reg_map
index|[
name|regno
index|]
index|[
name|mode
index|]
condition|)
name|map
operator|->
name|leaf_reg_map
index|[
name|regno
index|]
index|[
name|mode
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return
name|map
operator|->
name|leaf_reg_map
index|[
name|regno
index|]
index|[
name|mode
index|]
return|;
block|}
endif|#
directive|endif
else|else
return|return
name|orig
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|==
name|NULL
condition|)
block|{
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|REG_LOOP_TEST_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_LOOP_TEST_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */
if|if
condition|(
name|REG_POINTER
argument_list|(
name|map
operator|->
name|x_regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|map
operator|->
name|regno_pointer_align
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
return|;
case|case
name|SUBREG
case|:
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|,
name|for_lhs
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
case|case
name|ADDRESSOF
case|:
name|copy
operator|=
name|gen_rtx_ADDRESSOF
argument_list|(
name|mode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|,
name|for_lhs
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ADDRESSOF_DECL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|ADDRESSOF_REGNO
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|REG_LOOP_TEST_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_LOOP_TEST_P
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */
if|if
condition|(
name|REG_POINTER
argument_list|(
name|map
operator|->
name|x_regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|,
name|map
operator|->
name|regno_pointer_align
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
name|ADDRESSOF_REGNO
argument_list|(
name|copy
argument_list|)
operator|=
name|regno
expr_stmt|;
return|return
name|copy
return|;
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* USE and CLOBBER are ordinary, but we convert (use (subreg foo)) 	 to (use foo) if the original insn didn't have a subreg. 	 Removing the subreg distorts the VAX movstrhi pattern 	 by changing the mode of an operand.  */
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|,
name|code
operator|==
name|CLOBBER
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SUBREG
condition|)
name|copy
operator|=
name|SUBREG_REG
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|copy
argument_list|)
return|;
comment|/* We need to handle "deleted" labels that appear in the DECL_RTL        of a LABEL_DECL.  */
case|case
name|NOTE
case|:
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|orig
argument_list|)
operator|!=
name|NOTE_INSN_DELETED_LABEL
condition|)
break|break;
comment|/* ... FALLTHRU ...  */
case|case
name|CODE_LABEL
case|:
name|LABEL_PRESERVE_P
argument_list|(
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|)
operator|=
name|LABEL_PRESERVE_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
name|copy
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|mode
argument_list|,
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
condition|?
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
else|:
name|get_label_from_map
argument_list|(
name|map
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* The fact that this label was previously nonlocal does not mean 	 it still is, so we must check if it is within the range of 	 this function's labels.  */
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|copy
argument_list|)
operator|=
operator|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
operator|&&
operator|!
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|get_first_label_num
argument_list|()
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|max_label_num
argument_list|()
operator|)
operator|)
expr_stmt|;
comment|/* If we have made a nonlocal label local, it means that this 	 inlined call will be referring to our nonlocal goto handler. 	 So make sure we create one for this block; we normally would 	 not since this is not otherwise considered a "call".  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|orig
argument_list|)
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|copy
argument_list|)
condition|)
name|function_call_count
operator|++
expr_stmt|;
return|return
name|copy
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
return|return
name|orig
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* Symbols which represent the address of a label stored in the constant 	 pool must be modified to point to a constant pool entry for the 	 remapped label.  Otherwise, symbols are returned unchanged.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
name|struct
name|function
modifier|*
name|f
init|=
name|inlining
condition|?
name|inlining
else|:
name|cfun
decl_stmt|;
name|rtx
name|constant
init|=
name|get_pool_constant_for_function
argument_list|(
name|f
argument_list|,
name|orig
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|const_mode
init|=
name|get_pool_mode_for_function
argument_list|(
name|f
argument_list|,
name|orig
argument_list|)
decl_stmt|;
if|if
condition|(
name|inlining
condition|)
block|{
name|rtx
name|temp
init|=
name|force_const_mem
argument_list|(
name|const_mode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|constant
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Legitimizing the address here is incorrect.  		 Since we had a SYMBOL_REF before, we can assume it is valid 		 to have one in this position in the insn.  		 Also, change_address may create new registers.  These 		 registers will not have valid reg_map entries.  This can 		 cause try_constants() to fail because assumes that all 		 registers in the rtx have valid reg_map entries, and it may 		 end up replacing one of these new registers with junk.  */
block|if (! memory_address_p (GET_MODE (temp), XEXP (temp, 0))) 		temp = change_address (temp, GET_MODE (temp), XEXP (temp, 0));
endif|#
directive|endif
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|orig
argument_list|)
condition|)
name|temp
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|constant
argument_list|,
name|map
argument_list|,
name|for_lhs
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|orig
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* We have to make a new copy of this CONST_DOUBLE because don't want 	 to use the old value of CONST_DOUBLE_MEM.  Also, this may be a 	 duplicate of a CONST_DOUBLE we have already seen.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|immed_double_const
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|orig
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|orig
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|CONST
case|:
comment|/* Make new constant pool entry for a constant 	 that was in the pool of the inline function.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|orig
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* If a single asm insn contains multiple output operands then 	 it contains multiple ASM_OPERANDS rtx's that share the input 	 and constraint vecs.  We must make sure that the copied insn 	 continues to share it.  */
if|if
condition|(
name|map
operator|->
name|orig_asm_operands_vector
operator|==
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|orig
argument_list|)
condition|)
block|{
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|ASM_OPERANDS
argument_list|)
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|copy
argument_list|)
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|copy
argument_list|)
operator|=
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|copy
argument_list|)
operator|=
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|copy
argument_list|)
operator|=
name|map
operator|->
name|copy_asm_operands_vector
expr_stmt|;
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|copy
argument_list|)
operator|=
name|map
operator|->
name|copy_asm_constraints_vector
expr_stmt|;
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|copy
argument_list|)
operator|=
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
break|break;
case|case
name|CALL
case|:
comment|/* This is given special treatment because the first 	 operand of a CALL is a (MEM ...) which may get 	 forced into a register for cse.  This is undesirable 	 if function-address cse isn't wanted or if we won't do cse.  */
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
operator|!
operator|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
operator|)
condition|)
endif|#
directive|endif
block|{
name|rtx
name|copy
init|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|copy
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_CALL
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
break|break;
if|#
directive|if
literal|0
comment|/* Must be ifdefed out for loop unrolling to work.  */
block|case RETURN:       abort ();
endif|#
directive|endif
case|case
name|SET
case|:
comment|/* If this is setting fp or ap, it means that we have a nonlocal goto. 	 Adjust the setting by the offset of the area we made. 	 If the nonlocal goto is into the current function, 	 this will result in unnecessarily bad code, but should work.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|SET_DEST
argument_list|(
name|orig
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
block|{
comment|/* In case a translation hasn't occurred already, make one now.  */
name|rtx
name|equiv_reg
decl_stmt|;
name|rtx
name|equiv_loc
decl_stmt|;
name|HOST_WIDE_INT
name|loc_offset
decl_stmt|;
name|copy_rtx_and_substitute
argument_list|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|,
name|for_lhs
argument_list|)
expr_stmt|;
name|equiv_reg
operator|=
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|equiv_loc
operator|=
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|REGNO
argument_list|(
name|equiv_reg
argument_list|)
argument_list|)
operator|.
name|rtx
expr_stmt|;
name|loc_offset
operator|=
name|GET_CODE
argument_list|(
name|equiv_loc
argument_list|)
operator|==
name|REG
condition|?
literal|0
else|:
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|equiv_loc
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|SET_SRC
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
name|loc_offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|SET_SRC
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|inlining
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|const_mode
init|=
name|get_pool_mode_for_function
argument_list|(
name|inlining
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|constant
init|=
name|get_pool_constant_for_function
argument_list|(
name|inlining
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|constant
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|constant
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this was an address of a constant pool entry that itself 	     had to be placed in the constant pool, it might not be a 	     valid address.  So the recursive call might have turned it 	     into a register.  In that case, it isn't a constant any 	     more, so return it.  This has the potential of changing a 	     MEM into a REG, but we'll assume that it safe.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|constant
argument_list|)
condition|)
return|return
name|constant
return|;
return|return
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|const_mode
argument_list|,
name|constant
argument_list|)
argument_list|)
return|;
block|}
name|copy
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|copy
argument_list|,
name|orig
argument_list|)
expr_stmt|;
comment|/* If inlining and this is not for the LHS, turn off RTX_UNCHANGING_P 	 since this may be an indirect reference to a parameter and the 	 actual may not be readonly.  */
if|if
condition|(
name|inlining
operator|&&
operator|!
name|for_lhs
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|copy
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|copy
return|;
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Copy this through the wide int field; that's safest.  */
name|X0WINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|X0WINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|,
name|map
argument_list|,
name|for_lhs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|map
argument_list|,
name|for_lhs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|XTREE
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XTREE
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
operator|&&
name|map
operator|->
name|orig_asm_operands_vector
operator|==
literal|0
condition|)
block|{
name|map
operator|->
name|orig_asm_operands_vector
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|map
operator|->
name|copy_asm_operands_vector
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|map
operator|->
name|copy_asm_constraints_vector
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute known constant values into INSN, if that is valid.  */
end_comment

begin_function
name|void
name|try_constants
parameter_list|(
name|insn
parameter_list|,
name|map
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|map
operator|->
name|num_sets
operator|=
literal|0
expr_stmt|;
comment|/* First try just updating addresses, then other things.  This is      important when we have something like the store of a constant      into memory and we can update the memory address but the machine      does not support a constant source.  */
name|subst_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
comment|/* Show we don't know the value of anything stored or clobbered.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_stores
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|map
operator|->
name|last_pc_value
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|map
operator|->
name|last_cc0_value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set up any constant equivalences made in this insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|num_sets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
decl_stmt|;
name|MAYBE_EXTEND_CONST_EQUIV_VARRAY
argument_list|(
name|map
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|.
name|rtx
operator|==
literal|0
comment|/* Following clause is a hack to make case work where GNU C++ 		 reassigns a variable to make cse work right.  */
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|.
name|rtx
argument_list|,
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
argument_list|)
condition|)
name|SET_CONST_EQUIV_DATA
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|,
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
argument_list|,
name|map
operator|->
name|const_age
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
operator|==
name|pc_rtx
condition|)
name|map
operator|->
name|last_pc_value
operator|=
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
elseif|else
if|if
condition|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
operator|==
name|cc0_rtx
condition|)
name|map
operator|->
name|last_cc0_value
operator|=
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute known constants for pseudo regs in the contents of LOC,    which are part of INSN.    If INSN is zero, the substitution should always be done (this is used to    update DECL_RTL).    These changes are taken out by try_constants if the result is not valid.     Note that we are more concerned with determining when the result of a SET    is a constant, for further propagation, than actually inserting constants    into insns; cse will do the latter task better.     This function is also used to adjust address of items previously addressed    via the virtual stack variable or virtual incoming arguments registers.     If MEMONLY is nonzero, only make changes inside a MEM.  */
end_comment

begin_function
specifier|static
name|void
name|subst_constants
parameter_list|(
name|loc
parameter_list|,
name|insn
parameter_list|,
name|map
parameter_list|,
name|memonly
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|int
name|memonly
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|num_changes
init|=
name|num_validated_changes
argument_list|()
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|op0_mode
init|=
name|MAX_MACHINE_MODE
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDRESS
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
if|if
condition|(
operator|!
name|memonly
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|map
operator|->
name|last_cc0_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* The only thing we can do with a USE or CLOBBER is possibly do 	 some substitutions in a MEM within it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
comment|/* Substitute for parms and known constants.  Don't replace 	 hard regs used as user variables with constants.  */
if|if
condition|(
operator|!
name|memonly
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|const_equiv_data
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_USERVAR_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|(
name|size_t
operator|)
name|regno
operator|<
name|VARRAY_SIZE
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|)
operator|&&
operator|(
name|p
operator|=
operator|&
name|VARRAY_CONST_EQUIV
argument_list|(
name|map
operator|->
name|const_equiv_varray
argument_list|,
name|regno
argument_list|)
operator|,
name|p
operator|->
name|rtx
operator|!=
literal|0
operator|)
operator|&&
name|p
operator|->
name|age
operator|>=
name|map
operator|->
name|const_age
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|p
operator|->
name|rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|SUBREG
case|:
comment|/* SUBREG applied to something other than a reg 	 should be treated as ordinary, since that must 	 be a special hack and we don't know how to treat it specially. 	 Consider for example mulsidi3 in m68k.md. 	 Ordinary SUBREG of a REG needs this special treatment.  */
if|if
condition|(
operator|!
name|memonly
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
comment|/* We can't call subst_constants on&SUBREG_REG (x) because any 	     constant or SUBREG wouldn't be valid inside our SUBEG.  Instead, 	     see what is inside, try to form the new SUBREG and see if that is 	     valid.  We handle two cases: extracting a full word in an 	     integral mode and extracting the low part.  */
name|subst_constants
argument_list|(
operator|&
name|inner
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|inner
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|cancel_changes
argument_list|(
name|num_changes
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MEM
case|:
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If a memory address got spoiled, change it back.  */
if|if
condition|(
operator|!
name|memonly
operator|&&
name|insn
operator|!=
literal|0
operator|&&
name|num_validated_changes
argument_list|()
operator|!=
name|num_changes
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|cancel_changes
argument_list|(
name|num_changes
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
comment|/* Substitute constants in our source, and in any arguments to a 	   complex (e..g, ZERO_EXTRACT) destination, but not in the destination 	   itself.  */
name|rtx
modifier|*
name|dest_loc
init|=
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
operator|*
name|dest_loc
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|tem
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* If SET_SRC is a COMPARE which subst_constants would turn into 	   COMPARE of 2 VOIDmode constants, note the mode in which comparison 	   is to be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|MODE_CC
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|dest
operator|==
name|cc0_rtx
endif|#
directive|endif
condition|)
block|{
name|compare_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_mode
operator|==
name|VOIDmode
condition|)
name|compare_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|subst_constants
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
name|memonly
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
name|memonly
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
name|memonly
argument_list|)
expr_stmt|;
block|}
name|dest_loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do substitute in the address of a destination in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|MEM
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for the case of DEST a SUBREG, both it and the underlying 	   register are less than one word, and the SUBREG has the wider mode. 	   In the case, we are really setting the underlying register to the 	   source converted to the mode of DEST.  So indicate that.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|src
argument_list|)
operator|)
condition|)
name|src
operator|=
name|tem
operator|,
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If storing a recognizable value save it for later recording.  */
if|if
condition|(
operator|(
name|map
operator|->
name|num_sets
operator|<
name|MAX_RECOG_OPERANDS
operator|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
operator|||
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|dest
operator|==
name|cc0_rtx
endif|#
directive|endif
operator|||
operator|(
name|dest
operator|==
name|pc_rtx
operator|&&
operator|(
name|src
operator|==
name|pc_rtx
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|RETURN
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Normally, this copy won't do anything.  But, if SRC is a COMPARE 	       it will cause us to save the COMPARE with any constants 	       substituted, which is what we want for later.  */
name|rtx
name|src_copy
init|=
name|copy_rtx
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|map
operator|->
name|equiv_sets
index|[
name|map
operator|->
name|num_sets
index|]
operator|.
name|equiv
operator|=
name|src_copy
expr_stmt|;
name|map
operator|->
name|equiv_sets
index|[
name|map
operator|->
name|num_sets
operator|++
index|]
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|compare_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|MODE_CC
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|dest
operator|==
name|cc0_rtx
endif|#
directive|endif
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|map
operator|->
name|compare_src
operator|=
name|src_copy
expr_stmt|;
name|map
operator|->
name|compare_mode
operator|=
name|compare_mode
expr_stmt|;
block|}
block|}
block|}
return|return;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* If the first operand is an expression, save its mode for later.  */
if|if
condition|(
operator|*
name|format_ptr
operator|==
literal|'e'
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
name|memonly
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
case|case
literal|'n'
case|:
case|case
literal|'t'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|subst_constants
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|,
name|memonly
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If this is a commutative operation, move a constant to the second      operand unless the second operand is already a CONST_INT.  */
if|if
condition|(
operator|!
name|memonly
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Simplify the expression in case we put in some constants.  */
if|if
condition|(
operator|!
name|memonly
condition|)
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
if|if
condition|(
name|op0_mode
operator|==
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0_mode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|op_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|const0_rtx
condition|)
name|new
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
name|REAL_VALUE_TYPE
name|val
decl_stmt|;
comment|/* Avoid automatic aggregate initialization.  */
name|val
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|new
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
block|}
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'3'
case|:
if|if
condition|(
name|op0_mode
operator|==
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|==
name|map
operator|->
name|compare_src
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We have compare of two VOIDmode constants for which 		   we recorded the comparison mode.  */
name|rtx
name|temp
init|=
name|simplify_relational_operation
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|map
operator|->
name|compare_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|const1_rtx
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|new
condition|)
name|new
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show that register modified no longer contain known constants.  We are    called from note_stores with parts of the new insn.  */
end_comment

begin_function
specifier|static
name|void
name|mark_stores
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* DEST is always the innermost thing set, except in the case of      SUBREGs of hard registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|,
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|int
name|uregno
init|=
name|regno
decl_stmt|;
name|unsigned
name|int
name|last_reg
init|=
operator|(
name|uregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|uregno
else|:
name|uregno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|uregno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Ignore virtual stack var or virtual arg register since those 	 are handled separately.  */
if|if
condition|(
name|uregno
operator|!=
name|VIRTUAL_INCOMING_ARGS_REGNUM
operator|&&
name|uregno
operator|!=
name|VIRTUAL_STACK_VARS_REGNUM
condition|)
for|for
control|(
name|i
operator|=
name|uregno
init|;
name|i
operator|<=
name|last_reg
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|<
name|VARRAY_SIZE
argument_list|(
name|global_const_equiv_varray
argument_list|)
condition|)
name|VARRAY_CONST_EQUIV
argument_list|(
name|global_const_equiv_varray
argument_list|,
name|i
argument_list|)
operator|.
name|rtx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so    that it points to the node itself, thus indicating that the node is its    own (abstract) origin.  Additionally, if the BLOCK_ABSTRACT_ORIGIN for    the given node is NULL, recursively descend the decl/block tree which    it is the root of, and for each other ..._DECL or BLOCK node contained    therein whose DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also    still NULL, set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN    values to point to themselves.  */
end_comment

begin_function
specifier|static
name|void
name|set_block_origin_self
parameter_list|(
name|stmt
parameter_list|)
name|tree
name|stmt
decl_stmt|;
block|{
if|if
condition|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|stmt
expr_stmt|;
block|{
name|tree
name|local_decl
decl_stmt|;
for|for
control|(
name|local_decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|local_decl
operator|!=
name|NULL_TREE
condition|;
name|local_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|local_decl
argument_list|)
control|)
name|set_decl_origin_self
argument_list|(
name|local_decl
argument_list|)
expr_stmt|;
comment|/* Potential recursion.  */
block|}
block|{
name|tree
name|subblock
decl_stmt|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblock
operator|!=
name|NULL_TREE
condition|;
name|subblock
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|set_block_origin_self
argument_list|(
name|subblock
argument_list|)
expr_stmt|;
comment|/* Recurse.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL node, if the DECL_ABSTRACT_ORIGIN for    the given ..._DECL node is NULL, set the DECL_ABSTRACT_ORIGIN for the    node to so that it points to the node itself, thus indicating that the    node represents its own (abstract) origin.  Additionally, if the    DECL_ABSTRACT_ORIGIN for the given node is NULL, recursively descend    the decl/block tree of which the given node is the root of, and for    each other ..._DECL or BLOCK node contained therein whose    DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also still NULL,    set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN values to    point to themselves.  */
end_comment

begin_function
name|void
name|set_decl_origin_self
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|arg
argument_list|)
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|set_block_origin_self
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to some BLOCK node, and a boolean value to set the    "abstract" flags to, set that value into the BLOCK_ABSTRACT flag for    the given block, and for all local decls and all local sub-blocks    (recursively) which are contained therein.  */
end_comment

begin_function
specifier|static
name|void
name|set_block_abstract_flags
parameter_list|(
name|stmt
parameter_list|,
name|setting
parameter_list|)
name|tree
name|stmt
decl_stmt|;
name|int
name|setting
decl_stmt|;
block|{
name|tree
name|local_decl
decl_stmt|;
name|tree
name|subblock
decl_stmt|;
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
operator|=
name|setting
expr_stmt|;
for|for
control|(
name|local_decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|local_decl
operator|!=
name|NULL_TREE
condition|;
name|local_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|local_decl
argument_list|)
control|)
name|set_decl_abstract_flags
argument_list|(
name|local_decl
argument_list|,
name|setting
argument_list|)
expr_stmt|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblock
operator|!=
name|NULL_TREE
condition|;
name|subblock
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|set_block_abstract_flags
argument_list|(
name|subblock
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL node, and a boolean value to set the    "abstract" flags to, set that value into the DECL_ABSTRACT flag for the    given decl, and (in the case where the decl is a FUNCTION_DECL) also    set the abstract flags for all of the parameters, local vars, local    blocks and sub-blocks (recursively) to the same setting.  */
end_comment

begin_function
name|void
name|set_decl_abstract_flags
parameter_list|(
name|decl
parameter_list|,
name|setting
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|setting
decl_stmt|;
block|{
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|DECL_ABSTRACT
argument_list|(
name|arg
argument_list|)
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|set_block_abstract_flags
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the assembly language code for the function FNDECL    from its DECL_SAVED_INSNS.  Used for inline functions that are output    at end of compilation instead of where they came in the source.  */
end_comment

begin_function
name|void
name|output_inline_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|struct
name|function
modifier|*
name|old_cfun
init|=
name|cfun
decl_stmt|;
name|enum
name|debug_info_type
name|old_write_symbols
init|=
name|write_symbols
decl_stmt|;
name|struct
name|gcc_debug_hooks
modifier|*
name|old_debug_hooks
init|=
name|debug_hooks
decl_stmt|;
name|struct
name|function
modifier|*
name|f
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|cfun
operator|=
name|f
expr_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
name|clear_emit_caches
argument_list|()
expr_stmt|;
name|set_new_last_label_num
argument_list|(
name|f
operator|->
name|inl_max_label_num
argument_list|)
expr_stmt|;
comment|/* We're not deferring this any longer.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If requested, suppress debugging information.  */
if|if
condition|(
name|f
operator|->
name|no_debugging_symbols
condition|)
block|{
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
block|}
comment|/* Compile this function all the way down to assembly code.  As a      side effect this destroys the saved RTL representation, but      that's okay, because we don't need to inline this anymore.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cfun
operator|=
name|old_cfun
expr_stmt|;
name|current_function_decl
operator|=
name|old_cfun
condition|?
name|old_cfun
operator|->
name|decl
else|:
literal|0
expr_stmt|;
name|write_symbols
operator|=
name|old_write_symbols
expr_stmt|;
name|debug_hooks
operator|=
name|old_debug_hooks
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to keep track of the values hard regs had at the start of    the function.  */
end_comment

begin_function
name|rtx
name|get_hard_reg_initial_reg
parameter_list|(
name|fun
parameter_list|,
name|reg
parameter_list|)
name|struct
name|function
modifier|*
name|fun
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|struct
name|initial_value_struct
modifier|*
name|ivs
init|=
name|fun
operator|->
name|hard_reg_initial_vals
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ivs
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivs
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|hard_reg
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|rtx
name|has_func_hard_reg_initial_val
parameter_list|(
name|fun
parameter_list|,
name|reg
parameter_list|)
name|struct
name|function
modifier|*
name|fun
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|struct
name|initial_value_struct
modifier|*
name|ivs
init|=
name|fun
operator|->
name|hard_reg_initial_vals
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ivs
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivs
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|hard_reg
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|rtx
name|get_func_hard_reg_initial_val
parameter_list|(
name|fun
parameter_list|,
name|reg
parameter_list|)
name|struct
name|function
modifier|*
name|fun
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|struct
name|initial_value_struct
modifier|*
name|ivs
init|=
name|fun
operator|->
name|hard_reg_initial_vals
decl_stmt|;
name|rtx
name|rv
init|=
name|has_func_hard_reg_initial_val
argument_list|(
name|fun
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
name|rv
return|;
if|if
condition|(
name|ivs
operator|==
literal|0
condition|)
block|{
name|fun
operator|->
name|hard_reg_initial_vals
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|initial_value_struct
argument_list|)
argument_list|)
expr_stmt|;
name|ivs
operator|=
name|fun
operator|->
name|hard_reg_initial_vals
expr_stmt|;
name|ivs
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
name|ivs
operator|->
name|max_entries
operator|=
literal|5
expr_stmt|;
name|ivs
operator|->
name|entries
operator|=
operator|(
name|initial_value_pair
operator|*
operator|)
name|xmalloc
argument_list|(
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|initial_value_pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ivs
operator|->
name|num_entries
operator|>=
name|ivs
operator|->
name|max_entries
condition|)
block|{
name|ivs
operator|->
name|max_entries
operator|+=
literal|5
expr_stmt|;
name|ivs
operator|->
name|entries
operator|=
operator|(
name|initial_value_pair
operator|*
operator|)
name|xrealloc
argument_list|(
name|ivs
operator|->
name|entries
argument_list|,
name|ivs
operator|->
name|max_entries
operator|*
sizeof|sizeof
argument_list|(
name|initial_value_pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ivs
operator|->
name|entries
index|[
name|ivs
operator|->
name|num_entries
index|]
operator|.
name|hard_reg
operator|=
name|reg
expr_stmt|;
name|ivs
operator|->
name|entries
index|[
name|ivs
operator|->
name|num_entries
index|]
operator|.
name|pseudo
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ivs
operator|->
name|entries
index|[
name|ivs
operator|->
name|num_entries
operator|++
index|]
operator|.
name|pseudo
return|;
block|}
end_function

begin_function
name|rtx
name|get_hard_reg_initial_val
parameter_list|(
name|mode
parameter_list|,
name|regno
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
return|return
name|get_func_hard_reg_initial_val
argument_list|(
name|cfun
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|has_hard_reg_initial_val
parameter_list|(
name|mode
parameter_list|,
name|regno
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
return|return
name|has_func_hard_reg_initial_val
argument_list|(
name|cfun
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mark_hard_reg_initial_vals
parameter_list|(
name|fun
parameter_list|)
name|struct
name|function
modifier|*
name|fun
decl_stmt|;
block|{
name|struct
name|initial_value_struct
modifier|*
name|ivs
init|=
name|fun
operator|->
name|hard_reg_initial_vals
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ivs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivs
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|ggc_mark_rtx
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|hard_reg
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setup_initial_hard_reg_value_integration
parameter_list|(
name|inl_f
parameter_list|,
name|remap
parameter_list|)
name|struct
name|function
modifier|*
name|inl_f
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|remap
decl_stmt|;
block|{
name|struct
name|initial_value_struct
modifier|*
name|ivs
init|=
name|inl_f
operator|->
name|hard_reg_initial_vals
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ivs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivs
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
name|remap
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
argument_list|)
index|]
operator|=
name|get_func_hard_reg_initial_val
argument_list|(
name|cfun
argument_list|,
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|hard_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emit_initial_value_sets
parameter_list|()
block|{
name|struct
name|initial_value_struct
modifier|*
name|ivs
init|=
name|cfun
operator|->
name|hard_reg_initial_vals
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
if|if
condition|(
name|ivs
operator|==
literal|0
condition|)
return|return;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivs
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
argument_list|,
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|hard_reg
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|seq
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the backend knows where to allocate pseudos for hard    register initial values, register these allocations now.  */
end_comment

begin_function
name|void
name|allocate_initial_values
parameter_list|(
name|reg_equiv_memory_loc
parameter_list|)
name|rtx
modifier|*
name|reg_equiv_memory_loc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ALLOCATE_INITIAL_VALUE
name|struct
name|initial_value_struct
modifier|*
name|ivs
init|=
name|cfun
operator|->
name|hard_reg_initial_vals
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ivs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivs
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|ALLOCATE_INITIAL_VALUE
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|hard_reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
operator|||
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
empty_stmt|;
comment|/* Do nothing.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg_renumber
index|[
name|regno
index|]
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Poke the regno right into regno_reg_rtx 	     so that even fixed regs are accepted.  */
name|REGNO
argument_list|(
name|ivs
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pseudo
argument_list|)
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

