begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Precompiled header implementation for the C languages.    Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* This structure is read very early when validating the PCH, and    might be read for a PCH which is for a completely different compiler    for a different operating system.  Thus, it should really only contain    'unsigned char' entries, at least in the initial entries.       If you add or change entries before version_length, you should increase    the version number in get_ident().       There are a bunch of fields named *_length; those are lengths of data that    follows this structure in the same order as the fields in the structure.     The flags_info field is used to verify that certain flags settings that    have to be the same during the compilation of the PCH and a compilation    using the PCH are indeed the same.  */
end_comment

begin_struct
struct|struct
name|c_pch_validity
block|{
name|unsigned
name|char
name|host_machine_length
decl_stmt|;
name|unsigned
name|char
name|target_machine_length
decl_stmt|;
name|unsigned
name|char
name|version_length
decl_stmt|;
name|unsigned
name|char
name|debug_info_type
decl_stmt|;
name|unsigned
name|int
name|flags_info
decl_stmt|;
name|void
function_decl|(
modifier|*
name|pch_init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|size_t
name|target_data_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If -funit-at-a-time is set, we require that it was also set during the    compilation of the PCH we may be using.  */
end_comment

begin_define
define|#
directive|define
name|FLAG_UNIT_AT_A_TIME_SET
value|1<< 0
end_define

begin_struct
struct|struct
name|c_pch_header
block|{
name|unsigned
name|long
name|asm_size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IDENT_LENGTH
value|8
end_define

begin_comment
comment|/* The file we'll be writing the PCH to.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pch_outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The position in the assembler output file when pch_init was called.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|asm_file_startpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The host and target machines.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|host_machine
index|[]
init|=
name|HOST_MACHINE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|target_machine
index|[]
init|=
name|TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_ident
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Compute an appropriate 8-byte magic number for the PCH file, so that    utilities like file(1) can identify it, and so that GCC can quickly    ignore non-PCH files and PCH files that are of a completely different    format.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ident
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|result
index|[
name|IDENT_LENGTH
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
name|template
index|[
name|IDENT_LENGTH
index|]
init|=
literal|"gpch.012"
decl_stmt|;
specifier|static
specifier|const
name|char
name|c_language_chars
index|[]
init|=
literal|"Co+O"
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|template
argument_list|,
name|IDENT_LENGTH
argument_list|)
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|=
name|c_language_chars
index|[
name|c_language
index|]
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Prepare to write a PCH file.  This is called at the start of     compilation.  */
end_comment

begin_function
name|void
name|pch_init
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|c_pch_validity
name|v
decl_stmt|;
name|void
modifier|*
name|target_validity
decl_stmt|;
specifier|static
specifier|const
name|char
name|partial_pch
index|[
name|IDENT_LENGTH
index|]
init|=
literal|"gpcWrite"
decl_stmt|;
name|unsigned
name|int
name|current_flags_info
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pch_file
condition|)
return|return;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
name|current_flags_info
operator||=
name|FLAG_UNIT_AT_A_TIME_SET
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|pch_file
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|fatal_error
argument_list|(
literal|"can't create precompiled header %s: %m"
argument_list|,
name|pch_file
argument_list|)
expr_stmt|;
name|pch_outfile
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|host_machine
argument_list|)
operator|>
literal|255
operator|||
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|>
literal|255
operator|||
name|strlen
argument_list|(
name|version_string
argument_list|)
operator|>
literal|255
condition|)
name|abort
argument_list|()
expr_stmt|;
name|v
operator|.
name|host_machine_length
operator|=
name|strlen
argument_list|(
name|host_machine
argument_list|)
expr_stmt|;
name|v
operator|.
name|target_machine_length
operator|=
name|strlen
argument_list|(
name|target_machine
argument_list|)
expr_stmt|;
name|v
operator|.
name|version_length
operator|=
name|strlen
argument_list|(
name|version_string
argument_list|)
expr_stmt|;
name|v
operator|.
name|debug_info_type
operator|=
name|write_symbols
expr_stmt|;
name|v
operator|.
name|flags_info
operator|=
name|current_flags_info
expr_stmt|;
name|v
operator|.
name|pch_init
operator|=
operator|&
name|pch_init
expr_stmt|;
name|target_validity
operator|=
name|targetm
operator|.
name|get_pch_validity
argument_list|(
operator|&
name|v
operator|.
name|target_data_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|partial_pch
argument_list|,
name|IDENT_LENGTH
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|host_machine
argument_list|,
name|v
operator|.
name|host_machine_length
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|target_machine
argument_list|,
name|v
operator|.
name|target_machine_length
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|version_string
argument_list|,
name|v
operator|.
name|version_length
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|target_validity
argument_list|,
name|v
operator|.
name|target_data_length
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write to %s: %m"
argument_list|,
name|pch_file
argument_list|)
expr_stmt|;
comment|/* We need to be able to re-read the output.  */
comment|/* The driver always provides a valid -o option.  */
if|if
condition|(
name|asm_file_name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|asm_file_name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"`%s' is not a valid output file"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
name|asm_file_startpos
operator|=
name|ftell
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Let the debugging format deal with the PCHness.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|handle_pch
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cpp_save_state
argument_list|(
name|parse_in
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the PCH file.  This is called at the end of a compilation which    will produce a PCH file.  */
end_comment

begin_function
name|void
name|c_common_write_pch
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|asm_file_end
decl_stmt|;
name|long
name|written
decl_stmt|;
name|struct
name|c_pch_header
name|h
decl_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|handle_pch
call|)
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cpp_write_pch_deps
argument_list|(
name|parse_in
argument_list|,
name|pch_outfile
argument_list|)
expr_stmt|;
name|asm_file_end
operator|=
name|ftell
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|h
operator|.
name|asm_size
operator|=
name|asm_file_end
operator|-
name|asm_file_startpos
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
literal|1
argument_list|,
name|pch_outfile
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write %s: %m"
argument_list|,
name|pch_file
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
literal|16384
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|asm_out_file
argument_list|,
name|asm_file_startpos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't seek in %s: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
for|for
control|(
name|written
operator|=
name|asm_file_startpos
init|;
name|written
operator|<
name|asm_file_end
condition|;
control|)
block|{
name|long
name|size
init|=
name|asm_file_end
operator|-
name|written
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|16384
condition|)
name|size
operator|=
literal|16384
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|asm_out_file
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read %s: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|pch_outfile
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write %s: %m"
argument_list|,
name|pch_file
argument_list|)
expr_stmt|;
name|written
operator|+=
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* asm_out_file can be written afterwards, so must be flushed first.  */
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|gt_pch_save
argument_list|(
name|pch_outfile
argument_list|)
expr_stmt|;
name|cpp_write_pch_state
argument_list|(
name|parse_in
argument_list|,
name|pch_outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|pch_outfile
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|fwrite
argument_list|(
name|get_ident
argument_list|()
argument_list|,
name|IDENT_LENGTH
argument_list|,
literal|1
argument_list|,
name|pch_outfile
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write %s: %m"
argument_list|,
name|pch_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pch_outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the PCH file called NAME, open on FD, to see if it can be    used in this compilation.  Return 1 if valid, 0 if the file can't    be used now but might be if it's seen later in the compilation, and    2 if this file could never be used in the compilation.  */
end_comment

begin_function
name|int
name|c_common_valid_pch
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|int
name|sizeread
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
name|ident
index|[
name|IDENT_LENGTH
index|]
decl_stmt|;
name|char
name|short_strings
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|strings_length
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch_ident
decl_stmt|;
name|struct
name|c_pch_validity
name|v
decl_stmt|;
name|unsigned
name|int
name|current_flags_info
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
name|current_flags_info
operator||=
name|FLAG_UNIT_AT_A_TIME_SET
expr_stmt|;
comment|/* Perform a quick test of whether this is a valid      precompiled header for the current language      and with the current flag settings.  */
name|sizeread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|ident
argument_list|,
name|IDENT_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizeread
operator|==
operator|-
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read %s: %m"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sizeread
operator|!=
name|IDENT_LENGTH
condition|)
return|return
literal|2
return|;
name|pch_ident
operator|=
name|get_ident
argument_list|()
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|ident
argument_list|,
name|pch_ident
argument_list|,
name|IDENT_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|ident
argument_list|,
name|pch_ident
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
comment|/* It's a PCH, for the right language, but has the wrong version. 	     */
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: not compatible with this GCC version"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ident
argument_list|,
name|pch_ident
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* It's a PCH for the wrong language.  */
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: not for %s"
argument_list|,
name|name
argument_list|,
name|lang_hooks
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* Not any kind of PCH.  */
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: not a PCH file"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
comment|/* At this point, we know it's a PCH file, so it ought to be long enough      that we can read a c_pch_validity structure.  */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|v
argument_list|)
condition|)
name|fatal_error
argument_list|(
literal|"can't read %s: %m"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strings_length
operator|=
operator|(
name|v
operator|.
name|host_machine_length
operator|+
name|v
operator|.
name|target_machine_length
operator|+
name|v
operator|.
name|version_length
operator|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|short_strings
argument_list|,
name|strings_length
argument_list|)
operator|!=
name|strings_length
condition|)
name|fatal_error
argument_list|(
literal|"can't read %s: %m"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|host_machine_length
operator|!=
name|strlen
argument_list|(
name|host_machine
argument_list|)
operator|||
name|memcmp
argument_list|(
name|host_machine
argument_list|,
name|short_strings
argument_list|,
name|strlen
argument_list|(
name|host_machine
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: created on host `%.*s', but used on host `%s'"
argument_list|,
name|name
argument_list|,
name|v
operator|.
name|host_machine_length
argument_list|,
name|short_strings
argument_list|,
name|host_machine
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|v
operator|.
name|target_machine_length
operator|!=
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|||
name|memcmp
argument_list|(
name|target_machine
argument_list|,
name|short_strings
operator|+
name|v
operator|.
name|host_machine_length
argument_list|,
name|strlen
argument_list|(
name|target_machine
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: created for target `%.*s', but used for target `%s'"
argument_list|,
name|name
argument_list|,
name|v
operator|.
name|target_machine_length
argument_list|,
name|short_strings
operator|+
name|v
operator|.
name|host_machine_length
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|v
operator|.
name|version_length
operator|!=
name|strlen
argument_list|(
name|version_string
argument_list|)
operator|||
name|memcmp
argument_list|(
name|version_string
argument_list|,
operator|(
name|short_strings
operator|+
name|v
operator|.
name|host_machine_length
operator|+
name|v
operator|.
name|target_machine_length
operator|)
argument_list|,
name|v
operator|.
name|version_length
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: created by version `%.*s', but this is version `%s'"
argument_list|,
name|name
argument_list|,
name|v
operator|.
name|version_length
argument_list|,
operator|(
name|short_strings
operator|+
name|v
operator|.
name|host_machine_length
operator|+
name|v
operator|.
name|target_machine_length
operator|)
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|v
operator|.
name|flags_info
operator|!=
name|current_flags_info
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: created using different flags"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|/* The allowable debug info combinations are that either the PCH file      was built with the same as is being used now, or the PCH file was      built for some kind of debug info but now none is in use.  */
if|if
condition|(
name|v
operator|.
name|debug_info_type
operator|!=
name|write_symbols
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: created with -g%s, but used with -g%s"
argument_list|,
name|name
argument_list|,
name|debug_type_names
index|[
name|v
operator|.
name|debug_info_type
index|]
argument_list|,
name|debug_type_names
index|[
name|write_symbols
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|/* If the text segment was not loaded at the same address as it was      when the PCH file was created, function pointers loaded from the      PCH will not be valid.  We could in theory remap all the function      pointers, but no support for that exists at present.  */
if|if
condition|(
name|v
operator|.
name|pch_init
operator|!=
operator|&
name|pch_init
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: had text segment at different address"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|/* Check the target-specific validity data.  */
block|{
name|void
modifier|*
name|this_file_data
init|=
name|xmalloc
argument_list|(
name|v
operator|.
name|target_data_length
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|this_file_data
argument_list|,
name|v
operator|.
name|target_data_length
argument_list|)
operator|!=
name|v
operator|.
name|target_data_length
condition|)
name|fatal_error
argument_list|(
literal|"can't read %s: %m"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|msg
operator|=
name|targetm
operator|.
name|pch_valid_p
argument_list|(
name|this_file_data
argument_list|,
name|v
operator|.
name|target_data_length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|this_file_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
comment|/* Check the preprocessor macros are the same as when the PCH was      generated.  */
name|result
operator|=
name|cpp_valid_state
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
return|return
literal|2
return|;
else|else
return|return
name|result
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Load in the PCH file NAME, open on FD.  It was originally searched for    by ORIG_NAME.  */
end_comment

begin_function
name|void
name|c_common_read_pch
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|c_pch_header
name|h
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|written
decl_stmt|;
name|struct
name|save_macro_data
modifier|*
name|smd
decl_stmt|;
name|f
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"calling fdopen"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
operator|->
name|valid_pch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"reading"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|xmalloc
argument_list|(
literal|16384
argument_list|)
expr_stmt|;
for|for
control|(
name|written
operator|=
literal|0
init|;
name|written
operator|<
name|h
operator|.
name|asm_size
condition|;
control|)
block|{
name|long
name|size
init|=
name|h
operator|.
name|asm_size
operator|-
name|written
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|16384
condition|)
name|size
operator|=
literal|16384
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|asm_out_file
argument_list|)
operator|!=
literal|1
condition|)
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"reading"
argument_list|)
expr_stmt|;
name|written
operator|+=
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cpp_prepare_state
argument_list|(
name|pfile
argument_list|,
operator|&
name|smd
argument_list|)
expr_stmt|;
name|gt_pch_restore
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_read_state
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|f
argument_list|,
name|smd
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that no more PCH files should be read.  */
end_comment

begin_function
name|void
name|c_common_no_more_pch
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
operator|->
name|valid_pch
condition|)
block|{
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
operator|->
name|valid_pch
operator|=
name|NULL
expr_stmt|;
name|host_hooks
operator|.
name|gt_pch_use_address
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

