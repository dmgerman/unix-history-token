begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DDG - Data Dependence Graph implementation.    Copyright (C) 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Ayal Zaks and Mustafa Hagog<zaks,mustafa@il.ibm.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"ddg.h"
end_include

begin_comment
comment|/* A flag indicating that a ddg edge belongs to an SCC or not.  */
end_comment

begin_enum
enum|enum
name|edge_flag
block|{
name|NOT_IN_SCC
init|=
literal|0
block|,
name|IN_SCC
block|}
enum|;
end_enum

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|add_backarc_to_ddg
parameter_list|(
name|ddg_ptr
parameter_list|,
name|ddg_edge_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_backarc_to_scc
parameter_list|(
name|ddg_scc_ptr
parameter_list|,
name|ddg_edge_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_scc_to_ddg
parameter_list|(
name|ddg_all_sccs_ptr
parameter_list|,
name|ddg_scc_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_ddg_dependence
parameter_list|(
name|ddg_ptr
parameter_list|,
name|ddg_node_ptr
parameter_list|,
name|ddg_node_ptr
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_ddg_dep_no_link
parameter_list|(
name|ddg_ptr
parameter_list|,
name|ddg_node_ptr
parameter_list|,
name|ddg_node_ptr
parameter_list|,
name|dep_type
parameter_list|,
name|dep_data_type
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ddg_edge_ptr
name|create_ddg_edge
parameter_list|(
name|ddg_node_ptr
parameter_list|,
name|ddg_node_ptr
parameter_list|,
name|dep_type
parameter_list|,
name|dep_data_type
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_edge_to_ddg
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|ddg_edge_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Auxiliary variable for mem_read_insn_p/mem_write_insn_p.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|mem_ref_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Auxiliary function for mem_read_insn_p.  */
end_comment

begin_function
specifier|static
name|int
name|mark_mem_use
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|MEM_P
argument_list|(
operator|*
name|x
argument_list|)
condition|)
name|mem_ref_p
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Auxiliary function for mem_read_insn_p.  */
end_comment

begin_function
specifier|static
name|void
name|mark_mem_use_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|for_each_rtx
argument_list|(
name|x
argument_list|,
name|mark_mem_use
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if INSN reads from memory.  */
end_comment

begin_function
specifier|static
name|bool
name|mem_read_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|mem_ref_p
operator|=
name|false
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_mem_use_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|mem_ref_p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_mem_store
parameter_list|(
name|rtx
name|loc
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
argument_list|)
condition|)
name|mem_ref_p
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if INSN writes to memory.  */
end_comment

begin_function
specifier|static
name|bool
name|mem_write_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|mem_ref_p
operator|=
name|false
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_mem_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|mem_ref_p
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if X has access to memory.  */
end_comment

begin_function
specifier|static
name|bool
name|rtx_mem_access_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_mem_access_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rtx_mem_access_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if INSN reads to or writes from memory.  */
end_comment

begin_function
specifier|static
name|bool
name|mem_access_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|rtx_mem_access_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Computes the dependence parameters (latency, distance etc.), creates    a ddg_edge and adds it to the given DDG.  */
end_comment

begin_function
specifier|static
name|void
name|create_ddg_dependence
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|ddg_node_ptr
name|src_node
parameter_list|,
name|ddg_node_ptr
name|dest_node
parameter_list|,
name|rtx
name|link
parameter_list|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|latency
decl_stmt|,
name|distance
init|=
literal|0
decl_stmt|;
name|int
name|interloop
init|=
operator|(
name|src_node
operator|->
name|cuid
operator|>=
name|dest_node
operator|->
name|cuid
operator|)
decl_stmt|;
name|dep_type
name|t
init|=
name|TRUE_DEP
decl_stmt|;
name|dep_data_type
name|dt
init|=
operator|(
name|mem_access_insn_p
argument_list|(
name|src_node
operator|->
name|insn
argument_list|)
operator|&&
name|mem_access_insn_p
argument_list|(
name|dest_node
operator|->
name|insn
argument_list|)
condition|?
name|MEM_DEP
else|:
name|REG_DEP
operator|)
decl_stmt|;
comment|/* For now we don't have an exact calculation of the distance,      so assume 1 conservatively.  */
if|if
condition|(
name|interloop
condition|)
name|distance
operator|=
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* Note: REG_DEP_ANTI applies to MEM ANTI_DEP as well!!  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
condition|)
name|t
operator|=
name|ANTI_DEP
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
name|t
operator|=
name|OUTPUT_DEP
expr_stmt|;
name|latency
operator|=
name|insn_cost
argument_list|(
name|src_node
operator|->
name|insn
argument_list|,
name|link
argument_list|,
name|dest_node
operator|->
name|insn
argument_list|)
expr_stmt|;
name|e
operator|=
name|create_ddg_edge
argument_list|(
name|src_node
argument_list|,
name|dest_node
argument_list|,
name|t
argument_list|,
name|dt
argument_list|,
name|latency
argument_list|,
name|distance
argument_list|)
expr_stmt|;
if|if
condition|(
name|interloop
condition|)
block|{
comment|/* Some interloop dependencies are relaxed: 	 1. Every insn is output dependent on itself; ignore such deps. 	 2. Every true/flow dependence is an anti dependence in the 	 opposite direction with distance 1; such register deps 	 will be removed by renaming if broken --- ignore them.  */
if|if
condition|(
operator|!
operator|(
name|t
operator|==
name|OUTPUT_DEP
operator|&&
name|src_node
operator|==
name|dest_node
operator|)
operator|&&
operator|!
operator|(
name|t
operator|==
name|ANTI_DEP
operator|&&
name|dt
operator|==
name|REG_DEP
operator|)
condition|)
name|add_backarc_to_ddg
argument_list|(
name|g
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|ANTI_DEP
operator|&&
name|dt
operator|==
name|REG_DEP
condition|)
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* We can fix broken anti register deps using reg-moves.  */
else|else
name|add_edge_to_ddg
argument_list|(
name|g
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The same as the above function, but it doesn't require a link parameter.  */
end_comment

begin_function
specifier|static
name|void
name|create_ddg_dep_no_link
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|ddg_node_ptr
name|from
parameter_list|,
name|ddg_node_ptr
name|to
parameter_list|,
name|dep_type
name|d_t
parameter_list|,
name|dep_data_type
name|d_dt
parameter_list|,
name|int
name|distance
parameter_list|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|l
decl_stmt|;
name|rtx
name|link
init|=
name|alloc_INSN_LIST
argument_list|(
name|to
operator|->
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|d_t
operator|==
name|ANTI_DEP
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d_t
operator|==
name|OUTPUT_DEP
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|l
operator|=
name|insn_cost
argument_list|(
name|from
operator|->
name|insn
argument_list|,
name|link
argument_list|,
name|to
operator|->
name|insn
argument_list|)
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|e
operator|=
name|create_ddg_edge
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|d_t
argument_list|,
name|d_dt
argument_list|,
name|l
argument_list|,
name|distance
argument_list|)
expr_stmt|;
if|if
condition|(
name|distance
operator|>
literal|0
condition|)
name|add_backarc_to_ddg
argument_list|(
name|g
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|add_edge_to_ddg
argument_list|(
name|g
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a downwards exposed register def RD, add inter-loop true dependences    for all its uses in the next iteration, and an output dependence to the    first def of the next iteration.  */
end_comment

begin_function
specifier|static
name|void
name|add_deps_for_def
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|df_ref
modifier|*
name|rd
parameter_list|)
block|{
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|rd
argument_list|)
decl_stmt|;
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
name|DF_RU_BB_INFO
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|bb
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|r_use
decl_stmt|;
name|int
name|use_before_def
init|=
name|false
decl_stmt|;
name|rtx
name|def_insn
init|=
name|DF_REF_INSN
argument_list|(
name|rd
argument_list|)
decl_stmt|;
name|ddg_node_ptr
name|src_node
init|=
name|get_node_of_insn
argument_list|(
name|g
argument_list|,
name|def_insn
argument_list|)
decl_stmt|;
comment|/* Create and inter-loop true dependence between RD and each of its uses      that is upwards exposed in RD's block.  */
for|for
control|(
name|r_use
operator|=
name|DF_REF_CHAIN
argument_list|(
name|rd
argument_list|)
init|;
name|r_use
operator|!=
name|NULL
condition|;
name|r_use
operator|=
name|r_use
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|r_use
operator|->
name|ref
operator|->
name|id
argument_list|)
condition|)
block|{
name|rtx
name|use_insn
init|=
name|DF_REF_INSN
argument_list|(
name|r_use
operator|->
name|ref
argument_list|)
decl_stmt|;
name|ddg_node_ptr
name|dest_node
init|=
name|get_node_of_insn
argument_list|(
name|g
argument_list|,
name|use_insn
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|src_node
operator|&&
name|dest_node
argument_list|)
expr_stmt|;
comment|/* Any such upwards exposed use appears before the rd def.  */
name|use_before_def
operator|=
name|true
expr_stmt|;
name|create_ddg_dep_no_link
argument_list|(
name|g
argument_list|,
name|src_node
argument_list|,
name|dest_node
argument_list|,
name|TRUE_DEP
argument_list|,
name|REG_DEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create an inter-loop output dependence between RD (which is the      last def in its block, being downwards exposed) and the first def      in its block.  Avoid creating a self output dependence.  Avoid creating      an output dependence if there is a dependence path between the two defs      starting with a true dependence followed by an anti dependence (i.e. if      there is a use between the two defs.  */
if|if
condition|(
operator|!
name|use_before_def
condition|)
block|{
name|struct
name|df_ref
modifier|*
name|def
init|=
name|df_bb_regno_first_def_find
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|bb
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ddg_node_ptr
name|dest_node
decl_stmt|;
if|if
condition|(
operator|!
name|def
operator|||
name|rd
operator|->
name|id
operator|==
name|def
operator|->
name|id
condition|)
return|return;
comment|/* Check if there are uses after RD.  */
for|for
control|(
name|i
operator|=
name|src_node
operator|->
name|cuid
operator|+
literal|1
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|df_find_use
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|rd
operator|->
name|reg
argument_list|)
condition|)
return|return;
name|dest_node
operator|=
name|get_node_of_insn
argument_list|(
name|g
argument_list|,
name|def
operator|->
name|insn
argument_list|)
expr_stmt|;
name|create_ddg_dep_no_link
argument_list|(
name|g
argument_list|,
name|src_node
argument_list|,
name|dest_node
argument_list|,
name|OUTPUT_DEP
argument_list|,
name|REG_DEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a register USE, add an inter-loop anti dependence to the first    (nearest BLOCK_BEGIN) def of the next iteration, unless USE is followed    by a def in the block.  */
end_comment

begin_function
specifier|static
name|void
name|add_deps_for_use
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|df_ref
modifier|*
name|use
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|first_def
init|=
name|df_bb_regno_first_def_find
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|bb
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|ddg_node_ptr
name|use_node
decl_stmt|;
name|ddg_node_ptr
name|def_node
decl_stmt|;
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
decl_stmt|;
name|bb_info
operator|=
name|DF_RD_BB_INFO
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_def
condition|)
return|return;
name|use_node
operator|=
name|get_node_of_insn
argument_list|(
name|g
argument_list|,
name|use
operator|->
name|insn
argument_list|)
expr_stmt|;
name|def_node
operator|=
name|get_node_of_insn
argument_list|(
name|g
argument_list|,
name|first_def
operator|->
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|use_node
operator|&&
name|def_node
argument_list|)
expr_stmt|;
comment|/* Make sure there are no defs after USE.  */
for|for
control|(
name|i
operator|=
name|use_node
operator|->
name|cuid
operator|+
literal|1
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|df_find_def
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|use
operator|->
name|reg
argument_list|)
condition|)
return|return;
comment|/* We must not add ANTI dep when there is an intra-loop TRUE dep in      the opposite direction. If the first_def reaches the USE then there is      such a dep.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|first_def
operator|->
name|id
argument_list|)
condition|)
name|create_ddg_dep_no_link
argument_list|(
name|g
argument_list|,
name|use_node
argument_list|,
name|def_node
argument_list|,
name|ANTI_DEP
argument_list|,
name|REG_DEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build inter-loop dependencies, by looking at DF analysis backwards.  */
end_comment

begin_function
specifier|static
name|void
name|build_inter_loop_deps
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|unsigned
name|rd_num
decl_stmt|,
name|u_num
decl_stmt|;
name|struct
name|df_rd_bb_info
modifier|*
name|rd_bb_info
decl_stmt|;
name|struct
name|df_ru_bb_info
modifier|*
name|ru_bb_info
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|rd_bb_info
operator|=
name|DF_RD_BB_INFO
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|bb
argument_list|)
expr_stmt|;
comment|/* Find inter-loop output and true deps by connecting downward exposed defs      to the first def of the BB and to upwards exposed uses.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|rd_bb_info->gen
argument_list|,
literal|0
argument_list|,
argument|rd_num
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ref
modifier|*
name|rd
init|=
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|rd_num
argument_list|)
decl_stmt|;
name|add_deps_for_def
argument_list|(
name|g
argument_list|,
name|df
argument_list|,
name|rd
argument_list|)
expr_stmt|;
block|}
name|ru_bb_info
operator|=
name|DF_RU_BB_INFO
argument_list|(
name|df
argument_list|,
name|g
operator|->
name|bb
argument_list|)
expr_stmt|;
comment|/* Find inter-loop anti deps.  We are interested in uses of the block that      appear below all defs; this implies that these uses are killed.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ru_bb_info->kill
argument_list|,
literal|0
argument_list|,
argument|u_num
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ref
modifier|*
name|use
init|=
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|u_num
argument_list|)
decl_stmt|;
comment|/* We are interested in uses of this BB.  */
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|use
operator|->
name|insn
argument_list|)
operator|==
name|g
operator|->
name|bb
condition|)
name|add_deps_for_use
argument_list|(
name|g
argument_list|,
name|df
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given two nodes, analyze their RTL insns and add inter-loop mem deps    to ddg G.  */
end_comment

begin_function
specifier|static
name|void
name|add_inter_loop_mem_dep
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|ddg_node_ptr
name|from
parameter_list|,
name|ddg_node_ptr
name|to
parameter_list|)
block|{
if|if
condition|(
name|mem_write_insn_p
argument_list|(
name|from
operator|->
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|mem_read_insn_p
argument_list|(
name|to
operator|->
name|insn
argument_list|)
condition|)
name|create_ddg_dep_no_link
argument_list|(
name|g
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|TRUE_DEP
argument_list|,
name|MEM_DEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|->
name|cuid
operator|!=
name|to
operator|->
name|cuid
condition|)
name|create_ddg_dep_no_link
argument_list|(
name|g
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|OUTPUT_DEP
argument_list|,
name|MEM_DEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mem_read_insn_p
argument_list|(
name|to
operator|->
name|insn
argument_list|)
condition|)
return|return;
elseif|else
if|if
condition|(
name|from
operator|->
name|cuid
operator|!=
name|to
operator|->
name|cuid
condition|)
block|{
name|create_ddg_dep_no_link
argument_list|(
name|g
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|ANTI_DEP
argument_list|,
name|MEM_DEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|create_ddg_dep_no_link
argument_list|(
name|g
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|TRUE_DEP
argument_list|,
name|MEM_DEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform intra-block Data Dependency analysis and connect the nodes in    the DDG.  We assume the loop has a single basic block.  */
end_comment

begin_function
specifier|static
name|void
name|build_intra_loop_deps
parameter_list|(
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Hold the dependency analysis state during dependency calculations.  */
name|struct
name|deps
name|tmp_deps
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|link
decl_stmt|;
comment|/* Build the dependence information, using the sched_analyze function.  */
name|init_deps_global
argument_list|()
expr_stmt|;
name|init_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
comment|/* Do the intra-block data dependence analysis for the given block.  */
name|get_ebb_head_tail
argument_list|(
name|g
operator|->
name|bb
argument_list|,
name|g
operator|->
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|sched_analyze
argument_list|(
operator|&
name|tmp_deps
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* Build intra-loop data dependencies using the scheduler dependency      analysis.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|ddg_node_ptr
name|dest_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|dest_node
operator|->
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|dest_node
operator|->
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ddg_node_ptr
name|src_node
init|=
name|get_node_of_insn
argument_list|(
name|g
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|src_node
condition|)
continue|continue;
name|add_forw_dep
argument_list|(
name|dest_node
operator|->
name|insn
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|create_ddg_dependence
argument_list|(
name|g
argument_list|,
name|src_node
argument_list|,
name|dest_node
argument_list|,
name|INSN_DEPEND
argument_list|(
name|src_node
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this insn modifies memory, add an edge to all insns that access 	 memory.  */
if|if
condition|(
name|mem_access_insn_p
argument_list|(
name|dest_node
operator|->
name|insn
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
block|{
name|ddg_node_ptr
name|j_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|mem_access_insn_p
argument_list|(
name|j_node
operator|->
name|insn
argument_list|)
condition|)
comment|/* Don't bother calculating inter-loop dep if an intra-loop dep 		   already exists.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dest_node
operator|->
name|successors
argument_list|,
name|j
argument_list|)
condition|)
name|add_inter_loop_mem_dep
argument_list|(
name|g
argument_list|,
name|dest_node
argument_list|,
name|j_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Free the INSN_LISTs.  */
name|finish_deps_global
argument_list|()
expr_stmt|;
name|free_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a basic block, create its DDG and return a pointer to a variable    of ddg type that represents it.    Initialize the ddg structure fields to the appropriate values.  */
end_comment

begin_function
name|ddg_ptr
name|create_ddg
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|closing_branch_deps
parameter_list|)
block|{
name|ddg_ptr
name|g
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|first_note
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_nodes
init|=
literal|0
decl_stmt|;
name|g
operator|=
operator|(
name|ddg_ptr
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ddg
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|bb
operator|=
name|bb
expr_stmt|;
name|g
operator|->
name|closing_branch_deps
operator|=
name|closing_branch_deps
expr_stmt|;
comment|/* Count the number of insns in the BB.  */
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
continue|continue;
if|if
condition|(
name|mem_read_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|g
operator|->
name|num_loads
operator|++
expr_stmt|;
if|if
condition|(
name|mem_write_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|g
operator|->
name|num_stores
operator|++
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
block|}
comment|/* There is nothing to do for this BB.  */
if|if
condition|(
name|num_nodes
operator|<=
literal|1
condition|)
block|{
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Allocate the nodes array, and initialize the nodes.  */
name|g
operator|->
name|num_nodes
operator|=
name|num_nodes
expr_stmt|;
name|g
operator|->
name|nodes
operator|=
operator|(
name|ddg_node_ptr
operator|)
name|xcalloc
argument_list|(
name|num_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ddg_node
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|closing_branch
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|first_note
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_note
operator|&&
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
condition|)
name|first_note
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|g
operator|->
name|closing_branch
argument_list|)
expr_stmt|;
name|g
operator|->
name|closing_branch
operator|=
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
if|if
condition|(
operator|!
name|first_note
condition|)
name|first_note
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|cuid
operator|=
name|i
expr_stmt|;
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|successors
operator|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|successors
argument_list|)
expr_stmt|;
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|predecessors
operator|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|predecessors
argument_list|)
expr_stmt|;
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|first_note
operator|=
operator|(
name|first_note
condition|?
name|first_note
else|:
name|insn
operator|)
expr_stmt|;
name|g
operator|->
name|nodes
index|[
name|i
operator|++
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|first_note
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* We must have found a branch in DDG.  */
name|gcc_assert
argument_list|(
name|g
operator|->
name|closing_branch
argument_list|)
expr_stmt|;
comment|/* Build the data dependency graph.  */
name|build_intra_loop_deps
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|build_inter_loop_deps
argument_list|(
name|g
argument_list|,
name|df
argument_list|)
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Free all the memory allocated for the DDG.  */
end_comment

begin_function
name|void
name|free_ddg
parameter_list|(
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|ddg_edge_ptr
name|e
init|=
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|out
decl_stmt|;
while|while
condition|(
name|e
condition|)
block|{
name|ddg_edge_ptr
name|next
init|=
name|e
operator|->
name|next_out
decl_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|successors
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|predecessors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|->
name|num_backarcs
operator|>
literal|0
condition|)
name|free
argument_list|(
name|g
operator|->
name|backarcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_ddg_edge
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|ddg_edge_ptr
name|e
parameter_list|)
block|{
name|char
name|dep_c
decl_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|OUTPUT_DEP
case|:
name|dep_c
operator|=
literal|'O'
expr_stmt|;
break|break;
case|case
name|ANTI_DEP
case|:
name|dep_c
operator|=
literal|'A'
expr_stmt|;
break|break;
default|default:
name|dep_c
operator|=
literal|'T'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [%d -(%c,%d,%d)-> %d] "
argument_list|,
name|INSN_UID
argument_list|(
name|e
operator|->
name|src
operator|->
name|insn
argument_list|)
argument_list|,
name|dep_c
argument_list|,
name|e
operator|->
name|latency
argument_list|,
name|e
operator|->
name|distance
argument_list|,
name|INSN_UID
argument_list|(
name|e
operator|->
name|dest
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the DDG nodes with there in/out edges to the dump file.  */
end_comment

begin_function
name|void
name|print_ddg
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|print_rtl_single
argument_list|(
name|file
argument_list|,
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"OUT ARCS: "
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
name|print_ddg_edge
argument_list|(
name|file
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nIN ARCS: "
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|in
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_in
control|)
name|print_ddg_edge
argument_list|(
name|file
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the given DDG in VCG format.  */
end_comment

begin_function
name|void
name|vcg_print_ddg
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|src_cuid
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"graph: {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|src_cuid
operator|=
literal|0
init|;
name|src_cuid
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|src_cuid
operator|++
control|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|src_uid
init|=
name|INSN_UID
argument_list|(
name|g
operator|->
name|nodes
index|[
name|src_cuid
index|]
operator|.
name|insn
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"node: {title: \"%d_%d\" info1: \""
argument_list|,
name|src_cuid
argument_list|,
name|src_uid
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|file
argument_list|,
name|g
operator|->
name|nodes
index|[
name|src_cuid
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"}\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|g
operator|->
name|nodes
index|[
name|src_cuid
index|]
operator|.
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
block|{
name|int
name|dst_uid
init|=
name|INSN_UID
argument_list|(
name|e
operator|->
name|dest
operator|->
name|insn
argument_list|)
decl_stmt|;
name|int
name|dst_cuid
init|=
name|e
operator|->
name|dest
operator|->
name|cuid
decl_stmt|;
comment|/* Give the backarcs a different color.  */
if|if
condition|(
name|e
operator|->
name|distance
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"backedge: {color: red "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"edge: { "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"sourcename: \"%d_%d\" "
argument_list|,
name|src_cuid
argument_list|,
name|src_uid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"targetname: \"%d_%d\" "
argument_list|,
name|dst_cuid
argument_list|,
name|dst_uid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"label: \"%d_%d\"}\n"
argument_list|,
name|e
operator|->
name|latency
argument_list|,
name|e
operator|->
name|distance
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an edge and initialize it with given values.  */
end_comment

begin_function
specifier|static
name|ddg_edge_ptr
name|create_ddg_edge
parameter_list|(
name|ddg_node_ptr
name|src
parameter_list|,
name|ddg_node_ptr
name|dest
parameter_list|,
name|dep_type
name|t
parameter_list|,
name|dep_data_type
name|dt
parameter_list|,
name|int
name|l
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|ddg_edge_ptr
name|e
init|=
operator|(
name|ddg_edge_ptr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ddg_edge
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|src
operator|=
name|src
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|dest
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|e
operator|->
name|data_type
operator|=
name|dt
expr_stmt|;
name|e
operator|->
name|latency
operator|=
name|l
expr_stmt|;
name|e
operator|->
name|distance
operator|=
name|d
expr_stmt|;
name|e
operator|->
name|next_in
operator|=
name|e
operator|->
name|next_out
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|aux
operator|.
name|info
operator|=
literal|0
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Add the given edge to the in/out linked lists of the DDG nodes.  */
end_comment

begin_function
specifier|static
name|void
name|add_edge_to_ddg
parameter_list|(
name|ddg_ptr
name|g
name|ATTRIBUTE_UNUSED
parameter_list|,
name|ddg_edge_ptr
name|e
parameter_list|)
block|{
name|ddg_node_ptr
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|ddg_node_ptr
name|dest
init|=
name|e
operator|->
name|dest
decl_stmt|;
comment|/* Should have allocated the sbitmaps.  */
name|gcc_assert
argument_list|(
name|src
operator|->
name|successors
operator|&&
name|dest
operator|->
name|predecessors
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|src
operator|->
name|successors
argument_list|,
name|dest
operator|->
name|cuid
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|dest
operator|->
name|predecessors
argument_list|,
name|src
operator|->
name|cuid
argument_list|)
expr_stmt|;
name|e
operator|->
name|next_in
operator|=
name|dest
operator|->
name|in
expr_stmt|;
name|dest
operator|->
name|in
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|next_out
operator|=
name|src
operator|->
name|out
expr_stmt|;
name|src
operator|->
name|out
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Algorithm for computing the recurrence_length of an scc.  We assume at    for now that cycles in the data dependence graph contain a single backarc.    This simplifies the algorithm, and can be generalized later.  */
end_comment

begin_function
specifier|static
name|void
name|set_recurrence_length
parameter_list|(
name|ddg_scc_ptr
name|scc
parameter_list|,
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scc
operator|->
name|num_backarcs
condition|;
name|j
operator|++
control|)
block|{
name|ddg_edge_ptr
name|backarc
init|=
name|scc
operator|->
name|backarcs
index|[
name|j
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|distance
init|=
name|backarc
operator|->
name|distance
decl_stmt|;
name|ddg_node_ptr
name|src
init|=
name|backarc
operator|->
name|dest
decl_stmt|;
name|ddg_node_ptr
name|dest
init|=
name|backarc
operator|->
name|src
decl_stmt|;
name|length
operator|=
name|longest_simple_path
argument_list|(
name|g
argument_list|,
name|src
operator|->
name|cuid
argument_list|,
name|dest
operator|->
name|cuid
argument_list|,
name|scc
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
comment|/* fprintf (stderr, "Backarc not on simple cycle in SCC.\n"); */
continue|continue;
block|}
name|length
operator|+=
name|backarc
operator|->
name|latency
expr_stmt|;
name|result
operator|=
name|MAX
argument_list|(
name|result
argument_list|,
operator|(
name|length
operator|/
name|distance
operator|)
argument_list|)
expr_stmt|;
block|}
name|scc
operator|->
name|recurrence_length
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new SCC given the set of its nodes.  Compute its recurrence_length    and mark edges that belong to this scc as IN_SCC.  */
end_comment

begin_function
specifier|static
name|ddg_scc_ptr
name|create_scc
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|nodes
parameter_list|)
block|{
name|ddg_scc_ptr
name|scc
decl_stmt|;
name|unsigned
name|int
name|u
init|=
literal|0
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|scc
operator|=
operator|(
name|ddg_scc_ptr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ddg_scc
argument_list|)
argument_list|)
expr_stmt|;
name|scc
operator|->
name|backarcs
operator|=
name|NULL
expr_stmt|;
name|scc
operator|->
name|num_backarcs
operator|=
literal|0
expr_stmt|;
name|scc
operator|->
name|nodes
operator|=
name|sbitmap_alloc
argument_list|(
name|g
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|scc
operator|->
name|nodes
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|/* Mark the backarcs that belong to this SCC.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|sbi
argument_list|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|ddg_node_ptr
name|n
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
for|for
control|(
name|e
operator|=
name|n
operator|->
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|nodes
argument_list|,
name|e
operator|->
name|dest
operator|->
name|cuid
argument_list|)
condition|)
block|{
name|e
operator|->
name|aux
operator|.
name|count
operator|=
name|IN_SCC
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|distance
operator|>
literal|0
condition|)
name|add_backarc_to_scc
argument_list|(
name|scc
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|set_recurrence_length
argument_list|(
name|scc
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|scc
return|;
block|}
end_function

begin_comment
comment|/* Cleans the memory allocation of a given SCC.  */
end_comment

begin_function
specifier|static
name|void
name|free_scc
parameter_list|(
name|ddg_scc_ptr
name|scc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scc
condition|)
return|return;
name|sbitmap_free
argument_list|(
name|scc
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|scc
operator|->
name|num_backarcs
operator|>
literal|0
condition|)
name|free
argument_list|(
name|scc
operator|->
name|backarcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a given edge known to be a backarc to the given DDG.  */
end_comment

begin_function
specifier|static
name|void
name|add_backarc_to_ddg
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|ddg_edge_ptr
name|e
parameter_list|)
block|{
name|int
name|size
init|=
operator|(
name|g
operator|->
name|num_backarcs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ddg_edge_ptr
argument_list|)
decl_stmt|;
name|add_edge_to_ddg
argument_list|(
name|g
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|g
operator|->
name|backarcs
operator|=
operator|(
name|ddg_edge_ptr
operator|*
operator|)
name|xrealloc
argument_list|(
name|g
operator|->
name|backarcs
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|g
operator|->
name|backarcs
index|[
name|g
operator|->
name|num_backarcs
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add backarc to an SCC.  */
end_comment

begin_function
specifier|static
name|void
name|add_backarc_to_scc
parameter_list|(
name|ddg_scc_ptr
name|scc
parameter_list|,
name|ddg_edge_ptr
name|e
parameter_list|)
block|{
name|int
name|size
init|=
operator|(
name|scc
operator|->
name|num_backarcs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ddg_edge_ptr
argument_list|)
decl_stmt|;
name|scc
operator|->
name|backarcs
operator|=
operator|(
name|ddg_edge_ptr
operator|*
operator|)
name|xrealloc
argument_list|(
name|scc
operator|->
name|backarcs
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|scc
operator|->
name|backarcs
index|[
name|scc
operator|->
name|num_backarcs
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the given SCC to the DDG.  */
end_comment

begin_function
specifier|static
name|void
name|add_scc_to_ddg
parameter_list|(
name|ddg_all_sccs_ptr
name|g
parameter_list|,
name|ddg_scc_ptr
name|scc
parameter_list|)
block|{
name|int
name|size
init|=
operator|(
name|g
operator|->
name|num_sccs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ddg_scc_ptr
argument_list|)
decl_stmt|;
name|g
operator|->
name|sccs
operator|=
operator|(
name|ddg_scc_ptr
operator|*
operator|)
name|xrealloc
argument_list|(
name|g
operator|->
name|sccs
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|g
operator|->
name|sccs
index|[
name|g
operator|->
name|num_sccs
operator|++
index|]
operator|=
name|scc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the instruction INSN return the node that represents it.  */
end_comment

begin_function
name|ddg_node_ptr
name|get_node_of_insn
parameter_list|(
name|ddg_ptr
name|g
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|==
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|insn
condition|)
return|return
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given a set OPS of nodes in the DDG, find the set of their successors    which are not in OPS, and set their bits in SUCC.  Bits corresponding to    OPS are cleared from SUCC.  Leaves the other bits in SUCC unchanged.  */
end_comment

begin_function
name|void
name|find_successors
parameter_list|(
name|sbitmap
name|succ
parameter_list|,
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|ops
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|ops
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
block|{
specifier|const
name|sbitmap
name|node_succ
init|=
name|NODE_SUCCESSORS
argument_list|(
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|succ
argument_list|,
name|succ
argument_list|,
name|node_succ
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* We want those that are not in ops.  */
name|sbitmap_difference
argument_list|(
name|succ
argument_list|,
name|succ
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a set OPS of nodes in the DDG, find the set of their predecessors    which are not in OPS, and set their bits in PREDS.  Bits corresponding to    OPS are cleared from PREDS.  Leaves the other bits in PREDS unchanged.  */
end_comment

begin_function
name|void
name|find_predecessors
parameter_list|(
name|sbitmap
name|preds
parameter_list|,
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|ops
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|ops
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
block|{
specifier|const
name|sbitmap
name|node_preds
init|=
name|NODE_PREDECESSORS
argument_list|(
operator|&
name|g
operator|->
name|nodes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|preds
argument_list|,
name|preds
argument_list|,
name|node_preds
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* We want those that are not in ops.  */
name|sbitmap_difference
argument_list|(
name|preds
argument_list|,
name|preds
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare function to be passed to qsort to order the backarcs in descending    recMII order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_sccs
parameter_list|(
specifier|const
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|)
block|{
name|int
name|rec_l1
init|=
operator|(
operator|*
operator|(
name|ddg_scc_ptr
operator|*
operator|)
name|s1
operator|)
operator|->
name|recurrence_length
decl_stmt|;
name|int
name|rec_l2
init|=
operator|(
operator|*
operator|(
name|ddg_scc_ptr
operator|*
operator|)
name|s2
operator|)
operator|->
name|recurrence_length
decl_stmt|;
return|return
operator|(
operator|(
name|rec_l2
operator|>
name|rec_l1
operator|)
operator|-
operator|(
name|rec_l2
operator|<
name|rec_l1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Order the backarcs in descending recMII order using compare_sccs.  */
end_comment

begin_function
specifier|static
name|void
name|order_sccs
parameter_list|(
name|ddg_all_sccs_ptr
name|g
parameter_list|)
block|{
name|qsort
argument_list|(
name|g
operator|->
name|sccs
argument_list|,
name|g
operator|->
name|num_sccs
argument_list|,
sizeof|sizeof
argument_list|(
name|ddg_scc_ptr
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_sccs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform the Strongly Connected Components decomposing algorithm on the    DDG and return DDG_ALL_SCCS structure that contains them.  */
end_comment

begin_function
name|ddg_all_sccs_ptr
name|create_ddg_all_sccs
parameter_list|(
name|ddg_ptr
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_nodes
init|=
name|g
operator|->
name|num_nodes
decl_stmt|;
name|sbitmap
name|from
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|to
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|scc_nodes
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|ddg_all_sccs_ptr
name|sccs
init|=
operator|(
name|ddg_all_sccs_ptr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ddg_all_sccs
argument_list|)
argument_list|)
decl_stmt|;
name|sccs
operator|->
name|ddg
operator|=
name|g
expr_stmt|;
name|sccs
operator|->
name|sccs
operator|=
name|NULL
expr_stmt|;
name|sccs
operator|->
name|num_sccs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_backarcs
condition|;
name|i
operator|++
control|)
block|{
name|ddg_scc_ptr
name|scc
decl_stmt|;
name|ddg_edge_ptr
name|backarc
init|=
name|g
operator|->
name|backarcs
index|[
name|i
index|]
decl_stmt|;
name|ddg_node_ptr
name|src
init|=
name|backarc
operator|->
name|src
decl_stmt|;
name|ddg_node_ptr
name|dest
init|=
name|backarc
operator|->
name|dest
decl_stmt|;
comment|/* If the backarc already belongs to an SCC, continue.  */
if|if
condition|(
name|backarc
operator|->
name|aux
operator|.
name|count
operator|==
name|IN_SCC
condition|)
continue|continue;
name|sbitmap_zero
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|from
argument_list|,
name|dest
operator|->
name|cuid
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|to
argument_list|,
name|src
operator|->
name|cuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_nodes_on_paths
argument_list|(
name|scc_nodes
argument_list|,
name|g
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
condition|)
block|{
name|scc
operator|=
name|create_scc
argument_list|(
name|g
argument_list|,
name|scc_nodes
argument_list|)
expr_stmt|;
name|add_scc_to_ddg
argument_list|(
name|sccs
argument_list|,
name|scc
argument_list|)
expr_stmt|;
block|}
block|}
name|order_sccs
argument_list|(
name|sccs
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|scc_nodes
argument_list|)
expr_stmt|;
return|return
name|sccs
return|;
block|}
end_function

begin_comment
comment|/* Frees the memory allocated for all SCCs of the DDG, but keeps the DDG.  */
end_comment

begin_function
name|void
name|free_ddg_all_sccs
parameter_list|(
name|ddg_all_sccs_ptr
name|all_sccs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|all_sccs
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|all_sccs
operator|->
name|num_sccs
condition|;
name|i
operator|++
control|)
name|free_scc
argument_list|(
name|all_sccs
operator|->
name|sccs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_sccs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given FROM - a bitmap of source nodes - and TO - a bitmap of destination    nodes - find all nodes that lie on paths from FROM to TO (not excluding    nodes from FROM and TO).  Return nonzero if nodes exist.  */
end_comment

begin_function
name|int
name|find_nodes_on_paths
parameter_list|(
name|sbitmap
name|result
parameter_list|,
name|ddg_ptr
name|g
parameter_list|,
name|sbitmap
name|from
parameter_list|,
name|sbitmap
name|to
parameter_list|)
block|{
name|int
name|answer
decl_stmt|;
name|int
name|change
decl_stmt|;
name|unsigned
name|int
name|u
init|=
literal|0
decl_stmt|;
name|int
name|num_nodes
init|=
name|g
operator|->
name|num_nodes
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|sbitmap
name|workset
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|reachable_from
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|reach_to
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|tmp
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap_copy
argument_list|(
name|reachable_from
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|tmp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|change
condition|)
block|{
name|change
operator|=
literal|0
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|workset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|workset
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|sbi
argument_list|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|out
init|;
name|e
operator|!=
operator|(
name|ddg_edge_ptr
operator|)
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
block|{
name|ddg_node_ptr
name|v_node
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|int
name|v
init|=
name|v_node
operator|->
name|cuid
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|reachable_from
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|reachable_from
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|tmp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
name|sbitmap_copy
argument_list|(
name|reach_to
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|tmp
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|change
condition|)
block|{
name|change
operator|=
literal|0
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|workset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|workset
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|sbi
argument_list|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|in
init|;
name|e
operator|!=
operator|(
name|ddg_edge_ptr
operator|)
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|next_in
control|)
block|{
name|ddg_node_ptr
name|v_node
init|=
name|e
operator|->
name|src
decl_stmt|;
name|int
name|v
init|=
name|v_node
operator|->
name|cuid
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|reach_to
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|reach_to
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|tmp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
name|answer
operator|=
name|sbitmap_a_and_b_cg
argument_list|(
name|result
argument_list|,
name|reachable_from
argument_list|,
name|reach_to
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|workset
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|reachable_from
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|reach_to
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
end_function

begin_comment
comment|/* Updates the counts of U_NODE's successors (that belong to NODES) to be    at-least as large as the count of U_NODE plus the latency between them.    Sets a bit in TMP for each successor whose count was changed (increased).    Returns nonzero if any count was changed.  */
end_comment

begin_function
specifier|static
name|int
name|update_dist_to_successors
parameter_list|(
name|ddg_node_ptr
name|u_node
parameter_list|,
name|sbitmap
name|nodes
parameter_list|,
name|sbitmap
name|tmp
parameter_list|)
block|{
name|ddg_edge_ptr
name|e
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|u_node
operator|->
name|out
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_out
control|)
block|{
name|ddg_node_ptr
name|v_node
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|int
name|v
init|=
name|v_node
operator|->
name|cuid
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|nodes
argument_list|,
name|v
argument_list|)
operator|&&
operator|(
name|e
operator|->
name|distance
operator|==
literal|0
operator|)
operator|&&
operator|(
name|v_node
operator|->
name|aux
operator|.
name|count
operator|<
name|u_node
operator|->
name|aux
operator|.
name|count
operator|+
name|e
operator|->
name|latency
operator|)
condition|)
block|{
name|v_node
operator|->
name|aux
operator|.
name|count
operator|=
name|u_node
operator|->
name|aux
operator|.
name|count
operator|+
name|e
operator|->
name|latency
expr_stmt|;
name|SET_BIT
argument_list|(
name|tmp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Find the length of a longest path from SRC to DEST in G,    going only through NODES, and disregarding backarcs.  */
end_comment

begin_function
name|int
name|longest_simple_path
parameter_list|(
name|struct
name|ddg
modifier|*
name|g
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|dest
parameter_list|,
name|sbitmap
name|nodes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|u
init|=
literal|0
decl_stmt|;
name|int
name|change
init|=
literal|1
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|num_nodes
init|=
name|g
operator|->
name|num_nodes
decl_stmt|;
name|sbitmap
name|workset
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
name|sbitmap
name|tmp
init|=
name|sbitmap_alloc
argument_list|(
name|num_nodes
argument_list|)
decl_stmt|;
comment|/* Data will hold the distance of the longest path found so far from      src to each node.  Initialize to -1 = less than minimum.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|g
operator|->
name|nodes
index|[
name|i
index|]
operator|.
name|aux
operator|.
name|count
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|nodes
index|[
name|src
index|]
operator|.
name|aux
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|tmp
argument_list|,
name|src
argument_list|)
expr_stmt|;
while|while
condition|(
name|change
condition|)
block|{
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|change
operator|=
literal|0
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|workset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|workset
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|sbi
argument_list|)
block|{
name|ddg_node_ptr
name|u_node
init|=
operator|&
name|g
operator|->
name|nodes
index|[
name|u
index|]
decl_stmt|;
name|change
operator||=
name|update_dist_to_successors
argument_list|(
name|u_node
argument_list|,
name|nodes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|g
operator|->
name|nodes
index|[
name|dest
index|]
operator|.
name|aux
operator|.
name|count
expr_stmt|;
name|sbitmap_free
argument_list|(
name|workset
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

