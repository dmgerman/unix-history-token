begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow optimization code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains optimizer of the control flow.  The main entrypoint is    cleanup_cfg.  Following optimizations are performed:     - Unreachable blocks removal    - Edge forwarding (edge to the forwarder block is forwarded to it's      successor.  Simplification of the branch instruction is performed by      underlying infrastructure so branch can be converted to simplejump or      eliminated).    - Cross jumping (tail merging)    - Conditional jump-around-simplejump simplification    - Basic block merging.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* cleanup_cfg maintains following flags for each basic block.  */
end_comment

begin_enum
enum|enum
name|bb_flags
block|{
comment|/* Set if life info needs to be recomputed for given BB.  */
name|BB_UPDATE_LIFE
init|=
literal|1
block|,
comment|/* Set if BB is the forwarder block to avoid too many        forwarder_block_p calls.  */
name|BB_FORWARDER_BLOCK
init|=
literal|2
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|BB_FLAGS
parameter_list|(
name|BB
parameter_list|)
value|(enum bb_flags) (BB)->aux
end_define

begin_define
define|#
directive|define
name|BB_SET_FLAG
parameter_list|(
name|BB
parameter_list|,
name|FLAG
parameter_list|)
define|\
value|(BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux | (FLAG))
end_define

begin_define
define|#
directive|define
name|BB_CLEAR_FLAG
parameter_list|(
name|BB
parameter_list|,
name|FLAG
parameter_list|)
define|\
value|(BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux& ~(FLAG))
end_define

begin_define
define|#
directive|define
name|FORWARDER_BLOCK_P
parameter_list|(
name|BB
parameter_list|)
value|(BB_FLAGS (BB)& BB_FORWARDER_BLOCK)
end_define

begin_decl_stmt
specifier|static
name|bool
name|try_crossjump_to_edge
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|edge
operator|,
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|try_crossjump_bb
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|outgoing_edges_match
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flow_find_cross_jump
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|insns_match_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|delete_unreachable_blocks
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|label_is_jump_target_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|tail_recursion_label_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_blocks_move_predecessor_nojumps
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_blocks_move_successor_nojumps
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|merge_blocks
name|PARAMS
argument_list|(
operator|(
name|edge
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|try_optimize_cfg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|try_simplify_condjump
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|try_forward_edges
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|edge
name|thread_jump
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|edge
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|mark_effect
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice_new_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_forwarder_flag
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Set flags for newly created block.  */
end_comment

begin_function
specifier|static
name|void
name|notice_new_block
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bb
condition|)
return|return;
name|BB_SET_FLAG
argument_list|(
name|bb
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwarder_block_p
argument_list|(
name|bb
argument_list|)
condition|)
name|BB_SET_FLAG
argument_list|(
name|bb
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recompute forwarder flag after block has been modified.  */
end_comment

begin_function
specifier|static
name|void
name|update_forwarder_flag
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
if|if
condition|(
name|forwarder_block_p
argument_list|(
name|bb
argument_list|)
condition|)
name|BB_SET_FLAG
argument_list|(
name|bb
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
else|else
name|BB_CLEAR_FLAG
argument_list|(
name|bb
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a conditional jump around an unconditional jump.    Return true if something changed.  */
end_comment

begin_function
specifier|static
name|bool
name|try_simplify_condjump
parameter_list|(
name|cbranch_block
parameter_list|)
name|basic_block
name|cbranch_block
decl_stmt|;
block|{
name|basic_block
name|jump_block
decl_stmt|,
name|jump_dest_block
decl_stmt|,
name|cbranch_dest_block
decl_stmt|;
name|edge
name|cbranch_jump_edge
decl_stmt|,
name|cbranch_fallthru_edge
decl_stmt|;
name|rtx
name|cbranch_insn
decl_stmt|;
comment|/* Verify that there are exactly two successors.  */
if|if
condition|(
operator|!
name|cbranch_block
operator|->
name|succ
operator|||
operator|!
name|cbranch_block
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|cbranch_block
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
return|return
name|false
return|;
comment|/* Verify that we've got a normal conditional branch at the end      of the block.  */
name|cbranch_insn
operator|=
name|cbranch_block
operator|->
name|end
expr_stmt|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|cbranch_insn
argument_list|)
condition|)
return|return
name|false
return|;
name|cbranch_fallthru_edge
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|cbranch_block
argument_list|)
expr_stmt|;
name|cbranch_jump_edge
operator|=
name|BRANCH_EDGE
argument_list|(
name|cbranch_block
argument_list|)
expr_stmt|;
comment|/* The next block must not have multiple predecessors, must not      be the last block in the function, and must contain just the      unconditional jump.  */
name|jump_block
operator|=
name|cbranch_fallthru_edge
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|jump_block
operator|->
name|pred
operator|->
name|pred_next
operator|||
name|jump_block
operator|->
name|index
operator|==
name|n_basic_blocks
operator|-
literal|1
operator|||
operator|!
name|FORWARDER_BLOCK_P
argument_list|(
name|jump_block
argument_list|)
condition|)
return|return
name|false
return|;
name|jump_dest_block
operator|=
name|jump_block
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
comment|/* The conditional branch must target the block after the      unconditional branch.  */
name|cbranch_dest_block
operator|=
name|cbranch_jump_edge
operator|->
name|dest
expr_stmt|;
if|if
condition|(
operator|!
name|can_fallthru
argument_list|(
name|jump_block
argument_list|,
name|cbranch_dest_block
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Invert the conditional branch.  */
if|if
condition|(
operator|!
name|invert_jump
argument_list|(
name|cbranch_insn
argument_list|,
name|block_label
argument_list|(
name|jump_dest_block
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Simplifying condjump %i around jump %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|cbranch_insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|jump_block
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Success.  Update the CFG to match.  Note that after this point      the edge variable names appear backwards; the redirection is done      this way to preserve edge profile data.  */
name|cbranch_jump_edge
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|cbranch_jump_edge
argument_list|,
name|cbranch_dest_block
argument_list|)
expr_stmt|;
name|cbranch_fallthru_edge
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|cbranch_fallthru_edge
argument_list|,
name|jump_dest_block
argument_list|)
expr_stmt|;
name|cbranch_jump_edge
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|cbranch_fallthru_edge
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|cbranch_block
argument_list|)
expr_stmt|;
comment|/* Delete the block with the unconditional jump, and clean up the mess.  */
name|flow_delete_block
argument_list|(
name|jump_block
argument_list|)
expr_stmt|;
name|tidy_fallthru_edge
argument_list|(
name|cbranch_jump_edge
argument_list|,
name|cbranch_block
argument_list|,
name|cbranch_dest_block
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to prove that operation is NOOP using CSElib or mark the effect    on register.  Used by jump threading.  */
end_comment

begin_function
specifier|static
name|bool
name|mark_effect
parameter_list|(
name|exp
parameter_list|,
name|nonequal
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|regset
name|nonequal
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* In case we do clobber the register, mark it as equal, as we know the          value is dead so it don't have to match.  */
case|case
name|CLOBBER
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|dest
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
case|case
name|SET
case|:
if|if
condition|(
name|rtx_equal_for_cselib_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|pc_rtx
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|true
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to prove that the basic block B will have no side effects and    allways continues in the same edge if reached via E.  Return the edge    if exist, NULL otherwise.  */
end_comment

begin_function
specifier|static
name|edge
name|thread_jump
parameter_list|(
name|mode
parameter_list|,
name|e
parameter_list|,
name|b
parameter_list|)
name|int
name|mode
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
block|{
name|rtx
name|set1
decl_stmt|,
name|set2
decl_stmt|,
name|cond1
decl_stmt|,
name|cond2
decl_stmt|,
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|,
name|reversed_code2
decl_stmt|;
name|bool
name|reverse1
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|regset
name|nonequal
decl_stmt|;
name|bool
name|failed
init|=
name|false
decl_stmt|;
comment|/* At the moment, we do handle only conditional jumps, but later we may      want to extend this code to tablejumps and others.  */
if|if
condition|(
operator|!
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|b
operator|->
name|succ
operator|||
operator|!
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
return|return
name|NULL
return|;
comment|/* Second branch must end with onlyjump, as we will eliminate the jump.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|b
operator|->
name|end
argument_list|)
condition|)
return|return
name|NULL
return|;
name|set1
operator|=
name|pc_set
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
name|set2
operator|=
name|pc_set
argument_list|(
name|b
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
condition|)
name|reverse1
operator|=
name|true
expr_stmt|;
name|cond1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond2
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse1
condition|)
name|code1
operator|=
name|reversed_comparison_code
argument_list|(
name|cond1
argument_list|,
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
else|else
name|code1
operator|=
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|GET_CODE
argument_list|(
name|cond2
argument_list|)
expr_stmt|;
name|reversed_code2
operator|=
name|reversed_comparison_code
argument_list|(
name|cond2
argument_list|,
name|b
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|code2
argument_list|)
operator|&&
operator|!
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|reversed_code2
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Ensure that the comparison operators are equivalent.      ??? This is far too pesimistic.  We should allow swapped operands,      different CCmodes, or for example comparisons for interval, that      dominate even when operands are not equivalent.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Short circuit cases where block B contains some side effects, as we can't      safely bypass it.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|head
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|cselib_init
argument_list|()
expr_stmt|;
comment|/* First process all values computed in the source basic block.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|e
operator|->
name|src
operator|->
name|head
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|e
operator|->
name|src
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|nonequal
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|nonequal
argument_list|)
expr_stmt|;
comment|/* Now assume that we've continued by the edge E to B and continue      processing as if it were same basic block.      Our goal is to prove that whole block is an NOOP.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|head
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|&&
operator|!
name|failed
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|failed
operator||=
name|mark_effect
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|nonequal
argument_list|)
expr_stmt|;
block|}
else|else
name|failed
operator||=
name|mark_effect
argument_list|(
name|pat
argument_list|,
name|nonequal
argument_list|)
expr_stmt|;
block|}
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Later we should clear nonequal of dead registers.  So far we don't      have life information in cfg_cleanup.  */
if|if
condition|(
name|failed
condition|)
goto|goto
name|failed_exit
goto|;
comment|/* In case liveness information is available, we need to prove equivalence      only of the live values.  */
if|if
condition|(
name|mode
operator|&
name|CLEANUP_UPDATE_LIFE
condition|)
name|AND_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|b
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|nonequal
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|goto failed_exit;
argument_list|)
empty_stmt|;
name|BITMAP_XFREE
argument_list|(
name|nonequal
argument_list|)
expr_stmt|;
name|cselib_finish
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|code2
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
condition|)
return|return
name|BRANCH_EDGE
argument_list|(
name|b
argument_list|)
return|;
else|else
return|return
name|FALLTHRU_EDGE
argument_list|(
name|b
argument_list|)
return|;
name|failed_exit
label|:
name|BITMAP_XFREE
argument_list|(
name|nonequal
argument_list|)
expr_stmt|;
name|cselib_finish
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to forward edges leaving basic block B.    Return true if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|try_forward_edges
parameter_list|(
name|mode
parameter_list|,
name|b
parameter_list|)
name|basic_block
name|b
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|,
modifier|*
name|threaded_edges
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|basic_block
name|target
decl_stmt|,
name|first
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|bool
name|threaded
init|=
name|false
decl_stmt|;
name|int
name|nthreaded_edges
init|=
literal|0
decl_stmt|;
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
comment|/* Skip complex edges because we don't know how to update them.           Still handle fallthru edges, as we can succeed to forward fallthru          edge to the same place as the branch edge of conditional branch          and turn conditional branch to an unconditional branch.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
continue|continue;
name|target
operator|=
name|first
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|n_basic_blocks
condition|)
block|{
name|basic_block
name|new_target
init|=
name|NULL
decl_stmt|;
name|bool
name|new_target_threaded
init|=
name|false
decl_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|target
argument_list|)
operator|&&
name|target
operator|->
name|succ
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* Bypass trivial infinite loops.  */
if|if
condition|(
name|target
operator|==
name|target
operator|->
name|succ
operator|->
name|dest
condition|)
name|counter
operator|=
name|n_basic_blocks
expr_stmt|;
name|new_target
operator|=
name|target
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
block|}
comment|/* Allow to thread only over one edge at time to simplify updating 	     of probabilities.  */
elseif|else
if|if
condition|(
name|mode
operator|&
name|CLEANUP_THREADING
condition|)
block|{
name|edge
name|t
init|=
name|thread_jump
argument_list|(
name|mode
argument_list|,
name|e
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|threaded_edges
condition|)
name|threaded_edges
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|threaded_edges
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Detect an infinite loop across blocks not 			 including the start block.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nthreaded_edges
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|threaded_edges
index|[
name|i
index|]
operator|==
name|t
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nthreaded_edges
condition|)
block|{
name|counter
operator|=
name|n_basic_blocks
expr_stmt|;
break|break;
block|}
block|}
comment|/* Detect an infinite loop across the start block.  */
if|if
condition|(
name|t
operator|->
name|dest
operator|==
name|b
condition|)
break|break;
if|if
condition|(
name|nthreaded_edges
operator|>=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|threaded_edges
index|[
name|nthreaded_edges
operator|++
index|]
operator|=
name|t
expr_stmt|;
name|new_target
operator|=
name|t
operator|->
name|dest
expr_stmt|;
name|new_target_threaded
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|new_target
condition|)
break|break;
comment|/* Avoid killing of loop pre-headers, as it is the place loop 	     optimizer wants to hoist code to.  	     For fallthru forwarders, the LOOP_BEG note must appear between 	     the header of block and CODE_LABEL of the loop, for non forwarders 	     it must appear before the JUMP_INSN.  */
if|if
condition|(
name|mode
operator|&
name|CLEANUP_PRE_LOOP
condition|)
block|{
name|rtx
name|insn
init|=
operator|(
name|target
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|?
name|target
operator|->
name|head
else|:
name|prev_nonnote_insn
argument_list|(
name|target
operator|->
name|end
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
break|break;
block|}
name|counter
operator|++
expr_stmt|;
name|target
operator|=
name|new_target
expr_stmt|;
name|threaded
operator||=
name|new_target_threaded
expr_stmt|;
block|}
if|if
condition|(
name|counter
operator|>=
name|n_basic_blocks
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Infinite loop in BB %i.\n"
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|first
condition|)
empty_stmt|;
comment|/* We didn't do anything.  */
else|else
block|{
comment|/* Save the values now, as the edge may get removed.  */
name|gcov_type
name|edge_count
init|=
name|e
operator|->
name|count
decl_stmt|;
name|int
name|edge_probability
init|=
name|e
operator|->
name|probability
decl_stmt|;
name|int
name|edge_frequency
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Don't force if target is exit block.  */
if|if
condition|(
name|threaded
operator|&&
name|target
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|notice_new_block
argument_list|(
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Conditionals threaded.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Forwarding edge %i->%i to %i failed.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We successfully forwarded the edge.  Now update profile 	     data: for each edge we traversed in the chain, remove 	     the original edge's execution count.  */
name|edge_frequency
operator|=
operator|(
operator|(
name|edge_probability
operator|*
name|b
operator|->
name|frequency
operator|+
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|)
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|FORWARDER_BLOCK_P
argument_list|(
name|b
argument_list|)
operator|&&
name|forwarder_block_p
argument_list|(
name|b
argument_list|)
condition|)
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
do|do
block|{
name|edge
name|t
decl_stmt|;
name|first
operator|->
name|count
operator|-=
name|edge_count
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|count
operator|<
literal|0
condition|)
name|first
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|first
operator|->
name|frequency
operator|-=
name|edge_frequency
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|frequency
operator|<
literal|0
condition|)
name|first
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|prob
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|nthreaded_edges
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|threaded_edges
index|[
name|n
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|src
operator|!=
name|first
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|frequency
condition|)
name|prob
operator|=
name|edge_frequency
operator|*
name|REG_BR_PROB_BASE
operator|/
name|first
operator|->
name|frequency
expr_stmt|;
else|else
name|prob
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prob
operator|>
name|t
operator|->
name|probability
condition|)
name|prob
operator|=
name|t
operator|->
name|probability
expr_stmt|;
name|t
operator|->
name|probability
operator|-=
name|prob
expr_stmt|;
name|prob
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob
expr_stmt|;
if|if
condition|(
name|prob
operator|<=
literal|0
condition|)
block|{
name|first
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|first
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
block|}
else|else
for|for
control|(
name|e
operator|=
name|first
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|probability
operator|=
operator|(
operator|(
name|e
operator|->
name|probability
operator|*
name|REG_BR_PROB_BASE
operator|)
operator|/
operator|(
name|double
operator|)
name|prob
operator|)
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is possible that as the result of 		     threading we've removed edge as it is 		     threaded to the fallthru edge.  Avoid 		     getting out of sync.  */
if|if
condition|(
name|n
operator|<
name|nthreaded_edges
operator|&&
name|first
operator|==
name|threaded_edges
index|[
name|n
index|]
operator|->
name|src
condition|)
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|first
operator|->
name|succ
expr_stmt|;
block|}
name|t
operator|->
name|count
operator|-=
name|edge_count
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|count
operator|<
literal|0
condition|)
name|t
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|t
operator|->
name|dest
expr_stmt|;
block|}
do|while
condition|(
name|first
operator|!=
name|target
condition|)
do|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|threaded_edges
condition|)
name|free
argument_list|(
name|threaded_edges
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if LABEL is a target of JUMP_INSN.  This applies only    to non-complex jumps.  That is, direct unconditional, conditional,    and tablejumps, but not computed jumps or returns.  It also does    not apply to the fallthru case of a conditional jump.  */
end_comment

begin_function
specifier|static
name|bool
name|label_is_jump_target_p
parameter_list|(
name|label
parameter_list|,
name|jump_insn
parameter_list|)
name|rtx
name|label
decl_stmt|,
name|jump_insn
decl_stmt|;
block|{
name|rtx
name|tmp
init|=
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|==
name|tmp
condition|)
return|return
name|true
return|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|tmp
operator|=
name|PATTERN
argument_list|(
name|tmp
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtvec
name|vec
init|=
name|XVEC
argument_list|(
name|tmp
argument_list|,
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|veclen
init|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|veclen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if LABEL is used for tail recursion.  */
end_comment

begin_function
specifier|static
name|bool
name|tail_recursion_label_p
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|tail_recursion_label_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|label
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block.  A has no incoming    fallthru edge, so it can be moved before B without adding or modifying    any jumps (aside from the jump from A to B).  */
end_comment

begin_function
specifier|static
name|void
name|merge_blocks_move_predecessor_nojumps
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|basic_block
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|rtx
name|barrier
decl_stmt|;
name|int
name|index
decl_stmt|;
name|barrier
operator|=
name|next_nonnote_insn
argument_list|(
name|a
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|!=
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|delete_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
comment|/* Move block and loop notes out of the chain so that we do not      disturb their order.       ??? A better solution would be to squeeze out all the non-nested notes      and adjust the block trees appropriately.   Even better would be to have      a tighter connection between block trees and rtl so that this is not      necessary.  */
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|a
operator|->
name|head
argument_list|,
operator|&
name|a
operator|->
name|end
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Scramble the insn chain.  */
if|if
condition|(
name|a
operator|->
name|end
operator|!=
name|PREV_INSN
argument_list|(
name|b
operator|->
name|head
argument_list|)
condition|)
name|reorder_insns_nobb
argument_list|(
name|a
operator|->
name|head
argument_list|,
name|a
operator|->
name|end
argument_list|,
name|PREV_INSN
argument_list|(
name|b
operator|->
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|BB_SET_FLAG
argument_list|(
name|a
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Moved block %d before %d and merged.\n"
argument_list|,
name|a
operator|->
name|index
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Swap the records for the two blocks around.  Although we are deleting B,      A is now where B was and we want to compact the BB array from where      A used to be.  */
name|BASIC_BLOCK
argument_list|(
name|a
operator|->
name|index
argument_list|)
operator|=
name|b
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|b
operator|->
name|index
argument_list|)
operator|=
name|a
expr_stmt|;
name|index
operator|=
name|a
operator|->
name|index
expr_stmt|;
name|a
operator|->
name|index
operator|=
name|b
operator|->
name|index
expr_stmt|;
name|b
operator|->
name|index
operator|=
name|index
expr_stmt|;
comment|/* Now blocks A and B are contiguous.  Merge them.  */
name|merge_blocks_nomove
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block.  B has no outgoing    fallthru edge, so it can be moved after A without adding or modifying    any jumps (aside from the jump from A to B).  */
end_comment

begin_function
specifier|static
name|void
name|merge_blocks_move_successor_nojumps
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|basic_block
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|rtx
name|barrier
decl_stmt|,
name|real_b_end
decl_stmt|;
name|real_b_end
operator|=
name|b
operator|->
name|end
expr_stmt|;
name|barrier
operator|=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* Recognize a jump table following block B.  */
if|if
condition|(
name|barrier
operator|&&
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|NEXT_INSN
argument_list|(
name|barrier
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|barrier
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|barrier
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|barrier
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
comment|/* Temporarily add the table jump insn to b, so that it will also 	 be moved to the correct location.  */
name|b
operator|->
name|end
operator|=
name|NEXT_INSN
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* There had better have been a barrier there.  Delete it.  */
if|if
condition|(
name|barrier
operator|&&
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
comment|/* Move block and loop notes out of the chain so that we do not      disturb their order.       ??? A better solution would be to squeeze out all the non-nested notes      and adjust the block trees appropriately.   Even better would be to have      a tighter connection between block trees and rtl so that this is not      necessary.  */
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|b
operator|->
name|head
argument_list|,
operator|&
name|b
operator|->
name|end
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Scramble the insn chain.  */
name|reorder_insns_nobb
argument_list|(
name|b
operator|->
name|head
argument_list|,
name|b
operator|->
name|end
argument_list|,
name|a
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* Restore the real end of b.  */
name|b
operator|->
name|end
operator|=
name|real_b_end
expr_stmt|;
comment|/* Now blocks A and B are contiguous.  Merge them.  */
name|merge_blocks_nomove
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|BB_SET_FLAG
argument_list|(
name|a
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Moved block %d after %d and merged.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|,
name|a
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to merge basic blocks that are potentially non-adjacent.    Return true iff the attempt succeeded.  */
end_comment

begin_function
specifier|static
name|bool
name|merge_blocks
parameter_list|(
name|e
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|mode
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|b
decl_stmt|,
name|c
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
comment|/* If C has a tail recursion label, do not merge.  There is no      edge recorded from the call_placeholder back to this label, as      that would make optimize_sibling_and_tail_recursive_calls more      complex for no gain.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_PRE_SIBCALL
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|c
operator|->
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|tail_recursion_label_p
argument_list|(
name|c
operator|->
name|head
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If B has a fallthru edge to C, no need to move anything.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|int
name|b_index
init|=
name|b
operator|->
name|index
decl_stmt|,
name|c_index
init|=
name|c
operator|->
name|index
decl_stmt|;
comment|/* We need to update liveness in case C already has broken liveness 	 or B ends by conditional jump to next instructions that will be 	 removed.  */
if|if
condition|(
operator|(
name|BB_FLAGS
argument_list|(
name|c
argument_list|)
operator|&
name|BB_UPDATE_LIFE
operator|)
operator|||
name|GET_CODE
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
name|merge_blocks_nomove
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|update_forwarder_flag
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Merged %d and %d without moving.\n"
argument_list|,
name|b_index
argument_list|,
name|c_index
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Otherwise we will need to move code around.  Do that only if expensive      transformations are allowed.  */
elseif|else
if|if
condition|(
name|mode
operator|&
name|CLEANUP_EXPENSIVE
condition|)
block|{
name|edge
name|tmp_edge
decl_stmt|,
name|b_fallthru_edge
decl_stmt|;
name|bool
name|c_has_outgoing_fallthru
decl_stmt|;
name|bool
name|b_has_incoming_fallthru
decl_stmt|;
comment|/* Avoid overactive code motion, as the forwarder blocks should be          eliminated by edge redirection instead.  One exception might have 	 been if B is a forwarder block and C has no fallthru edge, but 	 that should be cleaned up by bb-reorder instead.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|b
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We must make sure to not munge nesting of lexical blocks, 	 and loop notes.  This is done by squeezing out all the notes 	 and leaving them there to lie.  Not ideal, but functional.  */
for|for
control|(
name|tmp_edge
operator|=
name|c
operator|->
name|succ
init|;
name|tmp_edge
condition|;
name|tmp_edge
operator|=
name|tmp_edge
operator|->
name|succ_next
control|)
if|if
condition|(
name|tmp_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
name|c_has_outgoing_fallthru
operator|=
operator|(
name|tmp_edge
operator|!=
name|NULL
operator|)
expr_stmt|;
for|for
control|(
name|tmp_edge
operator|=
name|b
operator|->
name|pred
init|;
name|tmp_edge
condition|;
name|tmp_edge
operator|=
name|tmp_edge
operator|->
name|pred_next
control|)
if|if
condition|(
name|tmp_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
name|b_has_incoming_fallthru
operator|=
operator|(
name|tmp_edge
operator|!=
name|NULL
operator|)
expr_stmt|;
name|b_fallthru_edge
operator|=
name|tmp_edge
expr_stmt|;
comment|/* Otherwise, we're going to try to move C after B.  If C does 	 not have an outgoing fallthru, then it can be moved 	 immediately after B without introducing or modifying jumps.  */
if|if
condition|(
operator|!
name|c_has_outgoing_fallthru
condition|)
block|{
name|merge_blocks_move_successor_nojumps
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If B does not have an incoming fallthru, then it can be moved 	 immediately before C without introducing or modifying jumps. 	 C cannot be the first block, so we do not have to worry about 	 accessing a non-existent block.  */
if|if
condition|(
name|b_has_incoming_fallthru
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|b_fallthru_edge
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|false
return|;
name|bb
operator|=
name|force_nonfallthru
argument_list|(
name|b_fallthru_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
condition|)
name|notice_new_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
else|else
name|BB_SET_FLAG
argument_list|(
name|b_fallthru_edge
operator|->
name|src
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
block|}
name|merge_blocks_move_predecessor_nojumps
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */
end_comment

begin_function
specifier|static
name|bool
name|insns_match_p
parameter_list|(
name|mode
parameter_list|,
name|i1
parameter_list|,
name|i2
parameter_list|)
name|int
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|i1
decl_stmt|,
name|i2
decl_stmt|;
block|{
name|rtx
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* Verify that I1 and I2 are equivalent.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|i2
argument_list|)
condition|)
return|return
name|false
return|;
name|p1
operator|=
name|PATTERN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PATTERN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|p2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is a CALL_INSN, compare register usage information.      If we don't check this on stack register machines, the two      CALL_INSNs might be merged leaving reg-stack.c with mismatching      numbers of stack registers in the same basic block.      If we don't check this on machines with delay slots, a delay slot may      be filled that clobbers a parameter expected by the subroutine.       ??? We take the simple route for now and assume that if they're      equal, they were constructed identically.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* If cross_jump_death_matters is not 0, the insn's mode      indicates whether or not the insn contains any stack-like      regs.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_POST_REGSTACK
operator|)
operator|&&
name|stack_regs_mentioned
argument_list|(
name|i1
argument_list|)
condition|)
block|{
comment|/* If register stack conversion has already been done, then          death notes must also be compared before it is certain that          the two instruction streams match.  */
name|rtx
name|note
decl_stmt|;
name|HARD_REG_SET
name|i1_regset
decl_stmt|,
name|i2_regset
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i1_regset
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i2_regset
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|i1_regset
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|i2_regset
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|i1_regset
argument_list|,
name|i2_regset
argument_list|,
name|done
argument_list|)
expr_stmt|;
return|return
name|false
return|;
name|done
label|:
empty_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reload_completed
condition|?
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
else|:
operator|!
name|rtx_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
comment|/* The following code helps take care of G++ cleanups.  */
name|rtx
name|equiv1
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|equiv2
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|equiv1
operator|&&
name|equiv2
comment|/* If the equivalences are not to a constant, they may 	     reference pseudos that no longer exist, so we can't 	     use them.  */
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|s1
init|=
name|single_set
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|s2
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|!=
literal|0
operator|&&
name|s2
operator|!=
literal|0
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|s1
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|s2
argument_list|)
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|i1
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|i2
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the insns at the end of BB1 and BB2 and find the longest    sequence that are equivalent.  Store the first insns for that sequence    in *F1 and *F2 and return the sequence length.     To simplify callers of this function, if the blocks match exactly,    store the head of the blocks in *F1 and *F2.  */
end_comment

begin_function
specifier|static
name|int
name|flow_find_cross_jump
parameter_list|(
name|mode
parameter_list|,
name|bb1
parameter_list|,
name|bb2
parameter_list|,
name|f1
parameter_list|,
name|f2
parameter_list|)
name|int
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|basic_block
name|bb1
decl_stmt|,
name|bb2
decl_stmt|;
name|rtx
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|last1
decl_stmt|,
name|last2
decl_stmt|,
name|afterlast1
decl_stmt|,
name|afterlast2
decl_stmt|;
name|int
name|ninsns
init|=
literal|0
decl_stmt|;
comment|/* Skip simple jumps at the end of the blocks.  Complex jumps still      need to be compared for equivalence, which we'll do below.  */
name|i1
operator|=
name|bb1
operator|->
name|end
expr_stmt|;
name|last1
operator|=
name|afterlast1
operator|=
name|last2
operator|=
name|afterlast2
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|onlyjump_p
argument_list|(
name|i1
argument_list|)
operator|||
operator|(
name|returnjump_p
argument_list|(
name|i1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|last1
operator|=
name|i1
expr_stmt|;
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
name|i2
operator|=
name|bb2
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|onlyjump_p
argument_list|(
name|i2
argument_list|)
operator|||
operator|(
name|returnjump_p
argument_list|(
name|i2
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|last2
operator|=
name|i2
expr_stmt|;
comment|/* Count everything except for unconditional jump as insn.  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|i2
argument_list|)
operator|&&
operator|!
name|returnjump_p
argument_list|(
name|i2
argument_list|)
operator|&&
name|last1
condition|)
name|ninsns
operator|++
expr_stmt|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|true
condition|)
block|{
comment|/* Ignore notes.  */
while|while
condition|(
operator|!
name|active_insn_p
argument_list|(
name|i1
argument_list|)
operator|&&
name|i1
operator|!=
name|bb1
operator|->
name|head
condition|)
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|active_insn_p
argument_list|(
name|i2
argument_list|)
operator|&&
name|i2
operator|!=
name|bb2
operator|->
name|head
condition|)
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
name|bb1
operator|->
name|head
operator|||
name|i2
operator|==
name|bb2
operator|->
name|head
condition|)
break|break;
if|if
condition|(
operator|!
name|insns_match_p
argument_list|(
name|mode
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
condition|)
break|break;
comment|/* Don't begin a cross-jump with a USE or CLOBBER insn.  */
if|if
condition|(
name|active_insn_p
argument_list|(
name|i1
argument_list|)
condition|)
block|{
comment|/* If the merged insns have different REG_EQUAL notes, then 	     remove them.  */
name|rtx
name|equiv1
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|equiv2
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|equiv1
operator|&&
operator|!
name|equiv2
condition|)
name|remove_note
argument_list|(
name|i1
argument_list|,
name|equiv1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|equiv1
operator|&&
name|equiv2
condition|)
name|remove_note
argument_list|(
name|i2
argument_list|,
name|equiv2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|equiv1
operator|&&
name|equiv2
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|remove_note
argument_list|(
name|i1
argument_list|,
name|equiv1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|i2
argument_list|,
name|equiv2
argument_list|)
expr_stmt|;
block|}
name|afterlast1
operator|=
name|last1
operator|,
name|afterlast2
operator|=
name|last2
expr_stmt|;
name|last1
operator|=
name|i1
operator|,
name|last2
operator|=
name|i2
expr_stmt|;
name|ninsns
operator|++
expr_stmt|;
block|}
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Don't allow the insn after a compare to be shared by      cross-jumping unless the compare is also shared.  */
if|if
condition|(
name|ninsns
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|last1
argument_list|)
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|last1
argument_list|)
condition|)
name|last1
operator|=
name|afterlast1
operator|,
name|last2
operator|=
name|afterlast2
operator|,
name|ninsns
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Include preceding notes and labels in the cross-jump.  One,      this may bring us to the head of the blocks as requested above.      Two, it keeps line number notes as matched as may be.  */
if|if
condition|(
name|ninsns
condition|)
block|{
while|while
condition|(
name|last1
operator|!=
name|bb1
operator|->
name|head
operator|&&
operator|!
name|active_insn_p
argument_list|(
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
argument_list|)
condition|)
name|last1
operator|=
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last1
operator|!=
name|bb1
operator|->
name|head
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last1
operator|=
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
expr_stmt|;
while|while
condition|(
name|last2
operator|!=
name|bb2
operator|->
name|head
operator|&&
operator|!
name|active_insn_p
argument_list|(
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
argument_list|)
condition|)
name|last2
operator|=
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
expr_stmt|;
if|if
condition|(
name|last2
operator|!=
name|bb2
operator|->
name|head
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last2
operator|=
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
expr_stmt|;
operator|*
name|f1
operator|=
name|last1
expr_stmt|;
operator|*
name|f2
operator|=
name|last2
expr_stmt|;
block|}
return|return
name|ninsns
return|;
block|}
end_block

begin_comment
comment|/* Return true iff outgoing edges of BB1 and BB2 match, together with    the branch instruction.  This means that if we commonize the control    flow before end of the basic block, the semantic remains unchanged.     We may assume that there exists one edge with a common destination.  */
end_comment

begin_function
specifier|static
name|bool
name|outgoing_edges_match
parameter_list|(
name|mode
parameter_list|,
name|bb1
parameter_list|,
name|bb2
parameter_list|)
name|int
name|mode
decl_stmt|;
name|basic_block
name|bb1
decl_stmt|;
name|basic_block
name|bb2
decl_stmt|;
block|{
name|int
name|nehedges1
init|=
literal|0
decl_stmt|,
name|nehedges2
init|=
literal|0
decl_stmt|;
name|edge
name|fallthru1
init|=
literal|0
decl_stmt|,
name|fallthru2
init|=
literal|0
decl_stmt|;
name|edge
name|e1
decl_stmt|,
name|e2
decl_stmt|;
comment|/* If BB1 has only one successor, we may be looking at either an      unconditional jump, or a fake edge to exit.  */
if|if
condition|(
name|bb1
operator|->
name|succ
operator|&&
operator|!
name|bb1
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|!
operator|(
name|bb1
operator|->
name|succ
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
return|return
operator|(
name|bb2
operator|->
name|succ
operator|&&
operator|!
name|bb2
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|(
name|bb2
operator|->
name|succ
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
comment|/* Match conditional jumps - this may get tricky when fallthru and branch      edges are crossed.  */
if|if
condition|(
name|bb1
operator|->
name|succ
operator|&&
name|bb1
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|!
name|bb1
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
operator|&&
name|any_condjump_p
argument_list|(
name|bb1
operator|->
name|end
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|bb1
operator|->
name|end
argument_list|)
condition|)
block|{
name|edge
name|b1
decl_stmt|,
name|f1
decl_stmt|,
name|b2
decl_stmt|,
name|f2
decl_stmt|;
name|bool
name|reverse
decl_stmt|,
name|match
decl_stmt|;
name|rtx
name|set1
decl_stmt|,
name|set2
decl_stmt|,
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
if|if
condition|(
operator|!
name|bb2
operator|->
name|succ
operator|||
operator|!
name|bb2
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|bb1
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|bb2
operator|->
name|end
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|bb1
operator|->
name|end
argument_list|)
condition|)
return|return
name|false
return|;
name|b1
operator|=
name|BRANCH_EDGE
argument_list|(
name|bb1
argument_list|)
expr_stmt|;
name|b2
operator|=
name|BRANCH_EDGE
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
name|f1
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb1
argument_list|)
expr_stmt|;
name|f2
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
comment|/* Get around possible forwarders on fallthru edges.  Other cases          should be optimized out already.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|f1
operator|->
name|dest
argument_list|)
condition|)
name|f1
operator|=
name|f1
operator|->
name|dest
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|f2
operator|->
name|dest
argument_list|)
condition|)
name|f2
operator|=
name|f2
operator|->
name|dest
operator|->
name|succ
expr_stmt|;
comment|/* To simplify use of this function, return false if there are 	 unneeded forwarder blocks.  These will get eliminated later 	 during cleanup_cfg.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|f1
operator|->
name|dest
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|f2
operator|->
name|dest
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|b1
operator|->
name|dest
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|b2
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|f1
operator|->
name|dest
operator|==
name|f2
operator|->
name|dest
operator|&&
name|b1
operator|->
name|dest
operator|==
name|b2
operator|->
name|dest
condition|)
name|reverse
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|dest
operator|==
name|b2
operator|->
name|dest
operator|&&
name|b1
operator|->
name|dest
operator|==
name|f2
operator|->
name|dest
condition|)
name|reverse
operator|=
name|true
expr_stmt|;
else|else
return|return
name|false
return|;
name|set1
operator|=
name|pc_set
argument_list|(
name|bb1
operator|->
name|end
argument_list|)
expr_stmt|;
name|set2
operator|=
name|pc_set
argument_list|(
name|bb2
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
operator|!=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
condition|)
name|reverse
operator|=
operator|!
name|reverse
expr_stmt|;
name|cond1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond2
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|code2
operator|=
name|reversed_comparison_code
argument_list|(
name|cond2
argument_list|,
name|bb2
operator|->
name|end
argument_list|)
expr_stmt|;
else|else
name|code2
operator|=
name|GET_CODE
argument_list|(
name|cond2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|==
name|UNKNOWN
condition|)
return|return
name|false
return|;
comment|/* Verify codes and operands match.  */
name|match
operator|=
operator|(
operator|(
name|code1
operator|==
name|code2
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|code1
operator|==
name|swap_condition
argument_list|(
name|code2
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If we return true, we will join the blocks.  Which means that 	 we will only have one branch prediction bit to work with.  Thus 	 we require the existing branches to have probabilities that are 	 roughly similar.  */
if|if
condition|(
name|match
operator|&&
operator|!
name|optimize_size
operator|&&
name|bb1
operator|->
name|frequency
operator|>
name|BB_FREQ_MAX
operator|/
literal|1000
operator|&&
name|bb2
operator|->
name|frequency
operator|>
name|BB_FREQ_MAX
operator|/
literal|1000
condition|)
block|{
name|int
name|prob2
decl_stmt|;
if|if
condition|(
name|b1
operator|->
name|dest
operator|==
name|b2
operator|->
name|dest
condition|)
name|prob2
operator|=
name|b2
operator|->
name|probability
expr_stmt|;
else|else
comment|/* Do not use f2 probability as f2 may be forwarded.  */
name|prob2
operator|=
name|REG_BR_PROB_BASE
operator|-
name|b2
operator|->
name|probability
expr_stmt|;
comment|/* Fail if the difference in probabilities is 	     greater than 5%.  */
if|if
condition|(
name|abs
argument_list|(
name|b1
operator|->
name|probability
operator|-
name|prob2
argument_list|)
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|20
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Outcomes of branch in bb %i and %i differs to much (%i %i)\n"
argument_list|,
name|bb1
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|,
name|b1
operator|->
name|probability
argument_list|,
name|prob2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
operator|&&
name|match
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Conditionals in bb %i and %i match.\n"
argument_list|,
name|bb1
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
comment|/* Generic case - we are seeing an computed jump, table jump or trapping      instruction.  */
comment|/* First ensure that the instructions match.  There may be many outgoing      edges so this test is generally cheaper.      ??? Currently the tablejumps will never match, as they do have      different tables.  */
if|if
condition|(
operator|!
name|insns_match_p
argument_list|(
name|mode
argument_list|,
name|bb1
operator|->
name|end
argument_list|,
name|bb2
operator|->
name|end
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Search the outgoing edges, ensure that the counts do match, find possible      fallthru and exception handling edges since these needs more      validation.  */
for|for
control|(
name|e1
operator|=
name|bb1
operator|->
name|succ
operator|,
name|e2
operator|=
name|bb2
operator|->
name|succ
init|;
name|e1
operator|&&
name|e2
condition|;
name|e1
operator|=
name|e1
operator|->
name|succ_next
operator|,
name|e2
operator|=
name|e2
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e1
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
name|nehedges1
operator|++
expr_stmt|;
if|if
condition|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
name|nehedges2
operator|++
expr_stmt|;
if|if
condition|(
name|e1
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|fallthru1
operator|=
name|e1
expr_stmt|;
if|if
condition|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|fallthru2
operator|=
name|e2
expr_stmt|;
block|}
comment|/* If number of edges of various types does not match, fail.  */
if|if
condition|(
name|e1
operator|||
name|e2
operator|||
name|nehedges1
operator|!=
name|nehedges2
operator|||
operator|(
name|fallthru1
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|fallthru2
operator|!=
literal|0
operator|)
condition|)
return|return
name|false
return|;
comment|/* fallthru edges must be forwarded to the same destination.  */
if|if
condition|(
name|fallthru1
condition|)
block|{
name|basic_block
name|d1
init|=
operator|(
name|forwarder_block_p
argument_list|(
name|fallthru1
operator|->
name|dest
argument_list|)
condition|?
name|fallthru1
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
else|:
name|fallthru1
operator|->
name|dest
operator|)
decl_stmt|;
name|basic_block
name|d2
init|=
operator|(
name|forwarder_block_p
argument_list|(
name|fallthru2
operator|->
name|dest
argument_list|)
condition|?
name|fallthru2
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
else|:
name|fallthru2
operator|->
name|dest
operator|)
decl_stmt|;
if|if
condition|(
name|d1
operator|!=
name|d2
condition|)
return|return
name|false
return|;
block|}
comment|/* In case we do have EH edges, ensure we are in the same region.  */
if|if
condition|(
name|nehedges1
condition|)
block|{
name|rtx
name|n1
init|=
name|find_reg_note
argument_list|(
name|bb1
operator|->
name|end
argument_list|,
name|REG_EH_REGION
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|n2
init|=
name|find_reg_note
argument_list|(
name|bb2
operator|->
name|end
argument_list|,
name|REG_EH_REGION
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|n1
argument_list|,
literal|0
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|n2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We don't need to match the rest of edges as above checks should be enought      to ensure that they are equivalent.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* E1 and E2 are edges with the same destination block.  Search their    predecessors for common code.  If found, redirect control flow from    (maybe the middle of) E1->SRC to (maybe the middle of) E2->SRC.  */
end_comment

begin_function
specifier|static
name|bool
name|try_crossjump_to_edge
parameter_list|(
name|mode
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|)
name|int
name|mode
decl_stmt|;
name|edge
name|e1
decl_stmt|,
name|e2
decl_stmt|;
block|{
name|int
name|nmatch
decl_stmt|;
name|basic_block
name|src1
init|=
name|e1
operator|->
name|src
decl_stmt|,
name|src2
init|=
name|e2
operator|->
name|src
decl_stmt|;
name|basic_block
name|redirect_to
decl_stmt|;
name|rtx
name|newpos1
decl_stmt|,
name|newpos2
decl_stmt|;
name|edge
name|s
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|rtx
name|label
decl_stmt|;
comment|/* Search backward through forwarder blocks.  We don't need to worry      about multiple entry or chained forwarders, as they will be optimized      away.  We do this to look past the unconditional jump following a      conditional jump that is required due to the current CFG shape.  */
if|if
condition|(
name|src1
operator|->
name|pred
operator|&&
operator|!
name|src1
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|src1
argument_list|)
condition|)
name|e1
operator|=
name|src1
operator|->
name|pred
operator|,
name|src1
operator|=
name|e1
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|src2
operator|->
name|pred
operator|&&
operator|!
name|src2
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|src2
argument_list|)
condition|)
name|e2
operator|=
name|src2
operator|->
name|pred
operator|,
name|src2
operator|=
name|e2
operator|->
name|src
expr_stmt|;
comment|/* Nothing to do if we reach ENTRY, or a common source block.  */
if|if
condition|(
name|src1
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|src2
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|src1
operator|==
name|src2
condition|)
return|return
name|false
return|;
comment|/* Seeing more than 1 forwarder blocks would confuse us later...  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|e1
operator|->
name|dest
argument_list|)
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|e1
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|e2
operator|->
name|dest
argument_list|)
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|e2
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Likewise with dead code (possibly newly created by the other optimizations      of cfg_cleanup).  */
if|if
condition|(
operator|!
name|src1
operator|->
name|pred
operator|||
operator|!
name|src2
operator|->
name|pred
condition|)
return|return
name|false
return|;
comment|/* Look for the common insn sequence, part the first ...  */
if|if
condition|(
operator|!
name|outgoing_edges_match
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* ... and part the second.  */
name|nmatch
operator|=
name|flow_find_cross_jump
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|,
operator|&
name|newpos1
argument_list|,
operator|&
name|newpos2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nmatch
condition|)
return|return
name|false
return|;
comment|/* Avoid splitting if possible.  */
if|if
condition|(
name|newpos2
operator|==
name|src2
operator|->
name|head
condition|)
name|redirect_to
operator|=
name|src2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Splitting bb %i before %i insns\n"
argument_list|,
name|src2
operator|->
name|index
argument_list|,
name|nmatch
argument_list|)
expr_stmt|;
name|redirect_to
operator|=
name|split_block
argument_list|(
name|src2
argument_list|,
name|PREV_INSN
argument_list|(
name|newpos2
argument_list|)
argument_list|)
operator|->
name|dest
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Cross jumping from bb %i to bb %i; %i common insns\n"
argument_list|,
name|src1
operator|->
name|index
argument_list|,
name|src2
operator|->
name|index
argument_list|,
name|nmatch
argument_list|)
expr_stmt|;
name|redirect_to
operator|->
name|count
operator|+=
name|src1
operator|->
name|count
expr_stmt|;
name|redirect_to
operator|->
name|frequency
operator|+=
name|src1
operator|->
name|frequency
expr_stmt|;
comment|/* Recompute the frequencies and counts of outgoing edges.  */
for|for
control|(
name|s
operator|=
name|redirect_to
operator|->
name|succ
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|succ_next
control|)
block|{
name|edge
name|s2
decl_stmt|;
name|basic_block
name|d
init|=
name|s
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
for|for
control|(
name|s2
operator|=
name|src1
operator|->
name|succ
init|;
condition|;
name|s2
operator|=
name|s2
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|d2
init|=
name|s2
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|d2
argument_list|)
condition|)
name|d2
operator|=
name|d2
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|d2
condition|)
break|break;
block|}
name|s
operator|->
name|count
operator|+=
name|s2
operator|->
name|count
expr_stmt|;
comment|/* Take care to update possible forwarder blocks.  We verified          that there is no more than one in the chain, so we can't run          into infinite loop.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|s
operator|->
name|dest
argument_list|)
condition|)
block|{
name|s
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|+=
name|s2
operator|->
name|count
expr_stmt|;
name|s
operator|->
name|dest
operator|->
name|count
operator|+=
name|s2
operator|->
name|count
expr_stmt|;
name|s
operator|->
name|dest
operator|->
name|frequency
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|s2
operator|->
name|dest
argument_list|)
condition|)
block|{
name|s2
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|-=
name|s2
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|<
literal|0
condition|)
name|s2
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|s2
operator|->
name|dest
operator|->
name|count
operator|-=
name|s2
operator|->
name|count
expr_stmt|;
name|s2
operator|->
name|dest
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|dest
operator|->
name|frequency
operator|<
literal|0
condition|)
name|s2
operator|->
name|dest
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|dest
operator|->
name|count
operator|<
literal|0
condition|)
name|s2
operator|->
name|dest
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|redirect_to
operator|->
name|frequency
operator|&&
operator|!
name|src1
operator|->
name|frequency
condition|)
name|s
operator|->
name|probability
operator|=
operator|(
name|s
operator|->
name|probability
operator|+
name|s2
operator|->
name|probability
operator|)
operator|/
literal|2
expr_stmt|;
else|else
name|s
operator|->
name|probability
operator|=
operator|(
operator|(
name|s
operator|->
name|probability
operator|*
name|redirect_to
operator|->
name|frequency
operator|+
name|s2
operator|->
name|probability
operator|*
name|src1
operator|->
name|frequency
operator|)
operator|/
operator|(
name|redirect_to
operator|->
name|frequency
operator|+
name|src1
operator|->
name|frequency
operator|)
operator|)
expr_stmt|;
block|}
name|update_br_prob_note
argument_list|(
name|redirect_to
argument_list|)
expr_stmt|;
comment|/* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */
comment|/* Skip possible basic block header.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|newpos1
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|newpos1
operator|=
name|NEXT_INSN
argument_list|(
name|newpos1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|newpos1
argument_list|)
operator|==
name|NOTE
condition|)
name|newpos1
operator|=
name|NEXT_INSN
argument_list|(
name|newpos1
argument_list|)
expr_stmt|;
name|last
operator|=
name|src1
operator|->
name|end
expr_stmt|;
comment|/* Emit the jump insn.  */
name|label
operator|=
name|block_label
argument_list|(
name|redirect_to
argument_list|)
expr_stmt|;
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|src1
operator|->
name|end
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|src1
operator|->
name|end
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
comment|/* Delete the now unreachable instructions.  */
name|delete_insn_chain
argument_list|(
name|newpos1
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* Make sure there is a barrier after the new jump.  */
name|last
operator|=
name|next_nonnote_insn
argument_list|(
name|src1
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last
operator|||
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|src1
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* Update CFG.  */
while|while
condition|(
name|src1
operator|->
name|succ
condition|)
name|remove_edge
argument_list|(
name|src1
operator|->
name|succ
argument_list|)
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|src1
argument_list|,
name|redirect_to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BB_SET_FLAG
argument_list|(
name|src1
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
name|update_forwarder_flag
argument_list|(
name|src1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Search the predecessors of BB for common insn sequences.  When found,    share code between them by redirecting control flow.  Return true if    any changes made.  */
end_comment

begin_function
specifier|static
name|bool
name|try_crossjump_bb
parameter_list|(
name|mode
parameter_list|,
name|bb
parameter_list|)
name|int
name|mode
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|,
name|e2
decl_stmt|,
name|nexte2
decl_stmt|,
name|nexte
decl_stmt|,
name|fallthru
decl_stmt|;
name|bool
name|changed
decl_stmt|;
comment|/* Nothing to do if there is not at least two incoming edges.  */
if|if
condition|(
operator|!
name|bb
operator|->
name|pred
operator|||
operator|!
name|bb
operator|->
name|pred
operator|->
name|pred_next
condition|)
return|return
name|false
return|;
comment|/* It is always cheapest to redirect a block that ends in a branch to      a block that falls through into BB, as that adds no branches to the      program.  We'll try that combination first.  */
for|for
control|(
name|fallthru
operator|=
name|bb
operator|->
name|pred
init|;
name|fallthru
condition|;
name|fallthru
operator|=
name|fallthru
operator|->
name|pred_next
control|)
if|if
condition|(
name|fallthru
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
name|changed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|nexte
control|)
block|{
name|nexte
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
comment|/* As noted above, first try with the fallthru predecessor.  */
if|if
condition|(
name|fallthru
condition|)
block|{
comment|/* Don't combine the fallthru edge into anything else. 	     If there is a match, we'll do it the other way around.  */
if|if
condition|(
name|e
operator|==
name|fallthru
condition|)
continue|continue;
if|if
condition|(
name|try_crossjump_to_edge
argument_list|(
name|mode
argument_list|,
name|e
argument_list|,
name|fallthru
argument_list|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|nexte
operator|=
name|bb
operator|->
name|pred
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Non-obvious work limiting check: Recognize that we're going 	 to call try_crossjump_bb on every basic block.  So if we have 	 two blocks with lots of outgoing edges (a switch) and they 	 share lots of common destinations, then we would do the 	 cross-jump check once for each common destination.  	 Now, if the blocks actually are cross-jump candidates, then 	 all of their destinations will be shared.  Which means that 	 we only need check them for cross-jump candidacy once.  We 	 can eliminate redundant checks of crossjump(A,B) by arbitrarily 	 choosing to do the check from the block for which the edge 	 in question is the first successor of A.  */
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|succ
operator|!=
name|e
condition|)
continue|continue;
for|for
control|(
name|e2
operator|=
name|bb
operator|->
name|pred
init|;
name|e2
condition|;
name|e2
operator|=
name|nexte2
control|)
block|{
name|nexte2
operator|=
name|e2
operator|->
name|pred_next
expr_stmt|;
if|if
condition|(
name|e2
operator|==
name|e
condition|)
continue|continue;
comment|/* We've already checked the fallthru edge above.  */
if|if
condition|(
name|e2
operator|==
name|fallthru
condition|)
continue|continue;
comment|/* The "first successor" check above only prevents multiple 	     checks of crossjump(A,B).  In order to prevent redundant 	     checks of crossjump(B,A), require that A be the block 	     with the lowest index.  */
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|>
name|e2
operator|->
name|src
operator|->
name|index
condition|)
continue|continue;
if|if
condition|(
name|try_crossjump_to_edge
argument_list|(
name|mode
argument_list|,
name|e
argument_list|,
name|e2
argument_list|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|nexte
operator|=
name|bb
operator|->
name|pred
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Do simple CFG optimizations - basic block merging, simplifying of jump    instructions etc.  Return nonzero if changes were made.  */
end_comment

begin_function
specifier|static
name|bool
name|try_optimize_cfg
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bool
name|changed_overall
init|=
name|false
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|int
name|iterations
init|=
literal|0
decl_stmt|;
name|sbitmap
name|blocks
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
condition|)
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|update_forwarder_flag
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Attempt to merge blocks as made possible by edge removal.  If a block      has only one successor, and the successor has only one predecessor,      they may be combined.  */
do|do
block|{
name|changed
operator|=
name|false
expr_stmt|;
name|iterations
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n\ntry_optimize_cfg iteration %i\n\n"
argument_list|,
name|iterations
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
control|)
block|{
name|basic_block
name|c
decl_stmt|,
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|s
decl_stmt|;
name|bool
name|changed_here
init|=
name|false
decl_stmt|;
comment|/* Delete trivially dead basic blocks.  */
while|while
condition|(
name|b
operator|->
name|pred
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
name|BASIC_BLOCK
argument_list|(
name|b
operator|->
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Deleting block %i.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|flow_delete_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
block|}
comment|/* Remove code labels no longer used.  Don't do this before 	     CALL_PLACEHOLDER is removed, as some branches may be hidden 	     within.  */
if|if
condition|(
name|b
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
operator|(
name|b
operator|->
name|pred
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|b
operator|->
name|pred
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|b
operator|->
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
operator|!
operator|(
name|mode
operator|&
name|CLEANUP_PRE_SIBCALL
operator|)
operator|||
operator|!
name|tail_recursion_label_p
argument_list|(
name|b
operator|->
name|head
argument_list|)
operator|)
comment|/* If the previous block ends with a branch to this block, 		 we can't delete the label.  Normally this is a condjump 		 that is yet to be simplified, but if CASE_DROPS_THRU, 		 this can be a tablejump with some element going to the 		 same place as the default (fallthru).  */
operator|&&
operator|(
name|b
operator|->
name|pred
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|GET_CODE
argument_list|(
name|b
operator|->
name|pred
operator|->
name|src
operator|->
name|end
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|label_is_jump_target_p
argument_list|(
name|b
operator|->
name|head
argument_list|,
name|b
operator|->
name|pred
operator|->
name|src
operator|->
name|end
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|b
operator|->
name|head
decl_stmt|;
name|b
operator|->
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|head
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Deleted label in block %i.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* If we fall through an empty block, we can remove it.  */
if|if
condition|(
name|b
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
operator|(
name|b
operator|->
name|pred
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|b
operator|->
name|head
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|b
argument_list|)
comment|/* Note that forwarder_block_p true ensures that there 		 is a successor for this block.  */
operator|&&
operator|(
name|b
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|n_basic_blocks
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Deleting fallthru block %i.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|c
operator|=
name|BASIC_BLOCK
argument_list|(
name|b
operator|->
name|index
condition|?
name|b
operator|->
name|index
operator|-
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
name|redirect_edge_succ_nodup
argument_list|(
name|b
operator|->
name|pred
argument_list|,
name|b
operator|->
name|succ
operator|->
name|dest
argument_list|)
expr_stmt|;
name|flow_delete_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
block|}
comment|/* Merge blocks.  Loop because chains of blocks might be 	     combineable.  */
while|while
condition|(
operator|(
name|s
operator|=
name|b
operator|->
name|succ
operator|)
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|(
name|c
operator|=
name|s
operator|->
name|dest
operator|)
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|c
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
comment|/* If the jump insn has side effects, 		    we can't kill the edge.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|onlyjump_p
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|)
operator|&&
name|merge_blocks
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|mode
argument_list|)
condition|)
name|changed_here
operator|=
name|true
expr_stmt|;
comment|/* Simplify branch over branch.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_EXPENSIVE
operator|)
operator|&&
name|try_simplify_condjump
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
name|changed_here
operator|=
name|true
expr_stmt|;
block|}
comment|/* If B has a single outgoing edge, but uses a non-trivial jump 	     instruction without side-effects, we can either delete the 	     jump entirely, or replace it with a simple unconditional jump. 	     Use redirect_edge_and_branch to do the dirty work.  */
if|if
condition|(
name|b
operator|->
name|succ
operator|&&
operator|!
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|b
operator|->
name|succ
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|onlyjump_p
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|&&
name|redirect_edge_and_branch
argument_list|(
name|b
operator|->
name|succ
argument_list|,
name|b
operator|->
name|succ
operator|->
name|dest
argument_list|)
condition|)
block|{
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_UPDATE_LIFE
argument_list|)
expr_stmt|;
name|update_forwarder_flag
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|changed_here
operator|=
name|true
expr_stmt|;
block|}
comment|/* Simplify branch to branch.  */
if|if
condition|(
name|try_forward_edges
argument_list|(
name|mode
argument_list|,
name|b
argument_list|)
condition|)
name|changed_here
operator|=
name|true
expr_stmt|;
comment|/* Look for shared code between blocks.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
operator|)
operator|&&
name|try_crossjump_bb
argument_list|(
name|mode
argument_list|,
name|b
argument_list|)
condition|)
name|changed_here
operator|=
name|true
expr_stmt|;
comment|/* Don't get confused by the index shift caused by deleting 	     blocks.  */
if|if
condition|(
operator|!
name|changed_here
condition|)
name|i
operator|=
name|b
operator|->
name|index
operator|+
literal|1
expr_stmt|;
else|else
name|changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
operator|)
operator|&&
name|try_crossjump_bb
argument_list|(
name|mode
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|changed
condition|)
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|changed_overall
operator||=
name|changed
expr_stmt|;
block|}
do|while
condition|(
name|changed
condition|)
do|;
if|if
condition|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
condition|)
name|remove_fake_edges
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_UPDATE_LIFE
operator|)
operator|&&
name|changed_overall
condition|)
block|{
name|bool
name|found
init|=
literal|0
decl_stmt|;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BB_FLAGS
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
name|BB_UPDATE_LIFE
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|changed_overall
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete all unreachable basic blocks.  */
end_comment

begin_function
specifier|static
name|bool
name|delete_unreachable_blocks
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|find_unreachable_blocks
argument_list|()
expr_stmt|;
comment|/* Delete all unreachable basic blocks.  Count down so that we      don't interfere with the block renumbering that happens in      flow_delete_block.  */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|BB_REACHABLE
operator|)
condition|)
name|flow_delete_block
argument_list|(
name|b
argument_list|)
operator|,
name|changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
name|tidy_fallthru_edges
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tidy the CFG by deleting unreachable code and whatnot.  */
end_comment

begin_function
name|bool
name|cleanup_cfg
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_CLEANUP_CFG
argument_list|)
expr_stmt|;
name|changed
operator|=
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
if|if
condition|(
name|try_optimize_cfg
argument_list|(
name|mode
argument_list|)
condition|)
name|delete_unreachable_blocks
argument_list|()
operator|,
name|changed
operator|=
name|true
expr_stmt|;
comment|/* Kill the data we won't maintain.  */
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|label_value_list
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|tail_recursion_label_list
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CLEANUP_CFG
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

end_unit

