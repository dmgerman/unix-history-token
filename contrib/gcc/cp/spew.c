begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Type Analyzer for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Hacked... nay, bludgeoned... by Mark Eichin (eichin@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG    when compiling parse.c and spew.c.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|SPEW_INLINE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPEW_INLINE
value|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This takes a token stream that hasn't decided much about types and    tries to figure out as much as it can, with excessive lookahead and    backtracking.  */
end_comment

begin_comment
comment|/* fifo of tokens recognized and available to parser.  */
end_comment

begin_struct
struct|struct
name|token
block|{
comment|/* The values for YYCHAR will fit in a short.  */
name|short
name|yychar
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Since inline methods can refer to text which has not yet been seen,    we store the text of the method in a structure which is placed in the    DECL_PENDING_INLINE_INFO field of the FUNCTION_DECL.    After parsing the body of the class definition, the FUNCTION_DECL's are    scanned to see which ones have this field set.  Those are then digested    one at a time.     This function's FUNCTION_DECL will have a bit set in its common so    that we know to watch out for it.  */
end_comment

begin_struct
struct|struct
name|unparsed_text
block|{
name|struct
name|unparsed_text
modifier|*
name|next
decl_stmt|;
comment|/* process this one next */
name|tree
name|decl
decl_stmt|;
comment|/* associated declaration */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* name of file we were processing */
name|int
name|lineno
decl_stmt|;
comment|/* line number we got the text from */
name|int
name|interface
decl_stmt|;
comment|/* remembering interface_unknown and interface_only */
name|struct
name|token
modifier|*
name|pos
decl_stmt|;
comment|/* current position, when rescanning */
name|struct
name|token
modifier|*
name|limit
decl_stmt|;
comment|/* end of saved text */
block|}
struct|;
end_struct

begin_comment
comment|/* Stack of state saved off when we return to an inline method or    default argument that has been stored for later parsing.  */
end_comment

begin_struct
struct|struct
name|feed
block|{
name|struct
name|unparsed_text
modifier|*
name|input
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|yychar
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
name|int
name|first_token
decl_stmt|;
name|struct
name|obstack
name|token_obstack
decl_stmt|;
name|struct
name|feed
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|feed_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|feed
modifier|*
name|feed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|void
name|do_aggr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|int
name|identifier_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_tokens
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|feed_defarg
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_defarg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_token
name|PARAMS
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|int
name|num_tokens
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SPEW_INLINE
expr|struct
name|token
operator|*
name|nth_token
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|int
name|add_token
name|PARAMS
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|int
name|shift_token
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|void
name|push_token
name|PARAMS
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|void
name|consume_token
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|int
name|read_process_identifier
name|PARAMS
argument_list|(
operator|(
name|YYSTYPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|void
name|feed_input
name|PARAMS
argument_list|(
operator|(
expr|struct
name|unparsed_text
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SPEW_INLINE
name|void
name|snarf_block
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|snarf_defarg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frob_id
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of inline functions being held off until we reach the end of    the current class declaration.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unparsed_text
modifier|*
name|pending_inlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unparsed_text
modifier|*
name|pending_inlines_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of previously-deferred inline functions currently being parsed.    This exists solely to be a GC root.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unparsed_text
modifier|*
name|processing_these_inlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|begin_parsing_inclass_inline
name|PARAMS
argument_list|(
operator|(
expr|struct
name|unparsed_text
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|spew_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|yylex_ctr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_yychar
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parse.y: */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|debug_yytranslate
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|enum
name|cpp_ttype
name|last_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|last_token_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From lex.c: */
end_comment

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* let our brains leak out here too */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_comment
comment|/* The token fifo lives in this obstack.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|token_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_token
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sometimes we need to save tokens for later parsing.  If so, they are    stored on this obstack.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|inline_text_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inline_text_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we see a default argument in a method declaration, we snarf it as    text using snarf_defarg.  When we get up to namespace scope, we then go    through and parse all of them using do_pending_defargs.  Since yacc    parsers are not reentrant, we retain defargs state in these two    variables so that subsequent calls to do_pending_defargs can resume    where the previous call left off. DEFARG_FNS is a tree_list where     the TREE_TYPE is the current_class_type, TREE_VALUE is the FUNCTION_DECL,    and TREE_PURPOSE is the list unprocessed dependent functions.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|defarg_fns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of functions with unprocessed defargs */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|defarg_parm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current default parameter */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|defarg_depfns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of unprocessed fns met during current fn. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|defarg_fnsdone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of fns with circular defargs */
end_comment

begin_comment
comment|/* Initialize obstacks. Called once, from cxx_init.  */
end_comment

begin_function
name|void
name|init_spew
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|inline_text_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|token_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|feed_obstack
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|defarg_fns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|defarg_parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|defarg_depfns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|defarg_fnsdone
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|pending_inlines
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unparsed_text
operator|*
argument_list|)
argument_list|,
name|mark_pending_inlines
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|processing_these_inlines
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unparsed_text
operator|*
argument_list|)
argument_list|,
name|mark_pending_inlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_inline_text_obstack
parameter_list|()
block|{
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|inline_text_firstobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of read_token.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|int
name|read_process_identifier
parameter_list|(
name|pyylval
parameter_list|)
name|YYSTYPE
modifier|*
name|pyylval
decl_stmt|;
block|{
name|tree
name|id
init|=
name|pyylval
operator|->
name|ttype
decl_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|/* Possibly replace the IDENTIFIER_NODE with a magic cookie. 	 Can't put yylval.code numbers in ridpointers[].  Bleah.  */
switch|switch
condition|(
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
condition|)
block|{
case|case
name|RID_BITAND
case|:
name|pyylval
operator|->
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
return|return
literal|'&'
return|;
case|case
name|RID_AND_EQ
case|:
name|pyylval
operator|->
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
return|return
name|ASSIGN
return|;
case|case
name|RID_BITOR
case|:
name|pyylval
operator|->
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
return|return
literal|'|'
return|;
case|case
name|RID_OR_EQ
case|:
name|pyylval
operator|->
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
return|return
name|ASSIGN
return|;
case|case
name|RID_XOR
case|:
name|pyylval
operator|->
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
return|return
literal|'^'
return|;
case|case
name|RID_XOR_EQ
case|:
name|pyylval
operator|->
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
return|return
name|ASSIGN
return|;
case|case
name|RID_NOT_EQ
case|:
name|pyylval
operator|->
name|code
operator|=
name|NE_EXPR
expr_stmt|;
return|return
name|EQCOMPARE
return|;
default|default:
if|if
condition|(
name|C_RID_YYCODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPESPEC
condition|)
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|pyylval
operator|->
name|ttype
operator|=
name|ridpointers
index|[
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
return|return
name|C_RID_YYCODE
argument_list|(
name|id
argument_list|)
return|;
block|}
block|}
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that user does not collide with our internal naming      scheme.  This is not necessary if '.' is used to remove them from      the user's namespace, but is if '$' or double underscores are.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|JOINER
argument_list|)
operator|||
name|JOINER
operator|==
literal|'$'
if|if
condition|(
name|VPTR_NAME_P
argument_list|(
name|id
argument_list|)
operator|||
name|VTABLE_NAME_P
argument_list|(
name|id
argument_list|)
operator|||
name|TEMP_NAME_P
argument_list|(
name|id
argument_list|)
operator|||
name|ANON_AGGRNAME_P
argument_list|(
name|id
argument_list|)
condition|)
name|warning
argument_list|(
literal|"identifier name `%s' conflicts with GNU C++ internal naming strategy"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|IDENTIFIER
return|;
block|}
end_function

begin_comment
comment|/* Read the next token from the input file.  The token is written into    T, and its type number is returned.  */
end_comment

begin_function
specifier|static
name|int
name|read_token
parameter_list|(
name|t
parameter_list|)
name|struct
name|token
modifier|*
name|t
decl_stmt|;
block|{
name|retry
label|:
name|last_token
operator|=
name|c_lex
argument_list|(
operator|&
name|last_token_id
argument_list|)
expr_stmt|;
name|t
operator|->
name|yylval
operator|.
name|ttype
operator|=
name|last_token_id
expr_stmt|;
switch|switch
condition|(
name|last_token
condition|)
block|{
define|#
directive|define
name|YYCHAR
parameter_list|(
name|YY
parameter_list|)
value|t->yychar = (YY); break;
define|#
directive|define
name|YYCODE
parameter_list|(
name|C
parameter_list|)
value|t->yylval.code = (C);
case|case
name|CPP_EQ
case|:
name|YYCHAR
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
case|case
name|CPP_NOT
case|:
name|YYCHAR
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
case|case
name|CPP_GREATER
case|:
name|YYCODE
argument_list|(
name|GT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
case|case
name|CPP_LESS
case|:
name|YYCODE
argument_list|(
name|LT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
case|case
name|CPP_PLUS
case|:
name|YYCODE
argument_list|(
name|PLUS_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
case|case
name|CPP_MINUS
case|:
name|YYCODE
argument_list|(
name|MINUS_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
case|case
name|CPP_MULT
case|:
name|YYCODE
argument_list|(
name|MULT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
case|case
name|CPP_DIV
case|:
name|YYCODE
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
case|case
name|CPP_MOD
case|:
name|YYCODE
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
case|case
name|CPP_AND
case|:
name|YYCODE
argument_list|(
name|BIT_AND_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
case|case
name|CPP_OR
case|:
name|YYCODE
argument_list|(
name|BIT_IOR_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
case|case
name|CPP_XOR
case|:
name|YYCODE
argument_list|(
name|BIT_XOR_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
case|case
name|CPP_RSHIFT
case|:
name|YYCODE
argument_list|(
name|RSHIFT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|RSHIFT
argument_list|)
expr_stmt|;
case|case
name|CPP_LSHIFT
case|:
name|YYCODE
argument_list|(
name|LSHIFT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|LSHIFT
argument_list|)
expr_stmt|;
case|case
name|CPP_COMPL
case|:
name|YYCHAR
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
case|case
name|CPP_AND_AND
case|:
name|YYCHAR
argument_list|(
name|ANDAND
argument_list|)
expr_stmt|;
case|case
name|CPP_OR_OR
case|:
name|YYCHAR
argument_list|(
name|OROR
argument_list|)
expr_stmt|;
case|case
name|CPP_QUERY
case|:
name|YYCHAR
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
case|case
name|CPP_COLON
case|:
name|YYCHAR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
case|case
name|CPP_COMMA
case|:
name|YYCHAR
argument_list|(
literal|','
argument_list|)
expr_stmt|;
case|case
name|CPP_OPEN_PAREN
case|:
name|YYCHAR
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
case|case
name|CPP_CLOSE_PAREN
case|:
name|YYCHAR
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
case|case
name|CPP_EQ_EQ
case|:
name|YYCODE
argument_list|(
name|EQ_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|EQCOMPARE
argument_list|)
expr_stmt|;
case|case
name|CPP_NOT_EQ
case|:
name|YYCODE
argument_list|(
name|NE_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|EQCOMPARE
argument_list|)
expr_stmt|;
case|case
name|CPP_GREATER_EQ
case|:
name|YYCODE
argument_list|(
name|GE_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ARITHCOMPARE
argument_list|)
expr_stmt|;
case|case
name|CPP_LESS_EQ
case|:
name|YYCODE
argument_list|(
name|LE_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ARITHCOMPARE
argument_list|)
expr_stmt|;
case|case
name|CPP_PLUS_EQ
case|:
name|YYCODE
argument_list|(
name|PLUS_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_MINUS_EQ
case|:
name|YYCODE
argument_list|(
name|MINUS_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_MULT_EQ
case|:
name|YYCODE
argument_list|(
name|MULT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_DIV_EQ
case|:
name|YYCODE
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_MOD_EQ
case|:
name|YYCODE
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_AND_EQ
case|:
name|YYCODE
argument_list|(
name|BIT_AND_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_OR_EQ
case|:
name|YYCODE
argument_list|(
name|BIT_IOR_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_XOR_EQ
case|:
name|YYCODE
argument_list|(
name|BIT_XOR_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_RSHIFT_EQ
case|:
name|YYCODE
argument_list|(
name|RSHIFT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_LSHIFT_EQ
case|:
name|YYCODE
argument_list|(
name|LSHIFT_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_OPEN_SQUARE
case|:
name|YYCHAR
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
case|case
name|CPP_CLOSE_SQUARE
case|:
name|YYCHAR
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
case|case
name|CPP_OPEN_BRACE
case|:
name|YYCHAR
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
case|case
name|CPP_CLOSE_BRACE
case|:
name|YYCHAR
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
case|case
name|CPP_SEMICOLON
case|:
name|YYCHAR
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
case|case
name|CPP_ELLIPSIS
case|:
name|YYCHAR
argument_list|(
name|ELLIPSIS
argument_list|)
expr_stmt|;
case|case
name|CPP_PLUS_PLUS
case|:
name|YYCHAR
argument_list|(
name|PLUSPLUS
argument_list|)
expr_stmt|;
case|case
name|CPP_MINUS_MINUS
case|:
name|YYCHAR
argument_list|(
name|MINUSMINUS
argument_list|)
expr_stmt|;
case|case
name|CPP_DEREF
case|:
name|YYCHAR
argument_list|(
name|POINTSAT
argument_list|)
expr_stmt|;
case|case
name|CPP_DOT
case|:
name|YYCHAR
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
comment|/* These tokens are C++ specific.  */
case|case
name|CPP_SCOPE
case|:
name|YYCHAR
argument_list|(
name|SCOPE
argument_list|)
expr_stmt|;
case|case
name|CPP_DEREF_STAR
case|:
name|YYCHAR
argument_list|(
name|POINTSAT_STAR
argument_list|)
expr_stmt|;
case|case
name|CPP_DOT_STAR
case|:
name|YYCHAR
argument_list|(
name|DOT_STAR
argument_list|)
expr_stmt|;
case|case
name|CPP_MIN_EQ
case|:
name|YYCODE
argument_list|(
name|MIN_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_MAX_EQ
case|:
name|YYCODE
argument_list|(
name|MAX_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|CPP_MIN
case|:
name|YYCODE
argument_list|(
name|MIN_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|MIN_MAX
argument_list|)
expr_stmt|;
case|case
name|CPP_MAX
case|:
name|YYCODE
argument_list|(
name|MAX_EXPR
argument_list|)
expr_stmt|;
name|YYCHAR
argument_list|(
name|MIN_MAX
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|YYCHAR
undef|#
directive|undef
name|YYCODE
case|case
name|CPP_EOF
case|:
name|t
operator|->
name|yychar
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CPP_NAME
case|:
name|t
operator|->
name|yychar
operator|=
name|read_process_identifier
argument_list|(
operator|&
name|t
operator|->
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NUMBER
case|:
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
name|t
operator|->
name|yychar
operator|=
name|CONSTANT
expr_stmt|;
break|break;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
name|t
operator|->
name|yychar
operator|=
name|STRING
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
literal|"parse error"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|t
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
return|return
name|t
operator|->
name|yychar
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|feed_input
parameter_list|(
name|input
parameter_list|)
name|struct
name|unparsed_text
modifier|*
name|input
decl_stmt|;
block|{
name|struct
name|feed
modifier|*
name|f
decl_stmt|;
if|#
directive|if
literal|0
block|if (feed)     abort ();
endif|#
directive|endif
name|f
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|feed_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|feed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The token list starts just after the struct unparsed_text in memory.  */
name|input
operator|->
name|pos
operator|=
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|input
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfeeding %s:%d [%d tokens]\n"
argument_list|,
name|input
operator|->
name|filename
argument_list|,
name|input
operator|->
name|lineno
argument_list|,
name|input
operator|->
name|limit
operator|-
name|input
operator|->
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|->
name|input
operator|=
name|input
expr_stmt|;
name|f
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|f
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|f
operator|->
name|yychar
operator|=
name|yychar
expr_stmt|;
name|f
operator|->
name|yylval
operator|=
name|yylval
expr_stmt|;
name|f
operator|->
name|first_token
operator|=
name|first_token
expr_stmt|;
name|f
operator|->
name|token_obstack
operator|=
name|token_obstack
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|feed
expr_stmt|;
name|input_filename
operator|=
name|input
operator|->
name|filename
expr_stmt|;
name|lineno
operator|=
name|input
operator|->
name|lineno
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|NULL_TREE
expr_stmt|;
name|first_token
operator|=
literal|0
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|token_obstack
argument_list|)
expr_stmt|;
name|feed
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_input
parameter_list|()
block|{
name|struct
name|feed
modifier|*
name|f
init|=
name|feed
decl_stmt|;
name|input_filename
operator|=
name|f
operator|->
name|filename
expr_stmt|;
name|lineno
operator|=
name|f
operator|->
name|lineno
expr_stmt|;
name|yychar
operator|=
name|f
operator|->
name|yychar
expr_stmt|;
name|yylval
operator|=
name|f
operator|->
name|yylval
expr_stmt|;
name|first_token
operator|=
name|f
operator|->
name|first_token
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|token_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|token_obstack
operator|=
name|f
operator|->
name|token_obstack
expr_stmt|;
name|feed
operator|=
name|f
operator|->
name|next
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|feed_obstack
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\treturning to %s:%d\n"
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* GC callback to mark memory pointed to by the pending inline queue.  */
end_comment

begin_function
name|void
name|mark_pending_inlines
parameter_list|(
name|pi
parameter_list|)
name|PTR
name|pi
decl_stmt|;
block|{
name|struct
name|unparsed_text
modifier|*
name|up
init|=
operator|*
operator|(
expr|struct
name|unparsed_text
operator|*
operator|*
operator|)
name|pi
decl_stmt|;
while|while
condition|(
name|up
condition|)
block|{
name|struct
name|token
modifier|*
name|t
init|=
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|up
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|token
modifier|*
name|l
init|=
name|up
operator|->
name|limit
decl_stmt|;
while|while
condition|(
name|t
operator|<
name|l
condition|)
block|{
comment|/* Some of the possible values for yychar use yylval.code 	     instead of yylval.ttype.  We only have to worry about 	     yychars that could have been returned by read_token.  */
switch|switch
condition|(
name|t
operator|->
name|yychar
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'^'
case|:
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
name|LSHIFT
case|:
case|case
name|RSHIFT
case|:
case|case
name|ASSIGN
case|:
case|case
name|MIN_MAX
case|:
case|case
name|EQCOMPARE
case|:
case|case
name|ARITHCOMPARE
case|:
name|t
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t
operator|->
name|yylval
operator|.
name|ttype
condition|)
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
name|up
operator|=
name|up
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Token queue management.  */
end_comment

begin_comment
comment|/* Return the number of tokens available on the fifo.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|int
name|num_tokens
parameter_list|()
block|{
return|return
operator|(
name|obstack_object_size
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
operator|)
operator|-
name|first_token
return|;
block|}
end_function

begin_comment
comment|/* Fetch the token N down the line from the head of the fifo.  */
end_comment

begin_expr_stmt
specifier|static
name|SPEW_INLINE
expr|struct
name|token
operator|*
name|nth_token
argument_list|(
argument|n
argument_list|)
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* could just have this do slurp_ implicitly, but this way is easier      to debug...  */
name|my_friendly_assert
argument_list|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|num_tokens
argument_list|()
argument_list|,
literal|298
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
expr|struct
name|token
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|)
operator|+
name|n
operator|+
name|first_token
return|;
block|}
end_block

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|token
name|Teosi
init|=
block|{
name|END_OF_SAVED_INPUT
block|,
literal|0
name|UNION_INIT_ZERO
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|token
name|Tpad
init|=
block|{
name|EMPTY
block|,
literal|0
name|UNION_INIT_ZERO
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy the next token into T and return its value.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|int
name|add_token
parameter_list|(
name|t
parameter_list|)
name|struct
name|token
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|feed
condition|)
return|return
name|read_token
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
name|feed
operator|->
name|input
operator|->
name|pos
operator|<
name|feed
operator|->
name|input
operator|->
name|limit
condition|)
block|{
name|memcpy
argument_list|(
name|t
argument_list|,
name|feed
operator|->
name|input
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|feed
operator|->
name|input
operator|->
name|pos
operator|++
operator|)
operator|->
name|yychar
return|;
block|}
name|memcpy
argument_list|(
name|t
argument_list|,
operator|&
name|Teosi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|END_OF_SAVED_INPUT
return|;
block|}
end_function

begin_comment
comment|/* Shift the next token onto the fifo.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|int
name|shift_token
parameter_list|()
block|{
name|size_t
name|point
init|=
name|obstack_object_size
argument_list|(
operator|&
name|token_obstack
argument_list|)
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|add_token
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|+
name|point
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Consume the next token out of the fifo.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|void
name|consume_token
parameter_list|()
block|{
if|if
condition|(
name|num_tokens
argument_list|()
operator|==
literal|1
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|token_obstack
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|first_token
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|first_token
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a token at the head of the queue; it will be the next token read.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|void
name|push_token
parameter_list|(
name|t
parameter_list|)
name|struct
name|token
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
name|first_token
operator|==
literal|0
condition|)
comment|/* We hope this doesn't happen often.  */
block|{
name|size_t
name|active
init|=
name|obstack_object_size
argument_list|(
operator|&
name|token_obstack
argument_list|)
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|memmove
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|first_token
operator|++
expr_stmt|;
block|}
name|first_token
operator|--
expr_stmt|;
name|memcpy
argument_list|(
name|nth_token
argument_list|(
literal|0
argument_list|)
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pull in enough tokens that the queue is N long beyond the current    token.  */
end_comment

begin_function
specifier|static
name|void
name|scan_tokens
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|num
init|=
name|num_tokens
argument_list|()
decl_stmt|;
name|int
name|yychar
decl_stmt|;
comment|/* First, prune any empty tokens at the end.  */
name|i
operator|=
name|num
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|nth_token
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|EMPTY
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|num
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
operator|-
operator|(
operator|(
name|num
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|num
operator|=
name|i
expr_stmt|;
block|}
comment|/* Now, if we already have enough tokens, return.  */
if|if
condition|(
name|num
operator|>
name|n
condition|)
return|return;
comment|/* Never read past these characters: they might separate      the current input stream from one we save away later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|yychar
operator|=
name|nth_token
argument_list|(
name|i
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
literal|'{'
operator|||
name|yychar
operator|==
literal|':'
operator|||
name|yychar
operator|==
literal|';'
condition|)
goto|goto
name|pad_tokens
goto|;
block|}
while|while
condition|(
name|num_tokens
argument_list|()
operator|<=
name|n
condition|)
block|{
name|yychar
operator|=
name|shift_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
literal|'{'
operator|||
name|yychar
operator|==
literal|':'
operator|||
name|yychar
operator|==
literal|';'
condition|)
goto|goto
name|pad_tokens
goto|;
block|}
return|return;
name|pad_tokens
label|:
while|while
condition|(
name|num_tokens
argument_list|()
operator|<=
name|n
condition|)
name|obstack_grow
argument_list|(
operator|&
name|token_obstack
argument_list|,
operator|&
name|Tpad
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|looking_for_typename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|looking_for_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|after_friend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|after_new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_snarf_defarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|got_scope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|got_object
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|SPEW_INLINE
name|int
name|identifier_type
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|PTYPENAME
return|;
elseif|else
if|if
condition|(
name|looking_for_template
condition|)
return|return
name|PFUNCNAME
return|;
block|}
if|if
condition|(
name|looking_for_template
operator|&&
name|really_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* See through a baselink.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|decl
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|PFUNCNAME
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|NSNAME
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
name|IDENTIFIER
return|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
condition|)
return|return
name|SELFNAME
return|;
comment|/* A constructor declarator for a template type will get here as an      implicit typename, a TYPENAME_TYPE with a type.  */
name|t
operator|=
name|got_scope
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|decl
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|==
name|decl
condition|)
return|return
name|SELFNAME
return|;
return|return
name|TYPENAME
return|;
block|}
end_function

begin_comment
comment|/* token[0] == AGGR (struct/union/enum)    Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.    If token[2] == '{' or ':' then it's TYPENAME_DEFN.    It's also a definition if it's a forward declaration (as in 'struct Foo;')    which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|void
name|do_aggr
parameter_list|()
block|{
name|int
name|yc1
decl_stmt|,
name|yc2
decl_stmt|;
name|scan_tokens
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|yc1
operator|=
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|yc1
operator|!=
name|TYPENAME
operator|&&
name|yc1
operator|!=
name|IDENTIFIER
operator|&&
name|yc1
operator|!=
name|PTYPENAME
condition|)
return|return;
name|yc2
operator|=
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|yc2
operator|==
literal|';'
condition|)
block|{
comment|/* It's a forward declaration iff we were not preceded by          'friend' or `new'.  */
if|if
condition|(
name|after_friend
operator|||
name|after_new
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|yc2
operator|!=
literal|'{'
operator|&&
name|yc2
operator|!=
literal|':'
condition|)
return|return;
switch|switch
condition|(
name|yc1
condition|)
block|{
case|case
name|TYPENAME
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|TYPENAME_DEFN
expr_stmt|;
break|break;
case|case
name|PTYPENAME
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|PTYPENAME_DEFN
expr_stmt|;
break|break;
case|case
name|IDENTIFIER
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|IDENTIFIER_DEFN
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|see_typename
parameter_list|()
block|{
comment|/* Only types expected, not even namespaces. */
name|looking_for_typename
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|IDENTIFIER
condition|)
block|{
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
condition|)
name|yychar
operator|=
name|identifier_type
argument_list|(
name|lastiddecl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|()
block|{
name|int
name|yychr
decl_stmt|;
name|int
name|old_looking_for_typename
init|=
literal|0
decl_stmt|;
name|int
name|just_saw_new
init|=
literal|0
decl_stmt|;
name|int
name|just_saw_friend
init|=
literal|0
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_LEX
argument_list|)
expr_stmt|;
name|retry
label|:
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
block|{
name|yylex_ctr
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t## %d @%d "
argument_list|,
name|yylex_ctr
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|do_snarf_defarg
condition|)
block|{
name|do_snarf_defarg
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|snarf_defarg
argument_list|()
expr_stmt|;
name|yychar
operator|=
name|DEFARG
expr_stmt|;
name|got_object
operator|=
name|NULL_TREE
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LEX
argument_list|)
expr_stmt|;
return|return
name|DEFARG
return|;
block|}
comment|/* if we've got tokens, send them */
elseif|else
if|if
condition|(
name|num_tokens
argument_list|()
condition|)
name|yychr
operator|=
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
expr_stmt|;
else|else
name|yychr
operator|=
name|shift_token
argument_list|()
expr_stmt|;
comment|/* many tokens just need to be returned. At first glance, all we      have to do is send them back up, but some of them are needed to      figure out local context.  */
switch|switch
condition|(
name|yychr
condition|)
block|{
case|case
name|EMPTY
case|:
comment|/* This is a lexical no-op.  */
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|yychr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|consume_token
argument_list|()
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'('
case|:
name|scan_tokens
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
literal|')'
condition|)
block|{
name|consume_token
argument_list|()
expr_stmt|;
name|yychr
operator|=
name|LEFT_RIGHT
expr_stmt|;
block|}
break|break;
case|case
name|IDENTIFIER
case|:
block|{
name|int
name|peek
decl_stmt|;
name|scan_tokens
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|peek
operator|=
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
expr_stmt|;
name|yychr
operator|=
name|frob_id
argument_list|(
name|yychr
argument_list|,
name|peek
argument_list|,
operator|&
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IDENTIFIER_DEFN
case|:
case|case
name|TYPENAME
case|:
case|case
name|TYPENAME_DEFN
case|:
case|case
name|PTYPENAME
case|:
case|case
name|PTYPENAME_DEFN
case|:
comment|/* If we see a SCOPE next, restore the old value. 	 Otherwise, we got what we want. */
name|looking_for_typename
operator|=
name|old_looking_for_typename
expr_stmt|;
name|looking_for_template
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCSPEC
case|:
if|if
condition|(
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
operator|==
name|ridpointers
index|[
name|RID_EXTERN
index|]
condition|)
block|{
name|scan_tokens
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|STRING
condition|)
block|{
name|yychr
operator|=
name|EXTERN_LANG_STRING
expr_stmt|;
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|consume_token
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* do_aggr needs to know if the previous token was `friend'.  */
elseif|else
if|if
condition|(
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
operator|==
name|ridpointers
index|[
name|RID_FRIEND
index|]
condition|)
name|just_saw_friend
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEW
case|:
comment|/* do_aggr needs to know if the previous token was `new'.  */
name|just_saw_new
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYPESPEC
case|:
case|case
literal|'{'
case|:
case|case
literal|':'
case|:
case|case
literal|';'
case|:
comment|/* If this provides a type for us, then revert lexical 	 state to standard state.  */
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AGGR
case|:
name|do_aggr
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
comment|/* Set this again, in case we are rescanning.  */
name|looking_for_typename
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|after_friend
operator|=
name|just_saw_friend
expr_stmt|;
name|after_new
operator|=
name|just_saw_new
expr_stmt|;
comment|/* class member lookup only applies to the first token after the object      expression, except for explicit destructor calls.  */
if|if
condition|(
name|yychr
operator|!=
literal|'~'
condition|)
name|got_object
operator|=
name|NULL_TREE
expr_stmt|;
name|yychar
operator|=
name|yychr
expr_stmt|;
block|{
name|struct
name|token
modifier|*
name|tok
init|=
name|nth_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|yylval
operator|=
name|tok
operator|->
name|yylval
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|lineno
condition|)
name|lineno
operator|=
name|tok
operator|->
name|lineno
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|yychr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|consume_token
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LEX
argument_list|)
expr_stmt|;
return|return
name|yychr
return|;
block|}
end_function

begin_comment
comment|/* Unget character CH from the input stream.    If RESCAN is non-zero, then we want to `see' this    character as the next input token.  */
end_comment

begin_function
name|void
name|yyungetc
parameter_list|(
name|ch
parameter_list|,
name|rescan
parameter_list|)
name|int
name|ch
decl_stmt|;
name|int
name|rescan
decl_stmt|;
block|{
comment|/* Unget a character from the input stream.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
operator|||
name|rescan
operator|==
literal|0
condition|)
block|{
name|struct
name|token
name|fake
decl_stmt|;
comment|/* If we're putting back a brace, undo the change in indent_level 	 from the first time we saw it.  */
if|if
condition|(
name|ch
operator|==
literal|'{'
condition|)
name|indent_level
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'}'
condition|)
name|indent_level
operator|++
expr_stmt|;
name|fake
operator|.
name|yychar
operator|=
name|ch
expr_stmt|;
name|fake
operator|.
name|yylval
operator|.
name|ttype
operator|=
literal|0
expr_stmt|;
name|fake
operator|.
name|lineno
operator|=
name|lineno
expr_stmt|;
name|push_token
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yychar
operator|=
name|ch
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lexer hackery to determine what *IDP really is.  */
end_comment

begin_function
specifier|static
name|int
name|frob_id
parameter_list|(
name|yyc
parameter_list|,
name|peek
parameter_list|,
name|idp
parameter_list|)
name|int
name|yyc
decl_stmt|;
name|int
name|peek
decl_stmt|;
name|tree
modifier|*
name|idp
decl_stmt|;
block|{
name|tree
name|trrr
decl_stmt|;
name|int
name|old_looking_for_typename
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|peek
operator|==
name|SCOPE
condition|)
block|{
comment|/* Don't interfere with the setting from an 'aggr' prefix.  */
name|old_looking_for_typename
operator|=
name|looking_for_typename
expr_stmt|;
name|looking_for_typename
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'<'
condition|)
name|looking_for_template
operator|=
literal|1
expr_stmt|;
name|trrr
operator|=
name|lookup_name
argument_list|(
operator|*
name|idp
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|trrr
condition|)
block|{
name|yyc
operator|=
name|identifier_type
argument_list|(
name|trrr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yyc
condition|)
block|{
case|case
name|TYPENAME
case|:
case|case
name|SELFNAME
case|:
case|case
name|NSNAME
case|:
case|case
name|PTYPENAME
case|:
comment|/* If this got special lookup, remember it.  In these 	       cases, we know it can't be a declarator-id. */
if|if
condition|(
name|got_scope
operator|||
name|got_object
condition|)
operator|*
name|idp
operator|=
name|trrr
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PFUNCNAME
case|:
case|case
name|IDENTIFIER
case|:
name|lastiddecl
operator|=
name|trrr
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|lastiddecl
operator|=
name|NULL_TREE
expr_stmt|;
name|got_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|looking_for_typename
operator|=
name|old_looking_for_typename
expr_stmt|;
name|looking_for_template
operator|=
literal|0
expr_stmt|;
return|return
name|yyc
return|;
block|}
end_function

begin_comment
comment|/* ID is an operator name. Duplicate the hackery in yylex to determine what    it really is.  */
end_comment

begin_function
name|tree
name|frob_opname
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
name|scan_tokens
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|frob_id
argument_list|(
literal|0
argument_list|,
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|got_object
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* Set up the state required to correctly handle the definition of the    inline function whose preparsed state has been saved in PI.  */
end_comment

begin_function
specifier|static
name|void
name|begin_parsing_inclass_inline
parameter_list|(
name|pi
parameter_list|)
name|struct
name|unparsed_text
modifier|*
name|pi
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
comment|/* Record that we are processing the chain of inlines starting at      PI for GC.  */
if|if
condition|(
name|cfun
condition|)
name|cp_function_chain
operator|->
name|unparsed_inlines
operator|=
name|pi
expr_stmt|;
else|else
name|processing_these_inlines
operator|=
name|pi
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* If this is an inline function in a local class, we must make sure      that we save all pertinent information about the function      surrounding the local class.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|pi
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|push_function_context_to
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|feed_input
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
name|pi
operator|->
name|interface
operator|==
literal|1
expr_stmt|;
name|interface_only
operator|=
name|pi
operator|->
name|interface
operator|==
literal|0
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|pi
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|pi
operator|->
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Pass back a handle to the rest of the inline functions, so that they      can be processed later.  */
name|yychar
operator|=
name|PRE_PARSED_FUNCTION_DECL
expr_stmt|;
name|yylval
operator|.
name|pi
operator|=
name|pi
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|pi
operator|->
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
name|SF_DEFAULT
operator||
name|SF_PRE_PARSED
operator||
name|SF_INCLASS_INLINE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from the top level: if there are any pending inlines to    do, set up to process them now.  This function sets up the first function    to be parsed; after it has been, the rule for fndef in parse.y will    call process_next_inline to start working on the next one.  */
end_comment

begin_function
name|void
name|do_pending_inlines
parameter_list|()
block|{
comment|/* Oops, we're still dealing with the last batch.  */
if|if
condition|(
name|yychar
operator|==
name|PRE_PARSED_FUNCTION_DECL
condition|)
return|return;
if|if
condition|(
name|pending_inlines
condition|)
block|{
comment|/* Clear the chain, so that any inlines nested inside the batch 	 we're to process now don't refer to this batch.  See e.g. 	 g++.other/lookup6.C.  */
name|struct
name|unparsed_text
modifier|*
name|first
init|=
name|pending_inlines
decl_stmt|;
name|pending_inlines
operator|=
name|pending_inlines_tail
operator|=
literal|0
expr_stmt|;
name|begin_parsing_inclass_inline
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from the fndecl rule in the parser when the function just parsed    was declared using a PRE_PARSED_FUNCTION_DECL (i.e. came from    do_pending_inlines).  */
end_comment

begin_function
name|void
name|process_next_inline
parameter_list|(
name|i
parameter_list|)
name|struct
name|unparsed_text
modifier|*
name|i
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|i
operator|->
name|decl
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
condition|)
name|pop_function_context_from
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|!=
name|END_OF_SAVED_INPUT
condition|)
name|error
argument_list|(
literal|"parse error at end of saved function text"
argument_list|)
expr_stmt|;
name|end_input
argument_list|()
expr_stmt|;
name|i
operator|=
name|i
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|begin_parsing_inclass_inline
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cfun
condition|)
name|cp_function_chain
operator|->
name|unparsed_inlines
operator|=
literal|0
expr_stmt|;
else|else
name|processing_these_inlines
operator|=
literal|0
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of snarf_method, deals with actual absorption of the block.  */
end_comment

begin_function
specifier|static
name|SPEW_INLINE
name|void
name|snarf_block
parameter_list|(
name|starting_file
parameter_list|,
name|starting_line
parameter_list|)
specifier|const
name|char
modifier|*
name|starting_file
decl_stmt|;
name|int
name|starting_line
decl_stmt|;
block|{
name|int
name|blev
init|=
literal|1
decl_stmt|;
name|int
name|look_for_semicolon
init|=
literal|0
decl_stmt|;
name|int
name|look_for_lbrac
init|=
literal|0
decl_stmt|;
name|int
name|look_for_catch
init|=
literal|0
decl_stmt|;
name|int
name|yyc
decl_stmt|;
name|struct
name|token
name|tmp
decl_stmt|;
name|size_t
name|point
decl_stmt|;
if|if
condition|(
name|yychar
operator|==
literal|'{'
condition|)
comment|/* We incremented indent_level in yylex; undo that.  */
name|indent_level
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|yychar
operator|==
literal|'='
condition|)
name|look_for_semicolon
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|yychar
operator|==
literal|':'
operator|||
name|yychar
operator|==
name|RETURN_KEYWORD
operator|||
name|yychar
operator|==
name|TRY
condition|)
block|{
if|if
condition|(
name|yychar
operator|==
name|TRY
condition|)
name|look_for_catch
operator|=
literal|1
expr_stmt|;
name|look_for_lbrac
operator|=
literal|1
expr_stmt|;
name|blev
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|yyerror
argument_list|(
literal|"parse error in method specification"
argument_list|)
expr_stmt|;
comment|/* The current token is the first one to be recorded.  */
name|tmp
operator|.
name|yychar
operator|=
name|yychar
expr_stmt|;
name|tmp
operator|.
name|yylval
operator|=
name|yylval
expr_stmt|;
name|tmp
operator|.
name|lineno
operator|=
name|lineno
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|point
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|yyc
operator|=
name|add_token
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|obstack_base
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
operator|+
name|point
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyc
operator|==
literal|'{'
condition|)
block|{
name|look_for_lbrac
operator|=
literal|0
expr_stmt|;
name|blev
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yyc
operator|==
literal|'}'
condition|)
block|{
name|blev
operator|--
expr_stmt|;
if|if
condition|(
name|blev
operator|==
literal|0
operator|&&
operator|!
name|look_for_semicolon
condition|)
block|{
if|if
condition|(
operator|!
name|look_for_catch
condition|)
break|break;
if|if
condition|(
name|add_token
argument_list|(
operator|&
name|tmp
argument_list|)
operator|!=
name|CATCH
condition|)
block|{
name|push_token
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|look_for_lbrac
operator|=
literal|1
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|yyc
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|look_for_lbrac
condition|)
block|{
name|error
argument_list|(
literal|"function body for constructor missing"
argument_list|)
expr_stmt|;
comment|/* fake a { } to avoid further errors */
name|tmp
operator|.
name|yylval
operator|.
name|ttype
operator|=
literal|0
expr_stmt|;
name|tmp
operator|.
name|yychar
operator|=
literal|'{'
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|yychar
operator|=
literal|'}'
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|look_for_semicolon
operator|&&
name|blev
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|yyc
operator|==
literal|0
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_file
argument_list|,
name|starting_line
argument_list|,
literal|"end of file read inside definition"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function stores away the text for an inline function that should    be processed later (by do_pending_inlines).  */
end_comment

begin_function
name|void
name|snarf_method
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|unparsed_text
modifier|*
name|meth
decl_stmt|;
comment|/* Leave room for the header, then absorb the block.  */
name|obstack_blank
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unparsed_text
argument_list|)
argument_list|)
expr_stmt|;
name|snarf_block
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|)
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|meth
operator|=
operator|(
expr|struct
name|unparsed_text
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
comment|/* Happens when we get two declarations of the same function in the      same scope.  */
if|if
condition|(
name|decl
operator|==
name|void_type_node
operator|||
operator|(
name|current_class_type
operator|&&
name|TYPE_REDEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
name|meth
argument_list|)
expr_stmt|;
return|return;
block|}
name|meth
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|meth
operator|->
name|filename
operator|=
name|starting_filename
expr_stmt|;
name|meth
operator|->
name|lineno
operator|=
name|starting_lineno
expr_stmt|;
name|meth
operator|->
name|limit
operator|=
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|meth
operator|+
name|len
operator|)
expr_stmt|;
name|meth
operator|->
name|interface
operator|=
operator|(
name|interface_unknown
condition|?
literal|1
else|:
operator|(
name|interface_only
condition|?
literal|0
else|:
literal|2
operator|)
operator|)
expr_stmt|;
name|meth
operator|->
name|next
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsaved method of %d tokens from %s:%d\n"
argument_list|,
name|meth
operator|->
name|limit
operator|-
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|meth
operator|+
literal|1
operator|)
argument_list|,
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|meth
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pending_inlines_tail
condition|)
name|pending_inlines_tail
operator|->
name|next
operator|=
name|meth
expr_stmt|;
else|else
name|pending_inlines
operator|=
name|meth
expr_stmt|;
name|pending_inlines_tail
operator|=
name|meth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consume a no-commas expression - a default argument - and save it    on the inline_text_obstack.  */
end_comment

begin_function
specifier|static
name|tree
name|snarf_defarg
parameter_list|()
block|{
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|yyc
decl_stmt|;
name|int
name|plev
init|=
literal|0
decl_stmt|;
name|size_t
name|point
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|unparsed_text
modifier|*
name|buf
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unparsed_text
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|point
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|yyc
operator|=
name|add_token
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|obstack_base
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
operator|+
name|point
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plev
operator|<=
literal|0
operator|&&
operator|(
name|yyc
operator|==
literal|')'
operator|||
name|yyc
operator|==
literal|','
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|yyc
operator|==
literal|'('
operator|||
name|yyc
operator|==
literal|'['
condition|)
operator|++
name|plev
expr_stmt|;
elseif|else
if|if
condition|(
name|yyc
operator|==
literal|']'
operator|||
name|yyc
operator|==
literal|')'
condition|)
operator|--
name|plev
expr_stmt|;
elseif|else
if|if
condition|(
name|yyc
operator|==
literal|0
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|,
literal|"end of file read inside default argument"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Unget the last token.  */
name|push_token
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|obstack_base
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
operator|+
name|point
operator|)
argument_list|)
expr_stmt|;
comment|/* This is the documented way to shrink a growing obstack block.  */
name|obstack_blank
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
expr|struct
name|unparsed_text
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|buf
operator|->
name|decl
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|filename
operator|=
name|starting_filename
expr_stmt|;
name|buf
operator|->
name|lineno
operator|=
name|starting_lineno
expr_stmt|;
name|buf
operator|->
name|limit
operator|=
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|len
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsaved defarg of %d tokens from %s:%d\n"
argument_list|,
name|buf
operator|->
name|limit
operator|-
operator|(
expr|struct
name|token
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
argument_list|,
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arg
operator|=
name|make_node
argument_list|(
name|DEFAULT_ARG
argument_list|)
expr_stmt|;
name|DEFARG_POINTER
argument_list|(
name|arg
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Decide whether the default argument we are about to see should be    gobbled up as text for later parsing.  */
end_comment

begin_function
name|void
name|maybe_snarf_defarg
parameter_list|()
block|{
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|do_snarf_defarg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from grokfndecl to note a function decl with unparsed default    arguments for later processing.  Also called from grokdeclarator    for function types with unparsed defargs; the call from grokfndecl    will always come second, so we can overwrite the entry from the type.  */
end_comment

begin_function
name|void
name|add_defarg_fn
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_VALUE
argument_list|(
name|defarg_fns
argument_list|)
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|defarg_fns
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|defarg_fns
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|defarg_fns
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper for do_pending_defargs.  Starts the parsing of a default arg.  */
end_comment

begin_function
specifier|static
name|void
name|feed_defarg
parameter_list|(
name|p
parameter_list|)
name|tree
name|p
decl_stmt|;
block|{
name|tree
name|d
init|=
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|feed_input
argument_list|(
operator|(
expr|struct
name|unparsed_text
operator|*
operator|)
name|DEFARG_POINTER
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|DEFARG_MARKER
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for do_pending_defargs.  Ends the parsing of a default arg.  */
end_comment

begin_function
specifier|static
name|void
name|finish_defarg
parameter_list|()
block|{
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|!=
name|END_OF_SAVED_INPUT
condition|)
name|error
argument_list|(
literal|"parse error at end of saved function text"
argument_list|)
expr_stmt|;
name|end_input
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main function for deferred parsing of default arguments.  Called from    the parser.  */
end_comment

begin_function
name|void
name|do_pending_defargs
parameter_list|()
block|{
if|if
condition|(
name|defarg_parm
condition|)
name|finish_defarg
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|defarg_fns
condition|;
control|)
block|{
name|tree
name|current
init|=
name|defarg_fns
decl_stmt|;
name|tree
name|defarg_fn
init|=
name|TREE_VALUE
argument_list|(
name|defarg_fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|defarg_parm
operator|==
name|NULL_TREE
condition|)
block|{
name|push_nested_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|defarg_fns
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|defarg_fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|maybe_begin_member_template_processing
argument_list|(
name|defarg_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|defarg_fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|defarg_parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|defarg_fn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|defarg_parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|defarg_fn
argument_list|)
expr_stmt|;
block|}
else|else
name|defarg_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|defarg_parm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|defarg_parm
condition|;
name|defarg_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|defarg_parm
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|defarg_parm
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|defarg_parm
argument_list|)
argument_list|)
operator|!=
name|DEFAULT_ARG
condition|)
empty_stmt|;
comment|/* OK */
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|current
argument_list|)
operator|==
name|error_mark_node
condition|)
name|DEFARG_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|defarg_parm
argument_list|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|feed_defarg
argument_list|(
name|defarg_parm
argument_list|)
expr_stmt|;
comment|/* Return to the parser, which will process this defarg 	       and call us again.  */
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|defarg_fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
name|check_default_args
argument_list|(
name|defarg_fn
argument_list|)
expr_stmt|;
block|}
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_nested_class
argument_list|()
expr_stmt|;
name|defarg_fns
operator|=
name|TREE_CHAIN
argument_list|(
name|defarg_fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|defarg_depfns
condition|)
block|{
comment|/* This function's default args depend on unprocessed default args              of defarg_fns. We will need to reprocess this function, and              check for circular dependencies.  */
name|tree
name|a
decl_stmt|,
name|b
decl_stmt|;
for|for
control|(
name|a
operator|=
name|defarg_depfns
operator|,
name|b
operator|=
name|TREE_PURPOSE
argument_list|(
name|current
argument_list|)
init|;
name|a
operator|&&
name|b
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|b
operator|=
name|TREE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|b
argument_list|)
condition|)
goto|goto
name|different
goto|;
if|if
condition|(
name|a
operator|||
name|b
condition|)
block|{
name|different
label|:
empty_stmt|;
name|TREE_CHAIN
argument_list|(
name|current
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|defarg_fns
operator|=
name|chainon
argument_list|(
name|defarg_fns
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|current
argument_list|)
operator|=
name|defarg_depfns
expr_stmt|;
block|}
else|else
block|{
name|cp_warning_at
argument_list|(
literal|"circular dependency in default args of `%#D'"
argument_list|,
name|defarg_fn
argument_list|)
expr_stmt|;
comment|/* No need to say what else is dependent, as they will be                  picked up in another pass.  */
comment|/* Immediately repeat, but marked so that we break the loop. */
name|defarg_fns
operator|=
name|current
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|current
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|defarg_depfns
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|current
argument_list|)
operator|==
name|error_mark_node
condition|)
name|defarg_fnsdone
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|defarg_fn
argument_list|,
name|defarg_fnsdone
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* After parsing all the default arguments, we must clear any that remain,    which will be part of a circular dependency. */
end_comment

begin_function
name|void
name|done_pending_defargs
parameter_list|()
block|{
for|for
control|(
init|;
name|defarg_fnsdone
condition|;
name|defarg_fnsdone
operator|=
name|TREE_CHAIN
argument_list|(
name|defarg_fnsdone
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|defarg_fnsdone
argument_list|)
decl_stmt|;
name|tree
name|parms
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|parms
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|parms
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|DEFARG_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
literal|20010107
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* In processing the current default arg, we called FN, but that call    required a default argument of FN, and that had not yet been processed.    Remember FN.  */
end_comment

begin_function
name|void
name|unprocessed_defarg_fn
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|defarg_depfns
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|defarg_depfns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from the parser to update an element of TYPE_ARG_TYPES for some    FUNCTION_TYPE with the newly parsed version of its default argument, which    was previously digested as text.  */
end_comment

begin_function
name|void
name|replace_defarg
parameter_list|(
name|arg
parameter_list|,
name|init
parameter_list|)
name|tree
name|arg
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|!
name|can_convert_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid type `%T' for default argument to `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defarg_depfns
condition|)
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_comment
comment|/* debug_yychar takes a yychar (token number) value and prints its name.  */
end_comment

begin_function
specifier|static
name|void
name|debug_yychar
parameter_list|(
name|yy
parameter_list|)
name|int
name|yy
decl_stmt|;
block|{
if|if
condition|(
name|yy
operator|<
literal|256
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"->%d< %c>\n"
argument_list|,
name|lineno
argument_list|,
name|yy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yy
operator|==
name|IDENTIFIER
operator|||
name|yy
operator|==
name|TYPENAME
condition|)
block|{
specifier|const
name|char
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|id
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|id
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
literal|""
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"->%d<%s `%s'>\n"
argument_list|,
name|lineno
argument_list|,
name|debug_yytranslate
argument_list|(
name|yy
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"->%d<%s>\n"
argument_list|,
name|lineno
argument_list|,
name|debug_yytranslate
argument_list|(
name|yy
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|TYPE
parameter_list|)
value|cpp_type2name (TYPE)
end_define

begin_function
name|void
name|yyerror
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|_
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_token
operator|==
name|CPP_EOF
condition|)
name|error
argument_list|(
literal|"%s at end of input"
argument_list|,
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_token
operator|==
name|CPP_CHAR
operator|||
name|last_token
operator|==
name|CPP_WCHAR
condition|)
block|{
name|unsigned
name|int
name|val
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|ell
init|=
operator|(
name|last_token
operator|==
name|CPP_CHAR
operator|)
condition|?
literal|""
else|:
literal|"L"
decl_stmt|;
if|if
condition|(
name|val
operator|<=
name|UCHAR_MAX
operator|&&
name|ISGRAPH
argument_list|(
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"%s before %s'%c'"
argument_list|,
name|string
argument_list|,
name|ell
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s before %s'\\x%x'"
argument_list|,
name|string
argument_list|,
name|ell
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_token
operator|==
name|CPP_STRING
operator|||
name|last_token
operator|==
name|CPP_WSTRING
condition|)
name|error
argument_list|(
literal|"%s before string constant"
argument_list|,
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_token
operator|==
name|CPP_NUMBER
condition|)
name|error
argument_list|(
literal|"%s before numeric constant"
argument_list|,
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_token
operator|==
name|CPP_NAME
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last_token_id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"%s before `%s'"
argument_list|,
name|string
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|last_token_id
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISGRAPH
argument_list|(
name|yychar
argument_list|)
condition|)
name|error
argument_list|(
literal|"%s before `%c'"
argument_list|,
name|string
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s before `\%o'"
argument_list|,
name|string
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"%s before `%s' token"
argument_list|,
name|string
argument_list|,
name|NAME
argument_list|(
name|last_token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

