begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Type Analyzer for GNU C++.    Copyright (C) 1987, 89, 92-97, 1998 Free Software Foundation, Inc.    Hacked... nay, bludgeoned... by Mark Eichin (eichin@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG    when compiling parse.c and spew.c.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* This takes a token stream that hasn't decided much about types and    tries to figure out as much as it can, with excessive lookahead and    backtracking.  */
end_comment

begin_comment
comment|/* fifo of tokens recognized and available to parser.  */
end_comment

begin_struct
struct|struct
name|token
block|{
comment|/* The values for YYCHAR will fit in a short.  */
name|short
name|yychar
decl_stmt|;
name|short
name|end_of_file
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|do_aggr
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|probe_obstack
name|PROTO
argument_list|(
operator|(
expr|struct
name|obstack
operator|*
operator|,
name|tree
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_tokens
name|PROTO
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|num_tokens
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|token
modifier|*
name|nth_token
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_token
name|PROTO
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|consume_token
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_yychar
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From lex.c: */
end_comment

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* let our brains leak out here too */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|end_of_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|token_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_token
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|spew_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|yylex_ctr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|debug_yychar
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize token_obstack. Called once, from init_parse.  */
end_comment

begin_function
name|void
name|init_spew
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|token_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_comment
comment|/* Use functions for debugging...  */
end_comment

begin_comment
comment|/* Return the number of tokens available on the fifo.  */
end_comment

begin_function
specifier|static
name|int
name|num_tokens
parameter_list|()
block|{
return|return
operator|(
name|obstack_object_size
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
operator|)
operator|-
name|first_token
return|;
block|}
end_function

begin_comment
comment|/* Fetch the token N down the line from the head of the fifo.  */
end_comment

begin_function
specifier|static
name|struct
name|token
modifier|*
name|nth_token
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* could just have this do slurp_ implicitly, but this way is easier      to debug...  */
name|my_friendly_assert
argument_list|(
name|n
operator|<
name|num_tokens
argument_list|()
argument_list|,
literal|298
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|token
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|)
operator|+
name|n
operator|+
name|first_token
return|;
block|}
end_function

begin_comment
comment|/* Add a token to the token fifo.  */
end_comment

begin_function
specifier|static
name|void
name|add_token
parameter_list|(
name|t
parameter_list|)
name|struct
name|token
modifier|*
name|t
decl_stmt|;
block|{
name|obstack_grow
argument_list|(
operator|&
name|token_obstack
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consume the next token out of the fifo.  */
end_comment

begin_function
specifier|static
name|void
name|consume_token
parameter_list|()
block|{
if|if
condition|(
name|num_tokens
argument_list|()
operator|==
literal|1
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|token_obstack
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|first_token
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|first_token
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ...otherwise use macros.  */
end_comment

begin_define
define|#
directive|define
name|num_tokens
parameter_list|()
define|\
value|((obstack_object_size (&token_obstack) / sizeof (struct token)) - first_token)
end_define

begin_define
define|#
directive|define
name|nth_token
parameter_list|(
name|N
parameter_list|)
define|\
value|(((struct token*)obstack_base (&token_obstack))+(N)+first_token)
end_define

begin_define
define|#
directive|define
name|add_token
parameter_list|(
name|T
parameter_list|)
value|obstack_grow (&token_obstack, (T), sizeof (struct token))
end_define

begin_define
define|#
directive|define
name|consume_token
parameter_list|()
define|\
value|(num_tokens () == 1							\    ? (obstack_free (&token_obstack, obstack_base (&token_obstack)),	\       (first_token = 0))						\    : first_token++)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pull in enough tokens from real_yylex that the queue is N long beyond    the current token.  */
end_comment

begin_function
specifier|static
name|void
name|scan_tokens
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|token
modifier|*
name|tmp
decl_stmt|;
comment|/* We cannot read past certain tokens, so make sure we don't.  */
name|i
operator|=
name|num_tokens
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
condition|)
return|return;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|nth_token
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Never read past these characters: they might separate 	 the current input stream from one we save away later.  */
if|if
condition|(
name|tmp
operator|->
name|yychar
operator|==
literal|'{'
operator|||
name|tmp
operator|->
name|yychar
operator|==
literal|':'
operator|||
name|tmp
operator|->
name|yychar
operator|==
literal|';'
condition|)
goto|goto
name|pad_tokens
goto|;
block|}
while|while
condition|(
name|num_tokens
argument_list|()
operator|<=
name|n
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|token
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tmp
operator|->
name|yychar
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|tmp
operator|->
name|end_of_file
operator|=
name|end_of_file
expr_stmt|;
name|tmp
operator|->
name|yylval
operator|=
name|yylval
expr_stmt|;
name|end_of_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|yychar
operator|==
literal|'{'
operator|||
name|tmp
operator|->
name|yychar
operator|==
literal|':'
operator|||
name|tmp
operator|->
name|yychar
operator|==
literal|';'
condition|)
block|{
name|pad_tokens
label|:
while|while
condition|(
name|num_tokens
argument_list|()
operator|<=
name|n
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|token
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tmp
operator|->
name|yychar
operator|=
name|EMPTY
expr_stmt|;
name|tmp
operator|->
name|end_of_file
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like _obstack_allocated_p, but stop after checking NLEVELS chunks.  */
end_comment

begin_function
specifier|static
name|int
name|probe_obstack
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|,
name|nlevels
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|tree
name|obj
decl_stmt|;
name|unsigned
name|int
name|nlevels
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
operator|(
name|h
operator|)
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= rather than> since the object cannot be exactly at      the beginning of the chunk but might be an empty object exactly      at the end of an adjacent chunk.  */
for|for
control|(
init|;
name|nlevels
operator|!=
literal|0
operator|&&
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|tree
operator|)
name|lp
operator|>=
name|obj
operator|||
operator|(
name|tree
operator|)
name|lp
operator|->
name|limit
operator|<
name|obj
operator|)
condition|;
name|nlevels
operator|-=
literal|1
control|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
block|}
return|return
name|nlevels
operator|!=
literal|0
operator|&&
name|lp
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* from lex.c: */
end_comment

begin_comment
comment|/* Value is 1 (or 2) if we should try to make the next identifier look like    a typename (when it may be a local variable or a class variable).    Value is 0 if we treat this name in a default fashion.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|looking_for_typename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|looking_for_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|do_snarf_defarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|got_scope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|got_object
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|peekyylex
parameter_list|()
block|{
name|scan_tokens
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
return|;
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|()
block|{
name|struct
name|token
name|tmp_token
decl_stmt|;
name|tree
name|trrr
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|old_looking_for_typename
init|=
literal|0
decl_stmt|;
name|retry
label|:
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
block|{
name|yylex_ctr
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t## %d ##"
argument_list|,
name|yylex_ctr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|do_snarf_defarg
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|num_tokens
argument_list|()
operator|==
literal|0
argument_list|,
literal|2837
argument_list|)
expr_stmt|;
name|tmp_token
operator|.
name|yychar
operator|=
name|DEFARG
expr_stmt|;
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
operator|=
name|snarf_defarg
argument_list|()
expr_stmt|;
name|tmp_token
operator|.
name|end_of_file
operator|=
literal|0
expr_stmt|;
name|do_snarf_defarg
operator|=
literal|0
expr_stmt|;
name|add_token
argument_list|(
operator|&
name|tmp_token
argument_list|)
expr_stmt|;
block|}
comment|/* if we've got tokens, send them */
elseif|else
if|if
condition|(
name|num_tokens
argument_list|()
condition|)
block|{
name|tmp_token
operator|=
operator|*
name|nth_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* TMP_TOKEN.YYLVAL.TTYPE may have been allocated on the wrong obstack. 	 If we don't find it in CURRENT_OBSTACK's current or immediately 	 previous chunk, assume it was and copy it to the current obstack.  */
if|if
condition|(
operator|(
name|tmp_token
operator|.
name|yychar
operator|==
name|CONSTANT
operator|||
name|tmp_token
operator|.
name|yychar
operator|==
name|STRING
operator|)
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|)
operator|&&
operator|!
name|probe_obstack
argument_list|(
name|current_obstack
argument_list|,
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|probe_obstack
argument_list|(
name|saveable_obstack
argument_list|,
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|,
literal|2
argument_list|)
condition|)
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
operator|=
name|copy_node
argument_list|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if not, grab the next one and think about it */
name|tmp_token
operator|.
name|yychar
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|tmp_token
operator|.
name|yylval
operator|=
name|yylval
expr_stmt|;
name|tmp_token
operator|.
name|end_of_file
operator|=
name|end_of_file
expr_stmt|;
name|add_token
argument_list|(
operator|&
name|tmp_token
argument_list|)
expr_stmt|;
block|}
comment|/* many tokens just need to be returned. At first glance, all we      have to do is send them back up, but some of them are needed to      figure out local context.  */
switch|switch
condition|(
name|tmp_token
operator|.
name|yychar
condition|)
block|{
case|case
name|EMPTY
case|:
comment|/* This is a lexical no-op.  */
name|consume_token
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|tmp_token
operator|.
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|retry
goto|;
case|case
name|IDENTIFIER
case|:
name|scan_tokens
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|SCOPE
condition|)
block|{
comment|/* Don't interfere with the setting from an 'aggr' prefix.  */
name|old_looking_for_typename
operator|=
name|looking_for_typename
expr_stmt|;
name|looking_for_typename
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
literal|'<'
condition|)
name|looking_for_template
operator|=
literal|1
expr_stmt|;
name|trrr
operator|=
name|lookup_name
argument_list|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|trrr
condition|)
block|{
name|tmp_token
operator|.
name|yychar
operator|=
name|identifier_type
argument_list|(
name|trrr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tmp_token
operator|.
name|yychar
condition|)
block|{
case|case
name|TYPENAME
case|:
case|case
name|SELFNAME
case|:
case|case
name|NSNAME
case|:
case|case
name|PTYPENAME
case|:
name|lastiddecl
operator|=
name|trrr
expr_stmt|;
comment|/* If this got special lookup, remember it.  In these cases, 	         we don't have to worry about being a declarator-id. */
if|if
condition|(
name|got_scope
operator|||
name|got_object
condition|)
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
operator|=
name|trrr
expr_stmt|;
break|break;
case|case
name|PFUNCNAME
case|:
case|case
name|IDENTIFIER
case|:
name|lastiddecl
operator|=
name|trrr
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|101
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|lastiddecl
operator|=
name|NULL_TREE
expr_stmt|;
name|got_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* and fall through to...  */
case|case
name|IDENTIFIER_DEFN
case|:
case|case
name|TYPENAME
case|:
case|case
name|TYPENAME_DEFN
case|:
case|case
name|PTYPENAME
case|:
case|case
name|PTYPENAME_DEFN
case|:
name|consume_token
argument_list|()
expr_stmt|;
comment|/* If we see a SCOPE next, restore the old value. 	 Otherwise, we got what we want. */
name|looking_for_typename
operator|=
name|old_looking_for_typename
expr_stmt|;
name|looking_for_template
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCSPEC
case|:
comment|/* If export, warn that it's unimplemented and go on. */
if|if
condition|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
operator|==
name|get_identifier
argument_list|(
literal|"export"
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"keyword 'export' not implemented and will be ignored"
argument_list|)
expr_stmt|;
name|consume_token
argument_list|()
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
block|{
operator|++
name|first_token
expr_stmt|;
break|break;
block|}
case|case
name|NEW
case|:
comment|/* do_aggr needs to check if the previous token was RID_NEW, 	 so just increment first_token instead of calling consume_token.  */
operator|++
name|first_token
expr_stmt|;
break|break;
case|case
name|TYPESPEC
case|:
name|consume_token
argument_list|()
expr_stmt|;
break|break;
case|case
name|AGGR
case|:
operator|*
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|=
name|tmp_token
expr_stmt|;
name|do_aggr
argument_list|()
expr_stmt|;
comment|/* fall through to output...  */
case|case
name|ENUM
case|:
comment|/* Set this again, in case we are rescanning.  */
name|looking_for_typename
operator|=
literal|2
expr_stmt|;
comment|/* fall through...  */
default|default:
name|consume_token
argument_list|()
expr_stmt|;
block|}
comment|/* class member lookup only applies to the first token after the object      expression, except for explicit destructor calls.  */
if|if
condition|(
name|tmp_token
operator|.
name|yychar
operator|!=
literal|'~'
condition|)
name|got_object
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Clear looking_for_typename if we got 'enum { ... };'.  */
if|if
condition|(
name|tmp_token
operator|.
name|yychar
operator|==
literal|'{'
operator|||
name|tmp_token
operator|.
name|yychar
operator|==
literal|':'
operator|||
name|tmp_token
operator|.
name|yychar
operator|==
literal|';'
condition|)
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
name|yylval
operator|=
name|tmp_token
operator|.
name|yylval
expr_stmt|;
name|yychar
operator|=
name|tmp_token
operator|.
name|yychar
expr_stmt|;
name|end_of_file
operator|=
name|tmp_token
operator|.
name|end_of_file
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|yychar
return|;
block|}
end_function

begin_comment
comment|/* token[0] == AGGR (struct/union/enum)    Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.    If token[2] == '{' or ':' then it's TYPENAME_DEFN.    It's also a definition if it's a forward declaration (as in 'struct Foo;')    which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.  */
end_comment

begin_function
specifier|static
name|int
name|do_aggr
parameter_list|()
block|{
name|int
name|yc1
decl_stmt|,
name|yc2
decl_stmt|;
name|scan_tokens
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|yc1
operator|=
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|yc1
operator|!=
name|TYPENAME
operator|&&
name|yc1
operator|!=
name|IDENTIFIER
operator|&&
name|yc1
operator|!=
name|PTYPENAME
condition|)
return|return
literal|0
return|;
name|yc2
operator|=
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|yc2
operator|==
literal|';'
condition|)
block|{
comment|/* It's a forward declaration iff we were not preceded by          'friend' or `new'.  */
if|if
condition|(
name|first_token
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nth_token
argument_list|(
operator|-
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|SCSPEC
operator|&&
name|nth_token
argument_list|(
operator|-
literal|1
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nth_token
argument_list|(
operator|-
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|NEW
condition|)
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|yc2
operator|!=
literal|'{'
operator|&&
name|yc2
operator|!=
literal|':'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|yc1
condition|)
block|{
case|case
name|TYPENAME
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|TYPENAME_DEFN
expr_stmt|;
break|break;
case|case
name|PTYPENAME
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|PTYPENAME_DEFN
expr_stmt|;
break|break;
case|case
name|IDENTIFIER
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|IDENTIFIER_DEFN
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|102
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_comment
comment|/* debug_yychar takes a yychar (token number) value and prints its name.  */
end_comment

begin_function
specifier|static
name|int
name|debug_yychar
parameter_list|(
name|yy
parameter_list|)
name|int
name|yy
decl_stmt|;
block|{
comment|/* In parse.y: */
specifier|extern
name|char
modifier|*
name|debug_yytranslate
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|yy
operator|<
literal|256
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%d: %c>\n"
argument_list|,
name|yy
argument_list|,
name|yy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%d:%s>\n"
argument_list|,
name|yy
argument_list|,
name|debug_yytranslate
argument_list|(
name|yy
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

