begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-dependent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 88, 92, 93, 94, 1995 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language.    Lvalues can be assigned, unless they have TREE_READONLY.    Lvalues can have their address taken, unless they have DECL_REGISTER.  */
end_comment

begin_function
name|int
name|real_lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|language_lvalue_valid
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ref
operator|==
name|current_class_decl
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|/* preincrements and predecrements are valid lvals, provided 	 what they refer to are valid lvals. */
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|SAVE_EXPR
case|:
return|return
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
return|return
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* A currently unresolved scope ref.  */
case|case
name|SCOPE_REF
case|:
name|my_friendly_abort
argument_list|(
literal|103
argument_list|)
expr_stmt|;
case|case
name|OFFSET_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
return|return
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
literal|1
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
return|return
operator|(
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|language_lvalue_valid
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ref
operator|==
name|current_class_decl
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|/* preincrements and predecrements are valid lvals, provided 	 what they refer to are valid lvals. */
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|SAVE_EXPR
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
return|return
literal|1
return|;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
comment|/* A currently unresolved scope ref.  */
case|case
name|SCOPE_REF
case|:
name|my_friendly_abort
argument_list|(
literal|103
argument_list|)
expr_stmt|;
case|case
name|OFFSET_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
literal|1
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
return|return
operator|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|ref
parameter_list|,
name|string
parameter_list|)
name|tree
name|ref
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|error
argument_list|(
literal|"non-lvalue in %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* INIT is a CALL_EXPR which needs info about its target.    TYPE is the type that this initialization should appear to have.     Build an encapsulation of the initialization to perform    and return it so that it can be processed by language-independent    and language-specific expression expanders.     If WITH_CLEANUP_P is nonzero, we build a cleanup for this expression.    Otherwise, cleanups are not built here.  For example, when building    an initialization for a stack slot, since the called function handles    the cleanup, we would not want to do it here.  */
end_comment

begin_function
name|tree
name|build_cplus_new
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|with_cleanup_p
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|with_cleanup_p
decl_stmt|;
block|{
name|tree
name|slot
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|slot
operator|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|NEW_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|TARGET_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|if (with_cleanup_p&& TYPE_NEEDS_DESTRUCTOR (type))     {       TREE_OPERAND (rval, 2) = error_mark_node;       rval = build (WITH_CLEANUP_EXPR, type, rval, 0, 		    build_delete (build_pointer_type (type), 				  build_unary_op (ADDR_EXPR, slot, 0), 				  integer_two_node, 				  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0));       TREE_SIDE_EFFECTS (rval) = 1;       TREE_ADDRESSABLE (rval) = 1;     }
endif|#
directive|endif
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Recursively search EXP for CALL_EXPRs that need cleanups and replace    these CALL_EXPRs with tree nodes that will perform the cleanups.  */
end_comment

begin_function
name|tree
name|break_out_cleanups
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
return|return
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
return|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Recursively perform a preorder search EXP for CALL_EXPRs, making    copies where they are found.  Returns a deep copy all nodes transitively    containing CALL_EXPRs.  */
end_comment

begin_function
name|tree
name|break_out_calls
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
return|return
name|exp
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Don't try and defeat a save_expr, as it should only be done once. */
if|if
condition|(
name|code
operator|==
name|SAVE_EXPR
condition|)
return|return
name|exp
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'c'
case|:
comment|/* a constant */
case|case
literal|'t'
case|:
comment|/* a type node */
case|case
literal|'x'
case|:
comment|/* something random, like an identifier or an ERROR_MARK.  */
return|return
name|exp
return|;
case|case
literal|'d'
case|:
comment|/* A decl node */
if|#
directive|if
literal|0
comment|/* This is bogus.  jason 9/21/94 */
block|t1 = break_out_calls (DECL_INITIAL (exp));       if (t1 != DECL_INITIAL (exp)) 	{ 	  exp = copy_node (exp); 	  DECL_INITIAL (exp) = t1; 	}
endif|#
directive|endif
return|return
name|exp
return|;
case|case
literal|'b'
case|:
comment|/* A block node */
block|{
comment|/* Don't know how to handle these correctly yet.   Must do a 	   break_out_calls on all DECL_INITIAL values for local variables, 	   and also break_out_calls on all sub-blocks and sub-statements.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|exp
return|;
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
for|for
control|(
name|i
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|t1
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|exp
operator|=
name|copy_node
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
block|}
return|return
name|exp
return|;
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
name|t2
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
name|t1
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|1
condition|)
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t1
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|,
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is how primitive or already-canonicalized types' hash    codes are made.  MUST BE CONSISTENT WITH tree.c !!! */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH
parameter_list|(
name|TYPE
parameter_list|)
value|((HOST_WIDE_INT) (TYPE)& 0777777)
end_define

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments are described by ARGTYPES and whose values    are described by RETTYPE.  If each type exists already, reuse it.  */
end_comment

begin_function
name|tree
name|build_cplus_method_type
parameter_list|(
name|basetype
parameter_list|,
name|rettype
parameter_list|,
name|argtypes
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|rettype
decl_stmt|,
name|argtypes
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|tree
name|ptype
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rettype
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
condition|)
name|ptype
operator|=
name|build_signature_pointer_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_READONLY
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ptype
operator|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* The actual arglist for this function includes a "hidden" argument      which is "this".  Put it into the list of argument types.  */
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptype
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|argtypes
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|argtypes
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark first argtype as "artificial".  */
comment|/* If we already have such a type, use the old one and free this one.      Note that it also frees up the above cons cell if found.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|rettype
argument_list|)
operator|+
name|type_hash_list
argument_list|(
name|argtypes
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_cplus_staticfn_type
parameter_list|(
name|basetype
parameter_list|,
name|rettype
parameter_list|,
name|argtypes
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|rettype
decl_stmt|,
name|argtypes
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rettype
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|argtypes
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.      Note that it also frees up the above cons cell if found.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|rettype
argument_list|)
operator|+
name|type_hash_list
argument_list|(
name|argtypes
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_cplus_array_type
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* We need a new one.  If both ELT_TYPE and INDEX_TYPE are permanent,      make this permanent too.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|elt_type
argument_list|)
operator|&&
operator|(
name|index_type
operator|==
literal|0
operator|||
name|TREE_PERMANENT
argument_list|(
name|index_type
argument_list|)
operator|)
condition|)
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
name|t
operator|=
name|build_array_type
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* Push these needs up so that initialization takes place      more easily.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a variant type in the proper way for C/C++, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|cp_build_type_variant
parameter_list|(
name|type
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|real_main_variant
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|cp_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not, 	 make a copy.  (TYPE might have come from the hash table and 	 REAL_MAIN_VARIANT might be in some function's obstack.)  */
if|if
condition|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
condition|)
block|{
name|type
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_REFERENCE_TO
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|real_main_variant
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add OFFSET to all base types of T.     OFFSET, which is a type offset, is number of bytes.     Note that we don't have to worry about having two paths to the    same base type, since this type owns its association list.  */
end_comment

begin_function
name|void
name|propagate_binfo_offsets
parameter_list|(
name|binfo
parameter_list|,
name|offset
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
comment|/* note increment is done in the loop.  */
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|i
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|tree
name|base_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|delta
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_baselinks
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The next basetype offset must take into account the space 		   between the classes, not just the size of each class.  */
name|delta
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|if (BINFO_OFFSET_ZEROP (base_binfo)) 	    BINFO_OFFSET (base_binfo) = offset; 	  else 	    BINFO_OFFSET (base_binfo) 	      = size_binop (PLUS_EXPR, BINFO_OFFSET (base_binfo), offset);
else|#
directive|else
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|offset
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|base_binfos
condition|)
block|{
name|int
name|k
decl_stmt|;
name|tree
name|chain
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Now unshare the structure beneath BASE_BINFO.  */
for|for
control|(
name|k
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
name|tree
name|base_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_base_binfo
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|k
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|base_base_binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
block|}
comment|/* Now propagate the offset to the base types.  */
name|propagate_binfo_offsets
argument_list|(
name|base_binfo
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Go to our next class that counts for offset propagation.  */
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n_baselinks
condition|)
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the actual offsets that our virtual base classes    will have *for this type*.  This must be performed after    the fields are laid out, since virtual baseclasses must    lay down at the end of the record.     Returns the maximum number of virtual functions any of the virtual    baseclasses provide.  */
end_comment

begin_function
name|int
name|layout_vbasetypes
parameter_list|(
name|rec
parameter_list|,
name|max
parameter_list|)
name|tree
name|rec
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
comment|/* Get all the virtual base types that this type uses.      The TREE_VALUE slot holds the virtual baseclass type.  */
name|tree
name|vbase_types
init|=
name|get_vbase_types
argument_list|(
name|rec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|unsigned
name|record_align
init|=
name|MAX
argument_list|(
name|STRUCTURE_SIZE_BOUNDARY
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|unsigned
name|record_align
init|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|int
name|desired_align
decl_stmt|;
comment|/* Record size so far is CONST_SIZE + VAR_SIZE bits,      where CONST_SIZE is an integer      and VAR_SIZE is a tree expression.      If VAR_SIZE is null, the size is just CONST_SIZE.      Naturally we try to avoid using VAR_SIZE.  */
specifier|register
name|unsigned
name|const_size
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|var_size
init|=
literal|0
decl_stmt|;
name|int
name|nonvirtual_const_size
decl_stmt|;
name|tree
name|nonvirtual_var_size
decl_stmt|;
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|rec
argument_list|)
operator|=
name|vbase_types
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|const_size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|var_size
operator|=
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|nonvirtual_const_size
operator|=
name|const_size
expr_stmt|;
name|nonvirtual_var_size
operator|=
name|var_size
expr_stmt|;
while|while
condition|(
name|vbase_types
condition|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|vbase_types
argument_list|)
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|desired_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_size
operator|==
literal|0
condition|)
name|offset
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
comment|/* Give each virtual base type the alignment it wants.  */
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|*
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_int
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
operator|>
name|max
condition|)
name|max
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|vbase_types
argument_list|)
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Every virtual baseclass takes a least a UNIT, so that we can 	     take it's address and get something different for each base.  */
name|const_size
operator|+=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var_size
operator|==
literal|0
condition|)
name|var_size
operator|=
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|var_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_size
argument_list|,
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|const_size
condition|)
block|{
comment|/* Because a virtual base might take a single byte above, 	 we have to re-adjust the total size to make sure it it 	 a multiple of the alignment.  */
comment|/* Give the whole object the alignment it wants.  */
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|record_align
argument_list|)
operator|*
name|record_align
expr_stmt|;
block|}
comment|/* Set the alignment in the complete type.  We don't set CLASSTYPE_ALIGN    here, as that is for this class, without any virtual base classes.  */
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|record_align
expr_stmt|;
if|if
condition|(
name|const_size
operator|!=
name|nonvirtual_const_size
condition|)
block|{
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|size_int
argument_list|(
name|const_size
operator|-
name|nonvirtual_const_size
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|size_int
argument_list|(
name|const_size
argument_list|)
expr_stmt|;
block|}
comment|/* Now propagate offset information throughout the lattice      under the vbase type.  */
for|for
control|(
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|rec
argument_list|)
init|;
name|vbase_types
condition|;
name|vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase_types
argument_list|)
control|)
block|{
name|tree
name|base_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|vbase_types
argument_list|)
decl_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|vbase_types
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfos
condition|)
block|{
name|tree
name|chain
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Now unshare the structure beneath BASE_BINFO.  */
for|for
control|(
name|j
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|base_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_base_binfo
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|base_base_binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|=
name|vbase_types
expr_stmt|;
block|}
name|propagate_binfo_offsets
argument_list|(
name|vbase_types
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vbase_types
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|max
return|;
block|}
end_function

begin_comment
comment|/* Lay out the base types of a record type, REC.    Tentatively set the size and alignment of REC    according to the base types alone.     Offsets for immediate nonvirtual baseclasses are also computed here.     TYPE_BINFO (REC) should be NULL_TREE on entry, and this routine    creates a list of base_binfos in TYPE_BINFO (REC) from BINFOS.     Returns list of virtual base classes in a FIELD_DECL chain.  */
end_comment

begin_function
name|tree
name|layout_basetypes
parameter_list|(
name|rec
parameter_list|,
name|binfos
parameter_list|)
name|tree
name|rec
decl_stmt|,
name|binfos
decl_stmt|;
block|{
comment|/* Chain to hold all the new FIELD_DECLs which point at virtual      base classes.  */
name|tree
name|vbase_decls
init|=
name|NULL_TREE
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|unsigned
name|record_align
init|=
name|MAX
argument_list|(
name|STRUCTURE_SIZE_BOUNDARY
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|unsigned
name|record_align
init|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Record size so far is CONST_SIZE + VAR_SIZE bits, where CONST_SIZE is      an integer and VAR_SIZE is a tree expression.  If VAR_SIZE is null,      the size is just CONST_SIZE.  Naturally we try to avoid using      VAR_SIZE.  And so far, we've been successful. */
if|#
directive|if
literal|0
block|register tree var_size = 0;
endif|#
directive|endif
specifier|register
name|unsigned
name|const_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Handle basetypes almost like fields, but record their      offsets differently.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|inc
decl_stmt|,
name|desired_align
decl_stmt|,
name|int_vbase_size
decl_stmt|;
specifier|register
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This error is now reported in xref_tag, thus giving better 	     location information.  */
block|error_with_aggr_type (base_binfo, 				"base class `%s' has incomplete type");  	  TREE_VIA_PUBLIC (base_binfo) = 1; 	  TREE_VIA_PROTECTED (base_binfo) = 0; 	  TREE_VIA_VIRTUAL (base_binfo) = 0;
comment|/* Should handle this better so that  	     class A; 	     class B: private A { virtual void F(); };  	     does not dump core when compiled. */
block|my_friendly_abort (121);
endif|#
directive|endif
continue|continue;
block|}
comment|/* All basetypes are recorded in the association list of the 	 derived type.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* The offset for a virtual base class is only used in computing 	     virtual function tables and for initializing virtual base 	     pointers.  It is built once `get_vbase_types' is called.  */
comment|/* If this basetype can come from another vbase pointer 	     without an additional indirection, we will share 	     that pointer.  If an indirection is involved, we 	     make our own pointer.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
block|{
name|tree
name|other_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|other_base_binfo
argument_list|)
operator|&&
name|binfo_member
argument_list|(
name|basetype
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|other_base_binfo
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If you change any of the below, take a look at all the 	     other VFIELD_BASEs and VTABLE_BASEs in the code, and change 	     them too. */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VTABLE_BASE
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|rec
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|rec
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|vbase_decls
expr_stmt|;
name|BINFO_VPTR_FIELD
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|decl
expr_stmt|;
name|vbase_decls
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|warn_nonvdtor
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|warning_with_decl
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"destructor `%s' non-virtual"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"in inheritance relationship `%s: virtual %s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|rec
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|got_it
label|:
comment|/* The space this decl occupies has already been accounted for.  */
continue|continue;
block|}
if|if
condition|(
name|const_size
operator|==
literal|0
condition|)
name|offset
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
comment|/* Give each base type the alignment it wants.  */
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|*
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_int
argument_list|(
operator|(
name|const_size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* bpk: Disabled this check until someone is willing to 	     claim it as theirs and explain exactly what circumstances 	     warrant the warning.  */
block|if (warn_nonvdtor&& TYPE_HAS_DESTRUCTOR (basetype)&& DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0)) == NULL_TREE) 	    { 	      warning_with_decl (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0), 				 "destructor `%s' non-virtual"); 	      warning ("in inheritance relationship `%s:%s %s'", 		       TYPE_NAME_STRING (rec), 		       TREE_VIA_VIRTUAL (base_binfo) ? " virtual" : "", 		       TYPE_NAME_STRING (basetype)); 	    }
endif|#
directive|endif
block|}
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|BINFO_VTABLE
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|rec
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
comment|/* Add only the amount of storage not present in 	 the virtual baseclasses.  */
name|int_vbase_size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|>
name|int_vbase_size
condition|)
block|{
name|inc
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|-
name|int_vbase_size
operator|)
argument_list|)
expr_stmt|;
comment|/* Record must have at least as much alignment as any field.  */
name|desired_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
name|const_size
operator|+=
name|inc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|const_size
condition|)
name|CLASSTYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|size_int
argument_list|(
name|const_size
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|CLASSTYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|record_align
expr_stmt|;
return|return
name|vbase_decls
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hashing of lists so that we don't make duplicates.    The entry point is `list_hash_canon'.  */
end_comment

begin_comment
comment|/* Each hash table slot is a bucket containing a chain    of these structures.  */
end_comment

begin_struct
struct|struct
name|list_hash
block|{
name|struct
name|list_hash
modifier|*
name|next
decl_stmt|;
comment|/* Next structure in the bucket.  */
name|int
name|hashcode
decl_stmt|;
comment|/* Hash code of this list.  */
name|tree
name|list
decl_stmt|;
comment|/* The list recorded here.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Now here is the hash table.  When recording a list, it is added    to the slot whose index is the hash code mod the table size.    Note that the hash table is used for several kinds of lists.    While all these live in the same table, they are completely independent,    and the hash code is computed differently for each of these.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH_SIZE
value|59
end_define

begin_decl_stmt
name|struct
name|list_hash
modifier|*
name|list_hash_table
index|[
name|TYPE_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a hash code for a list (chain of TREE_LIST nodes    with goodies in the TREE_PURPOSE, TREE_VALUE, and bits of the    TREE_COMMON slots), by adding the hash codes of the individual entries.  */
end_comment

begin_function
name|int
name|list_hash
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1007
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1009
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to TYPE.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
name|tree
name|list_hash_lookup
parameter_list|(
name|hashcode
parameter_list|,
name|list
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_VIA_VIRTUAL
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_VIA_PUBLIC
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_VIA_PUBLIC
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_VIA_PROTECTED
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_VIA_PROTECTED
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
argument_list|,
literal|299
argument_list|)
expr_stmt|;
return|return
name|h
operator|->
name|list
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the list-hash-table    for a list TYPE whose hash code is HASHCODE.  */
end_comment

begin_function
name|void
name|list_hash_add
parameter_list|(
name|hashcode
parameter_list|,
name|list
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|list_hash
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|class_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|list_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|list
operator|=
name|list
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
expr_stmt|;
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given TYPE, and HASHCODE its hash code, return the canonical    object for an identical list if one already exists.    Otherwise, return TYPE, and record it as the canonical object    if it is a permanent object.     To use this function, first create a list of the sort you want.    Then compute its hash code from the fields of the list that    make it different from other similar lists.    Then call this function and use the value.    This function frees the list you pass in if it is a duplicate.  */
end_comment

begin_comment
comment|/* Set to 1 to debug without canonicalization.  Never set by program.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_no_list_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|list_hash_canon
parameter_list|(
name|hashcode
parameter_list|,
name|list
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|;
if|if
condition|(
name|debug_no_list_hash
condition|)
return|return
name|list
return|;
name|t1
operator|=
name|list_hash_lookup
argument_list|(
name|hashcode
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
comment|/* If this is a new list, record it for later reuse.  */
name|list_hash_add
argument_list|(
name|hashcode
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|tree
name|hash_tree_cons
parameter_list|(
name|via_public
parameter_list|,
name|via_virtual
parameter_list|,
name|via_protected
parameter_list|,
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|int
name|via_public
decl_stmt|,
name|via_virtual
decl_stmt|,
name|via_protected
decl_stmt|;
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
name|via_public
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|t
argument_list|)
operator|=
name|via_protected
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
operator|=
name|via_virtual
expr_stmt|;
name|hashcode
operator|=
name|list_hash
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|list_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Constructor for hashed lists.  */
end_comment

begin_function
name|tree
name|hash_tree_chain
parameter_list|(
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|list_hash
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|list_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar, but used for concatenating two lists.  */
end_comment

begin_function
name|tree
name|hash_chainon
parameter_list|(
name|list1
parameter_list|,
name|list2
parameter_list|)
name|tree
name|list1
decl_stmt|,
name|list2
decl_stmt|;
block|{
if|if
condition|(
name|list2
operator|==
literal|0
condition|)
return|return
name|list1
return|;
if|if
condition|(
name|list1
operator|==
literal|0
condition|)
return|return
name|list2
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
return|;
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|hash_chainon
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_identifier_list
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|list
init|=
name|IDENTIFIER_AS_LIST
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|!=
name|value
operator|)
condition|)
name|list
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|value
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|list
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|current_class_type
condition|)
comment|/* Don't mess up the constructor name.  */
name|list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|tree
name|id
decl_stmt|;
comment|/* This will return the correct thing for regular types, 	     nested types, and templates.  Yay! */
if|if
condition|(
name|TYPE_NESTED_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|id
operator|=
name|TYPE_NESTED_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_ID_AS_LIST
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_ID_AS_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|list
operator|=
name|CLASSTYPE_ID_AS_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_function
name|tree
name|get_decl_list
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|list
operator|=
name|get_identifier_list
argument_list|(
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|value
argument_list|)
condition|)
name|list
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|301
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
return|return
name|build_decl_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to    `build_tree_list (NULL_TREE, VALUE)'.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
name|tree
name|list_hash_lookup_or_cons
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
specifier|register
name|int
name|hashcode
init|=
name|TYPE_HASH
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ambient_obstack
decl_stmt|;
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|list
operator|=
name|get_identifier_list
argument_list|(
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|list
operator|=
name|CLASSTYPE_ID_AS_LIST
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|value
argument_list|)
condition|)
name|list
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|302
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
if|if
condition|(
name|debug_no_list_hash
condition|)
return|return
name|hash_tree_chain
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|)
return|;
for|for
control|(
name|h
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_VIA_PUBLIC
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_VIA_PROTECTED
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PURPOSE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|value
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
argument_list|,
literal|303
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
argument_list|,
literal|304
argument_list|)
expr_stmt|;
return|return
name|h
operator|->
name|list
return|;
block|}
name|ambient_obstack
operator|=
name|current_obstack
expr_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|list_hash_add
argument_list|(
name|hashcode
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an association between TYPE and some parameters:     OFFSET is the offset added to `this' to convert it to a pointer    of type `TYPE *'     BINFO is the base binfo to use, if we are deriving from one.  This    is necessary, as we want specialized parent binfos from base    classes, so that the VTABLE_NAMEs of bases are for the most derived    type, instead of of the simple type.     VTABLE is the virtual function table with which to initialize    sub-objects of type TYPE.     VIRTUALS are the virtual functions sitting in VTABLE.     CHAIN are more associations we must retain.  */
end_comment

begin_function
name|tree
name|make_binfo
parameter_list|(
name|offset
parameter_list|,
name|binfo
parameter_list|,
name|vtable
parameter_list|,
name|virtuals
parameter_list|,
name|chain
parameter_list|)
name|tree
name|offset
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|vtable
decl_stmt|,
name|virtuals
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|new_binfo
init|=
name|make_tree_vec
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|TREE_USED
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|offset
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|vtable
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|BINFO_VPTR_FIELD
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|binfo
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|BINFO_BASETYPES
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|copy_node
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_binfo
return|;
block|}
end_function

begin_comment
comment|/* Return the binfo value for ELEM in TYPE.  */
end_comment

begin_function
name|tree
name|binfo_value
parameter_list|(
name|elem
parameter_list|,
name|type
parameter_list|)
name|tree
name|elem
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|get_base_distance
argument_list|(
name|elem
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|2
condition|)
name|compiler_error
argument_list|(
literal|"base class `%s' ambiguous in binfo_value"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|type
condition|)
return|return
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elem
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_BINFO
argument_list|(
name|elem
argument_list|)
operator|==
name|type
condition|)
return|return
name|type
return|;
return|return
name|get_binfo
argument_list|(
name|elem
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|reverse_path
parameter_list|(
name|path
parameter_list|)
name|tree
name|path
decl_stmt|;
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|tmp
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|path
init|;
name|tmp
condition|;
name|tmp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_function
name|tree
name|virtual_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|nval
decl_stmt|;
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|elem
operator|==
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|rval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|binfos
operator|!=
name|NULL_TREE
condition|)
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|nval
operator|=
name|binfo_value
argument_list|(
name|elem
argument_list|,
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
condition|)
block|{
if|if
condition|(
name|rval
operator|&&
name|BINFO_OFFSET
argument_list|(
name|nval
argument_list|)
operator|!=
name|BINFO_OFFSET
argument_list|(
name|rval
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|104
argument_list|)
expr_stmt|;
name|rval
operator|=
name|nval
expr_stmt|;
block|}
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_function
name|void
name|debug_binfo
parameter_list|(
name|elem
parameter_list|)
name|tree
name|elem
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type \"%s\"; offset = %d\n"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable type:\n"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|elem
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable decl \"%s\"\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no vtable decl yet\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"virtuals:\n"
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [%d =? %d]\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|n
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the length of a chain of nodes chained through DECL_CHAIN.    We expect a null pointer to mark the end of the chain.    This is the Lisp primitive `length'.  */
end_comment

begin_function
name|int
name|decl_list_length
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|300
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|t
init|;
name|tail
condition|;
name|tail
operator|=
name|DECL_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|len
operator|++
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
name|int
name|count_functions
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
name|decl_list_length
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
name|my_friendly_abort
argument_list|(
literal|359
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like value_member, but for DECL_CHAINs.  */
end_comment

begin_function
name|tree
name|decl_value_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|list
condition|)
return|return
name|list
return|;
name|list
operator|=
name|DECL_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|int
name|is_overloaded_fn
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|really_overloaded_fn
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|get_first_fn
parameter_list|(
name|from
parameter_list|)
name|tree
name|from
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|from
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|from
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|fnaddr_from_vtable_entry
parameter_list|(
name|entry
parameter_list|)
name|tree
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
name|tree
name|func
init|=
name|entry
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|func
operator|=
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|==
name|THUNK_DECL
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|func
argument_list|)
return|;
else|else
return|return
name|entry
return|;
block|}
else|else
return|return
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|set_fnaddr_from_vtable_entry
parameter_list|(
name|entry
parameter_list|,
name|value
parameter_list|)
name|tree
name|entry
decl_stmt|,
name|value
decl_stmt|;
block|{
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|function_arg_chain
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|promotes_to_aggr_type
parameter_list|(
name|t
parameter_list|,
name|code
parameter_list|)
name|tree
name|t
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|code
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|is_aggr_type_2
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Give message using types TYPE1 and TYPE2 as arguments.    PFN is the function which will print the message;    S is the format string for PFN to use.  */
end_comment

begin_decl_stmt
name|void
name|message_2_types
argument_list|(
name|pfn
argument_list|,
name|s
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
name|void
argument_list|(
operator|*
name|pfn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|name1
init|=
name|TYPE_NAME
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|tree
name|name2
init|=
name|TYPE_NAME
argument_list|(
name|type2
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name1
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name1
operator|=
name|DECL_NAME
argument_list|(
name|name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name2
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name2
operator|=
name|DECL_NAME
argument_list|(
name|name2
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pfn
call|)
argument_list|(
name|s
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name1
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_define
define|#
directive|define
name|PRINT_RING_SIZE
value|4
end_define

begin_function
name|char
modifier|*
name|lang_printable_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|static
name|tree
name|decl_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|print_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|int
name|ring_counter
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Only cache functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|decl_as_string
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
return|;
comment|/* See if this print name is lying around.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PRINT_RING_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|decl_ring
index|[
name|i
index|]
operator|==
name|decl
condition|)
comment|/* yes, so return it.  */
return|return
name|print_ring
index|[
name|i
index|]
return|;
if|if
condition|(
operator|++
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|ring_counter
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|my_friendly_abort
argument_list|(
literal|106
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_ring
index|[
name|ring_counter
index|]
condition|)
name|free
argument_list|(
name|print_ring
index|[
name|ring_counter
index|]
argument_list|)
expr_stmt|;
block|{
name|int
name|print_ret_type_p
init|=
operator|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|decl_as_string
argument_list|(
name|decl
argument_list|,
name|print_ret_type_p
argument_list|)
decl_stmt|;
name|print_ring
index|[
name|ring_counter
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|print_ring
index|[
name|ring_counter
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|decl_ring
index|[
name|ring_counter
index|]
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|print_ring
index|[
name|ring_counter
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Comparison function for sorting identifiers in RAISES lists.    Note that because IDENTIFIER_NODEs are unique, we can sort    them by address, saving an indirection.  */
end_comment

begin_function
specifier|static
name|int
name|id_cmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|tree
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_VALUE
argument_list|(
operator|*
name|p1
argument_list|)
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_VALUE
argument_list|(
operator|*
name|p2
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions    listed in RAISES.  */
end_comment

begin_function
name|tree
name|build_exception_variant
parameter_list|(
name|type
parameter_list|,
name|raises
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|v
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|cname
decl_stmt|;
name|tree
modifier|*
name|a
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|list_length
argument_list|(
name|raises
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
control|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|v
argument_list|)
operator|!=
name|constp
operator|||
name|TYPE_VOLATILE
argument_list|(
name|v
argument_list|)
operator|!=
name|volatilep
condition|)
continue|continue;
comment|/* @@ This should do set equality, not exact match. */
if|if
condition|(
name|simple_cst_list_equal
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
argument_list|,
name|raises
argument_list|)
condition|)
comment|/* List of exceptions raised matches previously found list.  	   @@ Nice to free up storage used in consing up the 	   @@ list of exceptions raised.  */
return|return
name|v
return|;
block|}
comment|/* Need to build a new variant.  */
name|v
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|raises
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|raises
argument_list|)
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|raises
operator|=
name|copy_list
argument_list|(
name|raises
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
operator|=
name|raises
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of copy_to_permanent     Assuming T is a node build bottom-up, make it all exist on    permanent obstack, if it is not permanent already.  */
end_comment

begin_decl_stmt
name|tree
name|mapcar
argument_list|(
name|t
argument_list|,
name|func
argument_list|)
name|tree
name|t
decl_stmt|;
end_decl_stmt

begin_function_decl
name|tree
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|t
return|;
if|if
condition|(
name|tmp
operator|=
name|func
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
operator|!=
name|NULL_TREE
condition|)
return|return
name|tmp
return|;
switch|switch
condition|(
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|CONST_DECL
case|:
break|break;
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|chain
init|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|chain
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|chain
init|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|chain
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|TREE_VEC
case|:
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|len
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|len
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|copy_node
argument_list|(
name|t
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|NEW_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|SAVE_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|CALL_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|POINTER_TYPE
case|:
return|return
name|build_pointer_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|build_reference_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
return|return
name|build_function_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
name|build_array_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
return|return
name|build_index_type
argument_list|(
name|mapcar
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
return|return
name|build_offset_type
argument_list|(
name|mapcar
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
return|return
name|build_method_type
argument_list|(
name|mapcar
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|build_ptrmemfunc_type
argument_list|(
name|mapcar
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
comment|/* else fall through */
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' does not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|sorry
argument_list|(
literal|"initializer contains unrecognized tree code"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|107
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_block

begin_function
specifier|static
name|tree
name|perm_manip
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Assuming T is a node built bottom-up, make it all exist on    permanent obstack, if it is not permanent already.  */
end_comment

begin_function
name|tree
name|copy_to_permanent
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
name|int
name|resume
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|current_obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|resume
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|mapcar
argument_list|(
name|t
argument_list|,
name|perm_manip
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|resume
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|print_lang_statistics
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|maybepermanent_obstack
decl_stmt|;
name|print_obstack_statistics
argument_list|(
literal|"class_obstack"
argument_list|,
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
name|print_obstack_statistics
argument_list|(
literal|"permanent_obstack"
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|print_obstack_statistics
argument_list|(
literal|"maybepermanent_obstack"
argument_list|,
operator|&
name|maybepermanent_obstack
argument_list|)
expr_stmt|;
name|print_search_statistics
argument_list|()
expr_stmt|;
name|print_class_statistics
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is used by the `assert' macro.  It is provided in libgcc.a,    which `cc' doesn't know how to link.  Note that the C++ front-end    no longer actually uses the `assert' macro (instead, it calls    my_friendly_assert).  But all of the back-end files still need this.  */
end_comment

begin_function
name|void
name|__eprintf
parameter_list|(
name|string
parameter_list|,
name|expression
parameter_list|,
name|line
parameter_list|,
name|filename
parameter_list|)
ifdef|#
directive|ifdef
name|__STDC__
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|expression
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|expression
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|expression
argument_list|,
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for    TYPE (which is an ARRAY_TYPE).  This counts only elements of the top array. */
end_comment

begin_function
name|tree
name|array_type_nelts_top
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for    TYPE (which is an ARRAY_TYPE).  This one is a recursive count of all    ARRAY_TYPEs that are clumped together. */
end_comment

begin_function
name|tree
name|array_type_nelts_total
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|sz
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|n
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|sz
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|sz
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|bot_manip
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
return|return
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|break_out_target_exprs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Actually, we'll just clean out the target exprs for the moment.  */
end_comment

begin_function
name|tree
name|break_out_target_exprs
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|mapcar
argument_list|(
name|t
argument_list|,
name|bot_manip
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|unsave_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|UNSAVE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Modify a tree in place so that all the evaluate only once things    are cleared out.  Return the EXPR given.  */
end_comment

begin_function
name|tree
name|unsave_expr_now
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|expr
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
name|SAVE_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|sorry
argument_list|(
literal|"TARGET_EXPR reused inside UNSAVE_EXPR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RTL_EXPR
case|:
name|warning
argument_list|(
literal|"RTL_EXPR reused inside UNSAVE_EXPR"
argument_list|)
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|CALL_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|exp
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|exp
condition|)
block|{
name|unsave_expr_now
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|warning
argument_list|(
literal|"WITH_CLEANUP_EXPR reused inside UNSAVE_EXPR"
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* a constant */
case|case
literal|'t'
case|:
comment|/* a type node */
case|case
literal|'x'
case|:
comment|/* something random, like an identifier or an ERROR_MARK.  */
case|case
literal|'d'
case|:
comment|/* A decl node */
case|case
literal|'b'
case|:
comment|/* A block node */
return|return
name|expr
return|;
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
for|for
control|(
name|i
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|unsave_expr_now
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|999
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Since cleanup may have SAVE_EXPRs in it, we protect it with an    UNSAVE_EXPR as the backend cannot yet handle SAVE_EXPRs in cleanups    by itself.  */
end_comment

begin_function
name|int
name|cp_expand_decl_cleanup
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|;
block|{
return|return
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|unsave_expr
argument_list|(
name|cleanup
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

