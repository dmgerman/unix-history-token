begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-dependent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_function_decl
specifier|static
name|tree
name|bot_manip
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|bot_replace
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_cplus_array_type_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|list_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|list_hash_pieces
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|list_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_lvalue_kind
name|lvalue_p_1
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|no_linkage_helper
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mark_local_for_remap_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_unsave_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_target_expr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|count_trees_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|verify_stmt_tree_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_tree_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_local_temp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_java_interface_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_com_interface_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_init_priority_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If REF is an lvalue, returns the kind of lvalue that REF is.    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is    nonzero, rvalues of class type are considered lvalues.  */
end_comment

begin_function
specifier|static
name|cp_lvalue_kind
name|lvalue_p_1
parameter_list|(
name|tree
name|ref
parameter_list|,
name|int
name|treat_class_rvalues_as_lvalues
parameter_list|)
block|{
name|cp_lvalue_kind
name|op1_lvalue_kind
init|=
name|clk_none
decl_stmt|;
name|cp_lvalue_kind
name|op2_lvalue_kind
init|=
name|clk_none
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|clk_ordinary
return|;
if|if
condition|(
name|ref
operator|==
name|current_class_ptr
condition|)
return|return
name|clk_none
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|/* preincrements and predecrements are valid lvals, provided 	 what they refer to are valid lvals.  */
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|UNSAVE_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
name|op1_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
comment|/* In an expression of the form "X.Y", the packed-ness of the 	 expression does not depend on "X".  */
name|op1_lvalue_kind
operator|&=
operator|~
name|clk_packed
expr_stmt|;
comment|/* Look at the member designator.  */
if|if
condition|(
operator|!
name|op1_lvalue_kind
comment|/* The "field" can be a FUNCTION_DECL or an OVERLOAD in some	   	     situations.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Clear the ordinary bit.  If this object was a class 	     rvalue we want to preserve that information.  */
name|op1_lvalue_kind
operator|&=
operator|~
name|clk_ordinary
expr_stmt|;
comment|/* The lvalue is for a bitfield.  */
name|op1_lvalue_kind
operator||=
name|clk_bitfield
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_PACKED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|op1_lvalue_kind
operator||=
name|clk_packed
expr_stmt|;
return|return
name|op1_lvalue_kind
return|;
case|case
name|STRING_CST
case|:
return|return
name|clk_ordinary
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
name|clk_none
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
name|clk_ordinary
return|;
break|break;
comment|/* A currently unresolved scope ref.  */
case|case
name|SCOPE_REF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
name|op1_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
name|op2_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|op1_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
name|op2_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
return|return
name|clk_ordinary
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
return|return
name|treat_class_rvalues_as_lvalues
condition|?
name|clk_class
else|:
name|clk_none
return|;
case|case
name|CALL_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
comment|/* Any class-valued call would be wrapped in a TARGET_EXPR.  */
return|return
name|clk_none
return|;
case|case
name|FUNCTION_DECL
case|:
comment|/* All functions (except non-static-member functions) are 	 lvalues.  */
return|return
operator|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|ref
argument_list|)
condition|?
name|clk_none
else|:
name|clk_ordinary
operator|)
return|;
case|case
name|NON_DEPENDENT_EXPR
case|:
comment|/* We must consider NON_DEPENDENT_EXPRs to be lvalues so that 	 things like "&E" where "E" is an expression with a 	 non-dependent type work. It is safe to be lenient because an 	 error will be issued when the template is instantiated if "E" 	 is not an lvalue.  */
return|return
name|clk_ordinary
return|;
default|default:
break|break;
block|}
comment|/* If one operand is not an lvalue at all, then this expression is      not an lvalue.  */
if|if
condition|(
operator|!
name|op1_lvalue_kind
operator|||
operator|!
name|op2_lvalue_kind
condition|)
return|return
name|clk_none
return|;
comment|/* Otherwise, it's an lvalue, and it has all the odd properties      contributed by either operand.  */
name|op1_lvalue_kind
operator|=
name|op1_lvalue_kind
operator||
name|op2_lvalue_kind
expr_stmt|;
comment|/* It's not an ordinary lvalue if it involves either a bit-field or      a class rvalue.  */
if|if
condition|(
operator|(
name|op1_lvalue_kind
operator|&
operator|~
name|clk_ordinary
operator|)
operator|!=
name|clk_none
condition|)
name|op1_lvalue_kind
operator|&=
operator|~
name|clk_ordinary
expr_stmt|;
return|return
name|op1_lvalue_kind
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of lvalue that REF is, in the sense of    [basic.lval].  This function should really be named lvalue_p; it    computes the C++ definition of lvalue.  */
end_comment

begin_function
name|cp_lvalue_kind
name|real_lvalue_p
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
return|return
name|lvalue_p_1
argument_list|(
name|ref
argument_list|,
comment|/*treat_class_rvalues_as_lvalues=*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This differs from real_lvalue_p in that class rvalues are    considered lvalues.  */
end_comment

begin_function
name|int
name|lvalue_p
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
return|return
operator|(
name|lvalue_p_1
argument_list|(
name|ref
argument_list|,
comment|/*class rvalue ok*/
literal|1
argument_list|)
operator|!=
name|clk_none
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|tree
name|ref
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-lvalue in %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_target_expr
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build
argument_list|(
name|TARGET_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|value
argument_list|,
name|cxx_maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We always set TREE_SIDE_EFFECTS so that expand_expr does not      ignore the TARGET_EXPR.  If there really turn out to be no      side-effects, then the optimizer should be able to get rid of      whatever code is generated anyhow.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return an undeclared local temporary of type TYPE for use in building a    TARGET_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|build_local_temp
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|slot
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|slot
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|layout_decl
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|slot
return|;
block|}
end_function

begin_comment
comment|/* INIT is a CALL_EXPR which needs info about its target.    TYPE is the type that this initialization should appear to have.     Build an encapsulation of the initialization to perform    and return it so that it can be processed by language-independent    and language-specific expression expanders.  */
end_comment

begin_function
name|tree
name|build_cplus_new
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|slot
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|int
name|is_ctor
decl_stmt|;
comment|/* Make sure that we're not trying to create an instance of an      abstract class.  */
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|AGGR_INIT_EXPR
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
return|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|is_ctor
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|slot
operator|=
name|build_local_temp
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We split the CALL_EXPR into its function and its arguments here.      Then, in expand_expr, we put them back together.  The reason for      this is that this expression might be a default argument      expression.  In that case, we need a new temporary every time the      expression is used.  That's what break_out_target_exprs does; it      replaces every AGGR_INIT_EXPR with a copy that uses a fresh      temporary slot.  Then, expand_expr builds up a call-expression      using the new slot.  */
comment|/* If we don't need to use a constructor to create an object of this      type, don't mess with AGGR_INIT_EXPR.  */
if|if
condition|(
name|is_ctor
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|rval
operator|=
name|build
argument_list|(
name|AGGR_INIT_EXPR
argument_list|,
name|type
argument_list|,
name|fn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|rval
argument_list|)
operator|=
name|is_ctor
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|init
expr_stmt|;
name|rval
operator|=
name|build_target_expr
argument_list|(
name|slot
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Build a TARGET_EXPR using INIT to initialize a new temporary of the    indicated TYPE.  */
end_comment

begin_function
name|tree
name|build_target_expr_with_type
parameter_list|(
name|tree
name|init
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|slot
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
return|return
name|init
return|;
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|VA_ARG_EXPR
condition|)
comment|/* We need to build up a copy constructor call.  COND_EXPR is a special        case because we already have copies on the arms and we don't want        another one here.  A CONSTRUCTOR is aggregate initialization, which        is handled separately.  A VA_ARG_EXPR is magic creation of an        aggregate; there's no additional work to be done.  */
return|return
name|force_rvalue
argument_list|(
name|init
argument_list|)
return|;
name|slot
operator|=
name|build_local_temp
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|build_target_expr
argument_list|(
name|slot
argument_list|,
name|init
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like the above function, but without the checking.  This function should    only be used by code which is deliberately trying to subvert the type    system, such as call_builtin_trap.  */
end_comment

begin_function
name|tree
name|force_target_expr
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|slot
init|=
name|build_local_temp
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|build_target_expr
argument_list|(
name|slot
argument_list|,
name|init
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like build_target_expr_with_type, but use the type of INIT.  */
end_comment

begin_function
name|tree
name|get_target_expr
parameter_list|(
name|tree
name|init
parameter_list|)
block|{
return|return
name|build_target_expr_with_type
argument_list|(
name|init
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|build_cplus_array_type_1
parameter_list|(
name|tree
name|elt_type
parameter_list|,
name|tree
name|index_type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|elt_type
operator|==
name|error_mark_node
operator|||
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|elt_type
argument_list|)
operator|||
operator|(
name|index_type
operator|&&
name|value_dependent_expression_p
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|elt_type
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|=
name|index_type
expr_stmt|;
block|}
else|else
name|t
operator|=
name|build_array_type
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* Push these needs up so that initialization takes place      more easily.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_cplus_array_type
parameter_list|(
name|tree
name|elt_type
parameter_list|,
name|tree
name|index_type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|type_quals
init|=
name|cp_type_quals
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|elt_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|elt_type
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_cplus_array_type_1
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|t
operator|=
name|cp_build_qualified_type
argument_list|(
name|t
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles    arrays correctly.  In particular, if TYPE is an array of T's, and    TYPE_QUALS is non-empty, returns an array of qualified T's.       FLAGS determines how to deal with illformed qualifications. If    tf_ignore_bad_quals is set, then bad qualifications are dropped    (this is permitted if TYPE was introduced via a typedef or template    type parameter). If bad qualifications are dropped and tf_warning    is set, then a warning is issued for non-const qualifications.  If    tf_ignore_bad_quals is not set and tf_error is not set, we    return error_mark_node. Otherwise, we issue an error, and ignore    the qualifications.     Qualification of a reference type is valid when the reference came    via a typedef or template type argument. [dcl.ref] No such    dispensation is provided for qualifying a function type.  [dcl.fct]    DR 295 queries this and the proposed resolution brings it into line    with qualifying a reference.  We implement the DR.  We also behave    in a similar manner for restricting non-pointer types.  */
end_comment

begin_function
name|tree
name|cp_build_qualified_type_real
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|type_quals
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|int
name|bad_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|type
return|;
if|if
condition|(
name|type_quals
operator|==
name|cp_type_quals
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* In C++, the qualification really applies to the array element 	 type.  Obtain the appropriately qualified element type.  */
name|tree
name|t
decl_stmt|;
name|tree
name|element_type
init|=
name|cp_build_qualified_type_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|element_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* See if we already have an identically qualified type.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|cp_type_quals
argument_list|(
name|t
argument_list|)
operator|==
name|type_quals
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|t
condition|)
block|{
comment|/* Make a new array type, just like the old one, but with the 	     appropriately qualified element type.  */
name|t
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|element_type
expr_stmt|;
block|}
comment|/* Even if we already had this variant, we update 	 TYPE_NEEDS_CONSTRUCTING and TYPE_HAS_NONTRIVIAL_DESTRUCTOR in case 	 they changed since the variant was originally created.   	  	 This seems hokey; if there is some way to use a previous 	 variant *without* coming through here, 	 TYPE_NEEDS_CONSTRUCTING will never be updated.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|element_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|element_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* For a pointer-to-member type, we can't just return a 	 cv-qualified version of the RECORD_TYPE.  If we do, we 	 haven't changed the field that contains the actual pointer to 	 a method, and so TYPE_PTRMEMFUNC_FN_TYPE will be wrong.  */
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|t
argument_list|,
name|type_quals
argument_list|,
name|complain
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc_type
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* A reference, function or method type shall not be cv qualified.      [dcl.ref], [dct.fct]  */
if|if
condition|(
name|type_quals
operator|&
operator|(
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
block|{
name|bad_quals
operator||=
name|type_quals
operator|&
operator|(
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator|)
expr_stmt|;
name|type_quals
operator|&=
operator|~
operator|(
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator|)
expr_stmt|;
block|}
comment|/* A restrict-qualified type must be a pointer (or reference)      to object or incomplete type.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|bad_quals
operator||=
name|TYPE_QUAL_RESTRICT
expr_stmt|;
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_RESTRICT
expr_stmt|;
block|}
if|if
condition|(
name|bad_quals
operator|==
name|TYPE_UNQUALIFIED
condition|)
comment|/*OK*/
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|complain
operator|&
operator|(
name|tf_error
operator||
name|tf_ignore_bad_quals
operator|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
else|else
block|{
if|if
condition|(
name|complain
operator|&
name|tf_ignore_bad_quals
condition|)
comment|/* We're not going to warn about constifying things that can't  	   be constified.  */
name|bad_quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
if|if
condition|(
name|bad_quals
condition|)
block|{
name|tree
name|bad_type
init|=
name|build_qualified_type
argument_list|(
name|ptr_type_node
argument_list|,
name|bad_quals
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|complain
operator|&
name|tf_ignore_bad_quals
operator|)
condition|)
name|error
argument_list|(
literal|"`%V' qualifiers cannot be applied to `%T'"
argument_list|,
name|bad_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Retrieve (or create) the appropriately qualified variant.  */
name|result
operator|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
comment|/* If this was a pointer-to-method type, and we just made a copy,      then we need to unshare the record that holds the cached      pointer-to-member-function type, because these will be distinct      between the unqualified and qualified types.  */
if|if
condition|(
name|result
operator|!=
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|TYPE_LANG_SPECIFIC
argument_list|(
name|result
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns the canonical version of TYPE.  In other words, if TYPE is    a typedef, returns the underlying type.  The cv-qualification of    the type returned matches the type input; they will always be    compatible types.  */
end_comment

begin_function
name|tree
name|canonical_type_variant
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|cp_build_qualified_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Makes new binfos for the indirect bases under BINFO. T is the most    derived TYPE. PREV is the previous binfo, whose TREE_CHAIN we make    point to this binfo. We return the last BINFO created.     The CLASSTYPE_VBASECLASSES list of T is constructed in reverse    order (pre-order, depth-first, right-to-left). You must nreverse it.     The BINFO_INHERITANCE of a virtual base class points to the binfo    og the most derived type.     The binfo's TREE_CHAIN is set to inheritance graph order, but bases    for non-class types are not included (i.e. those which are    dependent bases in non-instantiated templates).  */
end_comment

begin_function
name|tree
name|copy_base_binfos
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
name|prev
parameter_list|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ix
decl_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|prev
operator|=
name|binfo
expr_stmt|;
if|if
condition|(
name|binfos
operator|==
name|NULL_TREE
condition|)
return|return
name|prev
return|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
expr_stmt|;
comment|/* Now copy the structure beneath BINFO.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|n
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|tree
name|new_binfo
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|20030204
argument_list|)
expr_stmt|;
name|new_binfo
operator|=
name|base_binfo
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|new_binfo
expr_stmt|;
name|prev
operator|=
name|new_binfo
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|new_binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|new_binfo
operator|=
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_binfo
condition|)
name|new_binfo
operator|=
name|TREE_VALUE
argument_list|(
name|new_binfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new_binfo
condition|)
block|{
name|new_binfo
operator|=
name|make_binfo
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|base_binfo
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|copy_base_binfos
argument_list|(
name|new_binfo
argument_list|,
name|t
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|BINFO_TYPE
argument_list|(
name|new_binfo
argument_list|)
argument_list|,
name|new_binfo
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|new_binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|ix
argument_list|)
operator|=
name|new_binfo
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hashing of lists so that we don't make duplicates.    The entry point is `list_hash_canon'.  */
end_comment

begin_comment
comment|/* Now here is the hash table.  When recording a list, it is added    to the slot whose index is the hash code mod the table size.    Note that the hash table is used for several kinds of lists.    While all these live in the same table, they are completely independent,    and the hash code is computed differently for each of these.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (union tree_node))
argument_list|)
name|htab_t
name|list_hash_table
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|list_proxy
block|{
name|tree
name|purpose
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compare ENTRY (an entry in the hash table) with DATA (a list_proxy    for a node we are thinking about adding).  */
end_comment

begin_function
specifier|static
name|int
name|list_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|entry
decl_stmt|;
name|struct
name|list_proxy
modifier|*
name|proxy
init|=
operator|(
expr|struct
name|list_proxy
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|proxy
operator|->
name|value
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|proxy
operator|->
name|purpose
operator|&&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|proxy
operator|->
name|chain
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a list (chain of TREE_LIST nodes    with goodies in the TREE_PURPOSE, TREE_VALUE, and bits of the    TREE_COMMON slots), by adding the hash codes of the individual entries.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|list_hash_pieces
parameter_list|(
name|tree
name|purpose
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|chain
parameter_list|)
block|{
name|hashval_t
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chain
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1007
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1009
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Hash an already existing TREE_LIST.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|list_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|p
decl_stmt|;
return|return
name|list_hash_pieces
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given list components PURPOSE, VALUE, AND CHAIN, return the canonical    object for an identical list if one already exists.  Otherwise, build a    new one, and record it as the canonical object.  */
end_comment

begin_function
name|tree
name|hash_tree_cons
parameter_list|(
name|tree
name|purpose
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|chain
parameter_list|)
block|{
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|list_proxy
name|proxy
decl_stmt|;
comment|/* Hash the list node.  */
name|hashcode
operator|=
name|list_hash_pieces
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* Create a proxy for the TREE_LIST we would like to create.  We      don't actually create it so as to avoid creating garbage.  */
name|proxy
operator|.
name|purpose
operator|=
name|purpose
expr_stmt|;
name|proxy
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|proxy
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
comment|/* See if it is already in the table.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|list_hash_table
argument_list|,
operator|&
name|proxy
argument_list|,
name|hashcode
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If not, create a new node.  */
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
operator|*
name|slot
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Constructor for hashed lists.  */
end_comment

begin_function
name|tree
name|hash_tree_chain
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|chain
parameter_list|)
block|{
return|return
name|hash_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but used for concatenating two lists.  */
end_comment

begin_function
name|tree
name|hash_chainon
parameter_list|(
name|tree
name|list1
parameter_list|,
name|tree
name|list2
parameter_list|)
block|{
if|if
condition|(
name|list2
operator|==
literal|0
condition|)
return|return
name|list1
return|;
if|if
condition|(
name|list1
operator|==
literal|0
condition|)
return|return
name|list2
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
return|;
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|hash_chainon
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an association between TYPE and some parameters:     OFFSET is the offset added to `this' to convert it to a pointer    of type `TYPE *'     BINFO is the base binfo to use, if we are deriving from one.  This    is necessary, as we want specialized parent binfos from base    classes, so that the VTABLE_NAMEs of bases are for the most derived    type, instead of the simple type.     VTABLE is the virtual function table with which to initialize    sub-objects of type TYPE.     VIRTUALS are the virtual functions sitting in VTABLE.  */
end_comment

begin_function
name|tree
name|make_binfo
parameter_list|(
name|tree
name|offset
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|tree
name|vtable
parameter_list|,
name|tree
name|virtuals
parameter_list|)
block|{
name|tree
name|new_binfo
init|=
name|make_tree_vec
argument_list|(
name|BINFO_LANG_ELTS
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|new_binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|offset
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|vtable
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|virtuals
expr_stmt|;
if|if
condition|(
name|binfo
operator|&&
operator|!
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|binfo
argument_list|)
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|BINFO_BASETYPES
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|copy_node
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not need to copy the accesses, as they are read only.  */
name|BINFO_BASEACCESSES
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|BINFO_BASEACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
return|return
name|new_binfo
return|;
block|}
end_function

begin_function
name|void
name|debug_binfo
parameter_list|(
name|tree
name|elem
parameter_list|)
block|{
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type \"%s\", offset = "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\nvtable type:\n"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|elem
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable decl \"%s\"\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|get_vtbl_decl_for_binfo
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no vtable decl yet\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"virtuals:\n"
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [%ld =? %ld]\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|count_functions
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_overloaded_fn
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
comment|/* A baselink is also considered an overloaded function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|)
return|;
block|}
end_function

begin_function
name|int
name|really_overloaded_fn
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
comment|/* A baselink is also considered an overloaded function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|OVL_CHAIN
argument_list|(
name|x
argument_list|)
operator|)
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|)
return|;
block|}
end_function

begin_function
name|tree
name|get_first_fn
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|from
argument_list|)
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* A baselink is also considered an overloaded function.  */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|OVL_CURRENT
argument_list|(
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if T is a ->* or .* expression that refers to a    member function.  */
end_comment

begin_function
name|int
name|bound_pmf_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new OVL node, concatenating it with the old one.  */
end_comment

begin_function
name|tree
name|ovl_cons
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|chain
parameter_list|)
block|{
name|tree
name|result
init|=
name|make_node
argument_list|(
name|OVERLOAD
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|OVL_FUNCTION
argument_list|(
name|result
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|result
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a new overloaded function. If this is the first one,    just return it; otherwise, ovl_cons the _DECLs */
end_comment

begin_function
name|tree
name|build_overload
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|chain
parameter_list|)
block|{
if|if
condition|(
operator|!
name|chain
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|chain
operator|&&
name|TREE_CODE
argument_list|(
name|chain
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|chain
operator|=
name|ovl_cons
argument_list|(
name|chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|chain
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PRINT_RING_SIZE
value|4
end_define

begin_function
specifier|const
name|char
modifier|*
name|cxx_printable_name
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|v
parameter_list|)
block|{
specifier|static
name|tree
name|decl_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|print_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|int
name|ring_counter
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Only cache functions.  */
if|if
condition|(
name|v
operator|<
literal|2
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|lang_decl_name
argument_list|(
name|decl
argument_list|,
name|v
argument_list|)
return|;
comment|/* See if this print name is lying around.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PRINT_RING_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|decl_ring
index|[
name|i
index|]
operator|==
name|decl
condition|)
comment|/* yes, so return it.  */
return|return
name|print_ring
index|[
name|i
index|]
return|;
if|if
condition|(
operator|++
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|ring_counter
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|print_ring
index|[
name|ring_counter
index|]
condition|)
name|free
argument_list|(
name|print_ring
index|[
name|ring_counter
index|]
argument_list|)
expr_stmt|;
name|print_ring
index|[
name|ring_counter
index|]
operator|=
name|xstrdup
argument_list|(
name|lang_decl_name
argument_list|(
name|decl
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|decl_ring
index|[
name|ring_counter
index|]
operator|=
name|decl
expr_stmt|;
return|return
name|print_ring
index|[
name|ring_counter
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions    listed in RAISES.  */
end_comment

begin_function
name|tree
name|build_exception_variant
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|raises
parameter_list|)
block|{
name|tree
name|v
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|type_quals
init|=
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|v
argument_list|)
operator|==
name|type_quals
operator|&&
name|comp_except_specs
argument_list|(
name|raises
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|comp_type_attributes
call|)
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
condition|)
return|return
name|v
return|;
comment|/* Need to build a new variant.  */
name|v
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
operator|=
name|raises
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given a TEMPLATE_TEMPLATE_PARM node T, create a new    BOUND_TEMPLATE_TEMPLATE_PARM bound with NEWARGS as its template    arguments.  */
end_comment

begin_function
name|tree
name|bind_template_template_parm
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|newargs
parameter_list|)
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|t2
decl_stmt|;
name|t2
operator|=
name|make_aggr_type
argument_list|(
name|BOUND_TEMPLATE_TEMPLATE_PARM
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* These nodes have to be created to reflect new TYPE_DECL and template      arguments.  */
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t2
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TEMPLATE_PARM_DECL
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|t2
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
name|newargs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|t2
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t2
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t2
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|t2
return|;
block|}
end_function

begin_comment
comment|/* Called from count_trees via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|count_trees_r
parameter_list|(
name|tree
modifier|*
name|tp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|++
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Debugging function for measuring the rough complexity of a tree    representation.  */
end_comment

begin_function
name|int
name|count_trees
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|n_trees
init|=
literal|0
decl_stmt|;
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|t
argument_list|,
name|count_trees_r
argument_list|,
operator|&
name|n_trees
argument_list|)
expr_stmt|;
return|return
name|n_trees
return|;
block|}
end_function

begin_comment
comment|/* Called from verify_stmt_tree via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|verify_stmt_tree_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|htab_t
modifier|*
name|statements
init|=
operator|(
name|htab_t
operator|*
operator|)
name|data
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|STATEMENT_CODE_P
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this statement is already present in the hash table, then      there is a circularity in the statement tree.  */
if|if
condition|(
name|htab_find
argument_list|(
operator|*
name|statements
argument_list|,
name|t
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
operator|*
name|statements
argument_list|,
name|t
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|t
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Debugging function to check that the statement T has not been    corrupted.  For now, this function simply checks that T contains no    circularities.  */
end_comment

begin_function
name|void
name|verify_stmt_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|htab_t
name|statements
decl_stmt|;
name|statements
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|verify_stmt_tree_r
argument_list|,
operator|&
name|statements
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|statements
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from find_tree via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|find_tree_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|*
name|tp
operator|==
operator|(
name|tree
operator|)
name|data
condition|)
return|return
operator|(
name|tree
operator|)
name|data
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns X if X appears in the tree structure rooted at T.  */
end_comment

begin_function
name|tree
name|find_tree
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|x
parameter_list|)
block|{
return|return
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|t
argument_list|,
name|find_tree_r
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Passed to walk_tree.  Checks for the use of types with no linkage.  */
end_comment

begin_function
specifier|static
name|tree
name|no_linkage_helper
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check if the type T depends on a type with no linkage and if so, return    it.  */
end_comment

begin_function
name|tree
name|no_linkage_check
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* There's no point in checking linkage on template functions; we      can't know their complete types.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|NULL_TREE
return|;
name|t
operator|=
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|t
argument_list|,
name|no_linkage_helper
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|depth_reached
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|cxx_print_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|print_search_statistics
argument_list|()
expr_stmt|;
name|print_class_statistics
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maximum template instantiation depth reached: %d\n"
argument_list|,
name|depth_reached
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for TYPE    (which is an ARRAY_TYPE).  This counts only elements of the top    array.  */
end_comment

begin_function
name|tree
name|array_type_nelts_top
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for TYPE    (which is an ARRAY_TYPE).  This one is a recursive count of all    ARRAY_TYPEs that are clumped together.  */
end_comment

begin_function
name|tree
name|array_type_nelts_total
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|sz
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|n
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|sz
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|sz
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|sz
return|;
block|}
end_function

begin_comment
comment|/* Called from break_out_target_exprs via mapcar.  */
end_comment

begin_function
specifier|static
name|tree
name|bot_manip
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|splay_tree
name|target_remap
init|=
operator|(
operator|(
name|splay_tree
operator|)
name|data
operator|)
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* There can't be any TARGET_EXPRs or their slot variables below          this point.  We used to check !TREE_SIDE_EFFECTS, but then we          failed to copy an ADDR_EXPR of the slot VAR_DECL.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
name|tree
name|u
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AGGR_INIT_EXPR
condition|)
block|{
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|break_out_target_exprs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|build_target_expr_with_type
argument_list|(
name|break_out_target_exprs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Map the old variable to the new one.  */
name|splay_tree_insert
argument_list|(
name|target_remap
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the old expression with the new version.  */
operator|*
name|tp
operator|=
name|u
expr_stmt|;
comment|/* We don't have to go below this point; the recursive call to 	 break_out_target_exprs will have handled anything below this 	 point.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a copy of this node.  */
return|return
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Replace all remapped VAR_DECLs in T with their new equivalents.    DATA is really a splay-tree mapping old variables to new    variables.  */
end_comment

begin_function
specifier|static
name|tree
name|bot_replace
parameter_list|(
name|tree
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|splay_tree
name|target_remap
init|=
operator|(
operator|(
name|splay_tree
operator|)
name|data
operator|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|splay_tree_node
name|n
init|=
name|splay_tree_lookup
argument_list|(
name|target_remap
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
operator|*
name|t
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* When we parse a default argument expression, we may create    temporary variables via TARGET_EXPRs.  When we actually use the    default-argument expression, we make a copy of the expression, but    we must replace the temporaries with appropriate local versions.  */
end_comment

begin_function
name|tree
name|break_out_target_exprs
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
specifier|static
name|int
name|target_remap_count
decl_stmt|;
specifier|static
name|splay_tree
name|target_remap
decl_stmt|;
if|if
condition|(
operator|!
name|target_remap_count
operator|++
condition|)
name|target_remap
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
comment|/*splay_tree_delete_key_fn=*/
name|NULL
argument_list|,
comment|/*splay_tree_delete_value_fn=*/
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|bot_manip
argument_list|,
name|target_remap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|bot_replace
argument_list|,
name|target_remap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|target_remap_count
condition|)
block|{
name|splay_tree_delete
argument_list|(
name|target_remap
argument_list|)
expr_stmt|;
name|target_remap
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar to `build_nt', but for template definitions of dependent    expressions  */
end_comment

begin_function
name|tree
name|build_min_nt
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
name|input_line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|x
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar to `build', but for template definitions.  */
end_comment

begin_function
name|tree
name|build_min
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|tt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
name|input_line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|x
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar to `build', but for template definitions of non-dependent    expressions. NON_DEP is the non-dependent expression that has been    built.  */
end_comment

begin_function
name|tree
name|build_min_non_dep
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|non_dep
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|non_dep
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|non_dep
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
name|input_line
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|non_dep
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|x
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|COMPOUND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|non_dep
argument_list|)
operator|!=
name|COMPOUND_EXPR
condition|)
comment|/* This should not be considered a COMPOUND_EXPR, because it        resolves to an overload.  */
name|COMPOUND_EXPR_OVERLOADED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Returns an INTEGER_CST (of type `int') corresponding to I.    Multiple calls with the same value of I may or may not yield the    same node; therefore, callers should never modify the node    returned.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|shared_int_cache
index|[
literal|256
index|]
expr_stmt|;
end_expr_stmt

begin_function
name|tree
name|build_shared_int_cst
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>=
literal|256
condition|)
return|return
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|shared_int_cache
index|[
name|i
index|]
condition|)
name|shared_int_cache
index|[
name|i
index|]
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|shared_int_cache
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
name|tree
name|get_type_decl
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|abort
argument_list|()
expr_stmt|;
comment|/* Stop compiler from complaining control reaches end of non-void function.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return first vector element whose BINFO_TYPE is ELEM.    Return 0 if ELEM is not in VEC.  VEC may be NULL_TREE.  */
end_comment

begin_function
name|tree
name|vec_binfo_member
parameter_list|(
name|tree
name|elem
parameter_list|,
name|tree
name|vec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vec
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|elem
argument_list|,
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns the namespace that contains DECL, whether directly or    indirectly.  */
end_comment

begin_function
name|tree
name|decl_namespace_context
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|decl
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T1 is the same tree structure as T2.    Return 1 if they are the same. Return 0 if they are different.  */
end_comment

begin_function
name|bool
name|cp_tree_equal
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|t1
operator|||
operator|!
name|t2
condition|)
return|return
name|false
return|;
for|for
control|(
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
init|;
name|code1
operator|==
name|NOP_EXPR
operator|||
name|code1
operator|==
name|CONVERT_EXPR
operator|||
name|code1
operator|==
name|NON_LVALUE_EXPR
condition|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
control|)
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
init|;
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code1
operator|==
name|NON_LVALUE_EXPR
condition|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
control|)
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* They might have become equal now.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|true
return|;
if|if
condition|(
name|code1
operator|!=
name|code2
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* We need to do this when determining whether or not two 	 non-type pointer to member function template arguments 	 are the same.  */
if|if
condition|(
operator|!
operator|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
comment|/* The first operand is RTL.  */
operator|&&
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
block|{
name|tree
name|o1
init|=
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|o2
init|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Special case: if either target is an unallocated VAR_DECL, 	   it means that it's going to be unified with whatever the 	   TARGET_EXPR is really supposed to initialize, so treat it 	   as being equivalent to anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|o1
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|o1
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|o1
argument_list|)
condition|)
comment|/*Nop*/
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|o2
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|o2
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|o2
argument_list|)
condition|)
comment|/*Nop*/
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
case|case
name|WITH_CLEANUP_EXPR
case|:
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
operator|!=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|IDENTIFIER_NODE
case|:
return|return
name|false
return|;
case|case
name|BASELINK
case|:
return|return
operator|(
name|BASELINK_BINFO
argument_list|(
name|t1
argument_list|)
operator|==
name|BASELINK_BINFO
argument_list|(
name|t2
argument_list|)
operator|&&
name|BASELINK_ACCESS_BINFO
argument_list|(
name|t1
argument_list|)
operator|==
name|BASELINK_ACCESS_BINFO
argument_list|(
name|t2
argument_list|)
operator|&&
name|cp_tree_equal
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|t1
argument_list|)
argument_list|,
name|BASELINK_FUNCTIONS
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
return|return
operator|(
name|TEMPLATE_PARM_IDX
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_PARM_IDX
argument_list|(
name|t2
argument_list|)
operator|&&
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t2
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|vec1
decl_stmt|,
name|vec2
decl_stmt|;
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|vec1
operator|=
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vec2
operator|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vec1
operator|||
operator|!
name|vec2
condition|)
return|return
operator|!
name|vec1
operator|&&
operator|!
name|vec2
return|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|vec1
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|vec2
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|ix
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec1
argument_list|)
init|;
name|ix
operator|--
condition|;
control|)
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec1
argument_list|,
name|ix
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|vec2
argument_list|,
name|ix
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
block|{
name|tree
name|o1
init|=
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|o2
init|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|o1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|o2
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|o1
argument_list|)
condition|)
return|return
name|same_type_p
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
return|;
else|else
return|return
name|cp_tree_equal
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
return|;
block|}
case|case
name|PTRMEM_CST
case|:
comment|/* Two pointer-to-members are the same if they point to the same 	 field or function in the same class.  */
if|if
condition|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|t1
argument_list|)
operator|!=
name|PTRMEM_CST_MEMBER
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|same_type_p
argument_list|(
name|PTRMEM_CST_CLASS
argument_list|(
name|t1
argument_list|)
argument_list|,
name|PTRMEM_CST_CLASS
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|OVERLOAD
case|:
if|if
condition|(
name|OVL_FUNCTION
argument_list|(
name|t1
argument_list|)
operator|!=
name|OVL_FUNCTION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|cp_tree_equal
argument_list|(
name|OVL_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|OVL_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|code1
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
case|case
literal|'t'
case|:
return|return
name|same_type_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|20030617
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Build a wrapper around a 'struct z_candidate' so we can use it as a    tree.  */
end_comment

begin_function
name|tree
name|build_zc_wrapper
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|ptr
parameter_list|)
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|WRAPPER
argument_list|)
decl_stmt|;
name|WRAPPER_ZC
argument_list|(
name|t
argument_list|)
operator|=
name|ptr
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* The type of ARG when used as an lvalue.  */
end_comment

begin_function
name|tree
name|lvalue_type
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* The type of ARG for printing error messages; denote lvalues with    reference types.  */
end_comment

begin_function
name|tree
name|error_type
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
name|type
operator|=
name|build_reference_type
argument_list|(
name|lvalue_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Does FUNCTION use a variable-length argument list?  */
end_comment

begin_function
name|int
name|varargs_function_p
parameter_list|(
name|tree
name|function
parameter_list|)
block|{
name|tree
name|parm
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if decl is a member of a class.  */
end_comment

begin_function
name|int
name|member_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|tree
name|ctx
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
return|return
operator|(
name|ctx
operator|&&
name|TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a placeholder for member access where we don't actually have an    object that the access is against.  */
end_comment

begin_function
name|tree
name|build_dummy_object
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|void_zero_node
argument_list|)
decl_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We've gotten a reference to a member of TYPE.  Return *this if appropriate,    or a dummy object otherwise.  If BINFOP is non-0, it is filled with the    binfo path from current_class_type to TYPE, or 0.  */
end_comment

begin_function
name|tree
name|maybe_dummy_object
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|binfop
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|context
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
operator|(
name|binfo
operator|=
name|lookup_base
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|context
operator|=
name|current_class_type
expr_stmt|;
else|else
block|{
comment|/* Reference from a nested class member function.  */
name|context
operator|=
name|type
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|binfop
condition|)
operator|*
name|binfop
operator|=
name|binfo
expr_stmt|;
if|if
condition|(
name|current_class_ref
operator|&&
name|context
operator|==
name|current_class_type
comment|/* Kludge: Make sure that current_class_type is actually          correct.  It might not be if we're in the middle of          tsubst_default_argument.  */
operator|&&
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_ref
argument_list|)
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|decl
operator|=
name|current_class_ref
expr_stmt|;
else|else
name|decl
operator|=
name|build_dummy_object
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OB is a placeholder object, or a pointer to one.  */
end_comment

begin_function
name|int
name|is_dummy_object
parameter_list|(
name|tree
name|ob
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|ob
operator|=
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
operator|==
name|void_zero_node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff type T is a POD type, as defined in [basic.types].  */
end_comment

begin_function
name|int
name|pod_type_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|t
operator|=
name|strip_array_types
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* integral, character or enumeral type */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* pointer to non-member */
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* pointer to member */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
literal|1
return|;
comment|/* vectors are (small) arrays of scalars */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* other non-class type (reference or function) */
if|if
condition|(
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff zero initialization of type T means actually storing    zeros in it.  */
end_comment

begin_function
name|int
name|zero_init_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|t
operator|=
name|strip_array_types
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* NULL pointers to data members are initialized with -1.  */
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Classes that contain types that can't be zero-initialized, cannot      be zero-initialized themselves.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_NON_ZERO_INIT_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Table of valid C++ attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|cxx_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"java_interface"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_java_interface_attribute
block|}
block|,
block|{
literal|"com_interface"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_com_interface_attribute
block|}
block|,
block|{
literal|"init_priority"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_init_priority_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle a "java_interface" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_java_interface_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|!
name|TYPE_FOR_JAVA
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' attribute can only be applied to Java class definitions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TYPE_JAVA_INTERFACE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "com_interface" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_com_interface_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
specifier|static
name|int
name|warned
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|*
name|node
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute can only be applied to class definitions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|warned
operator|++
condition|)
name|warning
argument_list|(
literal|"`%s' is obsolete; g++ vtables are now COM-compatible by default"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "init_priority" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_init_priority_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|initp_expr
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|initp_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initp_expr
operator|||
name|TREE_CODE
argument_list|(
name|initp_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"requested init_priority is not an integer constant"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|pri
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|initp_expr
argument_list|)
expr_stmt|;
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|)
comment|/* Static objects in functions are initialized the 	 first time control passes through that 	 function. This is not precise enough to pin down an 	 init_priority value, so don't allow it.  */
operator|||
name|current_function_decl
condition|)
block|{
name|error
argument_list|(
literal|"can only use `%s' attribute on file-scope definitions of objects of class type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|pri
operator|>
name|MAX_INIT_PRIORITY
operator|||
name|pri
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"requested init_priority is out of range"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check for init_priorities that are reserved for      language and runtime support implementations.*/
if|if
condition|(
name|pri
operator|<=
name|MAX_RESERVED_INIT_PRIORITY
condition|)
block|{
name|warning
argument_list|(
literal|"requested init_priority is reserved for internal use"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUPPORTS_INIT_PRIORITY
condition|)
block|{
name|DECL_INIT_PRIORITY
argument_list|(
name|decl
argument_list|)
operator|=
name|pri
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"`%s' attribute is not supported on this platform"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a new PTRMEM_CST of the indicated TYPE.  The MEMBER is the    thing pointed to by the constant.  */
end_comment

begin_function
name|tree
name|make_ptrmem_cst
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|member
parameter_list|)
block|{
name|tree
name|ptrmem_cst
init|=
name|make_node
argument_list|(
name|PTRMEM_CST
argument_list|)
decl_stmt|;
comment|/* If would seem a great convenience if make_node would set      TREE_CONSTANT for things of class `c', but it does not.  */
name|TREE_CONSTANT
argument_list|(
name|ptrmem_cst
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ptrmem_cst
argument_list|)
operator|=
name|type
expr_stmt|;
name|PTRMEM_CST_MEMBER
argument_list|(
name|ptrmem_cst
argument_list|)
operator|=
name|member
expr_stmt|;
return|return
name|ptrmem_cst
return|;
block|}
end_function

begin_comment
comment|/* Build a variant of TYPE that has the indicated ATTRIBUTES.  May    return an existing type of an appropriate type already exists.  */
end_comment

begin_function
name|tree
name|cp_build_type_attribute_variant
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|new_type
decl_stmt|;
name|new_type
operator|=
name|build_type_attribute_variant
argument_list|(
name|type
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|new_type
argument_list|)
operator|!=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|new_type
operator|=
name|build_exception_variant
argument_list|(
name|new_type
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_type
return|;
block|}
end_function

begin_comment
comment|/* Apply FUNC to all language-specific sub-trees of TP in a pre-order    traversal.  Called from walk_tree().  */
end_comment

begin_function
name|tree
name|cp_walk_subtrees
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees_p
parameter_list|,
name|walk_tree_fn
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|htab
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
define|#
directive|define
name|WALK_SUBTREE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\       result = walk_tree (&(NODE), func, data, htab);	\       if (result)					\ 	return result;					\     }							\   while (0)
comment|/* Not one of the easy cases.  We must explicitly go through the      children.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DEFAULT_ARG
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|TYPEOF_TYPE
case|:
case|case
name|BASELINK
case|:
comment|/* None of these have subtrees other than those already walked          above.  */
operator|*
name|walk_subtrees_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PTRMEM_CST
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERLOAD
case|:
name|WALK_SUBTREE
argument_list|(
name|OVL_FUNCTION
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|OVL_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|WALK_SUBTREE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* We didn't find what we were looking for.  */
return|return
name|NULL_TREE
return|;
undef|#
directive|undef
name|WALK_SUBTREE
block|}
end_function

begin_comment
comment|/* Decide whether there are language-specific reasons to not inline a    function as a tree.  */
end_comment

begin_function
name|int
name|cp_cannot_inline_tree_fn
parameter_list|(
name|tree
modifier|*
name|fnp
parameter_list|)
block|{
name|tree
name|fn
init|=
operator|*
name|fnp
decl_stmt|;
comment|/* We can inline a template instantiation only if it's fully      instantiated.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
operator|&&
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Don't instantiate functions that are not going to be 	 inlined.  */
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|template_for_substitution
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|fn
operator|=
operator|*
name|fnp
operator|=
name|instantiate_decl
argument_list|(
name|fn
argument_list|,
comment|/*defer_ok=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|flag_really_no_inline
operator|&&
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Don't auto-inline anything that might not be bound within      this unit of translation.  */
if|if
condition|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|varargs_function_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|function_attribute_inlinable_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add any pending functions other than the current function (already    handled by the caller), that thus cannot be inlined, to FNS_P, then    return the latest function added to the array, PREV_FN.  */
end_comment

begin_function
name|tree
name|cp_add_pending_fn_decls
parameter_list|(
name|void
modifier|*
name|fns_p
parameter_list|,
name|tree
name|prev_fn
parameter_list|)
block|{
name|varray_type
modifier|*
name|fnsp
init|=
operator|(
name|varray_type
operator|*
operator|)
name|fns_p
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|scope_chain
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|prev
control|)
if|if
condition|(
name|s
operator|->
name|function_decl
operator|&&
name|s
operator|->
name|function_decl
operator|!=
name|prev_fn
condition|)
block|{
name|VARRAY_PUSH_TREE
argument_list|(
operator|*
name|fnsp
argument_list|,
name|s
operator|->
name|function_decl
argument_list|)
expr_stmt|;
name|prev_fn
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
block|}
return|return
name|prev_fn
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a tree node is an OVERLOAD node.  Used to decide    whether to copy a node or to preserve its chain when inlining a    function.  */
end_comment

begin_function
name|int
name|cp_is_overload_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
return|;
block|}
end_function

begin_comment
comment|/* Determine whether VAR is a declaration of an automatic variable in    function FN.  */
end_comment

begin_function
name|int
name|cp_auto_var_in_fn_p
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
return|return
operator|(
name|DECL_P
argument_list|(
name|var
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
operator|==
name|fn
operator|&&
name|nonstatic_local_decl_p
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Tell whether a declaration is needed for the RESULT of a function    FN being inlined into CALLER or if the top node of target_exprs is    to be used.  */
end_comment

begin_function
name|tree
name|cp_copy_res_decl_for_inlining
parameter_list|(
name|tree
name|result
parameter_list|,
name|tree
name|fn
parameter_list|,
name|tree
name|caller
parameter_list|,
name|void
modifier|*
name|decl_map_
parameter_list|,
name|int
modifier|*
name|need_decl
parameter_list|,
name|tree
name|return_slot_addr
parameter_list|)
block|{
name|splay_tree
name|decl_map
init|=
operator|(
name|splay_tree
operator|)
name|decl_map_
decl_stmt|;
name|tree
name|var
decl_stmt|;
comment|/* If FN returns an aggregate then the caller will always pass the      address of the return slot explicitly.  If we were just to      create a new VAR_DECL here, then the result of this function      would be copied (bitwise) into the variable initialized by the      TARGET_EXPR.  That's incorrect, so we must transform any      references to the RESULT into references to the target.  */
comment|/* We should have an explicit return slot iff the return type is      TREE_ADDRESSABLE.  See simplify_aggr_init_expr.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|!=
operator|(
name|return_slot_addr
operator|!=
name|NULL_TREE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|need_decl
operator|=
operator|!
name|return_slot_addr
expr_stmt|;
if|if
condition|(
name|return_slot_addr
condition|)
block|{
name|var
operator|=
name|build_indirect_ref
argument_list|(
name|return_slot_addr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Otherwise, make an appropriate copy.  */
else|else
name|var
operator|=
name|copy_decl_for_inlining
argument_list|(
name|result
argument_list|,
name|fn
argument_list|,
name|caller
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|nrv
init|=
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
operator|->
name|x_return_value
decl_stmt|;
if|if
condition|(
name|nrv
condition|)
block|{
comment|/* We have a named return value; copy the name and source 	     position so we can get reasonable debugging information, and 	     register the return variable as its equivalent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
comment|/* But not if we're initializing a variable from the 		 enclosing function which already has its own name.  */
operator|&&
name|DECL_NAME
argument_list|(
name|var
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_NAME
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
comment|/* Don't lose initialization info.  */
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
comment|/* Don't forget that it needs to go in the stack.  */
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
block|}
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|nrv
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|var
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Initialize tree.c.  */
end_comment

begin_function
name|void
name|init_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|list_hash_table
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|list_hash
argument_list|,
name|list_hash_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called via walk_tree.  If *TP points to a DECL_STMT for a local    declaration, copies the declaration and enters it in the splay_tree    pointed to by DATA (which is really a `splay_tree *').  */
end_comment

begin_function
specifier|static
name|tree
name|mark_local_for_remap_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|splay_tree
name|st
init|=
operator|(
name|splay_tree
operator|)
name|data
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|DECL_STMT
operator|&&
name|nonstatic_local_decl_p
argument_list|(
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|decl
operator|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_STMT
condition|)
name|decl
operator|=
name|LABEL_STMT_LABEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|nonstatic_local_decl_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CASE_LABEL
condition|)
name|decl
operator|=
name|CASE_LABEL_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|tree
name|copy
decl_stmt|;
comment|/* Make a copy.  */
name|copy
operator|=
name|copy_decl_for_inlining
argument_list|(
name|decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember the copy.  */
name|splay_tree_insert
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|copy
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_tree when an expression is unsaved.  Using the    splay_tree pointed to by ST (which is really a `splay_tree'),    remaps all local declarations to appropriate replacements.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_unsave_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|splay_tree
name|st
init|=
operator|(
name|splay_tree
operator|)
name|data
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Only a local declaration (variable or label).  */
if|if
condition|(
name|nonstatic_local_decl_p
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
comment|/* Lookup the declaration.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* If it's there, remap it.  */
if|if
condition|(
name|n
condition|)
operator|*
name|tp
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|remap_save_expr
argument_list|(
name|tp
argument_list|,
name|st
argument_list|,
name|current_function_decl
argument_list|,
name|walk_subtrees
argument_list|)
expr_stmt|;
else|else
block|{
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do whatever unsaving is required.  */
name|unsave_expr_1
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called whenever an expression needs to be unsaved.  */
end_comment

begin_function
name|tree
name|cxx_unsave_expr_now
parameter_list|(
name|tree
name|tp
parameter_list|)
block|{
name|splay_tree
name|st
decl_stmt|;
comment|/* Create a splay-tree to map old local variable declarations to new      ones.  */
name|st
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk the tree once figuring out what needs to be remapped.  */
name|walk_tree
argument_list|(
operator|&
name|tp
argument_list|,
name|mark_local_for_remap_r
argument_list|,
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk the tree again, copying, remapping, and unsaving.  */
name|walk_tree
argument_list|(
operator|&
name|tp
argument_list|,
name|cp_unsave_r
argument_list|,
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of special function that DECL (a FUNCTION_DECL)    is.  Note that sfk_none is zero, so this function can be used as a    predicate to test whether or not DECL is a special function.  */
end_comment

begin_function
name|special_function_kind
name|special_function_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Rather than doing all this stuff with magic names, we should      probably have a field of type `special_function_kind' in      DECL_LANG_SPECIFIC.  */
if|if
condition|(
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_copy_constructor
return|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_constructor
return|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
operator|==
name|NOP_EXPR
condition|)
return|return
name|sfk_assignment_operator
return|;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_destructor
return|;
if|if
condition|(
name|DECL_COMPLETE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_complete_destructor
return|;
if|if
condition|(
name|DECL_BASE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_base_destructor
return|;
if|if
condition|(
name|DECL_DELETING_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_deleting_destructor
return|;
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_conversion
return|;
return|return
name|sfk_none
return|;
block|}
end_function

begin_comment
comment|/* Returns true if and only if NODE is a name, i.e., a node created    by the parser when processing an id-expression.  */
end_comment

begin_function
name|bool
name|name_p
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
comment|/* An ordinary unqualified name.  */
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|IDENTIFIER_NODE
comment|/* A destructor name.  */
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|BIT_NOT_EXPR
comment|/* A qualified name.  */
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|SCOPE_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if TYPE is a character type, including wchar_t.  */
end_comment

begin_function
name|int
name|char_type_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
operator|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|char_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|type
argument_list|,
name|unsigned_char_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|type
argument_list|,
name|signed_char_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|type
argument_list|,
name|wchar_type_node
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of linkage associated with the indicated DECL.  Th    value returned is as specified by the language standard; it is    independent of implementation details regarding template    instantiation, etc.  For example, it is possible that a declaration    to which this function assigns external linkage would not show up    as a global symbol when you run `nm' on the resulting object file.  */
end_comment

begin_function
name|linkage_kind
name|decl_linkage
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* This function doesn't attempt to calculate the linkage from first      principles as given in [basic.link].  Instead, it makes use of      the fact that we have already set TREE_PUBLIC appropriately, and      then handles a few special cases.  Ideally, we would calculate      linkage first, and then transform that into a concrete      implementation.  */
comment|/* Things that don't have names have no linkage.  */
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_none
return|;
comment|/* Things that are TREE_PUBLIC have external linkage.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_external
return|;
comment|/* Some things that are not TREE_PUBLIC have external linkage, too.      For example, on targets that don't have weak symbols, we make all      template instantiations have internal linkage (in the object      file), but the symbols should still be treated as having external      linkage from the point of view of the language.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_external
return|;
comment|/* Things in local scope do not have linkage, if they don't have      TREE_PUBLIC set.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_none
return|;
comment|/* Everything else has internal linkage.  */
return|return
name|lk_internal
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* EXP is an expression that we want to pre-evaluate.  Returns via INITP an    expression to perform the pre-evaluation, and returns directly an    expression to use the precalculated result.  */
end_comment

begin_function
name|tree
name|stabilize_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
modifier|*
name|initp
parameter_list|)
block|{
name|tree
name|init_expr
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|init_expr
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|exp
argument_list|)
operator|||
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|init_expr
operator|=
name|get_target_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|init_expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init_expr
operator|=
name|get_target_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|init_expr
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_indirect_ref
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|initp
operator|=
name|init_expr
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Like stabilize_expr, but for a call whose args we want to    pre-evaluate.  */
end_comment

begin_function
name|void
name|stabilize_call
parameter_list|(
name|tree
name|call
parameter_list|,
name|tree
modifier|*
name|initp
parameter_list|)
block|{
name|tree
name|inits
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|call
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|AGGR_INIT_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|1
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|init
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|stabilize_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
comment|/* Nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|inits
condition|)
name|inits
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|inits
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|inits
operator|=
name|init
expr_stmt|;
block|}
operator|*
name|initp
operator|=
name|inits
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like stabilize_expr, but for an initialization.  If we are initializing    an object of class type, we don't want to introduce an extra temporary,    so we look past the TARGET_EXPR and stabilize the arguments of the call    instead.  */
end_comment

begin_function
name|bool
name|stabilize_init
parameter_list|(
name|tree
name|init
parameter_list|,
name|tree
modifier|*
name|initp
parameter_list|)
block|{
name|tree
name|t
init|=
name|init
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INIT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|TARGET_EXPR
condition|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|stabilize_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|initp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INIT_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|t
operator|=
name|TARGET_EXPR_INITIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|t
operator|=
name|expr_last
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Default-initialization.  */
operator|*
name|initp
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If the initializer is a COND_EXPR, we can't preevaluate 	 anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|false
return|;
comment|/* The TARGET_EXPR might be initializing via bitwise copy from 	 another variable; leave that alone.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
condition|)
name|stabilize_call
argument_list|(
name|t
argument_list|,
name|initp
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Like "fold", but should be used whenever we might be processing the    body of a template.  */
end_comment

begin_function
name|tree
name|fold_if_not_in_template
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
comment|/* In the body of a template, there is never any need to call      "fold".  We will call fold later when actually instantiating the      template.  Integral constant expressions in templates will be      evaluated via fold_non_dependent_expr, as necessary.  */
return|return
operator|(
name|processing_template_decl
condition|?
name|expr
else|:
name|fold
argument_list|(
name|expr
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|ENABLE_TREE_CHECKING
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_comment
comment|/* Complain that some language-specific thing hanging off a tree    node has been accessed improperly.  */
end_comment

begin_function
name|void
name|lang_check_failed
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"lang_* check: failed in %s, at %s:%d"
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_TREE_CHECKING */
end_comment

begin_include
include|#
directive|include
file|"gt-cp-tree.h"
end_include

end_unit

