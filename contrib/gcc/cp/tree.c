begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-dependent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 88, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|compiler_error
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|tree
name|get_identifier_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|bot_manip
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|perm_manip
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_cplus_array_type_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_hash_add
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|list_hash
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|list_hash_lookup
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|propagate_binfo_offsets
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unshare_base_binfos
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|avoid_overlap
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|equal_functions
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language.    Lvalues can be assigned, unless they have TREE_READONLY.    Lvalues can have their address taken, unless they have DECL_REGISTER.  */
end_comment

begin_function
name|int
name|real_lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|language_lvalue_valid
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ref
operator|==
name|current_class_ptr
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|/* preincrements and predecrements are valid lvals, provided 	 what they refer to are valid lvals.  */
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|UNSAVE_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
return|return
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
literal|1
return|;
break|break;
comment|/* A currently unresolved scope ref.  */
case|case
name|SCOPE_REF
case|:
name|my_friendly_abort
argument_list|(
literal|103
argument_list|)
expr_stmt|;
case|case
name|OFFSET_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
return|return
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
literal|1
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
return|return
operator|(
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This differs from real_lvalue_p in that class rvalues are considered    lvalues.  */
end_comment

begin_function
name|int
name|lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|language_lvalue_valid
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ref
operator|==
name|current_class_ptr
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|/* preincrements and predecrements are valid lvals, provided 	 what they refer to are valid lvals.  */
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|UNSAVE_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|TARGET_EXPR
case|:
return|return
literal|1
return|;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
comment|/* A currently unresolved scope ref.  */
case|case
name|SCOPE_REF
case|:
name|my_friendly_abort
argument_list|(
literal|103
argument_list|)
expr_stmt|;
case|case
name|OFFSET_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
literal|1
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
return|return
operator|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|ref
parameter_list|,
name|string
parameter_list|)
name|tree
name|ref
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|error
argument_list|(
literal|"non-lvalue in %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* INIT is a CALL_EXPR which needs info about its target.    TYPE is the type that this initialization should appear to have.     Build an encapsulation of the initialization to perform    and return it so that it can be processed by language-independent    and language-specific expression expanders.  */
end_comment

begin_function
name|tree
name|build_cplus_new
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|slot
decl_stmt|;
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|AGGR_INIT_EXPR
condition|)
return|return
name|init
return|;
name|slot
operator|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_decl
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|AGGR_INIT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|TARGET_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Encapsulate the expression INIT in a TARGET_EXPR.  */
end_comment

begin_function
name|tree
name|get_target_expr
parameter_list|(
name|init
parameter_list|)
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|slot
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|slot
operator|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_decl
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|TARGET_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|slot
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Recursively search EXP for CALL_EXPRs that need cleanups and replace    these CALL_EXPRs with tree nodes that will perform the cleanups.  */
end_comment

begin_function
name|tree
name|break_out_cleanups
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
return|return
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|tmp
argument_list|)
return|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Recursively perform a preorder search EXP for CALL_EXPRs, making    copies where they are found.  Returns a deep copy all nodes transitively    containing CALL_EXPRs.  */
end_comment

begin_function
name|tree
name|break_out_calls
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
decl_stmt|,
name|t2
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
return|return
name|exp
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Don't try and defeat a save_expr, as it should only be done once.  */
if|if
condition|(
name|code
operator|==
name|SAVE_EXPR
condition|)
return|return
name|exp
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'c'
case|:
comment|/* a constant */
case|case
literal|'t'
case|:
comment|/* a type node */
case|case
literal|'x'
case|:
comment|/* something random, like an identifier or an ERROR_MARK.  */
return|return
name|exp
return|;
case|case
literal|'d'
case|:
comment|/* A decl node */
if|#
directive|if
literal|0
comment|/* This is bogus.  jason 9/21/94 */
block|t1 = break_out_calls (DECL_INITIAL (exp));       if (t1 != DECL_INITIAL (exp)) 	{ 	  exp = copy_node (exp); 	  DECL_INITIAL (exp) = t1; 	}
endif|#
directive|endif
return|return
name|exp
return|;
case|case
literal|'b'
case|:
comment|/* A block node */
block|{
comment|/* Don't know how to handle these correctly yet.   Must do a 	   break_out_calls on all DECL_INITIAL values for local variables, 	   and also break_out_calls on all sub-blocks and sub-statements.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|exp
return|;
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
for|for
control|(
name|i
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|t1
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|exp
operator|=
name|copy_node
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
block|}
return|return
name|exp
return|;
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
name|t2
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
name|t1
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|1
condition|)
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t1
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|,
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|expression_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is how primitive or already-canonicalized types' hash    codes are made.  MUST BE CONSISTENT WITH tree.c !!! */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH
parameter_list|(
name|TYPE
parameter_list|)
value|((HOST_WIDE_INT) (TYPE)& 0777777)
end_define

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments are described by ARGTYPES and whose values    are described by RETTYPE.  If each type exists already, reuse it.  */
end_comment

begin_function
name|tree
name|build_cplus_method_type
parameter_list|(
name|basetype
parameter_list|,
name|rettype
parameter_list|,
name|argtypes
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|rettype
decl_stmt|,
name|argtypes
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|tree
name|ptype
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rettype
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
condition|)
name|ptype
operator|=
name|build_signature_pointer_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_READONLY
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ptype
operator|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* The actual arglist for this function includes a "hidden" argument      which is "this".  Put it into the list of argument types.  */
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptype
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|argtypes
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|argtypes
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark first argtype as "artificial".  */
comment|/* If we already have such a type, use the old one and free this one.      Note that it also frees up the above cons cell if found.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|rettype
argument_list|)
operator|+
name|type_hash_list
argument_list|(
name|argtypes
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_cplus_array_type_1
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* We need a new one.  If both ELT_TYPE and INDEX_TYPE are permanent,      make this permanent too.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|elt_type
argument_list|)
operator|&&
operator|(
name|index_type
operator|==
literal|0
operator|||
name|TREE_PERMANENT
argument_list|(
name|index_type
argument_list|)
operator|)
condition|)
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
operator|||
name|uses_template_parms
argument_list|(
name|index_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|elt_type
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|=
name|index_type
expr_stmt|;
block|}
else|else
name|t
operator|=
name|build_array_type
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* Push these needs up so that initialization takes place      more easily.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_cplus_array_type
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
name|elt_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_cplus_array_type_1
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|t
operator|=
name|cp_build_type_variant
argument_list|(
name|t
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a variant type in the proper way for C/C++, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|cp_build_type_variant
parameter_list|(
name|type
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|real_main_variant
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type_1
argument_list|(
name|cp_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not, 	 make a copy.  (TYPE might have come from the hash table and 	 REAL_MAIN_VARIANT might be in some function's obstack.)  */
if|if
condition|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
condition|)
block|{
name|type
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_REFERENCE_TO
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|real_main_variant
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
return|return
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the canonical version of TYPE.  In other words, if TYPE is    a typedef, returns the underlying type.  The cv-qualification of    the type returned matches the type input; they will always be    compatible types.  */
end_comment

begin_function
name|tree
name|canonical_type_variant
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|constp
operator|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constp
operator|=
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|cp_build_type_variant
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add OFFSET to all base types of T.     OFFSET, which is a type offset, is number of bytes.     Note that we don't have to worry about having two paths to the    same base type, since this type owns its association list.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_binfo_offsets
parameter_list|(
name|binfo
parameter_list|,
name|offset
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
comment|/* note increment is done in the loop.  */
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|i
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|tree
name|delta
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_baselinks
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The next basetype offset must take into account the space 		   between the classes, not just the size of each class.  */
name|delta
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|if (BINFO_OFFSET_ZEROP (base_binfo)) 	    BINFO_OFFSET (base_binfo) = offset; 	  else 	    BINFO_OFFSET (base_binfo) 	      = size_binop (PLUS_EXPR, BINFO_OFFSET (base_binfo), offset);
else|#
directive|else
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|offset
expr_stmt|;
endif|#
directive|endif
name|unshare_base_binfos
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* Go to our next class that counts for offset propagation.  */
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n_baselinks
condition|)
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Makes new binfos for the indirect bases under BASE_BINFO, and updates    BINFO_OFFSET for them and their bases.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_base_binfos
parameter_list|(
name|base_binfo
parameter_list|)
name|tree
name|base_binfo
decl_stmt|;
block|{
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|tree
name|base_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|chain
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Now unshare the structure beneath BASE_BINFO.  */
for|for
control|(
name|j
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|base_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_base_binfo
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|base_base_binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
block|}
comment|/* Completely unshare potentially shared data, and 	 update what is ours.  */
name|propagate_binfo_offsets
argument_list|(
name|base_binfo
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the work of layout_record, now taking virtual bases into account.    Also compute the actual offsets that our base classes will have.    This must be performed after the fields are laid out, since virtual    baseclasses must lay down at the end of the record.     Returns the maximum number of virtual functions any of the    baseclasses provide.  */
end_comment

begin_function
name|int
name|layout_basetypes
parameter_list|(
name|rec
parameter_list|,
name|max
parameter_list|)
name|tree
name|rec
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|rec
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Get all the virtual base types that this type uses.      The TREE_VALUE slot holds the virtual baseclass type.  */
name|tree
name|vbase_types
init|=
name|get_vbase_types
argument_list|(
name|rec
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|record_align
init|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|desired_align
decl_stmt|;
comment|/* Record size so far is CONST_SIZE bits, where CONST_SIZE is an integer.  */
specifier|register
name|unsigned
name|int
name|const_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nonvirtual_const_size
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
comment|/* Packed structures don't need to have minimum size.  */
if|if
condition|(
operator|!
name|TYPE_PACKED
argument_list|(
name|rec
argument_list|)
condition|)
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|STRUCTURE_SIZE_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|rec
argument_list|)
operator|=
name|vbase_types
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
literal|19970302
argument_list|)
expr_stmt|;
name|const_size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|nonvirtual_const_size
operator|=
name|const_size
expr_stmt|;
while|while
condition|(
name|vbase_types
condition|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|vbase_types
argument_list|)
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|desired_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_size
operator|==
literal|0
condition|)
name|offset
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
comment|/* Give each virtual base type the alignment it wants.  */
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|desired_align
argument_list|)
operator|*
name|desired_align
expr_stmt|;
name|offset
operator|=
name|size_int
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
operator|>
name|max
condition|)
name|max
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|vbase_types
argument_list|)
operator|=
name|offset
expr_stmt|;
comment|/* Every virtual baseclass takes a least a UNIT, so that we can 	 take it's address and get something different for each base.  */
name|const_size
operator|+=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|CLASSTYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|const_size
condition|)
block|{
comment|/* Because a virtual base might take a single byte above, 	 we have to re-adjust the total size to make sure it is 	 a multiple of the alignment.  */
comment|/* Give the whole object the alignment it wants.  */
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|record_align
argument_list|)
operator|*
name|record_align
expr_stmt|;
block|}
comment|/* Set the alignment in the complete type.  We don't set CLASSTYPE_ALIGN    here, as that is for this class, without any virtual base classes.  */
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|record_align
expr_stmt|;
if|if
condition|(
name|const_size
operator|!=
name|nonvirtual_const_size
condition|)
block|{
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|size_int
argument_list|(
name|const_size
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|rec
argument_list|)
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now propagate offset information throughout the lattice.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|rec
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|basetype
argument_list|,
literal|23897
argument_list|)
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|size_int
argument_list|(
name|CEIL
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|unshare_base_binfos
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|rec
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|rec
argument_list|)
init|;
name|vbase_types
condition|;
name|vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase_types
argument_list|)
control|)
block|{
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|vbase_types
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|unshare_base_binfos
argument_list|(
name|vbase_types
argument_list|)
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
end_function

begin_comment
comment|/* If the empty base field in DECL overlaps with a base of the same type in    NEWDECL, which is either another base field or the first data field of    the class, pad the base just before NEWDECL and return 1.  Otherwise,    return 0.  */
end_comment

begin_function
specifier|static
name|int
name|avoid_overlap
parameter_list|(
name|decl
parameter_list|,
name|newdecl
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|newdecl
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|newdecl
operator|==
name|NULL_TREE
operator|||
operator|!
name|types_overlap_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|field
operator|=
name|decl
init|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|!=
name|newdecl
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
empty_stmt|;
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|=
name|integer_one_node
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns a list of fields to stand in for the base class subobjects    of REC.  These fields are later removed by layout_basetypes.  */
end_comment

begin_function
name|tree
name|build_base_fields
parameter_list|(
name|rec
parameter_list|)
name|tree
name|rec
decl_stmt|;
block|{
comment|/* Chain to hold all the new FIELD_DECLs which stand in for base class      subobjects.  */
name|tree
name|base_decls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|rec
argument_list|)
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|nextdecl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|saw_empty
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|base_align
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
comment|/* This error is now reported in xref_tag, thus giving better 	   location information.  */
continue|continue;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|rec
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_SIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|base_decls
expr_stmt|;
name|base_decls
operator|=
name|decl
expr_stmt|;
if|if
condition|(
operator|!
name|flag_new_abi
condition|)
block|{
comment|/* Brain damage for backwards compatibility.  For no good reason, 	     the old layout_basetypes made every base at least as large as 	     the alignment for the bases up to that point, gratuitously 	     wasting space.  So we do the same thing here.  */
name|base_align
operator|=
name|MAX
argument_list|(
name|base_align
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|size_int
argument_list|(
name|MAX
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|base_align
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|integer_zero_node
condition|)
name|saw_empty
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Reverse the list of fields so we allocate the bases in the proper      order.  */
name|base_decls
operator|=
name|nreverse
argument_list|(
name|base_decls
argument_list|)
expr_stmt|;
comment|/* In the presence of empty base classes, we run the risk of allocating      two objects of the same class on top of one another.  Avoid that.  */
if|if
condition|(
name|flag_new_abi
operator|&&
name|saw_empty
condition|)
for|for
control|(
name|decl
operator|=
name|base_decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|integer_zero_node
condition|)
block|{
comment|/* First step through the following bases until we find 	       an overlap or a non-empty base.  */
for|for
control|(
name|nextdecl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
init|;
name|nextdecl
condition|;
name|nextdecl
operator|=
name|TREE_CHAIN
argument_list|(
name|nextdecl
argument_list|)
control|)
block|{
if|if
condition|(
name|avoid_overlap
argument_list|(
name|decl
argument_list|,
name|nextdecl
argument_list|)
operator|||
name|DECL_SIZE
argument_list|(
name|nextdecl
argument_list|)
operator|!=
name|integer_zero_node
condition|)
goto|goto
name|nextbase
goto|;
block|}
comment|/* If we're still looking, also check against the first 	       field.  */
for|for
control|(
name|nextdecl
operator|=
name|TYPE_FIELDS
argument_list|(
name|rec
argument_list|)
init|;
name|nextdecl
operator|&&
name|TREE_CODE
argument_list|(
name|nextdecl
argument_list|)
operator|!=
name|FIELD_DECL
condition|;
name|nextdecl
operator|=
name|TREE_CHAIN
argument_list|(
name|nextdecl
argument_list|)
control|)
comment|/* keep looking */
empty_stmt|;
name|avoid_overlap
argument_list|(
name|decl
argument_list|,
name|nextdecl
argument_list|)
expr_stmt|;
block|}
name|nextbase
label|:
empty_stmt|;
block|}
return|return
name|base_decls
return|;
block|}
end_function

begin_comment
comment|/* Returns list of virtual base class pointers in a FIELD_DECL chain.  */
end_comment

begin_function
name|tree
name|build_vbase_pointer_fields
parameter_list|(
name|rec
parameter_list|)
name|tree
name|rec
decl_stmt|;
block|{
comment|/* Chain to hold all the new FIELD_DECLs which point at virtual      base classes.  */
name|tree
name|vbase_decls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|rec
argument_list|)
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Handle basetypes almost like fields, but record their      offsets differently.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
comment|/* This error is now reported in xref_tag, thus giving better 	   location information.  */
continue|continue;
comment|/* All basetypes are recorded in the association list of the 	 derived type.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* The offset for a virtual base class is only used in computing 	     virtual function tables and for initializing virtual base 	     pointers.  It is built once `get_vbase_types' is called.  */
comment|/* If this basetype can come from another vbase pointer 	     without an additional indirection, we will share 	     that pointer.  If an indirection is involved, we 	     make our own pointer.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
block|{
name|tree
name|other_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|other_base_binfo
argument_list|)
operator|&&
name|binfo_member
argument_list|(
name|basetype
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|other_base_binfo
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If you change any of the below, take a look at all the 	     other VFIELD_BASEs and VTABLE_BASEs in the code, and change 	     them too.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VTABLE_BASE
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|rec
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|rec
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|vbase_decls
expr_stmt|;
name|BINFO_VPTR_FIELD
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|decl
expr_stmt|;
name|vbase_decls
operator|=
name|decl
expr_stmt|;
name|got_it
label|:
comment|/* The space this decl occupies has already been accounted for.  */
empty_stmt|;
block|}
block|}
return|return
name|vbase_decls
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hashing of lists so that we don't make duplicates.    The entry point is `list_hash_canon'.  */
end_comment

begin_comment
comment|/* Each hash table slot is a bucket containing a chain    of these structures.  */
end_comment

begin_struct
struct|struct
name|list_hash
block|{
name|struct
name|list_hash
modifier|*
name|next
decl_stmt|;
comment|/* Next structure in the bucket.  */
name|int
name|hashcode
decl_stmt|;
comment|/* Hash code of this list.  */
name|tree
name|list
decl_stmt|;
comment|/* The list recorded here.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Now here is the hash table.  When recording a list, it is added    to the slot whose index is the hash code mod the table size.    Note that the hash table is used for several kinds of lists.    While all these live in the same table, they are completely independent,    and the hash code is computed differently for each of these.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH_SIZE
value|59
end_define

begin_decl_stmt
specifier|static
name|struct
name|list_hash
modifier|*
name|list_hash_table
index|[
name|TYPE_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a hash code for a list (chain of TREE_LIST nodes    with goodies in the TREE_PURPOSE, TREE_VALUE, and bits of the    TREE_COMMON slots), by adding the hash codes of the individual entries.  */
end_comment

begin_function
specifier|static
name|int
name|list_hash
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chain
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1007
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1009
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to TYPE.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|tree
name|list_hash_lookup
parameter_list|(
name|hashcode
parameter_list|,
name|via_public
parameter_list|,
name|via_protected
parameter_list|,
name|via_virtual
parameter_list|,
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|int
name|hashcode
decl_stmt|,
name|via_public
decl_stmt|,
name|via_virtual
decl_stmt|,
name|via_protected
decl_stmt|;
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|via_virtual
operator|&&
name|TREE_VIA_PUBLIC
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|via_public
operator|&&
name|TREE_VIA_PROTECTED
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|via_protected
operator|&&
name|TREE_PURPOSE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|purpose
operator|&&
name|TREE_VALUE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|value
operator|&&
name|TREE_CHAIN
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|chain
condition|)
return|return
name|h
operator|->
name|list
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the list-hash-table    for a list TYPE whose hash code is HASHCODE.  */
end_comment

begin_function
specifier|static
name|void
name|list_hash_add
parameter_list|(
name|hashcode
parameter_list|,
name|list
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|list_hash
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|class_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|list_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|list
operator|=
name|list
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
expr_stmt|;
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given TYPE, and HASHCODE its hash code, return the canonical    object for an identical list if one already exists.    Otherwise, return TYPE, and record it as the canonical object    if it is a permanent object.     To use this function, first create a list of the sort you want.    Then compute its hash code from the fields of the list that    make it different from other similar lists.    Then call this function and use the value.    This function frees the list you pass in if it is a duplicate.  */
end_comment

begin_comment
comment|/* Set to 1 to debug without canonicalization.  Never set by program.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_no_list_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|hash_tree_cons
parameter_list|(
name|via_public
parameter_list|,
name|via_virtual
parameter_list|,
name|via_protected
parameter_list|,
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|int
name|via_public
decl_stmt|,
name|via_virtual
decl_stmt|,
name|via_protected
decl_stmt|;
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|debug_no_list_hash
condition|)
block|{
name|hashcode
operator|=
name|list_hash
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|t
operator|=
name|list_hash_lookup
argument_list|(
name|hashcode
argument_list|,
name|via_public
argument_list|,
name|via_protected
argument_list|,
name|via_virtual
argument_list|,
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
block|}
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
name|via_public
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|t
argument_list|)
operator|=
name|via_protected
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
operator|=
name|via_virtual
expr_stmt|;
comment|/* If this is a new list, record it for later reuse.  */
if|if
condition|(
operator|!
name|debug_no_list_hash
condition|)
name|list_hash_add
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Constructor for hashed lists.  */
end_comment

begin_function
name|tree
name|hash_tree_chain
parameter_list|(
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
return|return
name|hash_tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but used for concatenating two lists.  */
end_comment

begin_function
name|tree
name|hash_chainon
parameter_list|(
name|list1
parameter_list|,
name|list2
parameter_list|)
name|tree
name|list1
decl_stmt|,
name|list2
decl_stmt|;
block|{
if|if
condition|(
name|list2
operator|==
literal|0
condition|)
return|return
name|list1
return|;
if|if
condition|(
name|list1
operator|==
literal|0
condition|)
return|return
name|list2
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
return|;
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|hash_chainon
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_identifier_list
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|list
init|=
name|IDENTIFIER_AS_LIST
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|!=
name|value
operator|)
condition|)
name|list
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|value
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|list
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|current_class_type
condition|)
comment|/* Don't mess up the constructor name.  */
name|list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|CLASSTYPE_ID_AS_LIST
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_ID_AS_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|list
operator|=
name|CLASSTYPE_ID_AS_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_function
name|tree
name|get_decl_list
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|list
operator|=
name|get_identifier_list
argument_list|(
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|value
argument_list|)
operator|&&
name|value
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|value
argument_list|)
condition|)
name|list
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|301
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
return|return
name|build_decl_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an association between TYPE and some parameters:     OFFSET is the offset added to `this' to convert it to a pointer    of type `TYPE *'     BINFO is the base binfo to use, if we are deriving from one.  This    is necessary, as we want specialized parent binfos from base    classes, so that the VTABLE_NAMEs of bases are for the most derived    type, instead of the simple type.     VTABLE is the virtual function table with which to initialize    sub-objects of type TYPE.     VIRTUALS are the virtual functions sitting in VTABLE.     CHAIN are more associations we must retain.  */
end_comment

begin_function
name|tree
name|make_binfo
parameter_list|(
name|offset
parameter_list|,
name|binfo
parameter_list|,
name|vtable
parameter_list|,
name|virtuals
parameter_list|,
name|chain
parameter_list|)
name|tree
name|offset
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|vtable
decl_stmt|,
name|virtuals
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|new_binfo
init|=
name|make_tree_vec
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|TREE_USED
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|offset
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|vtable
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|BINFO_VPTR_FIELD
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|binfo
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|BINFO_BASETYPES
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|copy_node
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_binfo
return|;
block|}
end_function

begin_comment
comment|/* Return the binfo value for ELEM in TYPE.  */
end_comment

begin_function
name|tree
name|binfo_value
parameter_list|(
name|elem
parameter_list|,
name|type
parameter_list|)
name|tree
name|elem
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|get_base_distance
argument_list|(
name|elem
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|2
condition|)
name|compiler_error
argument_list|(
literal|"base class `%s' ambiguous in binfo_value"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|type
condition|)
return|return
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elem
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_BINFO
argument_list|(
name|elem
argument_list|)
operator|==
name|type
condition|)
return|return
name|type
return|;
return|return
name|get_binfo
argument_list|(
name|elem
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|reverse_path
parameter_list|(
name|path
parameter_list|)
name|tree
name|path
decl_stmt|;
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|tmp
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|path
init|;
name|tmp
condition|;
name|tmp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_function
name|void
name|debug_binfo
parameter_list|(
name|elem
parameter_list|)
name|tree
name|elem
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type \"%s\"; offset = %ld\n"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable type:\n"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|elem
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable decl \"%s\"\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no vtable decl yet\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"virtuals:\n"
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [%ld =? %ld]\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize an CPLUS_BINDING node that does not live on an obstack. */
end_comment

begin_function
name|tree
name|binding_init
parameter_list|(
name|node
parameter_list|)
name|struct
name|tree_binding
modifier|*
name|node
decl_stmt|;
block|{
specifier|static
name|struct
name|tree_binding
modifier|*
name|source
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|source
operator|=
operator|(
expr|struct
name|tree_binding
operator|*
operator|)
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
operator|*
name|node
operator|=
operator|*
name|source
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
operator|(
name|tree
operator|)
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tree
operator|)
name|node
return|;
block|}
end_function

begin_function
name|int
name|count_functions
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|359
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_overloaded_fn
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* XXX A baselink is also considered an overloaded function.      As is a placeholder from push_class_decls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
operator|||
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|388
argument_list|)
expr_stmt|;
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|)
return|;
block|}
end_function

begin_function
name|int
name|really_overloaded_fn
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* A baselink is also considered an overloaded function.      This might also be an ambiguous class member. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|tree
name|get_first_fn
parameter_list|(
name|from
parameter_list|)
name|tree
name|from
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|from
argument_list|)
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* A baselink is also considered an overloaded function. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|from
operator|=
name|TREE_VALUE
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|OVL_CURRENT
argument_list|(
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new OVL node, concatenating it with the old one. */
end_comment

begin_function
name|tree
name|ovl_cons
parameter_list|(
name|decl
parameter_list|,
name|chain
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|result
init|=
name|make_node
argument_list|(
name|OVERLOAD
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|OVL_FUNCTION
argument_list|(
name|result
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|result
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Same as ovl_cons, but on the scratch_obstack. */
end_comment

begin_function
name|tree
name|scratch_ovl_cons
parameter_list|(
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|expression_obstack
decl_stmt|;
name|current_obstack
operator|=
name|expression_obstack
expr_stmt|;
name|node
operator|=
name|ovl_cons
argument_list|(
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Build a new overloaded function. If this is the first one,    just return it; otherwise, ovl_cons the _DECLs */
end_comment

begin_function
name|tree
name|build_overload
parameter_list|(
name|decl
parameter_list|,
name|chain
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|chain
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chain
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|chain
operator|=
name|ovl_cons
argument_list|(
name|chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|chain
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff functions are equivalent. Equivalent functions are    not identical only if one is a function-local extern function.    This assumes that function-locals don't have TREE_PERMANENT.  */
end_comment

begin_function
specifier|static
name|int
name|equal_functions
parameter_list|(
name|fn1
parameter_list|,
name|fn2
parameter_list|)
name|tree
name|fn1
decl_stmt|;
name|tree
name|fn2
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|fn1
argument_list|)
operator|||
operator|!
name|TREE_PERMANENT
argument_list|(
name|fn2
argument_list|)
condition|)
return|return
name|decls_match
argument_list|(
name|fn1
argument_list|,
name|fn2
argument_list|)
return|;
return|return
name|fn1
operator|==
name|fn2
return|;
block|}
end_function

begin_comment
comment|/* True if fn is in ovl. */
end_comment

begin_function
name|int
name|ovl_member
parameter_list|(
name|fn
parameter_list|,
name|ovl
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|ovl
decl_stmt|;
block|{
if|if
condition|(
name|ovl
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ovl
argument_list|)
operator|!=
name|OVERLOAD
condition|)
return|return
name|equal_functions
argument_list|(
name|ovl
argument_list|,
name|fn
argument_list|)
return|;
for|for
control|(
init|;
name|ovl
condition|;
name|ovl
operator|=
name|OVL_CHAIN
argument_list|(
name|ovl
argument_list|)
control|)
if|if
condition|(
name|equal_functions
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|ovl
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_aggr_type_2
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|t2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PRINT_RING_SIZE
value|4
end_define

begin_function
name|char
modifier|*
name|lang_printable_name
parameter_list|(
name|decl
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
specifier|static
name|tree
name|decl_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|print_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|int
name|ring_counter
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Only cache functions.  */
if|if
condition|(
name|v
operator|<
literal|2
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|lang_decl_name
argument_list|(
name|decl
argument_list|,
name|v
argument_list|)
return|;
comment|/* See if this print name is lying around.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PRINT_RING_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|decl_ring
index|[
name|i
index|]
operator|==
name|decl
condition|)
comment|/* yes, so return it.  */
return|return
name|print_ring
index|[
name|i
index|]
return|;
if|if
condition|(
operator|++
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|ring_counter
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|my_friendly_abort
argument_list|(
literal|106
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_ring
index|[
name|ring_counter
index|]
condition|)
name|free
argument_list|(
name|print_ring
index|[
name|ring_counter
index|]
argument_list|)
expr_stmt|;
name|print_ring
index|[
name|ring_counter
index|]
operator|=
name|xstrdup
argument_list|(
name|lang_decl_name
argument_list|(
name|decl
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|decl_ring
index|[
name|ring_counter
index|]
operator|=
name|decl
expr_stmt|;
return|return
name|print_ring
index|[
name|ring_counter
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions    listed in RAISES.  */
end_comment

begin_function
name|tree
name|build_exception_variant
parameter_list|(
name|type
parameter_list|,
name|raises
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
name|tree
name|v
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
control|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|v
argument_list|)
operator|!=
name|constp
operator|||
name|TYPE_VOLATILE
argument_list|(
name|v
argument_list|)
operator|!=
name|volatilep
condition|)
continue|continue;
comment|/* @@ This should do set equality, not exact match.  */
if|if
condition|(
name|simple_cst_list_equal
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
argument_list|,
name|raises
argument_list|)
condition|)
comment|/* List of exceptions raised matches previously found list.  	   @@ Nice to free up storage used in consing up the 	   @@ list of exceptions raised.  */
return|return
name|v
return|;
block|}
comment|/* Need to build a new variant.  */
name|v
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|raises
argument_list|)
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|raises
operator|=
name|copy_list
argument_list|(
name|raises
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
operator|=
name|raises
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given a TEMPLATE_TEMPLATE_PARM node T, create a new one together with its     lang_specific field and its corresponding TEMPLATE_DECL node */
end_comment

begin_function
name|tree
name|copy_template_template_parm
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|template
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|make_lang_type
argument_list|(
name|TEMPLATE_TEMPLATE_PARM
argument_list|)
decl_stmt|;
name|template
operator|=
name|copy_node
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
operator|=
name|t2
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
operator|=
name|template
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t2
argument_list|)
operator|=
name|template
expr_stmt|;
comment|/* No need to copy these */
name|TYPE_FIELDS
argument_list|(
name|t2
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t2
argument_list|)
operator|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t2
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of copy_to_permanent     Assuming T is a node build bottom-up, make it all exist on    permanent obstack, if it is not permanent already.  */
end_comment

begin_function_decl
name|tree
name|mapcar
parameter_list|(
name|t
parameter_list|,
name|func
parameter_list|)
name|tree
name|t
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|t
return|;
if|if
condition|(
name|tmp
operator|=
name|func
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
operator|!=
name|NULL_TREE
condition|)
return|return
name|tmp
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|CONST_DECL
case|:
comment|/* Rather than aborting, return error_mark_node.  This allows us 	 to report a sensible error message on code like this:  	 void g() { int i; f<i>(7); }            In a case like:             void g() { const int i = 7; f<i>(7); }  	 however, we must actually return the constant initializer.  */
name|tmp
operator|=
name|decl_constant_value
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|t
condition|)
return|return
name|mapcar
argument_list|(
name|tmp
argument_list|,
name|func
argument_list|)
return|;
else|else
return|return
name|error_mark_node
return|;
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|chain
init|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|chain
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|chain
init|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|chain
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|OVERLOAD
case|:
block|{
name|tree
name|chain
init|=
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|chain
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|TREE_VEC
case|:
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|len
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|len
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|copy_node
argument_list|(
name|t
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|AGGR_INIT_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|SAVE_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|SCOPE_REF
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|CALL_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* tree.def says that operand two is RTL, but 	 build_call_declarator puts trees in there.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
else|else
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|t
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|POINTER_TYPE
case|:
name|tmp
operator|=
name|build_pointer_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|REFERENCE_TYPE
case|:
name|tmp
operator|=
name|build_reference_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
name|tmp
operator|=
name|build_function_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
name|tmp
operator|=
name|build_cplus_array_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
name|tmp
operator|=
name|build_index_type
argument_list|(
name|mapcar
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
name|tmp
operator|=
name|build_offset_type
argument_list|(
name|mapcar
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
name|tmp
operator|=
name|build_cplus_method_type
argument_list|(
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|,
name|mapcar
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|CONSTRUCTOR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
operator|=
name|mapcar
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
return|return
name|copy_template_template_parm
argument_list|(
name|t
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|t
return|;
case|case
name|NEW_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|mapcar
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|build_ptrmemfunc_type
argument_list|(
name|mapcar
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|func
argument_list|)
argument_list|)
return|;
comment|/* else fall through */
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|sorry
argument_list|(
literal|"initializer contains unrecognized tree code"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|107
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_block

begin_function
specifier|static
name|tree
name|perm_manip
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Support `void f () { extern int i; A<&i> a; }' */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* copy_rtx won't make a new SYMBOL_REF, so call make_decl_rtl again.  */
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|t
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Assuming T is a node built bottom-up, make it all exist on    permanent obstack, if it is not permanent already.  */
end_comment

begin_function
name|tree
name|copy_to_permanent
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|t
operator|=
name|mapcar
argument_list|(
name|t
argument_list|,
name|perm_manip
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|depth_reached
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_lang_statistics
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|decl_obstack
decl_stmt|;
name|print_obstack_statistics
argument_list|(
literal|"class_obstack"
argument_list|,
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
name|print_obstack_statistics
argument_list|(
literal|"decl_obstack"
argument_list|,
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
name|print_search_statistics
argument_list|()
expr_stmt|;
name|print_class_statistics
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maximum template instantiation depth reached: %d\n"
argument_list|,
name|depth_reached
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is used by the `assert' macro.  It is provided in libgcc.a,    which `cc' doesn't know how to link.  Note that the C++ front-end    no longer actually uses the `assert' macro (instead, it calls    my_friendly_assert).  But all of the back-end files still need this.  */
end_comment

begin_function
name|void
name|__eprintf
parameter_list|(
name|string
parameter_list|,
name|expression
parameter_list|,
name|line
parameter_list|,
name|filename
parameter_list|)
ifdef|#
directive|ifdef
name|__STDC__
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|expression
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|expression
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|expression
argument_list|,
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for TYPE    (which is an ARRAY_TYPE).  This counts only elements of the top    array.  */
end_comment

begin_function
name|tree
name|array_type_nelts_top
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for TYPE    (which is an ARRAY_TYPE).  This one is a recursive count of all    ARRAY_TYPEs that are clumped together.  */
end_comment

begin_function
name|tree
name|array_type_nelts_total
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|sz
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|n
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|sz
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|sz
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|bot_manip
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AGGR_INIT_EXPR
condition|)
block|{
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|break_out_target_exprs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Actually, we'll just clean out the target exprs for the moment.  */
end_comment

begin_function
name|tree
name|break_out_target_exprs
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|mapcar
argument_list|(
name|t
argument_list|,
name|bot_manip
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Obstack used for allocating nodes in template function and variable    definitions.  */
end_comment

begin_comment
comment|/* Similar to `build_nt', except we build    on the permanent_obstack, regardless.  */
end_comment

begin_decl_stmt
name|tree
name|build_min_nt
name|VPROTO
argument_list|(
operator|(
expr|enum
name|tree_code
name|code
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|enum
name|tree_code
name|code
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|expression_obstack
decl_stmt|;
name|va_list
name|p
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|VA_START
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expression_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|x
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expression_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Similar to `build', except we build    on the permanent_obstack, regardless.  */
end_comment

begin_decl_stmt
name|tree
name|build_min
name|VPROTO
argument_list|(
operator|(
expr|enum
name|tree_code
name|code
operator|,
name|tree
name|tt
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|tt
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|expression_obstack
decl_stmt|;
name|va_list
name|p
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|VA_START
argument_list|(
name|p
argument_list|,
name|tt
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
name|tt
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expression_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|x
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expression_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as `tree_cons' but make a permanent object.  */
end_comment

begin_function
name|tree
name|min_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|node
operator|=
name|tree_cons
argument_list|(
name|copy_to_permanent
argument_list|(
name|purpose
argument_list|)
argument_list|,
name|copy_to_permanent
argument_list|(
name|value
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
name|tree
name|get_type_decl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
return|return
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
return|;
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
comment|/* Stop compiler from complaining control reaches end of non-void function.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|can_free
parameter_list|(
name|obstack
parameter_list|,
name|t
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|size
operator|=
operator|(
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((x + obstack_alignment_mask (obstack)) \& ~ obstack_alignment_mask (obstack))
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|t
operator|+
name|ROUND
argument_list|(
name|size
argument_list|)
operator|==
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
condition|)
return|return
literal|1
return|;
undef|#
directive|undef
name|ROUND
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return first vector element whose BINFO_TYPE is ELEM.    Return 0 if ELEM is not in VEC.  VEC may be NULL_TREE.  */
end_comment

begin_function
name|tree
name|vec_binfo_member
parameter_list|(
name|elem
parameter_list|,
name|vec
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|vec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vec
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|elem
argument_list|,
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Kludge around the fact that DECL_CONTEXT for virtual functions returns    the wrong thing for decl_function_context.  Hopefully the uses in the    backend won't matter, since we don't need a static chain for local class    methods.  FIXME!  */
end_comment

begin_function
name|tree
name|hack_decl_function_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|decl_function_context
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T1 is the same tree structure as T2.    Return 1 if they are the same.    Return 0 if they are understandably different.    Return -1 if either contains tree structure not understood by    this function.  */
end_comment

begin_function
name|int
name|cp_tree_equal
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|NOP_EXPR
operator|||
name|code1
operator|==
name|CONVERT_EXPR
operator|||
name|code1
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|cp_tree_equal
argument_list|(
name|t1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code1
operator|!=
name|code2
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* We need to do this when determining whether or not two 	 non-type pointer to member function template arguments 	 are the same.  */
if|if
condition|(
operator|!
operator|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
comment|/* The first operand is RTL.  */
operator|&&
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_list_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
comment|/* Special case: if either target is an unallocated VAR_DECL, 	 it means that it's going to be unified with whatever the 	 TARGET_EXPR is really supposed to initialize, so treat it 	 as being equivalent to anything.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|cmp
operator|=
literal|1
expr_stmt|;
else|else
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
return|return
literal|0
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
return|return
name|TEMPLATE_PARM_IDX
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_PARM_IDX
argument_list|(
name|t2
argument_list|)
operator|&&
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
return|return
name|comptypes
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
name|cmp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code1
index|]
condition|;
operator|++
name|i
control|)
block|{
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
block|}
return|return
name|cmp
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similar to make_tree_vec, but build on a temporary obstack.  */
end_comment

begin_function
name|tree
name|make_temp_vec
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
name|expression_obstack
expr_stmt|;
name|node
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Build a wrapper around some pointer PTR so we can use it as a tree.  */
end_comment

begin_function
name|tree
name|build_ptr_wrapper
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|WRAPPER
argument_list|)
decl_stmt|;
name|WRAPPER_PTR
argument_list|(
name|t
argument_list|)
operator|=
name|ptr
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Same, but on the expression_obstack.  */
end_comment

begin_function
name|tree
name|build_expr_ptr_wrapper
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|push_expression_obstack
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_ptr_wrapper
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a wrapper around some integer I so we can use it as a tree.  */
end_comment

begin_function
name|tree
name|build_int_wrapper
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|WRAPPER
argument_list|)
decl_stmt|;
name|WRAPPER_INT
argument_list|(
name|t
argument_list|)
operator|=
name|i
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_srcloc
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* Make sure that we put these on the permanent obstack; up in      add_pending_template, we pass this return value into perm_tree_cons,      which also puts it on the permanent_obstack.  However, this wasn't      explicitly doing the same.  */
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|SRCLOC
argument_list|)
expr_stmt|;
name|SRCLOC_FILE
argument_list|(
name|t
argument_list|)
operator|=
name|file
expr_stmt|;
name|SRCLOC_LINE
argument_list|(
name|t
argument_list|)
operator|=
name|line
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_srcloc_here
parameter_list|()
block|{
return|return
name|build_srcloc
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|push_expression_obstack
parameter_list|()
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|current_obstack
operator|=
name|expression_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The type of ARG when used as an lvalue.  */
end_comment

begin_function
name|tree
name|lvalue_type
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|type
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The type of ARG for printing error messages; denote lvalues with    reference types.  */
end_comment

begin_function
name|tree
name|error_type
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
name|type
operator|=
name|build_reference_type
argument_list|(
name|lvalue_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Does FUNCTION use a variable-length argument list?  */
end_comment

begin_function
name|int
name|varargs_function_p
parameter_list|(
name|function
parameter_list|)
name|tree
name|function
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if decl is a member of a class.  */
end_comment

begin_function
name|int
name|member_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|ctx
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
return|return
operator|(
name|ctx
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|)
return|;
block|}
end_function

end_unit

