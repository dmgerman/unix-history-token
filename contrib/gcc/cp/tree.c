begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-dependent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_decl_stmt
specifier|static
name|tree
name|bot_manip
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|bot_replace
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_cplus_array_type_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|list_hash_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|list_hash_pieces
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|list_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cp_lvalue_kind
name|lvalue_p_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|no_linkage_helper
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_srcloc
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|mark_local_for_remap_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|cp_unsave_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_unsave
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_target_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|count_trees_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|verify_stmt_tree_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|find_tree_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cp_statement_code_p
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_java_interface_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_com_interface_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|handle_init_priority_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If REF is an lvalue, returns the kind of lvalue that REF is.    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is    non-zero, rvalues of class type are considered lvalues.  */
end_comment

begin_function
specifier|static
name|cp_lvalue_kind
name|lvalue_p_1
parameter_list|(
name|ref
parameter_list|,
name|treat_class_rvalues_as_lvalues
parameter_list|)
name|tree
name|ref
decl_stmt|;
name|int
name|treat_class_rvalues_as_lvalues
decl_stmt|;
block|{
name|cp_lvalue_kind
name|op1_lvalue_kind
init|=
name|clk_none
decl_stmt|;
name|cp_lvalue_kind
name|op2_lvalue_kind
init|=
name|clk_none
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|clk_ordinary
return|;
if|if
condition|(
name|ref
operator|==
name|current_class_ptr
condition|)
return|return
name|clk_none
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|/* preincrements and predecrements are valid lvals, provided 	 what they refer to are valid lvals.  */
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|UNSAVE_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
comment|/* This shouldn't be here, but there are lots of places in the compiler          that are sloppy about tacking on NOP_EXPRs to the same type when 	 no actual conversion is happening.  */
case|case
name|NOP_EXPR
case|:
return|return
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
name|op1_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1_lvalue_kind
comment|/* The "field" can be a FUNCTION_DECL or an OVERLOAD in some 	     situations.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Clear the ordinary bit.  If this object was a class 	     rvalue we want to preserve that information.  */
name|op1_lvalue_kind
operator|&=
operator|~
name|clk_ordinary
expr_stmt|;
comment|/* The lvalue is for a btifield.  */
name|op1_lvalue_kind
operator||=
name|clk_bitfield
expr_stmt|;
block|}
return|return
name|op1_lvalue_kind
return|;
case|case
name|STRING_CST
case|:
return|return
name|clk_ordinary
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
name|clk_none
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
name|clk_ordinary
return|;
break|break;
comment|/* A currently unresolved scope ref.  */
case|case
name|SCOPE_REF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|OFFSET_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|clk_ordinary
return|;
comment|/* Fall through.  */
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
name|op1_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
name|op2_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|op1_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
name|op2_lvalue_kind
operator|=
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
return|return
name|clk_ordinary
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|lvalue_p_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|treat_class_rvalues_as_lvalues
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
return|return
name|treat_class_rvalues_as_lvalues
condition|?
name|clk_class
else|:
name|clk_none
return|;
case|case
name|CALL_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
return|return
operator|(
operator|(
name|treat_class_rvalues_as_lvalues
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|)
condition|?
name|clk_class
else|:
name|clk_none
operator|)
return|;
case|case
name|FUNCTION_DECL
case|:
comment|/* All functions (except non-static-member functions) are 	 lvalues.  */
return|return
operator|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|ref
argument_list|)
condition|?
name|clk_none
else|:
name|clk_ordinary
operator|)
return|;
default|default:
break|break;
block|}
comment|/* If one operand is not an lvalue at all, then this expression is      not an lvalue.  */
if|if
condition|(
operator|!
name|op1_lvalue_kind
operator|||
operator|!
name|op2_lvalue_kind
condition|)
return|return
name|clk_none
return|;
comment|/* Otherwise, it's an lvalue, and it has all the odd properties      contributed by either operand.  */
name|op1_lvalue_kind
operator|=
name|op1_lvalue_kind
operator||
name|op2_lvalue_kind
expr_stmt|;
comment|/* It's not an ordinary lvalue if it involves either a bit-field or      a class rvalue.  */
if|if
condition|(
operator|(
name|op1_lvalue_kind
operator|&
operator|~
name|clk_ordinary
operator|)
operator|!=
name|clk_none
condition|)
name|op1_lvalue_kind
operator|&=
operator|~
name|clk_ordinary
expr_stmt|;
return|return
name|op1_lvalue_kind
return|;
block|}
end_function

begin_comment
comment|/* If REF is an lvalue, returns the kind of lvalue that REF is.    Otherwise, returns clk_none.  Lvalues can be assigned, unless they    have TREE_READONLY, or unless they are FUNCTION_DECLs.  Lvalues can    have their address taken, unless they have DECL_REGISTER.  */
end_comment

begin_function
name|cp_lvalue_kind
name|real_lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
return|return
name|lvalue_p_1
argument_list|(
name|ref
argument_list|,
comment|/*treat_class_rvalues_as_lvalues=*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This differs from real_lvalue_p in that class rvalues are    considered lvalues.  */
end_comment

begin_function
name|int
name|lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
return|return
operator|(
name|lvalue_p_1
argument_list|(
name|ref
argument_list|,
comment|/*treat_class_rvalues_as_lvalues=*/
literal|1
argument_list|)
operator|!=
name|clk_none
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|ref
parameter_list|,
name|string
parameter_list|)
name|tree
name|ref
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|error
argument_list|(
literal|"non-lvalue in %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_target_expr
parameter_list|(
name|decl
parameter_list|,
name|value
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build
argument_list|(
name|TARGET_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|value
argument_list|,
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We always set TREE_SIDE_EFFECTS so that expand_expr does not      ignore the TARGET_EXPR.  If there really turn out to be no      side-effects, then the optimizer should be able to get rid of      whatever code is generated anyhow.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* INIT is a CALL_EXPR which needs info about its target.    TYPE is the type that this initialization should appear to have.     Build an encapsulation of the initialization to perform    and return it so that it can be processed by language-independent    and language-specific expression expanders.  */
end_comment

begin_function
name|tree
name|build_cplus_new
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|slot
decl_stmt|;
name|tree
name|rval
decl_stmt|;
comment|/* Make sure that we're not trying to create an instance of an      abstract class.  */
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|AGGR_INIT_EXPR
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
return|;
name|slot
operator|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|slot
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|layout_decl
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We split the CALL_EXPR into its function and its arguments here.      Then, in expand_expr, we put them back together.  The reason for      this is that this expression might be a default argument      expression.  In that case, we need a new temporary every time the      expression is used.  That's what break_out_target_exprs does; it      replaces every AGGR_INIT_EXPR with a copy that uses a fresh      temporary slot.  Then, expand_expr builds up a call-expression      using the new slot.  */
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|AGGR_INIT_EXPR
argument_list|,
name|type
argument_list|,
name|fn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|rval
argument_list|)
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|rval
operator|=
name|build_target_expr
argument_list|(
name|slot
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Buidl a TARGET_EXPR using INIT to initialize a new temporary of the    indicated TYPE.  */
end_comment

begin_function
name|tree
name|build_target_expr_with_type
parameter_list|(
name|init
parameter_list|,
name|type
parameter_list|)
name|tree
name|init
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|slot
decl_stmt|;
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
return|return
name|init
return|;
name|slot
operator|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|slot
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|layout_decl
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_target_expr
argument_list|(
name|slot
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like build_target_expr_with_type, but use the type of INIT.  */
end_comment

begin_function
name|tree
name|get_target_expr
parameter_list|(
name|init
parameter_list|)
name|tree
name|init
decl_stmt|;
block|{
return|return
name|build_target_expr_with_type
argument_list|(
name|init
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recursively perform a preorder search EXP for CALL_EXPRs, making    copies where they are found.  Returns a deep copy all nodes transitively    containing CALL_EXPRs.  */
end_comment

begin_function
name|tree
name|break_out_calls
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
decl_stmt|,
name|t2
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
return|return
name|exp
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Don't try and defeat a save_expr, as it should only be done once.  */
if|if
condition|(
name|code
operator|==
name|SAVE_EXPR
condition|)
return|return
name|exp
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'c'
case|:
comment|/* a constant */
case|case
literal|'t'
case|:
comment|/* a type node */
case|case
literal|'x'
case|:
comment|/* something random, like an identifier or an ERROR_MARK.  */
return|return
name|exp
return|;
case|case
literal|'d'
case|:
comment|/* A decl node */
if|#
directive|if
literal|0
comment|/* This is bogus.  jason 9/21/94 */
block|t1 = break_out_calls (DECL_INITIAL (exp));       if (t1 != DECL_INITIAL (exp)) 	{ 	  exp = copy_node (exp); 	  DECL_INITIAL (exp) = t1; 	}
endif|#
directive|endif
return|return
name|exp
return|;
case|case
literal|'b'
case|:
comment|/* A block node */
block|{
comment|/* Don't know how to handle these correctly yet.   Must do a 	   break_out_calls on all DECL_INITIAL values for local variables, 	   and also break_out_calls on all sub-blocks and sub-statements.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|exp
return|;
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
for|for
control|(
name|i
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|t1
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|exp
operator|=
name|copy_node
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
block|}
return|return
name|exp
return|;
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
name|t2
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
name|t1
operator|=
name|break_out_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|1
condition|)
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t1
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments are described by ARGTYPES and whose values    are described by RETTYPE.  If each type exists already, reuse it.  */
end_comment

begin_function
name|tree
name|build_cplus_method_type
parameter_list|(
name|basetype
parameter_list|,
name|rettype
parameter_list|,
name|argtypes
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|rettype
decl_stmt|,
name|argtypes
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|tree
name|ptype
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rettype
expr_stmt|;
name|ptype
operator|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* The actual arglist for this function includes a "hidden" argument      which is "this".  Put it into the list of argument types.  */
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptype
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|argtypes
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|argtypes
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark first argtype as "artificial".  */
comment|/* If we already have such a type, use the old one and free this one.      Note that it also frees up the above cons cell if found.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|rettype
argument_list|)
operator|+
name|type_hash_list
argument_list|(
name|argtypes
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_cplus_array_type_1
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|elt_type
operator|==
name|error_mark_node
operator|||
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
operator|||
name|uses_template_parms
argument_list|(
name|elt_type
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|index_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|elt_type
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|=
name|index_type
expr_stmt|;
block|}
else|else
name|t
operator|=
name|build_array_type
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* Push these needs up so that initialization takes place      more easily.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_cplus_array_type
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|type_quals
init|=
name|cp_type_quals
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|elt_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|elt_type
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_cplus_array_type_1
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|t
operator|=
name|cp_build_qualified_type
argument_list|(
name|t
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles    arrays correctly.  In particular, if TYPE is an array of T's, and    TYPE_QUALS is non-empty, returns an array of qualified T's.  If    at attempt is made to qualify a type illegally, and COMPLAIN is    non-zero, an error is issued.  If COMPLAIN is zero, error_mark_node    is returned.  */
end_comment

begin_function
name|tree
name|cp_build_qualified_type_real
parameter_list|(
name|type
parameter_list|,
name|type_quals
parameter_list|,
name|complain
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|type
return|;
if|if
condition|(
name|type_quals
operator|==
name|cp_type_quals
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* A restrict-qualified pointer type must be a pointer (or reference)      to object or incomplete type.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
operator|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"`%T' cannot be `restrict'-qualified"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
return|return
name|error_mark_node
return|;
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_RESTRICT
expr_stmt|;
block|}
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"`%T' cannot be `const'-, `volatile'-, or `restrict'-qualified"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
return|return
name|error_mark_node
return|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* In C++, the qualification really applies to the array element 	 type.  Obtain the appropriately qualified element type.  */
name|tree
name|t
decl_stmt|;
name|tree
name|element_type
init|=
name|cp_build_qualified_type_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|element_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* See if we already have an identically qualified type.  */
name|t
operator|=
name|get_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
comment|/* If we didn't already have it, create it now.  */
if|if
condition|(
operator|!
name|t
condition|)
block|{
comment|/* Make a new array type, just like the old one, but with the 	     appropriately qualified element type.  */
name|t
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|element_type
expr_stmt|;
block|}
comment|/* Even if we already had this variant, we update 	 TYPE_NEEDS_CONSTRUCTING and TYPE_HAS_NONTRIVIAL_DESTRUCTOR in case 	 they changed since the variant was originally created.   	  	 This seems hokey; if there is some way to use a previous 	 variant *without* coming through here, 	 TYPE_NEEDS_CONSTRUCTING will never be updated.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|element_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|element_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* For a pointer-to-member type, we can't just return a 	 cv-qualified version of the RECORD_TYPE.  If we do, we 	 haven't change the field that contains the actual pointer to 	 a method, and so TYPE_PTRMEMFUNC_FN_TYPE will be wrong.  */
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|t
argument_list|,
name|type_quals
argument_list|,
name|complain
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc_type
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* Retrieve (or create) the appropriately qualified variant.  */
name|result
operator|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
comment|/* If this was a pointer-to-method type, and we just made a copy,      then we need to clear the cached associated      pointer-to-member-function type; it is not valid for the new      type.  */
if|if
condition|(
name|result
operator|!=
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|TYPE_SET_PTRMEMFUNC_TYPE
argument_list|(
name|result
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns the canonical version of TYPE.  In other words, if TYPE is    a typedef, returns the underlying type.  The cv-qualification of    the type returned matches the type input; they will always be    compatible types.  */
end_comment

begin_function
name|tree
name|canonical_type_variant
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|cp_build_qualified_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Makes new binfos for the indirect bases under BINFO, and updates    BINFO_OFFSET for them and their bases.  */
end_comment

begin_function
name|void
name|unshare_base_binfos
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|new_binfo
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|binfos
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* Now unshare the structure beneath BINFO.  */
for|for
control|(
name|j
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|new_binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|base_binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|unshare_base_binfos
argument_list|(
name|new_binfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hashing of lists so that we don't make duplicates.    The entry point is `list_hash_canon'.  */
end_comment

begin_comment
comment|/* Now here is the hash table.  When recording a list, it is added    to the slot whose index is the hash code mod the table size.    Note that the hash table is used for several kinds of lists.    While all these live in the same table, they are completely independent,    and the hash code is computed differently for each of these.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|list_hash_table
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|list_proxy
block|{
name|tree
name|purpose
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compare ENTRY (an entry in the hash table) with DATA (a list_proxy    for a node we are thinking about adding).  */
end_comment

begin_function
specifier|static
name|int
name|list_hash_eq
parameter_list|(
name|entry
parameter_list|,
name|data
parameter_list|)
specifier|const
name|void
modifier|*
name|entry
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|entry
decl_stmt|;
name|struct
name|list_proxy
modifier|*
name|proxy
init|=
operator|(
expr|struct
name|list_proxy
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|proxy
operator|->
name|value
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|proxy
operator|->
name|purpose
operator|&&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|proxy
operator|->
name|chain
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a list (chain of TREE_LIST nodes    with goodies in the TREE_PURPOSE, TREE_VALUE, and bits of the    TREE_COMMON slots), by adding the hash codes of the individual entries.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|list_hash_pieces
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|hashval_t
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chain
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1007
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1009
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Hash an already existing TREE_LIST.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|list_hash
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|p
decl_stmt|;
return|return
name|list_hash_pieces
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given list components PURPOSE, VALUE, AND CHAIN, return the canonical    object for an identical list if one already exists.  Otherwise, build a    new one, and record it as the canonical object.  */
end_comment

begin_function
name|tree
name|hash_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
name|struct
name|list_proxy
name|proxy
decl_stmt|;
comment|/* Hash the list node.  */
name|hashcode
operator|=
name|list_hash_pieces
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* Create a proxy for the TREE_LIST we would like to create.  We      don't actually create it so as to avoid creating garbage.  */
name|proxy
operator|.
name|purpose
operator|=
name|purpose
expr_stmt|;
name|proxy
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|proxy
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
comment|/* See if it is already in the table.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|list_hash_table
argument_list|,
operator|&
name|proxy
argument_list|,
name|hashcode
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If not, create a new node.  */
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
operator|*
name|slot
operator|=
operator|(
name|PTR
operator|)
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Constructor for hashed lists.  */
end_comment

begin_function
name|tree
name|hash_tree_chain
parameter_list|(
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
return|return
name|hash_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but used for concatenating two lists.  */
end_comment

begin_function
name|tree
name|hash_chainon
parameter_list|(
name|list1
parameter_list|,
name|list2
parameter_list|)
name|tree
name|list1
decl_stmt|,
name|list2
decl_stmt|;
block|{
if|if
condition|(
name|list2
operator|==
literal|0
condition|)
return|return
name|list1
return|;
if|if
condition|(
name|list1
operator|==
literal|0
condition|)
return|return
name|list2
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
return|;
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|hash_chainon
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an association between TYPE and some parameters:     OFFSET is the offset added to `this' to convert it to a pointer    of type `TYPE *'     BINFO is the base binfo to use, if we are deriving from one.  This    is necessary, as we want specialized parent binfos from base    classes, so that the VTABLE_NAMEs of bases are for the most derived    type, instead of the simple type.     VTABLE is the virtual function table with which to initialize    sub-objects of type TYPE.     VIRTUALS are the virtual functions sitting in VTABLE.  */
end_comment

begin_function
name|tree
name|make_binfo
parameter_list|(
name|offset
parameter_list|,
name|binfo
parameter_list|,
name|vtable
parameter_list|,
name|virtuals
parameter_list|)
name|tree
name|offset
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|vtable
decl_stmt|,
name|virtuals
decl_stmt|;
block|{
name|tree
name|new_binfo
init|=
name|make_tree_vec
argument_list|(
literal|11
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_BINFO
argument_list|(
name|binfo
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|offset
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|vtable
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|virtuals
expr_stmt|;
if|if
condition|(
name|binfo
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|BINFO_BASETYPES
argument_list|(
name|new_binfo
argument_list|)
operator|=
name|copy_node
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_binfo
return|;
block|}
end_function

begin_comment
comment|/* Return a TREE_LIST whose TREE_VALUE nodes along the    BINFO_INHERITANCE_CHAIN for BINFO, but in the opposite order.  In    other words, while the BINFO_INHERITANCE_CHAIN goes from base    classes to derived classes, the reversed path goes from derived    classes to base classes.  */
end_comment

begin_function
name|tree
name|reverse_path
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|reversed_path
decl_stmt|;
name|reversed_path
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|binfo
condition|)
block|{
name|reversed_path
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|binfo
argument_list|,
name|reversed_path
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
return|return
name|reversed_path
return|;
block|}
end_function

begin_function
name|void
name|debug_binfo
parameter_list|(
name|elem
parameter_list|)
name|tree
name|elem
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type \"%s\", offset = "
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nvtable type:\n"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|BINFO_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|elem
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable decl \"%s\"\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|get_vtbl_decl_for_binfo
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no vtable decl yet\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"virtuals:\n"
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [%ld =? %ld]\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|count_functions
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_overloaded_fn
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* A baselink is also considered an overloaded function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|)
return|;
block|}
end_function

begin_function
name|int
name|really_overloaded_fn
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* A baselink is also considered an overloaded function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|tree
name|get_first_fn
parameter_list|(
name|from
parameter_list|)
name|tree
name|from
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|from
argument_list|)
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* A baselink is also considered an overloaded function. */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|TREE_VALUE
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|OVL_CURRENT
argument_list|(
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if T is a ->* or .* expression that refers to a    member function.  */
end_comment

begin_function
name|int
name|bound_pmf_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new OVL node, concatenating it with the old one. */
end_comment

begin_function
name|tree
name|ovl_cons
parameter_list|(
name|decl
parameter_list|,
name|chain
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|result
init|=
name|make_node
argument_list|(
name|OVERLOAD
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|OVL_FUNCTION
argument_list|(
name|result
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|result
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a new overloaded function. If this is the first one,    just return it; otherwise, ovl_cons the _DECLs */
end_comment

begin_function
name|tree
name|build_overload
parameter_list|(
name|decl
parameter_list|,
name|chain
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|chain
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|chain
operator|&&
name|TREE_CODE
argument_list|(
name|chain
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|chain
operator|=
name|ovl_cons
argument_list|(
name|chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|chain
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|is_aggr_type_2
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if CODE is the code for a statement.  */
end_comment

begin_function
name|int
name|cp_statement_code_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SUBOBJECT
case|:
case|case
name|CLEANUP_STMT
case|:
case|case
name|CTOR_STMT
case|:
case|case
name|CTOR_INITIALIZER
case|:
case|case
name|RETURN_INIT
case|:
case|case
name|TRY_BLOCK
case|:
case|case
name|HANDLER
case|:
case|case
name|EH_SPEC_BLOCK
case|:
case|case
name|USING_STMT
case|:
case|case
name|TAG_DEFN
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PRINT_RING_SIZE
value|4
end_define

begin_function
specifier|const
name|char
modifier|*
name|lang_printable_name
parameter_list|(
name|decl
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
specifier|static
name|tree
name|decl_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|print_ring
index|[
name|PRINT_RING_SIZE
index|]
decl_stmt|;
specifier|static
name|int
name|ring_counter
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Only cache functions.  */
if|if
condition|(
name|v
operator|<
literal|2
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|lang_decl_name
argument_list|(
name|decl
argument_list|,
name|v
argument_list|)
return|;
comment|/* See if this print name is lying around.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PRINT_RING_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|decl_ring
index|[
name|i
index|]
operator|==
name|decl
condition|)
comment|/* yes, so return it.  */
return|return
name|print_ring
index|[
name|i
index|]
return|;
if|if
condition|(
operator|++
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|ring_counter
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ring_counter
operator|==
name|PRINT_RING_SIZE
condition|)
name|ring_counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl_ring
index|[
name|ring_counter
index|]
operator|==
name|current_function_decl
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|print_ring
index|[
name|ring_counter
index|]
condition|)
name|free
argument_list|(
name|print_ring
index|[
name|ring_counter
index|]
argument_list|)
expr_stmt|;
name|print_ring
index|[
name|ring_counter
index|]
operator|=
name|xstrdup
argument_list|(
name|lang_decl_name
argument_list|(
name|decl
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|decl_ring
index|[
name|ring_counter
index|]
operator|=
name|decl
expr_stmt|;
return|return
name|print_ring
index|[
name|ring_counter
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions    listed in RAISES.  */
end_comment

begin_function
name|tree
name|build_exception_variant
parameter_list|(
name|type
parameter_list|,
name|raises
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
name|tree
name|v
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|type_quals
init|=
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|v
argument_list|)
operator|==
name|type_quals
operator|&&
name|comp_except_specs
argument_list|(
name|raises
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|v
return|;
comment|/* Need to build a new variant.  */
name|v
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
operator|=
name|raises
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given a TEMPLATE_TEMPLATE_PARM node T, create a new    BOUND_TEMPLATE_TEMPLATE_PARM bound with NEWARGS as its template    arguments.  */
end_comment

begin_function
name|tree
name|bind_template_template_parm
parameter_list|(
name|t
parameter_list|,
name|newargs
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|newargs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|t2
decl_stmt|;
name|t2
operator|=
name|make_aggr_type
argument_list|(
name|BOUND_TEMPLATE_TEMPLATE_PARM
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* These nodes have to be created to reflect new TYPE_DECL and template      arguments.  */
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t2
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TEMPLATE_PARM_DECL
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|t2
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
name|newargs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|t2
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t2
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t2
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|t2
return|;
block|}
end_function

begin_comment
comment|/* Called from count_trees via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|count_trees_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
operator|++
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Debugging function for measuring the rough complexity of a tree    representation.  */
end_comment

begin_function
name|int
name|count_trees
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|n_trees
init|=
literal|0
decl_stmt|;
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|t
argument_list|,
name|count_trees_r
argument_list|,
operator|&
name|n_trees
argument_list|)
expr_stmt|;
return|return
name|n_trees
return|;
block|}
end_function

begin_comment
comment|/* Called from verify_stmt_tree via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|verify_stmt_tree_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|htab_t
modifier|*
name|statements
init|=
operator|(
name|htab_t
operator|*
operator|)
name|data
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|statement_code_p
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this statement is already present in the hash table, then      there is a circularity in the statement tree.  */
if|if
condition|(
name|htab_find
argument_list|(
operator|*
name|statements
argument_list|,
name|t
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
operator|*
name|statements
argument_list|,
name|t
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|t
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Debugging function to check that the statement T has not been    corrupted.  For now, this function simply checks that T contains no    circularities.  */
end_comment

begin_function
name|void
name|verify_stmt_tree
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|htab_t
name|statements
decl_stmt|;
name|statements
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|verify_stmt_tree_r
argument_list|,
operator|&
name|statements
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|statements
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from find_tree via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|find_tree_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|tp
operator|==
operator|(
name|tree
operator|)
name|data
condition|)
return|return
operator|(
name|tree
operator|)
name|data
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns X if X appears in the tree structure rooted at T.  */
end_comment

begin_function
name|tree
name|find_tree
parameter_list|(
name|t
parameter_list|,
name|x
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|x
decl_stmt|;
block|{
return|return
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|t
argument_list|,
name|find_tree_r
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Passed to walk_tree.  Checks for the use of types with no linkage.  */
end_comment

begin_function
specifier|static
name|tree
name|no_linkage_helper
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check if the type T depends on a type with no linkage and if so, return    it.  */
end_comment

begin_function
name|tree
name|no_linkage_check
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
comment|/* There's no point in checking linkage on template functions; we      can't know their complete types.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|NULL_TREE
return|;
name|t
operator|=
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|t
argument_list|,
name|no_linkage_helper
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|depth_reached
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|cxx_print_statistics
parameter_list|()
block|{
name|print_search_statistics
argument_list|()
expr_stmt|;
name|print_class_statistics
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maximum template instantiation depth reached: %d\n"
argument_list|,
name|depth_reached
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for TYPE    (which is an ARRAY_TYPE).  This counts only elements of the top    array.  */
end_comment

begin_function
name|tree
name|array_type_nelts_top
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for TYPE    (which is an ARRAY_TYPE).  This one is a recursive count of all    ARRAY_TYPEs that are clumped together.  */
end_comment

begin_function
name|tree
name|array_type_nelts_total
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|sz
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|n
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|sz
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|sz
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|sz
return|;
block|}
end_function

begin_comment
comment|/* Called from break_out_target_exprs via mapcar.  */
end_comment

begin_function
specifier|static
name|tree
name|bot_manip
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|splay_tree
name|target_remap
init|=
operator|(
operator|(
name|splay_tree
operator|)
name|data
operator|)
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* There can't be any TARGET_EXPRs or their slot variables below          this point.  We used to check !TREE_SIDE_EFFECTS, but then we          failed to copy an ADDR_EXPR of the slot VAR_DECL.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
name|tree
name|u
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AGGR_INIT_EXPR
condition|)
block|{
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|break_out_target_exprs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|build_target_expr_with_type
argument_list|(
name|break_out_target_exprs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Map the old variable to the new one.  */
name|splay_tree_insert
argument_list|(
name|target_remap
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the old expression with the new version.  */
operator|*
name|tp
operator|=
name|u
expr_stmt|;
comment|/* We don't have to go below this point; the recursive call to 	 break_out_target_exprs will have handled anything below this 	 point.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a copy of this node.  */
return|return
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Replace all remapped VAR_DECLs in T with their new equivalents.    DATA is really a splay-tree mapping old variables to new    variables.  */
end_comment

begin_function
specifier|static
name|tree
name|bot_replace
parameter_list|(
name|t
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|splay_tree
name|target_remap
init|=
operator|(
operator|(
name|splay_tree
operator|)
name|data
operator|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|splay_tree_node
name|n
init|=
name|splay_tree_lookup
argument_list|(
name|target_remap
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
operator|*
name|t
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* When we parse a default argument expression, we may create    temporary variables via TARGET_EXPRs.  When we actually use the    default-argument expression, we make a copy of the expression, but    we must replace the temporaries with appropriate local versions.  */
end_comment

begin_function
name|tree
name|break_out_target_exprs
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|static
name|int
name|target_remap_count
decl_stmt|;
specifier|static
name|splay_tree
name|target_remap
decl_stmt|;
if|if
condition|(
operator|!
name|target_remap_count
operator|++
condition|)
name|target_remap
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
comment|/*splay_tree_delete_key_fn=*/
name|NULL
argument_list|,
comment|/*splay_tree_delete_value_fn=*/
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|bot_manip
argument_list|,
name|target_remap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|bot_replace
argument_list|,
name|target_remap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|target_remap_count
condition|)
block|{
name|splay_tree_delete
argument_list|(
name|target_remap
argument_list|)
expr_stmt|;
name|target_remap
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Obstack used for allocating nodes in template function and variable    definitions.  */
end_comment

begin_comment
comment|/* Similar to `build_nt', except that we set TREE_COMPLEXITY to be the    current line number.  */
end_comment

begin_decl_stmt
name|tree
name|build_min_nt
name|VPARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
name|code
operator|,
operator|...
operator|)
argument_list|)
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|x
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Similar to `build', except we set TREE_COMPLEXITY to the current    line-number.  */
end_comment

begin_decl_stmt
name|tree
name|build_min
name|VPARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
name|code
operator|,
name|tree
name|tt
operator|,
operator|...
operator|)
argument_list|)
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|tree
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|x
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Returns an INTEGER_CST (of type `int') corresponding to I.    Multiple calls with the same value of I may or may not yield the    same node; therefore, callers should never modify the node    returned.  */
end_comment

begin_function
name|tree
name|build_shared_int_cst
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|static
name|tree
name|cache
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|256
condition|)
return|return
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|cache
index|[
name|i
index|]
condition|)
name|cache
index|[
name|i
index|]
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cache
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
name|tree
name|get_type_decl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|abort
argument_list|()
expr_stmt|;
comment|/* Stop compiler from complaining control reaches end of non-void function.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return first vector element whose BINFO_TYPE is ELEM.    Return 0 if ELEM is not in VEC.  VEC may be NULL_TREE.  */
end_comment

begin_function
name|tree
name|vec_binfo_member
parameter_list|(
name|elem
parameter_list|,
name|vec
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|vec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vec
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|elem
argument_list|,
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns the namespace that contains DECL, whether directly or    indirectly.  */
end_comment

begin_function
name|tree
name|decl_namespace_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|decl
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T1 is the same tree structure as T2.    Return 1 if they are the same.    Return 0 if they are understandably different.    Return -1 if either contains tree structure not understood by    this function.  */
end_comment

begin_function
name|int
name|cp_tree_equal
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|NOP_EXPR
operator|||
name|code1
operator|==
name|CONVERT_EXPR
operator|||
name|code1
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|cp_tree_equal
argument_list|(
name|t1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code1
operator|!=
name|code2
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* We need to do this when determining whether or not two 	 non-type pointer to member function template arguments 	 are the same.  */
if|if
condition|(
operator|!
operator|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
comment|/* The first operand is RTL.  */
operator|&&
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_list_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
comment|/* Special case: if either target is an unallocated VAR_DECL, 	 it means that it's going to be unified with whatever the 	 TARGET_EXPR is really supposed to initialize, so treat it 	 as being equivalent to anything.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|cmp
operator|=
literal|1
expr_stmt|;
else|else
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
return|return
literal|0
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
return|return
name|TEMPLATE_PARM_IDX
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_PARM_IDX
argument_list|(
name|t2
argument_list|)
operator|&&
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|same_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|PTRMEM_CST
case|:
comment|/* Two pointer-to-members are the same if they point to the same 	 field or function in the same class.  */
return|return
operator|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|t1
argument_list|)
operator|==
name|PTRMEM_CST_MEMBER
argument_list|(
name|t2
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|PTRMEM_CST_CLASS
argument_list|(
name|t1
argument_list|)
argument_list|,
name|PTRMEM_CST_CLASS
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
block|{
name|int
name|i
decl_stmt|;
name|cmp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|code1
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|cmp
operator|=
name|cp_tree_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
block|}
return|return
name|cmp
return|;
block|}
case|case
literal|'t'
case|:
return|return
name|same_type_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Build a wrapper around some pointer PTR so we can use it as a tree.  */
end_comment

begin_function
name|tree
name|build_ptr_wrapper
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|WRAPPER
argument_list|)
decl_stmt|;
name|WRAPPER_PTR
argument_list|(
name|t
argument_list|)
operator|=
name|ptr
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a wrapper around some integer I so we can use it as a tree.  */
end_comment

begin_function
name|tree
name|build_int_wrapper
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|WRAPPER
argument_list|)
decl_stmt|;
name|WRAPPER_INT
argument_list|(
name|t
argument_list|)
operator|=
name|i
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_srcloc
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|SRCLOC
argument_list|)
expr_stmt|;
name|SRCLOC_FILE
argument_list|(
name|t
argument_list|)
operator|=
name|file
expr_stmt|;
name|SRCLOC_LINE
argument_list|(
name|t
argument_list|)
operator|=
name|line
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_srcloc_here
parameter_list|()
block|{
return|return
name|build_srcloc
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The type of ARG when used as an lvalue.  */
end_comment

begin_function
name|tree
name|lvalue_type
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* The type of ARG for printing error messages; denote lvalues with    reference types.  */
end_comment

begin_function
name|tree
name|error_type
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
name|type
operator|=
name|build_reference_type
argument_list|(
name|lvalue_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Does FUNCTION use a variable-length argument list?  */
end_comment

begin_function
name|int
name|varargs_function_p
parameter_list|(
name|function
parameter_list|)
name|tree
name|function
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if decl is a member of a class.  */
end_comment

begin_function
name|int
name|member_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|tree
name|ctx
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
return|return
operator|(
name|ctx
operator|&&
name|TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a placeholder for member access where we don't actually have an    object that the access is against.  */
end_comment

begin_function
name|tree
name|build_dummy_object
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|void_zero_node
argument_list|)
decl_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We've gotten a reference to a member of TYPE.  Return *this if appropriate,    or a dummy object otherwise.  If BINFOP is non-0, it is filled with the    binfo path from current_class_type to TYPE, or 0.  */
end_comment

begin_function
name|tree
name|maybe_dummy_object
parameter_list|(
name|type
parameter_list|,
name|binfop
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
modifier|*
name|binfop
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|context
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
operator|(
name|binfo
operator|=
name|lookup_base
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|context
operator|=
name|current_class_type
expr_stmt|;
else|else
block|{
comment|/* Reference from a nested class member function.  */
name|context
operator|=
name|type
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|binfop
condition|)
operator|*
name|binfop
operator|=
name|binfo
expr_stmt|;
if|if
condition|(
name|current_class_ref
operator|&&
name|context
operator|==
name|current_class_type
condition|)
name|decl
operator|=
name|current_class_ref
expr_stmt|;
else|else
name|decl
operator|=
name|build_dummy_object
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OB is a placeholder object, or a pointer to one.  */
end_comment

begin_function
name|int
name|is_dummy_object
parameter_list|(
name|ob
parameter_list|)
name|tree
name|ob
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|ob
operator|=
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
operator|==
name|void_zero_node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff type T is a POD type, as defined in [basic.types].  */
end_comment

begin_function
name|int
name|pod_type_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|t
operator|=
name|strip_array_types
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* integral, character or enumeral type */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* pointer to non-member */
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* pointer to member object */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* pointer to member function */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* other non-class type (reference or function) */
if|if
condition|(
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Table of valid C++ attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|cp_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"java_interface"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_java_interface_attribute
block|}
block|,
block|{
literal|"com_interface"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_com_interface_attribute
block|}
block|,
block|{
literal|"init_priority"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_init_priority_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle a "java_interface" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_java_interface_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|!
name|TYPE_FOR_JAVA
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' attribute can only be applied to Java class definitions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TYPE_JAVA_INTERFACE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "com_interface" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_com_interface_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
specifier|static
name|int
name|warned
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
operator|||
operator|*
name|node
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute can only be applied to class definitions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|warned
operator|++
condition|)
name|warning
argument_list|(
literal|"`%s' is obsolete; g++ vtables are now COM-compatible by default"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "init_priority" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_init_priority_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|initp_expr
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|initp_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initp_expr
operator|||
name|TREE_CODE
argument_list|(
name|initp_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"requested init_priority is not an integer constant"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|pri
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|initp_expr
argument_list|)
expr_stmt|;
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|)
comment|/* Static objects in functions are initialized the 	 first time control passes through that 	 function. This is not precise enough to pin down an 	 init_priority value, so don't allow it. */
operator|||
name|current_function_decl
condition|)
block|{
name|error
argument_list|(
literal|"can only use `%s' attribute on file-scope definitions of objects of class type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|pri
operator|>
name|MAX_INIT_PRIORITY
operator|||
name|pri
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"requested init_priority is out of range"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check for init_priorities that are reserved for      language and runtime support implementations.*/
if|if
condition|(
name|pri
operator|<=
name|MAX_RESERVED_INIT_PRIORITY
condition|)
block|{
name|warning
argument_list|(
literal|"requested init_priority is reserved for internal use"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUPPORTS_INIT_PRIORITY
condition|)
block|{
name|DECL_INIT_PRIORITY
argument_list|(
name|decl
argument_list|)
operator|=
name|pri
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"`%s' attribute is not supported on this platform"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a new PTRMEM_CST of the indicated TYPE.  The MEMBER is the    thing pointed to by the constant.  */
end_comment

begin_function
name|tree
name|make_ptrmem_cst
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|member
decl_stmt|;
block|{
name|tree
name|ptrmem_cst
init|=
name|make_node
argument_list|(
name|PTRMEM_CST
argument_list|)
decl_stmt|;
comment|/* If would seem a great convenience if make_node would set      TREE_CONSTANT for things of class `c', but it does not.  */
name|TREE_CONSTANT
argument_list|(
name|ptrmem_cst
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ptrmem_cst
argument_list|)
operator|=
name|type
expr_stmt|;
name|PTRMEM_CST_MEMBER
argument_list|(
name|ptrmem_cst
argument_list|)
operator|=
name|member
expr_stmt|;
return|return
name|ptrmem_cst
return|;
block|}
end_function

begin_comment
comment|/* Apply FUNC to all language-specific sub-trees of TP in a pre-order    traversal.  Called from walk_tree().  */
end_comment

begin_function
name|tree
name|cp_walk_subtrees
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees_p
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|,
name|htab
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees_p
decl_stmt|;
name|walk_tree_fn
name|func
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|htab
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
define|#
directive|define
name|WALK_SUBTREE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\       result = walk_tree (&(NODE), func, data, htab);	\       if (result)					\ 	return result;					\     }							\   while (0)
comment|/* Not one of the easy cases.  We must explicitly go through the      children.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DEFAULT_ARG
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|TYPEOF_TYPE
case|:
comment|/* None of thse have subtrees other than those already walked          above.  */
operator|*
name|walk_subtrees_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PTRMEM_CST
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
comment|/* A BASELINK_P's TREE_PURPOSE is a BINFO, and hence circular.  */
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|WALK_SUBTREE
argument_list|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERLOAD
case|:
name|WALK_SUBTREE
argument_list|(
name|OVL_FUNCTION
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|OVL_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|WALK_SUBTREE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* We didn't find what we were looking for.  */
return|return
name|NULL_TREE
return|;
undef|#
directive|undef
name|WALK_SUBTREE
block|}
end_function

begin_comment
comment|/* Decide whether there are language-specific reasons to not inline a    function as a tree.  */
end_comment

begin_function
name|int
name|cp_cannot_inline_tree_fn
parameter_list|(
name|fnp
parameter_list|)
name|tree
modifier|*
name|fnp
decl_stmt|;
block|{
name|tree
name|fn
init|=
operator|*
name|fnp
decl_stmt|;
comment|/* We can inline a template instantiation only if it's fully      instantiated.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
operator|&&
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|fn
operator|=
operator|*
name|fnp
operator|=
name|instantiate_decl
argument_list|(
name|fn
argument_list|,
comment|/*defer_ok=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|varargs_function_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|function_attribute_inlinable_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add any pending functions other than the current function (already    handled by the caller), that thus cannot be inlined, to FNS_P, then    return the latest function added to the array, PREV_FN.  */
end_comment

begin_function
name|tree
name|cp_add_pending_fn_decls
parameter_list|(
name|fns_p
parameter_list|,
name|prev_fn
parameter_list|)
name|void
modifier|*
name|fns_p
decl_stmt|;
name|tree
name|prev_fn
decl_stmt|;
block|{
name|varray_type
modifier|*
name|fnsp
init|=
operator|(
name|varray_type
operator|*
operator|)
name|fns_p
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|scope_chain
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|prev
control|)
if|if
condition|(
name|s
operator|->
name|function_decl
operator|&&
name|s
operator|->
name|function_decl
operator|!=
name|prev_fn
condition|)
block|{
name|VARRAY_PUSH_TREE
argument_list|(
operator|*
name|fnsp
argument_list|,
name|s
operator|->
name|function_decl
argument_list|)
expr_stmt|;
name|prev_fn
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
block|}
return|return
name|prev_fn
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a tree node is an OVERLOAD node.  Used to decide    whether to copy a node or to preserve its chain when inlining a    function.  */
end_comment

begin_function
name|int
name|cp_is_overload_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
return|;
block|}
end_function

begin_comment
comment|/* Determine whether VAR is a declaration of an automatic variable in    function FN.  */
end_comment

begin_function
name|int
name|cp_auto_var_in_fn_p
parameter_list|(
name|var
parameter_list|,
name|fn
parameter_list|)
name|tree
name|var
decl_stmt|,
name|fn
decl_stmt|;
block|{
return|return
operator|(
name|DECL_P
argument_list|(
name|var
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
operator|==
name|fn
operator|&&
name|nonstatic_local_decl_p
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Tell whether a declaration is needed for the RESULT of a function    FN being inlined into CALLER or if the top node of target_exprs is    to be used.  */
end_comment

begin_function
name|tree
name|cp_copy_res_decl_for_inlining
parameter_list|(
name|result
parameter_list|,
name|fn
parameter_list|,
name|caller
parameter_list|,
name|decl_map_
parameter_list|,
name|need_decl
parameter_list|,
name|target_exprs
parameter_list|)
name|tree
name|result
decl_stmt|,
name|fn
decl_stmt|,
name|caller
decl_stmt|;
name|void
modifier|*
name|decl_map_
decl_stmt|;
name|int
modifier|*
name|need_decl
decl_stmt|;
name|void
modifier|*
name|target_exprs
decl_stmt|;
block|{
name|splay_tree
name|decl_map
init|=
operator|(
name|splay_tree
operator|)
name|decl_map_
decl_stmt|;
name|varray_type
modifier|*
name|texps
init|=
operator|(
name|varray_type
operator|*
operator|)
name|target_exprs
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|int
name|aggregate_return_p
decl_stmt|;
comment|/* Figure out whether or not FN returns an aggregate.  */
name|aggregate_return_p
operator|=
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|need_decl
operator|=
operator|!
name|aggregate_return_p
expr_stmt|;
comment|/* If FN returns an aggregate then the caller will always create the      temporary (using a TARGET_EXPR) and the call will be the      initializing expression for the TARGET_EXPR.  If we were just to      create a new VAR_DECL here, then the result of this function      would be copied (bitwise) into the variable initialized by the      TARGET_EXPR.  That's incorrect, so we must transform any      references to the RESULT into references to the target.  */
if|if
condition|(
name|aggregate_return_p
condition|)
block|{
if|if
condition|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
operator|*
name|texps
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|VARRAY_TOP_TREE
argument_list|(
operator|*
name|texps
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Otherwise, make an appropriate copy.  */
else|else
name|var
operator|=
name|copy_decl_for_inlining
argument_list|(
name|result
argument_list|,
name|fn
argument_list|,
name|caller
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|nrv
init|=
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
operator|->
name|x_return_value
decl_stmt|;
if|if
condition|(
name|nrv
condition|)
block|{
comment|/* We have a named return value; copy the name and source 	     position so we can get reasonable debugging information, and 	     register the return variable as its equivalent.  */
name|DECL_NAME
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|nrv
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|nrv
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|var
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Record that we're about to start inlining FN, and return non-zero if    that's OK.  Used for lang_hooks.tree_inlining.start_inlining.  */
end_comment

begin_function
name|int
name|cp_start_inlining
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
return|return
name|push_tinst_level
argument_list|(
name|fn
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Record that we're done inlining FN.  Used for    lang_hooks.tree_inlining.end_inlining.  */
end_comment

begin_function
name|void
name|cp_end_inlining
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
name|pop_tinst_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize tree.c.  */
end_comment

begin_function
name|void
name|init_tree
parameter_list|()
block|{
name|make_lang_type_fn
operator|=
name|cp_make_lang_type
expr_stmt|;
name|lang_unsave
operator|=
name|cp_unsave
expr_stmt|;
name|lang_statement_code_p
operator|=
name|cp_statement_code_p
expr_stmt|;
name|lang_set_decl_assembler_name
operator|=
name|mangle_decl
expr_stmt|;
name|list_hash_table
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|list_hash
argument_list|,
name|list_hash_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|list_hash_table
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|list_hash_table
argument_list|)
argument_list|,
name|mark_tree_hashtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called via walk_tree.  If *TP points to a DECL_STMT for a local    declaration, copies the declaration and enters it in the splay_tree    pointed to by DATA (which is really a `splay_tree *').  */
end_comment

begin_function
specifier|static
name|tree
name|mark_local_for_remap_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|splay_tree
name|st
init|=
operator|(
name|splay_tree
operator|)
name|data
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|DECL_STMT
operator|&&
name|nonstatic_local_decl_p
argument_list|(
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|decl
operator|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_STMT
condition|)
name|decl
operator|=
name|LABEL_STMT_LABEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|nonstatic_local_decl_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CASE_LABEL
condition|)
name|decl
operator|=
name|CASE_LABEL_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|tree
name|copy
decl_stmt|;
comment|/* Make a copy.  */
name|copy
operator|=
name|copy_decl_for_inlining
argument_list|(
name|decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember the copy.  */
name|splay_tree_insert
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|copy
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_tree when an expression is unsaved.  Using the    splay_tree pointed to by ST (which is really a `splay_tree'),    remaps all local declarations to appropriate replacements.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_unsave_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|splay_tree
name|st
init|=
operator|(
name|splay_tree
operator|)
name|data
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Only a local declaration (variable or label).  */
if|if
condition|(
name|nonstatic_local_decl_p
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
comment|/* Lookup the declaration.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* If it's there, remap it.  */
if|if
condition|(
name|n
condition|)
operator|*
name|tp
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|remap_save_expr
argument_list|(
name|tp
argument_list|,
name|st
argument_list|,
name|current_function_decl
argument_list|,
name|walk_subtrees
argument_list|)
expr_stmt|;
else|else
block|{
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do whatever unsaving is required.  */
name|unsave_expr_1
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called by unsave_expr_now whenever an expression (*TP) needs to be    unsaved.  */
end_comment

begin_function
specifier|static
name|void
name|cp_unsave
parameter_list|(
name|tp
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
block|{
name|splay_tree
name|st
decl_stmt|;
comment|/* Create a splay-tree to map old local variable declarations to new      ones.  */
name|st
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk the tree once figuring out what needs to be remapped.  */
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|mark_local_for_remap_r
argument_list|,
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk the tree again, copying, remapping, and unsaving.  */
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|cp_unsave_r
argument_list|,
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the kind of special function that DECL (a FUNCTION_DECL)    is.  Note that this sfk_none is zero, so this function can be used    as a predicate to test whether or not DECL is a special function.  */
end_comment

begin_function
name|special_function_kind
name|special_function_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Rather than doing all this stuff with magic names, we should      probably have a field of type `special_function_kind' in      DECL_LANG_SPECIFIC.  */
if|if
condition|(
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_copy_constructor
return|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_constructor
return|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
operator|==
name|NOP_EXPR
condition|)
return|return
name|sfk_assignment_operator
return|;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_destructor
return|;
if|if
condition|(
name|DECL_COMPLETE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_complete_destructor
return|;
if|if
condition|(
name|DECL_BASE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_base_destructor
return|;
if|if
condition|(
name|DECL_DELETING_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_deleting_destructor
return|;
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|sfk_conversion
return|;
return|return
name|sfk_none
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if TYPE is a character type, including wchar_t.  */
end_comment

begin_function
name|int
name|char_type_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|char_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|type
argument_list|,
name|unsigned_char_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|type
argument_list|,
name|signed_char_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|type
argument_list|,
name|wchar_type_node
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of linkage associated with the indicated DECL.  Th    value returned is as specified by the language standard; it is    independent of implementation details regarding template    instantiation, etc.  For example, it is possible that a declaration    to which this function assigns external linkage would not show up    as a global symbol when you run `nm' on the resulting object file.  */
end_comment

begin_function
name|linkage_kind
name|decl_linkage
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* This function doesn't attempt to calculate the linkage from first      principles as given in [basic.link].  Instead, it makes use of      the fact that we have already set TREE_PUBLIC appropriately, and      then handles a few special cases.  Ideally, we would calculate      linkage first, and then transform that into a concrete      implementation.  */
comment|/* Things that don't have names have no linkage.  */
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_none
return|;
comment|/* Things that are TREE_PUBLIC have external linkage.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_external
return|;
comment|/* Some things that are not TREE_PUBLIC have external linkage, too.      For example, on targets that don't have weak symbols, we make all      template instantiations have internal linkage (in the object      file), but the symbols should still be treated as having external      linkage from the point of view of the language.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_external
return|;
comment|/* Things in local scope do not have linkage, if they don't have      TREE_PUBLIC set.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|lk_none
return|;
comment|/* Everything else has internal linkage.  */
return|return
name|lk_internal
return|;
block|}
end_function

end_unit

