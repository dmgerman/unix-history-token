begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Garbage collection primitives for GNU C++.    Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_function_decl
specifier|extern
name|tree
name|define_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|build_t_desc_overload
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_protect    function.  Args are (class *value, int index); Returns value.  */
end_comment

begin_decl_stmt
name|tree
name|gc_protect_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_unprotect    function.  Args are (int index); void return.  */
end_comment

begin_decl_stmt
name|tree
name|gc_unprotect_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_push    function.  Args are (int length); void return.  */
end_comment

begin_decl_stmt
name|tree
name|gc_push_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_pop    function.  Args are void; void return.  */
end_comment

begin_decl_stmt
name|tree
name|gc_pop_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special integers that are used to represent bits in gc-safe objects.  */
end_comment

begin_decl_stmt
name|tree
name|gc_nonobject
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_visible
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_white
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_offwhite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_grey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_black
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in c-common.c */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|combine_strings
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Predicate that returns non-zero if TYPE needs some kind of    entry for the GC.  Returns zero otherwise.  */
end_comment

begin_function
name|int
name|type_needs_gc_entry
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|ttype
init|=
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|flag_gc
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Aggregate types need gc entries if any of their members      need gc entries.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|binfos
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We don't care about certain pointers.  Pointers 	 to virtual baseclasses are always up front.  We also 	 cull out virtual function table pointers because it's 	 easy, and it simplifies the logic.*/
while|while
condition|(
name|fields
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|||
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
literal|"__bits"
argument_list|)
operator|)
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
while|while
condition|(
name|fields
condition|)
block|{
if|if
condition|(
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
name|binfos
operator|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfos
condition|)
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|type_needs_gc_entry
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|ttype
operator|=
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_RTTI
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Predicate that returns non-zero iff FROM is safe from the GC.        If TO is nonzero, it means we know that FROM is being stored    in TO, which make make it safe.  */
end_comment

begin_function
name|int
name|value_safe_from_gc
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
comment|/* First, return non-zero for easy cases: parameters,      static variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|PARM_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|from
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If something has its address taken, it cannot be      in the heap, so it doesn't need to be protected.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_REFERENCE_EXPR
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If we are storing into a static variable, then what      we store will be safe from the gc.  */
if|if
condition|(
name|to
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|to
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Now recurse on structure of FROM.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
comment|/* These guys are special, and safe.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|||
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* fall through...  */
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
if|if
condition|(
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
comment|/* We can safely pass these things as parameters to functions.  */
if|if
condition|(
name|to
operator|==
literal|0
condition|)
return|return
literal|1
return|;
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|OFFSET_REF
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|METHOD_CALL_EXPR
case|:
break|break;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
if|if
condition|(
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|(
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|RTL_EXPR
case|:
comment|/* Every time we build an RTL_EXPR in the front-end, we must 	 ensure that everything in it is safe from the garbage collector. 	 ??? This has only been done for `build_new'.  */
return|return
literal|1
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|41
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FROM wasn't safe.  But other properties of TO might make it safe.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
comment|/* We already culled out static VAR_DECLs above.  */
return|return
literal|0
return|;
case|case
name|COMPONENT_REF
case|:
comment|/* These guys are special, and safe.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|||
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* fall through...  */
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
return|return
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
return|return
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|,
name|from
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|,
name|from
argument_list|)
operator|&&
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|2
argument_list|)
argument_list|,
name|from
argument_list|)
operator|)
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
comment|/* This used to be 0, but our current restricted model 	 allows this to be 1.  We'll never get arrays this way.  */
return|return
literal|1
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
comment|/* Catch-all case is that TO/FROM is not safe.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to build a static GC entry for DECL.  TYPE is DECL's type.     For objects of type `class *', this is just an entry in the    static vector __PTR_LIST__.     For objects of type `class[]', this requires building an entry    in the static vector __ARR_LIST__.     For aggregates, this records all fields of type `class *'    and `class[]' in the respective lists above.  */
end_comment

begin_function
name|void
name|build_static_gc_entry
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
comment|/* Now, figure out what sort of entry to build.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|assemble_gc_entry
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|ref
init|=
name|get_temp_name
argument_list|(
name|build_reference_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|ref
argument_list|,
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not yet implemented. 	  	 Cons up a static variable that holds address and length info 	 and add that to ___ARR_LIST__.  */
name|my_friendly_abort
argument_list|(
literal|43
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Protect FROM from the GC, assuming FROM is going to be    stored into TO.  We handle three cases for TO here:     case 1: TO is a stack variable.    case 2: TO is zero (which means it is a parameter).    case 3: TO is a return value.  */
end_comment

begin_function
name|tree
name|protect_value_from_gc
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
if|if
condition|(
name|to
operator|==
literal|0
condition|)
block|{
name|tree
name|cleanup
decl_stmt|;
name|to
operator|=
name|get_temp_regvar
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Convert from integer to list form since we'll use it twice.  */
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_function_call
argument_list|(
name|gc_unprotect_fndecl
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_expand_decl_cleanup
argument_list|(
name|to
argument_list|,
name|cleanup
argument_list|)
condition|)
block|{
name|compiler_error
argument_list|(
literal|"cannot unprotect parameter in this scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Should never need to protect a value that's headed for static storage.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|to
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|44
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
case|case
name|INDIRECT_REF
case|:
return|return
name|protect_value_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Because of a cast or a conversion, we might stick 	       a value into a variable that would not normally 	       have a GC entry.  */
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|=
name|size_int
argument_list|(
operator|++
name|current_function_obstack_index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current_function_obstack_usage
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build_function_call
argument_list|(
name|gc_protect_fndecl
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|from
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/* If we fall through the switch, assume we lost.  */
name|my_friendly_abort
argument_list|(
literal|45
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given the expression EXP of type `class *', return the head    of the object pointed to by EXP.  */
end_comment

begin_function
name|tree
name|build_headof
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|vptr
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`headof' applied to non-pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
operator|||
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|exp
return|;
name|vptr
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|vptr
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|,
name|vptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|offset
operator|=
name|build_array_ref
argument_list|(
name|vptr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|build_component_ref
argument_list|(
name|build_array_ref
argument_list|(
name|vptr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_type_variant
argument_list|(
name|ptr_type_node
argument_list|,
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the type_info node associated with the expression EXP.  If EXP is    a reference to a polymorphic class, return the dynamic type; otherwise    return the static type of the expression.  */
end_comment

begin_function
name|tree
name|build_typeid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|flag_rtti
condition|)
name|cp_error
argument_list|(
literal|"cannot take typeid of object when -frtti is not specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Strip top-level cv-qualifiers.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* if b is an instance of B, typeid(b) == typeid(B).  Do this before      reference trickiness.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
return|return
name|get_typeid
argument_list|(
name|type
argument_list|)
return|;
comment|/* peel back references, so they match. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers. */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Apply trivial conversion T -> T& for dereferenced ptrs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If exp is a reference to polymorphic type, get the real type_info.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* build reference to type_info from vtable.  */
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|t
operator|=
name|build_vfn_ref
argument_list|(
operator|(
name|tree
operator|*
operator|)
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_vfn_ref
argument_list|(
operator|(
name|tree
operator|*
operator|)
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|__class_desc_type_node
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* otherwise return the type_info for the static type of the expr.  */
return|return
name|get_typeid
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the type_info object for TYPE, creating it if necessary.  */
end_comment

begin_function
name|tree
name|get_typeid
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|td
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Is it useful (and/or correct) to have different typeids for `T&'      and `T'?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|td
operator|=
name|build_t_desc
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|td
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Get a bad_cast node for the program to throw...     See libstdc++::exception{,.cc} for __bad_cast_object */
end_comment

begin_function
name|tree
name|get_bad_cast_node
parameter_list|()
block|{
specifier|static
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|&&
operator|(
name|t
operator|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__bad_cast_object"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"you must #include<typeinfo>"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working    paper.  */
end_comment

begin_function
name|tree
name|build_dynamic_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|tc
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|exprtype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|ec
init|=
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
decl_stmt|;
name|tree
name|retval
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|tc
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|ec
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|exprtype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ec
operator|=
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ec
operator|!=
name|POINTER_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
break|break;
comment|/* else fall through */
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
break|break;
comment|/* else fall through */
default|default:
goto|goto
name|fail
goto|;
block|}
comment|/* Apply trivial conversion T -> T& for dereferenced ptrs.  */
if|if
condition|(
name|ec
operator|==
name|RECORD_TYPE
condition|)
block|{
name|exprtype
operator|=
name|build_type_variant
argument_list|(
name|exprtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|exprtype
operator|=
name|build_reference_type
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_to_reference
argument_list|(
name|exprtype
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ec
operator|=
name|REFERENCE_TYPE
expr_stmt|;
block|}
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|ec
operator|!=
name|REFERENCE_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* If *type is an unambiguous accessible base class of *exprtype,      convert statically.  */
block|{
name|int
name|distance
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|distance
operator|=
name|get_base_distance
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Otherwise *exprtype must be a polymorphic class (have a vtbl).  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* if TYPE is `void *', return pointer to complete object.  */
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
comment|/* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
return|return
name|build_headof
argument_list|(
name|expr
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|retval
decl_stmt|;
name|tree
name|result
decl_stmt|,
name|td1
decl_stmt|,
name|td2
decl_stmt|,
name|elems
decl_stmt|,
name|tmp1
decl_stmt|,
name|expr1
decl_stmt|;
comment|/* If we got here, we can't convert statically.  Therefore, 	     dynamic_cast<D&>(b) (b an object) cannot succeed.  */
if|if
condition|(
name|ec
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|cp_warning
argument_list|(
literal|"dynamic_cast of `%#D' to `%#T' can never succeed"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|build_throw
argument_list|(
name|get_bad_cast_node
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/* Ditto for dynamic_cast<D*>(&b).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|cp_warning
argument_list|(
literal|"dynamic_cast of `%#D' to `%#T' can never succeed"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
name|expr1
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
name|expr1
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Build run-time conversion.  */
name|expr1
operator|=
name|build_headof
argument_list|(
name|expr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec
operator|==
name|POINTER_TYPE
condition|)
name|td1
operator|=
name|build_typeid
argument_list|(
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|td1
operator|=
name|build_typeid
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
condition|)
name|td2
operator|=
name|get_typeid
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|td2
operator|=
name|get_typeid
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td2
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr1
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_method_call
argument_list|(
name|td1
argument_list|,
name|get_identifier
argument_list|(
literal|"__rtti_match"
argument_list|)
argument_list|,
name|elems
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|expr1
operator|=
name|build_throw
argument_list|(
name|get_bad_cast_node
argument_list|()
argument_list|)
expr_stmt|;
name|expr1
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr1
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|result
argument_list|,
name|result
argument_list|,
name|expr1
argument_list|)
return|;
block|}
comment|/* Now back to the type we want from a void*. */
name|result
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
name|fail
label|:
name|cp_error
argument_list|(
literal|"cannot dynamic_cast `%E' (of type `%#T') to type `%#T'"
argument_list|,
name|expr
argument_list|,
name|exprtype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and initialize various sorts of descriptors.  Every descriptor    node has a name associated with it (the name created by mangling).    For this reason, we use the identifier as our access to the __*_desc    nodes, instead of sticking them directly in the types.  Otherwise we    would burden all built-in types (and pointer types) with slots that    we don't necessarily want to use.     For each descriptor we build, we build a variable that contains    the descriptor's information.  When we need this info at runtime,    all we need is access to these variables.     Note: these constructors always return the address of the descriptor    info, since that is simplest for their mutual interaction.  */
end_comment

begin_function
specifier|static
name|tree
name|build_generic_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|,
name|elems
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|elems
decl_stmt|;
block|{
name|tree
name|init
init|=
name|elems
decl_stmt|;
name|int
name|toplev
init|=
name|global_bindings_p
argument_list|()
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tdecl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|tdecl
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|tdecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_decl
argument_list|(
name|tdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplev
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|tdecl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplev
condition|)
name|pop_from_top_level
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|tdecl
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|DECL_NAME
argument_list|(
name|tdecl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __bltn_desc node.  */
end_comment

begin_function
specifier|static
name|tree
name|build_bltn_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|elems
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_BOOL"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_CHAR"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|short_integer_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_SHORT"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_INT"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_integer_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_LONG"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_long_integer_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_LONGLONG"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_FLOAT"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_DOUBLE"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_LDOUBLE"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|unsigned_char_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_UCHAR"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|short_unsigned_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_USHORT"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|unsigned_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_UINT"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_unsigned_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_ULONG"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_long_unsigned_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_ULONGLONG"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|signed_char_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_SCHAR"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|wchar_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_WCHAR"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|__bltn_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_BI_VOID"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_compiler_error
argument_list|(
literal|"type `%T' not handled as a built-in type"
argument_list|)
expr_stmt|;
block|}
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__bltn_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __user_desc node.  */
end_comment

begin_function
specifier|static
name|tree
name|build_user_desc
parameter_list|(
name|tdecl
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
block|{
name|tree
name|elems
decl_stmt|,
name|name_string
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|tname
init|=
name|DECL_NAME
argument_list|(
name|tdecl
argument_list|)
decl_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|tname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|name_string
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__user_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __class_type_info node. */
end_comment

begin_function
specifier|static
name|tree
name|build_class_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|tname
init|=
name|DECL_NAME
argument_list|(
name|tdecl
argument_list|)
decl_stmt|;
name|tree
name|name_string
decl_stmt|;
name|int
name|i
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|n_base
init|=
name|i
decl_stmt|;
name|int
name|base_cnt
init|=
literal|0
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|vb
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|elems
decl_stmt|,
name|access
decl_stmt|,
name|offset
decl_stmt|,
name|isvir
decl_stmt|;
name|tree
name|base_list
decl_stmt|,
name|off_list
decl_stmt|,
name|acc_list
decl_stmt|,
name|isvir_list
decl_stmt|;
name|tree
name|t
decl_stmt|;
specifier|static
name|tree
name|acc_pub
init|=
name|NULL_TREE
decl_stmt|;
specifier|static
name|tree
name|acc_pro
init|=
name|NULL_TREE
decl_stmt|;
specifier|static
name|tree
name|acc_pri
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|acc_pub
operator|==
name|NULL_TREE
condition|)
block|{
name|acc_pub
operator|=
name|lookup_field
argument_list|(
name|__class_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_ACCESS_PUBLIC"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acc_pro
operator|=
name|lookup_field
argument_list|(
name|__class_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_ACCESS_PROTECTED"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acc_pri
operator|=
name|lookup_field
argument_list|(
name|__class_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_ACCESS_PRIVATE"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|base_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|off_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|acc_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|isvir_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|base
operator|=
name|build_t_desc
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|int
name|off
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
condition|)
name|access
operator|=
name|acc_pub
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|binfo
argument_list|)
condition|)
name|access
operator|=
name|acc_pro
expr_stmt|;
else|else
name|access
operator|=
name|acc_pri
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|isvir
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|isvir
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base
argument_list|,
name|base_list
argument_list|)
expr_stmt|;
name|isvir_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|isvir
argument_list|,
name|isvir_list
argument_list|)
expr_stmt|;
name|acc_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|access
argument_list|,
name|acc_list
argument_list|)
expr_stmt|;
name|off_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|offset
argument_list|,
name|off_list
argument_list|)
expr_stmt|;
name|base_cnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|i = n_base;   while (vb)     {       tree b;       access = acc_pub;       while (--i>= 0) 	{ 	  b = TREE_VEC_ELT (binfos, i); 	  if (BINFO_TYPE (vb) == BINFO_TYPE (b)&& TREE_VIA_VIRTUAL (b)) 	    { 	      if (TREE_VIA_PUBLIC (b)) 		access = acc_pub; 	      else if (TREE_VIA_PROTECTED (b)) 		access = acc_pro; 	      else 		access = acc_pri; 	      break; 	    } 	}       base = build_t_desc (BINFO_TYPE (vb), 1);       offset = BINFO_OFFSET (vb);       isvir = build_int_2 (1, 0);        base_list = tree_cons (NULL_TREE, base, base_list);       isvir_list = tree_cons (NULL_TREE, isvir, isvir_list);       acc_list = tree_cons (NULL_TREE, access, acc_list);       off_list = tree_cons (NULL_TREE, offset, off_list);        base_cnt++;       vb = TREE_CHAIN (vb);     }
endif|#
directive|endif
name|base_list
operator|=
name|finish_table
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|base_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off_list
operator|=
name|finish_table
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|off_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isvir_list
operator|=
name|finish_table
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|isvir_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acc_list
operator|=
name|finish_table
argument_list|(
name|NULL_TREE
argument_list|,
name|__access_mode_type_node
argument_list|,
name|acc_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|tname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|name_string
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|base_list
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|off_list
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|isvir_list
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|acc_list
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|base_cnt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__class_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __pointer_type_info node.  */
end_comment

begin_function
specifier|static
name|tree
name|build_ptr_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|elems
decl_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_t_desc
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__ptr_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __attr_type_info node.  */
end_comment

begin_function
specifier|static
name|tree
name|build_attr_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|elems
decl_stmt|,
name|t
decl_stmt|,
name|attrval
decl_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|attrval
operator|=
name|lookup_field
argument_list|(
name|__attr_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_ATTR_CONSTVOL"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|attrval
operator|=
name|lookup_field
argument_list|(
name|__attr_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_ATTR_CONST"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|attrval
operator|=
name|lookup_field
argument_list|(
name|__attr_desc_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"_RTTI_ATTR_VOLATILE"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_t_desc
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|attrval
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__attr_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __func_type_info node.  */
end_comment

begin_function
specifier|static
name|tree
name|build_func_desc
parameter_list|(
name|tdecl
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
block|{
name|tree
name|elems
decl_stmt|,
name|name_string
decl_stmt|;
name|tree
name|tname
init|=
name|DECL_NAME
argument_list|(
name|tdecl
argument_list|)
decl_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|tname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|name_string
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__func_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __ptmf_type_info node.  */
end_comment

begin_function
specifier|static
name|tree
name|build_ptmf_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|elems
decl_stmt|,
name|name_string
decl_stmt|;
name|tree
name|tname
init|=
name|DECL_NAME
argument_list|(
name|tdecl
argument_list|)
decl_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|tname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|name_string
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__ptmf_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __ptmd_type_info node.  */
end_comment

begin_function
specifier|static
name|tree
name|build_ptmd_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|tc
decl_stmt|,
name|t
decl_stmt|,
name|elems
decl_stmt|;
name|tc
operator|=
name|build_t_desc
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tc
operator|=
name|build_indirect_ref
argument_list|(
name|tc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_t_desc
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tc
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|__ptmd_desc_type_node
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|uninst_st
block|{
name|tree
name|type
decl_stmt|;
name|struct
name|uninst_st
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|uninst_st
name|uninst_node
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|uninst_node
modifier|*
name|uninst_desc
init|=
operator|(
name|uninst_node
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_uninstantiated_desc
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|uninst_node
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|uninst_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uninst_st
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|uninst_desc
expr_stmt|;
name|uninst_desc
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We may choose to link the emitting of certain high use TDs for certain    objects, we do that here.  Return the type to link against if such a    link exists, otherwise just return TYPE.  */
end_comment

begin_function
name|tree
name|get_def_to_follow
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* For now we don't lay out T&, T* TDs with the main TD for the object.  */
comment|/* Let T* and T& be written only when T is written (if T is an aggr).      We do this for const, but not for volatile, since volatile      is rare and const is not.  */
block|if (!TYPE_VOLATILE (taggr)&& (TREE_CODE (taggr) == POINTER_TYPE 	  || TREE_CODE (taggr) == REFERENCE_TYPE)&& IS_AGGR_TYPE (TREE_TYPE (taggr)))     taggr = TREE_TYPE (taggr);
endif|#
directive|endif
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* build a general type_info node. */
end_comment

begin_function
name|tree
name|build_t_desc
parameter_list|(
name|type
parameter_list|,
name|definition
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|definition
decl_stmt|;
block|{
name|tree
name|tdecl
decl_stmt|;
name|tree
name|tname
decl_stmt|,
name|name_string
decl_stmt|;
name|tree
name|elems
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|tt
decl_stmt|,
name|taggr
decl_stmt|;
if|if
condition|(
name|__ptmd_desc_type_node
operator|==
name|NULL_TREE
condition|)
block|{
name|init_type_desc
argument_list|()
expr_stmt|;
if|if
condition|(
name|__ptmd_desc_type_node
condition|)
block|{
for|for
control|(
init|;
name|uninst_desc
condition|;
name|uninst_desc
operator|=
name|uninst_desc
operator|->
name|next
control|)
name|build_t_desc
argument_list|(
name|uninst_desc
operator|->
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__t_desc_type_node
operator|==
name|NULL_TREE
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|cp_error
argument_list|(
literal|"failed to build type descriptor node of '%T', maybe typeinfo.h not included"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|warned
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|__ptmd_desc_type_node
operator|==
name|NULL_TREE
condition|)
block|{
name|add_uninstantiated_desc
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|definition
operator|=
literal|0
expr_stmt|;
block|}
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|tname
operator|=
name|build_t_desc_overload
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
condition|)
block|{
name|tdecl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|tname
argument_list|,
name|__t_desc_type_node
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tdecl
operator|=
name|pushdecl_top_level
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|tdecl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|definition
condition|)
name|cp_finish_decl
argument_list|(
name|tdecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|tdecl
operator|=
name|TREE_OPERAND
argument_list|(
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If it's not a definition, don't do anything more.  */
if|if
condition|(
operator|!
name|definition
condition|)
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
return|;
comment|/* If it has already been written, don't to anything more.  */
comment|/* Should this be on tdecl? */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
argument_list|)
condition|)
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
return|;
comment|/* If we previously defined it, return the defined result.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|tdecl
argument_list|)
condition|)
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
return|;
name|taggr
operator|=
name|get_def_to_follow
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If we know that we don't need to write out this type's      vtable, then don't write out it's type_info.  Somebody      else will take care of that.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|taggr
argument_list|)
operator|&&
name|CLASSTYPE_VFIELD
argument_list|(
name|taggr
argument_list|)
condition|)
block|{
comment|/* Let's play follow the vtable. */
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|taggr
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|taggr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
operator|(
name|definition
operator|>
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
condition|)
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
return|;
comment|/* Show that we are defining the t_desc for this type.  */
name|DECL_INITIAL
argument_list|(
name|tdecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|t
operator|=
name|DECL_CONTEXT
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|pushclass
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
name|t
operator|=
name|build_attr_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t
operator|=
name|build_ptr_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_ptmd_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build_ptr_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_BUILT_IN
argument_list|(
name|type
argument_list|)
condition|)
name|t
operator|=
name|build_bltn_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build_ptmf_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build_class_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|t
operator|=
name|build_func_desc
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_user_desc
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is the old dossier type descriptor generation code, it's much    more extended than rtti. It's reserved for later use. */
end_comment

begin_comment
comment|/* Build an initializer for a __t_desc node.  So that we can take advantage    of recursion, we accept NULL for TYPE.    DEFINITION is greater than zero iff we must define the type descriptor    (as opposed to merely referencing it).  1 means treat according to    #pragma interface/#pragma implementation rules.  2 means define as    global and public, no matter what.  */
end_comment

begin_comment
unit|tree build_t_desc (type, definition)      tree type;      int definition; {   tree tdecl;   tree tname, name_string;   tree elems, fields;   tree parents, vbases, offsets, ivars, methods, target_type;   int method_count = 0, field_count = 0;    if (type == NULL_TREE)     return NULL_TREE;    tname = build_t_desc_overload (type);   if (IDENTIFIER_AS_DESC (tname)&& (!definition || TREE_ASM_WRITTEN (IDENTIFIER_AS_DESC (tname))))     return IDENTIFIER_AS_DESC (tname);    tdecl = lookup_name (tname, 0);   if (tdecl == NULL_TREE)     {       tdecl = build_decl (VAR_DECL, tname, __t_desc_type_node);       DECL_EXTERNAL (tdecl) = 1;       TREE_PUBLIC (tdecl) = 1;       tdecl = pushdecl_top_level (tdecl);     }
comment|/* If we previously defined it, return the defined result.  */
end_comment

begin_comment
unit|else if (definition&& DECL_INITIAL (tdecl))     return IDENTIFIER_AS_DESC (tname);    if (definition)     {       tree taggr = type;
comment|/* Let T* and T& be written only when T is written (if T is an aggr).          We do this for const, but not for volatile, since volatile 	 is rare and const is not.  */
end_comment

begin_comment
unit|if (!TYPE_VOLATILE (taggr)&& (TREE_CODE (taggr) == POINTER_TYPE 	      || TREE_CODE (taggr) == REFERENCE_TYPE)&& IS_AGGR_TYPE (TREE_TYPE (taggr))) 	taggr = TREE_TYPE (taggr);
comment|/* If we know that we don't need to write out this type's 	 vtable, then don't write out it's dossier.  Somebody 	 else will take care of that.  */
end_comment

begin_comment
unit|if (IS_AGGR_TYPE (taggr)&& CLASSTYPE_VFIELD (taggr)) 	{ 	  if (CLASSTYPE_VTABLE_NEEDS_WRITING (taggr)) 	    { 	      TREE_PUBLIC (tdecl) = ! CLASSTYPE_INTERFACE_ONLY (taggr)&& CLASSTYPE_INTERFACE_KNOWN (taggr); 	      DECL_EXTERNAL (tdecl) = 0; 	    } 	  else 	    { 	      if (write_virtuals != 0) 		TREE_PUBLIC (tdecl) = 1; 	    } 	}       else 	{ 	  DECL_EXTERNAL (tdecl) = 0; 	  TREE_PUBLIC (tdecl) = (definition> 1); 	}     }   SET_IDENTIFIER_AS_DESC (tname, build_unary_op (ADDR_EXPR, tdecl, 0));    if (!definition || DECL_EXTERNAL (tdecl))     {
comment|/* That's it!  */
end_comment

begin_comment
unit|cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);       return IDENTIFIER_AS_DESC (tname);     }
comment|/* Show that we are defining the t_desc for this type.  */
end_comment

begin_comment
unit|DECL_INITIAL (tdecl) = error_mark_node;    parents = build_tree_list (NULL_TREE, integer_zero_node);   vbases = build_tree_list (NULL_TREE, integer_zero_node);   offsets = build_tree_list (NULL_TREE, integer_zero_node);   methods = NULL_TREE;   ivars = NULL_TREE;    if (TYPE_LANG_SPECIFIC (type))     {       int i = CLASSTYPE_N_BASECLASSES (type);       tree method_vec = CLASSTYPE_METHOD_VEC (type);       tree *meth, *end;       tree binfos = TYPE_BINFO_BASETYPES (type);       tree vb = CLASSTYPE_VBASECLASSES (type);        while (--i>= 0) 	parents = tree_cons (NULL_TREE, build_t_desc (BINFO_TYPE (TREE_VEC_ELT (binfos, i)), 0), parents);        while (vb) 	{ 	  vbases = tree_cons (NULL_TREE, build_t_desc (BINFO_TYPE (vb), 0), vbases); 	  offsets = tree_cons (NULL_TREE, BINFO_OFFSET (vb), offsets); 	  vb = TREE_CHAIN (vb); 	}        if (method_vec) 	for (meth = TREE_VEC_END (method_vec), 	     end =&TREE_VEC_ELT (method_vec, 0); meth-- != end; ) 	  if (*meth) 	    { 	      methods = tree_cons (NULL_TREE, build_m_desc (*meth), methods); 	      method_count++; 	    }     }    if (IS_AGGR_TYPE (type))     {       for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields)) 	if (TREE_CODE (fields) == FIELD_DECL 	    || TREE_CODE (fields) == VAR_DECL) 	  { 	    ivars = tree_cons (NULL_TREE, build_i_desc (fields), ivars); 	    field_count++; 	  }       ivars = nreverse (ivars);     }    parents = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), parents, 0);   vbases = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), vbases, 0);   offsets = finish_table (NULL_TREE, integer_type_node, offsets, 0);   if (methods == NULL_TREE)     methods = null_pointer_node;   else     methods = build_unary_op (ADDR_EXPR, 			      finish_table (NULL_TREE, __m_desc_type_node, methods, 0), 			      0);   if (ivars == NULL_TREE)     ivars = null_pointer_node;   else     ivars = build_unary_op (ADDR_EXPR, 			    finish_table (NULL_TREE, __i_desc_type_node, ivars, 0), 			    0);   if (TREE_TYPE (type))     target_type = build_t_desc (TREE_TYPE (type), definition);   else     target_type = integer_zero_node;    name_string = combine_strings (build_string (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));    elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0), 	   tree_cons (NULL_TREE, 		      TYPE_SIZE(type)? size_in_bytes(type) : integer_zero_node,
comment|/* really should use bitfield initialization here.  */
end_comment

begin_comment
unit|tree_cons (NULL_TREE, integer_zero_node, 	      tree_cons (NULL_TREE, target_type, 	       tree_cons (NULL_TREE, build_int_2 (field_count, 2), 		tree_cons (NULL_TREE, build_int_2 (method_count, 2), 		 tree_cons (NULL_TREE, ivars, 		  tree_cons (NULL_TREE, methods, 		   tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, parents, 0), 		    tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, vbases, 0), 		     build_tree_list (NULL_TREE, build_unary_op (ADDR_EXPR, offsets, 0))))))))))));   return build_generic_desc (tdecl, elems); }
comment|/* Build an initializer for a __i_desc node.  */
end_comment

begin_comment
unit|tree build_i_desc (decl)      tree decl; {   tree elems, name_string;   tree taggr;    name_string = DECL_NAME (decl);   name_string = combine_strings (build_string (IDENTIFIER_LENGTH (name_string)+1, IDENTIFIER_POINTER (name_string)));
comment|/* Now decide whether this ivar should cause it's type to get      def'd or ref'd in this file.  If the type we are looking at      has a proxy definition, we look at the proxy (i.e., a      `foo *' is equivalent to a `foo').  */
end_comment

begin_comment
unit|taggr = TREE_TYPE (decl);    if ((TREE_CODE (taggr) == POINTER_TYPE        || TREE_CODE (taggr) == REFERENCE_TYPE)&& TYPE_VOLATILE (taggr) == 0)     taggr = TREE_TYPE (taggr);    elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0), 	     tree_cons (NULL_TREE, DECL_FIELD_BITPOS (decl), 		build_tree_list (NULL_TREE, build_t_desc (TREE_TYPE (decl), 							  ! IS_AGGR_TYPE (taggr)))));   taggr = build (CONSTRUCTOR, __i_desc_type_node, NULL_TREE, elems);   TREE_CONSTANT (taggr) = 1;   TREE_STATIC (taggr) = 1;   TREE_READONLY (taggr) = 1;   return taggr; }
comment|/* Build an initializer for a __m_desc node.  */
end_comment

begin_comment
unit|tree build_m_desc (decl)      tree decl; {   tree taggr, elems, name_string;   tree parm_count, req_count, vindex, vcontext;   tree parms;   int p_count, r_count;   tree parm_types = NULL_TREE;    for (parms = TYPE_ARG_TYPES (TREE_TYPE (decl)), p_count = 0, r_count = 0;        parms != NULL_TREE; parms = TREE_CHAIN (parms), p_count++)     {       taggr = TREE_VALUE (parms);       if ((TREE_CODE (taggr) == POINTER_TYPE 	   || TREE_CODE (taggr) == REFERENCE_TYPE)&& TYPE_VOLATILE (taggr) == 0) 	taggr = TREE_TYPE (taggr);        parm_types = tree_cons (NULL_TREE, build_t_desc (TREE_VALUE (parms), 						       ! IS_AGGR_TYPE (taggr)), 			      parm_types);       if (TREE_PURPOSE (parms) == NULL_TREE) 	r_count++;     }    parm_types = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), 			     nreverse (parm_types), 0);   parm_count = build_int_2 (p_count, 0);   req_count = build_int_2 (r_count, 0);    if (DECL_VINDEX (decl))     vindex = DECL_VINDEX (decl);   else     vindex = integer_zero_node;   if (DECL_CONTEXT (decl)&& TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (decl))) == 't')     vcontext = build_t_desc (DECL_CONTEXT (decl), 0);   else     vcontext = integer_zero_node;   name_string = DECL_NAME (decl);   if (name_string == NULL)       name_string = DECL_ASSEMBLER_NAME (decl);   name_string = combine_strings (build_string (IDENTIFIER_LENGTH (name_string)+1, IDENTIFIER_POINTER (name_string)));
comment|/* Now decide whether the return type of this mvar      should cause it's type to get def'd or ref'd in this file.      If the type we are looking at has a proxy definition,      we look at the proxy (i.e., a `foo *' is equivalent to a `foo').  */
end_comment

begin_endif
unit|taggr = TREE_TYPE (TREE_TYPE (decl));    if ((TREE_CODE (taggr) == POINTER_TYPE        || TREE_CODE (taggr) == REFERENCE_TYPE)&& TYPE_VOLATILE (taggr) == 0)     taggr = TREE_TYPE (taggr);    elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0), 	     tree_cons (NULL_TREE, vindex, 		tree_cons (NULL_TREE, vcontext, 		   tree_cons (NULL_TREE, build_t_desc (TREE_TYPE (TREE_TYPE (decl)), 						       ! IS_AGGR_TYPE (taggr)), 		      tree_cons (NULL_TREE, build_c_cast (build_pointer_type (default_function_type), build_unary_op (ADDR_EXPR, decl, 0), 0), 			 tree_cons (NULL_TREE, parm_count, 			    tree_cons (NULL_TREE, req_count, 			       build_tree_list (NULL_TREE, build_unary_op (ADDR_EXPR, parm_types, 0)))))))));    taggr = build (CONSTRUCTOR, __m_desc_type_node, NULL_TREE, elems);   TREE_CONSTANT (taggr) = 1;   TREE_STATIC (taggr) = 1;   TREE_READONLY (taggr) = 1;   return taggr; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* dossier */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Conditionally emit code to set up an unwind-protect for the    garbage collector.  If this function doesn't do anything that involves    the garbage collector, then do nothing.  Otherwise, call __gc_push    at the beginning and __gc_pop at the end.     NOTE!  The __gc_pop function must operate transparently, since    it comes where the logical return label lies.  This means that    at runtime *it* must preserve any return value registers.  */
end_comment

begin_function
name|void
name|expand_gc_prologue_and_epilogue
parameter_list|()
block|{
specifier|extern
name|tree
name|maybe_gc_cleanup
decl_stmt|;
name|struct
name|rtx_def
modifier|*
name|last_parm_insn
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|get_last_insn
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|get_first_nonparm_insn
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|previous_insn
parameter_list|()
function_decl|;
name|tree
name|action
decl_stmt|;
comment|/* If we didn't need the obstack, don't cons any space.  */
if|if
condition|(
name|current_function_obstack_index
operator|==
literal|0
operator|||
name|current_function_obstack_usage
operator|==
literal|0
condition|)
return|return;
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
literal|0
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
name|action
operator|=
name|build_function_call
argument_list|(
name|gc_push_fndecl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size_int
argument_list|(
operator|++
name|current_function_obstack_index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* This will be expanded as a cleanup.  */
name|TREE_VALUE
argument_list|(
name|maybe_gc_cleanup
argument_list|)
operator|=
name|build_function_call
argument_list|(
name|gc_pop_fndecl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some day we'll use this function as a call-back and clean    up all the unnecessary gc dribble that we otherwise create.  */
end_comment

begin_function
name|void
name|lang_expand_end_bindings
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|struct
name|rtx_def
modifier|*
name|first
decl_stmt|,
decl|*
name|last
decl_stmt|;
end_function

begin_block
block|{ }
end_block

begin_escape
end_escape

begin_function
name|void
name|init_gc_processing
parameter_list|()
block|{
name|tree
name|parmtypes
init|=
name|hash_tree_chain
argument_list|(
name|class_star_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|gc_protect_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_protect"
argument_list|,
name|build_function_type
argument_list|(
name|class_star_type_node
argument_list|,
name|parmtypes
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gc_unprotect_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_unprotect"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parmtypes
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_push_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_push"
argument_list|,
name|TREE_TYPE
argument_list|(
name|gc_unprotect_fndecl
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_pop_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_pop"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_nonobject
operator|=
name|build_int_2
argument_list|(
literal|0x80000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_visible
operator|=
name|build_int_2
argument_list|(
literal|0x40000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_white
operator|=
name|integer_zero_node
expr_stmt|;
name|gc_offwhite
operator|=
name|build_int_2
argument_list|(
literal|0x10000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_grey
operator|=
name|build_int_2
argument_list|(
literal|0x20000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_black
operator|=
name|build_int_2
argument_list|(
literal|0x30000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

