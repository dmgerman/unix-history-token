begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RunTime Type Identification    Copyright (C) 1995, 96-97, 1998, 1999 Free Software Foundation, Inc.    Mostly written by Jason Merrill (jason@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|call_void_fn
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_headof_sub
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_headof
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_tinfo_var
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ifnonnull
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_dynamic_cast_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_si_desc
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_class_desc
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_attr_desc
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_ptr_desc
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_generic_desc
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|throw_bad_cast
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|throw_bad_typeid
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|type_info_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|tinfo_fn_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|tinfo_fn_type
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|init_rtti_processing
parameter_list|()
block|{
if|if
condition|(
name|flag_honor_std
condition|)
name|push_namespace
argument_list|(
name|get_identifier
argument_list|(
literal|"std"
argument_list|)
argument_list|)
expr_stmt|;
name|type_info_type_node
operator|=
name|xref_tag
argument_list|(
name|class_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"type_info"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_honor_std
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
name|tinfo_fn_id
operator|=
name|get_identifier
argument_list|(
literal|"__tf"
argument_list|)
expr_stmt|;
name|tinfo_fn_type
operator|=
name|build_function_type
argument_list|(
name|build_reference_type
argument_list|(
name|build_qualified_type
argument_list|(
name|type_info_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an object with at least one virtual table    pointer somewhere, return a pointer to a possible sub-object that    has a virtual table pointer in it that is the vtable parent for    that sub-object.  */
end_comment

begin_function
specifier|static
name|tree
name|build_headof_sub
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|CLASSTYPE_RTTI
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|exp
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Given the expression EXP of type `class *', return the head of the    object pointed to by EXP with type cv void*, if the class has any    virtual functions (TYPE_VIRTUAL_P), else just return the    expression.  */
end_comment

begin_function
specifier|static
name|tree
name|build_headof
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|aref
decl_stmt|;
name|tree
name|offset
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`headof' applied to non-pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"RTTI not supported for COM interface type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If we don't have rtti stuff, get to a sub-object that does.  */
if|if
condition|(
operator|!
name|CLASSTYPE_VFIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|build_headof_sub
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We use this a couple of times below, protect it.  */
name|exp
operator|=
name|save_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_vtbl_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|exp
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|offset
operator|=
name|aref
expr_stmt|;
else|else
name|offset
operator|=
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_qualified_type
argument_list|(
name|ptr_type_node
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a generic entry point taking and returning void.  */
end_comment

begin_function
specifier|static
name|tree
name|call_void_fn
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|d
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|d
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|d
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|build_call
argument_list|(
name|d
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a bad_cast node for the program to throw...     See libstdc++/exception.cc for __throw_bad_cast */
end_comment

begin_function
specifier|static
name|tree
name|throw_bad_cast
parameter_list|()
block|{
return|return
name|call_void_fn
argument_list|(
literal|"__throw_bad_cast"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|throw_bad_typeid
parameter_list|()
block|{
return|return
name|call_void_fn
argument_list|(
literal|"__throw_bad_typeid"
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the type_info function associated with the expression EXP.  If    EXP is a reference to a polymorphic class, return the dynamic type;    otherwise return the static type of the expression.  */
end_comment

begin_function
name|tree
name|get_tinfo_fn_dynamic
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"typeid of overloaded function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* peel back references, so they match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"taking typeid of incomplete type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If exp is a reference to polymorphic type, get the real type_info.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* build reference to type_info from vtable.  */
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|flag_rtti
condition|)
name|error
argument_list|(
literal|"taking dynamic typeid of object with -fno-rtti"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"RTTI not supported for COM interface type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If we don't have rtti stuff, get to a sub-object that does.  */
if|if
condition|(
operator|!
name|CLASSTYPE_VFIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|exp
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_headof_sub
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_indirect_ref
argument_list|(
name|exp
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|t
operator|=
name|build_vfn_ref
argument_list|(
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|,
name|exp
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_vfn_ref
argument_list|(
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|,
name|exp
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|tinfo_fn_type
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* otherwise return the type_info for the static type of the expr.  */
return|return
name|get_tinfo_fn
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_typeid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|exp
operator|=
name|get_tinfo_fn_dynamic
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_call
argument_list|(
name|exp
argument_list|,
name|TREE_TYPE
argument_list|(
name|tinfo_fn_type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_x_typeid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|cond
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
if|if
condition|(
operator|!
name|flag_rtti
condition|)
block|{
name|error
argument_list|(
literal|"cannot use typeid with -fno-rtti"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type_info_type_node
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"must #include<typeinfo> before using typeid"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|TYPEID_EXPR
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|exp
argument_list|,
operator|&
name|nonnull
argument_list|)
operator|&&
operator|!
name|nonnull
condition|)
block|{
name|exp
operator|=
name|stabilize_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|cond
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|get_tinfo_fn_dynamic
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|tinfo_fn_type
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_call
argument_list|(
name|exp
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
condition|)
block|{
name|tree
name|bad
init|=
name|throw_bad_typeid
argument_list|()
decl_stmt|;
name|bad
operator|=
name|build_compound_expr
argument_list|(
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|bad
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|cond
argument_list|,
name|exp
argument_list|,
name|bad
argument_list|)
expr_stmt|;
block|}
return|return
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_tinfo_var
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|tname
init|=
name|build_overload_with_type
argument_list|(
name|get_identifier
argument_list|(
literal|"__ti"
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|tdecl
decl_stmt|,
name|arrtype
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tname
argument_list|)
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tname
argument_list|)
return|;
comment|/* Figure out how much space we need to allocate for the type_info object.      If our struct layout or the type_info classes are changed, this will      need to be modified.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|size
operator|=
literal|3
operator|*
name|POINTER_SIZE
operator|+
name|INT_TYPE_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
name|size
operator|=
literal|3
operator|*
name|POINTER_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|size
operator|=
literal|2
operator|*
name|POINTER_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_VIA_PUBLIC
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|size
operator|=
literal|3
operator|*
name|POINTER_SIZE
expr_stmt|;
else|else
name|size
operator|=
literal|3
operator|*
name|POINTER_SIZE
operator|+
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|2
operator|*
name|POINTER_SIZE
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
comment|/* The type for a character array of the appropriate size.  */
name|arrtype
operator|=
name|build_cplus_array_type
argument_list|(
name|unsigned_char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|size
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tdecl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|tname
argument_list|,
name|arrtype
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|tdecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|tdecl
return|;
block|}
end_function

begin_comment
comment|/* Returns the decl for a function which will return a type_info node for    TYPE.  This version does not mark the function used, for use in    set_rtti_entry; for the vtable case, we'll get marked in    finish_vtable_vardecl, when we know that we want to be emitted.     We do this to avoid emitting the tinfo node itself, since we don't    currently support DECL_DEFER_OUTPUT for variables.  Also, we don't    associate constant pools with their functions properly, so we would    emit string constants and such even though we don't emit the actual    function.  When those bugs are fixed, this function should go away.  */
end_comment

begin_function
name|tree
name|get_tinfo_fn_unused
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_overload_with_type
argument_list|(
name|tinfo_fn_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|d
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|name
argument_list|,
name|tinfo_fn_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TINFO_FN_P
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mark_inline_for_output
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but also mark it used.  Called by various EH and RTTI code.  */
end_comment

begin_function
name|tree
name|get_tinfo_fn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|d
init|=
name|get_tinfo_fn_unused
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|mark_used
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|tree
name|get_typeid_1
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_call
argument_list|(
name|get_tinfo_fn
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|tinfo_fn_type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the type_info object for TYPE, creating it if necessary.  */
end_comment

begin_function
name|tree
name|get_typeid
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type_info_type_node
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"must #include<typeinfo> before using typeid"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|flag_rtti
condition|)
name|error
argument_list|(
literal|"requesting typeid with -fno-rtti"
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|TYPEID_EXPR
argument_list|,
name|type
argument_list|)
return|;
comment|/* If the type of the type-id is a reference type, the result of the      typeid expression refers to a type_info object representing the      referenced type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The top-level cv-qualifiers of the lvalue expression or the type-id      that is the operand of typeid are always ignored.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"taking typeid of incomplete type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|get_typeid_1
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether TEST is null before returning RESULT.  If TEST is used in    RESULT, it must have previously had a save_expr applied to it.  */
end_comment

begin_function
specifier|static
name|tree
name|ifnonnull
parameter_list|(
name|test
parameter_list|,
name|result
parameter_list|)
name|tree
name|test
decl_stmt|,
name|result
decl_stmt|;
block|{
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|test
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working    paper.  */
end_comment

begin_function
specifier|static
name|tree
name|build_dynamic_cast_1
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|tc
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|exprtype
decl_stmt|;
name|enum
name|tree_code
name|ec
decl_stmt|;
name|tree
name|dcast_fn
decl_stmt|;
name|tree
name|old_expr
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|exprtype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|exprtype
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ec
operator|=
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tc
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|ec
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|exprtype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ec
operator|=
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ec
operator|!=
name|POINTER_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
break|break;
comment|/* else fall through */
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|fail
goto|;
break|break;
comment|/* else fall through */
default|default:
goto|goto
name|fail
goto|;
block|}
comment|/* Apply trivial conversion T -> T& for dereferenced ptrs.  */
if|if
condition|(
name|ec
operator|==
name|RECORD_TYPE
condition|)
block|{
name|exprtype
operator|=
name|build_reference_type
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_to_reference
argument_list|(
name|exprtype
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ec
operator|=
name|REFERENCE_TYPE
expr_stmt|;
block|}
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|ec
operator|!=
name|REFERENCE_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* If *type is an unambiguous accessible base class of *exprtype,      convert statically.  */
block|{
name|int
name|distance
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|distance
operator|=
name|get_base_distance
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|distance
operator|==
operator|-
literal|2
condition|)
block|{
name|cp_error
argument_list|(
literal|"dynamic_cast from `%T' to ambiguous base class `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|distance
operator|==
operator|-
literal|3
condition|)
block|{
name|cp_error
argument_list|(
literal|"dynamic_cast from `%T' to private base class `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Otherwise *exprtype must be a polymorphic class (have a vtbl).  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|expr1
decl_stmt|;
comment|/* if TYPE is `void *', return pointer to complete object.  */
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
comment|/* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* Since expr is used twice below, save it.  */
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr1
operator|=
name|build_headof
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr1
argument_list|)
operator|!=
name|type
condition|)
name|expr1
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr1
argument_list|)
expr_stmt|;
return|return
name|ifnonnull
argument_list|(
name|expr
argument_list|,
name|expr1
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|retval
decl_stmt|;
name|tree
name|result
decl_stmt|,
name|td1
decl_stmt|,
name|td2
decl_stmt|,
name|td3
decl_stmt|,
name|elems
decl_stmt|,
name|expr2
decl_stmt|;
comment|/* If we got here, we can't convert statically.  Therefore, 	     dynamic_cast<D&>(b) (b an object) cannot succeed.  */
if|if
condition|(
name|ec
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_expr
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_expr
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|cp_warning
argument_list|(
literal|"dynamic_cast of `%#D' to `%#T' can never succeed"
argument_list|,
name|old_expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|throw_bad_cast
argument_list|()
return|;
block|}
block|}
comment|/* Ditto for dynamic_cast<D*>(&b).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|cp_warning
argument_list|(
literal|"dynamic_cast of `%#D' to `%#T' can never succeed"
argument_list|,
name|op
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
comment|/* Since expr is used twice below, save it.  */
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr1
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
name|expr1
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Build run-time conversion.  */
name|expr2
operator|=
name|build_headof
argument_list|(
name|expr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec
operator|==
name|POINTER_TYPE
condition|)
name|td1
operator|=
name|get_tinfo_fn_dynamic
argument_list|(
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|td1
operator|=
name|get_tinfo_fn_dynamic
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|td1
operator|=
name|decay_conversion
argument_list|(
name|td1
argument_list|)
expr_stmt|;
name|td2
operator|=
name|decay_conversion
argument_list|(
name|get_tinfo_fn
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|td3
operator|=
name|decay_conversion
argument_list|(
name|get_tinfo_fn
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td1
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td2
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr2
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td3
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr1
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dcast_fn
operator|=
name|get_identifier
argument_list|(
literal|"__dynamic_cast"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|dcast_fn
argument_list|)
condition|)
name|dcast_fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|dcast_fn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|tmp
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|td1
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|td1
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|td1
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dcast_fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|dcast_fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|dcast_fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|dcast_fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|dcast_fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|dcast_fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|dcast_fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|dcast_fn
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_call
argument_list|(
name|dcast_fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dcast_fn
argument_list|)
argument_list|)
argument_list|,
name|elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|expr1
operator|=
name|throw_bad_cast
argument_list|()
expr_stmt|;
name|expr1
operator|=
name|build_compound_expr
argument_list|(
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr1
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr1
argument_list|)
operator|=
name|type
expr_stmt|;
name|result
operator|=
name|save_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|result
argument_list|,
name|result
argument_list|,
name|expr1
argument_list|)
return|;
block|}
comment|/* Now back to the type we want from a void*.  */
name|result
operator|=
name|cp_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|ifnonnull
argument_list|(
name|expr
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
name|fail
label|:
name|cp_error
argument_list|(
literal|"cannot dynamic_cast `%E' (of type `%#T') to type `%#T'"
argument_list|,
name|expr
argument_list|,
name|exprtype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_dynamic_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|DYNAMIC_CAST_EXPR
argument_list|,
name|copy_to_permanent
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|)
return|;
return|return
name|convert_from_reference
argument_list|(
name|build_dynamic_cast_1
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and initialize various sorts of descriptors.  Every descriptor    node has a name associated with it (the name created by mangling).    For this reason, we use the identifier as our access to the __*_desc    nodes, instead of sticking them directly in the types.  Otherwise we    would burden all built-in types (and pointer types) with slots that    we don't necessarily want to use.     For each descriptor we build, we build a variable that contains    the descriptor's information.  When we need this info at runtime,    all we need is access to these variables.     Note: these constructors always return the address of the descriptor    info, since that is simplest for their mutual interaction.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|const_string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build an initializer for a __si_type_info node.  */
end_comment

begin_function
specifier|static
name|void
name|expand_si_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|elems
decl_stmt|,
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|name_string
init|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|get_typeid_1
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|decay_conversion
argument_list|(
name|get_tinfo_var
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|tdecl
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|name_string
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__rtti_si"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|tmp
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|type_info_type_node
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __class_type_info node.  */
end_comment

begin_function
specifier|static
name|void
name|expand_class_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|name_string
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|base_cnt
init|=
literal|0
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* See code below that used these.  */
block|tree vb = CLASSTYPE_VBASECLASSES (type);   int n_base = i;
endif|#
directive|endif
name|tree
name|base
decl_stmt|,
name|elems
decl_stmt|,
name|access
decl_stmt|,
name|offset
decl_stmt|,
name|isvir
decl_stmt|;
name|tree
name|elt
decl_stmt|,
name|elts
init|=
name|NULL_TREE
decl_stmt|;
specifier|static
name|tree
name|base_info_type_node
decl_stmt|;
if|if
condition|(
name|base_info_type_node
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|fields
index|[
literal|4
index|]
decl_stmt|;
comment|/* A reasonably close approximation of __class_type_info::base_info */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|base_info_type_node
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Actually const __user_type_info * */
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|type_info_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
operator|=
literal|29
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|boolean_type_node
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Actually enum access */
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
literal|2
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|base_info_type_node
argument_list|,
literal|"__base_info"
argument_list|,
name|fields
argument_list|,
literal|3
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|expand_expr_stmt
argument_list|(
name|get_typeid_1
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|decay_conversion
argument_list|(
name|get_tinfo_var
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|FORMAT_VBASE_NAME
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
condition|)
name|access
operator|=
name|access_public_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|binfo
argument_list|)
condition|)
name|access
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|access
operator|=
name|access_private_node
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|isvir
operator|=
name|boolean_true_node
expr_stmt|;
else|else
name|isvir
operator|=
name|boolean_false_node
expr_stmt|;
name|elt
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|base_info_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|offset
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|isvir
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|access
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|elt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|elts
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|elt
argument_list|,
name|elts
argument_list|)
expr_stmt|;
name|base_cnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|i = n_base;   while (vb)     {       tree b;       access = access_public_node;       while (--i>= 0) 	{ 	  b = TREE_VEC_ELT (binfos, i); 	  if (BINFO_TYPE (vb) == BINFO_TYPE (b)&& TREE_VIA_VIRTUAL (b)) 	    { 	      if (TREE_VIA_PUBLIC (b)) 		access = access_public_node; 	      else if (TREE_VIA_PROTECTED (b)) 		access = access_protected_node; 	      else 		access = access_private_node; 	      break; 	    } 	}       base = build_t_desc (BINFO_TYPE (vb), 1);       offset = BINFO_OFFSET (vb);       isvir = build_int_2 (1, 0);        base_list = expr_tree_cons (NULL_TREE, base, base_list);       isvir_list = expr_tree_cons (NULL_TREE, isvir, isvir_list);       acc_list = expr_tree_cons (NULL_TREE, access, acc_list);       off_list = expr_tree_cons (NULL_TREE, offset, off_list);        base_cnt++;       vb = TREE_CHAIN (vb);     }
endif|#
directive|endif
name|name
operator|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|tree
name|arrtype
init|=
name|build_array_type
argument_list|(
name|base_info_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|elts
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|arrtype
argument_list|,
name|NULL_TREE
argument_list|,
name|elts
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|elts
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|elts
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|elts
argument_list|)
operator|=
literal|1
expr_stmt|;
name|complete_array_type
argument_list|(
name|arrtype
argument_list|,
name|elts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|tdecl
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|name_string
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|elts
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_convert
argument_list|(
name|sizetype
argument_list|,
name|build_int_2
argument_list|(
name|base_cnt
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__rtti_class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|base_info_type_node
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __pointer_type_info node.  */
end_comment

begin_function
specifier|static
name|void
name|expand_ptr_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|elems
decl_stmt|,
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|name_string
init|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|get_typeid_1
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|decay_conversion
argument_list|(
name|get_tinfo_var
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|tdecl
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|name_string
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__rtti_ptr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|tmp
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|type_info_type_node
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __attr_type_info node.  */
end_comment

begin_function
specifier|static
name|void
name|expand_attr_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|elems
decl_stmt|,
name|t
decl_stmt|,
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|name_string
init|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|attrval
init|=
name|build_int_2
argument_list|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|expand_expr_stmt
argument_list|(
name|get_typeid_1
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|decay_conversion
argument_list|(
name|get_tinfo_var
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|tdecl
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|name_string
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|attrval
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__rtti_attr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|tmp
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|type_info_type_node
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a type_info node that just has a name.  */
end_comment

begin_function
specifier|static
name|void
name|expand_generic_desc
parameter_list|(
name|tdecl
parameter_list|,
name|type
parameter_list|,
name|fnname
parameter_list|)
name|tree
name|tdecl
decl_stmt|;
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|name_string
init|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|elems
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|tdecl
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|name_string
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
name|fnname
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|tmp
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code for a type_info initialization function.    Note that we take advantage of the passage     5.2.7  Type identification                               [expr.typeid]        Whether or not the destructor is called for the type_info object at the    end of the program is unspecified.     and don't bother to arrange for these objects to be destroyed.  It    doesn't matter, anyway, since the destructors don't do anything.            This must only be called from toplevel (i.e. from finish_file)!  */
end_comment

begin_function
name|void
name|synthesize_tinfo_fn
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmp
decl_stmt|,
name|addr
decl_stmt|,
name|tdecl
decl_stmt|;
if|if
condition|(
name|at_eof
condition|)
block|{
name|import_export_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_REALLY_EXTERN
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return;
block|}
name|tdecl
operator|=
name|get_tinfo_var
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|tdecl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|tdecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
comment|/* If the first word of the array (the vtable) is non-zero, we've already      initialized the object, so don't do it again.  */
name|addr
operator|=
name|decay_conversion
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_indirect_ref
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|tmp
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expand_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|,
literal|"__rtti_func"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|expand_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|,
literal|"__rtti_array"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|expand_attr_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|expand_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|,
literal|"__rtti_ptmd"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|expand_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|,
literal|"__rtti_ptmf"
argument_list|)
expr_stmt|;
else|else
name|expand_ptr_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|expand_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|,
literal|"__rtti_ptmf"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|expand_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|,
literal|"__rtti_user"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_VIA_PUBLIC
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|expand_si_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|expand_class_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|expand_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|type
argument_list|,
literal|"__rtti_user"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|252
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
comment|/* OK, now return the type_info object.  */
name|tmp
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type_info_type_node
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_indirect_ref
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c_expand_return
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

