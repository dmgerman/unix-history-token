begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RunTime Type Identification    Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Mostly written by Jason Merrill (jason@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Accessors for the type_info objects. We need to remember several things    about each of the type_info types. The global tree nodes such as    bltn_desc_type_node are TREE_LISTs, and these macros are used to access    the required information. */
end_comment

begin_comment
comment|/* The RECORD_TYPE of a type_info derived class. */
end_comment

begin_define
define|#
directive|define
name|TINFO_PSEUDO_TYPE
parameter_list|(
name|NODE
parameter_list|)
value|TREE_TYPE (NODE)
end_define

begin_comment
comment|/* The VAR_DECL of the vtable for the type_info derived class. */
end_comment

begin_define
define|#
directive|define
name|TINFO_VTABLE_DECL
parameter_list|(
name|NODE
parameter_list|)
value|TREE_VALUE (NODE)
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_headof
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ifnonnull
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tinfo_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_dynamic_cast_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|throw_bad_cast
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|throw_bad_typeid
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_tinfo_decl_dynamic
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|typeid_ok_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qualifier_flags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|target_incomplete_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tinfo_base_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|generic_initializer
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ptr_initializer
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ptm_initializer
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_class_hint_mark
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_class_hint_unmark
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|class_hint_flags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|class_initializer
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|synthesize_tinfo_var
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|create_real_tinfo_var
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|create_pseudo_type_info
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vmi_pseudo_type_info
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_tinfo_types
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typeinfo_in_lib_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doing_runtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|init_rtti_processing
parameter_list|()
block|{
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|type_info_type_node
operator|=
name|xref_tag
argument_list|(
name|class_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"type_info"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|tinfo_decl_type
operator|=
name|build_qualified_type
argument_list|(
name|type_info_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the expression EXP of type `class *', return the head of the    object pointed to by EXP with type cv void*, if the class has any    virtual functions (TYPE_POLYMORPHIC_P), else just return the    expression.  */
end_comment

begin_function
specifier|static
name|tree
name|build_headof
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|,
literal|20000112
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|exp
return|;
comment|/* We use this a couple of times below, protect it.  */
name|exp
operator|=
name|save_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* The offset-to-top field is at index -2 from the vptr.  */
name|index
operator|=
name|build_int_2
argument_list|(
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|build_vtbl_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_qualified_type
argument_list|(
name|ptr_type_node
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a bad_cast node for the program to throw...     See libstdc++/exception.cc for __throw_bad_cast */
end_comment

begin_function
specifier|static
name|tree
name|throw_bad_cast
parameter_list|()
block|{
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
literal|"__cxa_bad_cast"
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
name|fn
operator|=
name|push_throw_library_fn
argument_list|(
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|throw_bad_typeid
parameter_list|()
block|{
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
literal|"__cxa_bad_typeid"
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|t
init|=
name|build_qualified_type
argument_list|(
name|type_info_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_function_type
argument_list|(
name|build_reference_type
argument_list|(
name|t
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|fn
operator|=
name|push_throw_library_fn
argument_list|(
name|fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|build_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a pointer to type_info function associated with the expression EXP.    If EXP is a reference to a polymorphic class, return the dynamic type;    otherwise return the static type of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|get_tinfo_decl_dynamic
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* peel back references, so they match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|error_mark_node
return|;
comment|/* If exp is a reference to polymorphic type, get the real type_info.  */
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* build reference to type_info from vtable.  */
name|tree
name|t
decl_stmt|;
name|tree
name|index
decl_stmt|;
comment|/* The RTTI information is at index -1.  */
name|index
operator|=
name|integer_minus_one_node
expr_stmt|;
name|t
operator|=
name|build_vtbl_ref
argument_list|(
name|exp
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|tinfo_decl_type
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* otherwise return the type_info for the static type of the expr.  */
name|exp
operator|=
name|get_tinfo_decl
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|typeid_ok_p
parameter_list|()
block|{
if|if
condition|(
operator|!
name|flag_rtti
condition|)
block|{
name|error
argument_list|(
literal|"cannot use typeid with -fno-rtti"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type_info_type_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"must #include<typeinfo> before using typeid"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|tree
name|build_typeid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|cond
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|nonnull
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
operator|||
operator|!
name|typeid_ok_p
argument_list|()
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|TYPEID_EXPR
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|exp
argument_list|,
operator|&
name|nonnull
argument_list|)
operator|&&
operator|!
name|nonnull
condition|)
block|{
name|exp
operator|=
name|stabilize_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|cond
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|get_tinfo_decl_dynamic
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|exp
operator|=
name|build_indirect_ref
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
condition|)
block|{
name|tree
name|bad
init|=
name|throw_bad_typeid
argument_list|()
decl_stmt|;
name|exp
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cond
argument_list|,
name|exp
argument_list|,
name|bad
argument_list|)
expr_stmt|;
block|}
return|return
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the NTBS name of a type.  */
end_comment

begin_function
specifier|static
name|tree
name|tinfo_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|name_string
decl_stmt|;
name|name
operator|=
name|mangle_type_string
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name_string
return|;
block|}
end_function

begin_comment
comment|/* Returns a decl for the type_info variable for TYPE.  You must    arrange that the decl is mark_used, if actually use it --- decls in    vtables are only used if the vtable is output.  */
end_comment

begin_function
name|tree
name|get_tinfo_decl
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"cannot create type information for type `%T' because its size is variable"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|mangle_typeinfo_for_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|d
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
comment|/* The tinfo decl is the type_info object itself.  We make all          tinfo objects look as type_info, even though they will end up          being a subclass of that when emitted.  This means that we'll          erroneously think we know the dynamic type -- be careful in the          runtime.  */
name|d
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|tinfo_decl_type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|d
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_weak
operator|||
operator|!
name|typeinfo_in_lib_p
argument_list|(
name|type
argument_list|)
condition|)
name|comdat_linkage
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Remember the type it is for.  */
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_USED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Return the type_info object for TYPE.  */
end_comment

begin_function
name|tree
name|get_typeid
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|typeid_ok_p
argument_list|()
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|TYPEID_EXPR
argument_list|,
name|type
argument_list|)
return|;
comment|/* If the type of the type-id is a reference type, the result of the      typeid expression refers to a type_info object representing the      referenced type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The top-level cv-qualifiers of the lvalue expression or the type-id      that is the operand of typeid are always ignored.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|error_mark_node
return|;
return|return
name|get_tinfo_decl
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether TEST is null before returning RESULT.  If TEST is used in    RESULT, it must have previously had a save_expr applied to it.  */
end_comment

begin_function
specifier|static
name|tree
name|ifnonnull
parameter_list|(
name|test
parameter_list|,
name|result
parameter_list|)
name|tree
name|test
decl_stmt|,
name|result
decl_stmt|;
block|{
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|test
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working    paper.  */
end_comment

begin_function
specifier|static
name|tree
name|build_dynamic_cast_1
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|tc
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|exprtype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|dcast_fn
decl_stmt|;
name|tree
name|old_expr
init|=
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
init|=
name|NULL
decl_stmt|;
comment|/* T shall be a pointer or reference to a complete class type, or      `pointer to cv void''.  */
switch|switch
condition|(
name|tc
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
break|break;
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"target is not pointer or reference to class"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"target is not pointer or reference to complete type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
default|default:
name|errstr
operator|=
literal|"target is not pointer or reference"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|exprtype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
condition|)
name|expr
operator|=
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Apply trivial conversion T -> T& for dereferenced ptrs.  */
name|exprtype
operator|=
name|build_reference_type
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_to_reference
argument_list|(
name|exprtype
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|exprtype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* If T is a pointer type, v shall be an rvalue of a pointer to 	 complete class type, and the result is an rvalue of type T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|errstr
operator|=
literal|"source is not a pointer"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is not a pointer to class"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is a pointer to incomplete type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
else|else
block|{
comment|/* T is a reference type, v shall be an lvalue of a complete class 	 type, and the result is an lvalue of the type referred to by T.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is not of class type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is of incomplete class type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* The dynamic_cast operator shall not cast away constness.  */
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"conversion casts away constness"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* If *type is an unambiguous accessible base class of *exprtype,      convert statically.  */
block|{
name|tree
name|binfo
decl_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ba_not_special
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|expr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|expr
operator|=
name|non_lvalue
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
comment|/* Otherwise *exprtype must be a polymorphic class (have a vtbl).  */
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|expr1
decl_stmt|;
comment|/* if TYPE is `void *', return pointer to complete object.  */
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* Since expr is used twice below, save it.  */
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr1
operator|=
name|build_headof
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr1
argument_list|)
operator|!=
name|type
condition|)
name|expr1
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr1
argument_list|)
expr_stmt|;
return|return
name|ifnonnull
argument_list|(
name|expr
argument_list|,
name|expr1
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|retval
decl_stmt|;
name|tree
name|result
decl_stmt|,
name|td2
decl_stmt|,
name|td3
decl_stmt|,
name|elems
decl_stmt|;
name|tree
name|static_type
decl_stmt|,
name|target_type
decl_stmt|,
name|boff
decl_stmt|;
comment|/* If we got here, we can't convert statically.  Therefore, 	     dynamic_cast<D&>(b) (b an object) cannot succeed.  */
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_expr
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_expr
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|expr
init|=
name|throw_bad_cast
argument_list|()
decl_stmt|;
name|warning
argument_list|(
literal|"dynamic_cast of `%#D' to `%#T' can never succeed"
argument_list|,
name|old_expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Bash it to the expected type.  */
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
comment|/* Ditto for dynamic_cast<D*>(&b).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|"dynamic_cast of `%#D' to `%#T' can never succeed"
argument_list|,
name|op
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
name|target_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|static_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
expr_stmt|;
name|td2
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_tinfo_decl
argument_list|(
name|target_type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|td3
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_tinfo_decl
argument_list|(
name|static_type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine how T and V are related.  */
name|boff
operator|=
name|get_dynamic_cast_base_type
argument_list|(
name|static_type
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* Since expr is used twice below, save it.  */
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr1
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
name|expr1
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr1
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td3
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td2
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|boff
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dcast_fn
operator|=
name|dynamic_cast_node
expr_stmt|;
if|if
condition|(
operator|!
name|dcast_fn
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|tinfo_ptr
decl_stmt|;
name|tree
name|ns
init|=
name|abi_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|tinfo_ptr
operator|=
name|xref_tag
argument_list|(
name|class_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"__class_type_info"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tinfo_ptr
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|tinfo_ptr
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"__dynamic_cast"
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dcast_fn
operator|=
name|build_library_fn_ptr
argument_list|(
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|dynamic_cast_node
operator|=
name|dcast_fn
expr_stmt|;
block|}
name|result
operator|=
name|build_call
argument_list|(
name|dcast_fn
argument_list|,
name|elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|bad
init|=
name|throw_bad_cast
argument_list|()
decl_stmt|;
name|result
operator|=
name|save_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|result
argument_list|,
name|result
argument_list|,
name|bad
argument_list|)
return|;
block|}
comment|/* Now back to the type we want from a void*.  */
name|result
operator|=
name|cp_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|ifnonnull
argument_list|(
name|expr
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
else|else
name|errstr
operator|=
literal|"source type is not polymorphic"
expr_stmt|;
name|fail
label|:
name|error
argument_list|(
literal|"cannot dynamic_cast `%E' (of type `%#T') to type `%#T' (%s)"
argument_list|,
name|expr
argument_list|,
name|exprtype
argument_list|,
name|type
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_dynamic_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|DYNAMIC_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
return|return
name|convert_from_reference
argument_list|(
name|build_dynamic_cast_1
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the runtime bit mask encoding the qualifiers of TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|qualifier_flags
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* we want the qualifiers on this type, not any array core, it might have */
name|int
name|quals
init|=
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_CONST
condition|)
name|flags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|flags
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
name|flags
operator||=
literal|4
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero, if the pointer chain TYPE ends at an incomplete type, or    contains a pointer to member of an incomplete class.  */
end_comment

begin_function
specifier|static
name|int
name|target_incomplete_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|type
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a CONSTRUCTOR for the common part of the type_info objects. This    is the vtable pointer and NTBS name.  The NTBS name is emitted as a    comdat const char array, so it becomes a unique key for the type. Generate    and emit that VAR_DECL here.  (We can't always emit the type_info itself    as comdat, because of pointers to incomplete.) */
end_comment

begin_function
specifier|static
name|tree
name|tinfo_base_init
parameter_list|(
name|desc
parameter_list|,
name|target
parameter_list|)
name|tree
name|desc
decl_stmt|;
name|tree
name|target
decl_stmt|;
block|{
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name_decl
decl_stmt|;
block|{
name|tree
name|name_name
decl_stmt|;
comment|/* Generate the NTBS array variable.  */
name|tree
name|name_type
init|=
name|build_cplus_array_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|name_string
init|=
name|tinfo_name
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|name_name
operator|=
name|mangle_typeinfo_string_for_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|name_decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name_name
argument_list|,
name|name_type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|comdat_linkage
argument_list|(
name|name_decl
argument_list|)
expr_stmt|;
comment|/* External name of the string containing the type's name has a        special name.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|name_decl
argument_list|,
name|mangle_typeinfo_string_for_type
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|name_decl
argument_list|)
operator|=
name|name_string
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|name_decl
argument_list|,
name|name_string
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|name_decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TINFO_VTABLE_DECL
argument_list|(
name|desc
argument_list|)
condition|)
block|{
name|tree
name|vtbl_ptr
init|=
name|TINFO_VTABLE_DECL
argument_list|(
name|desc
argument_list|)
decl_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vtbl_ptr
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|name_decl
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of TYPE. DESC provides the    information about the particular type_info derivation, which adds no    additional fields to the type_info base.  */
end_comment

begin_function
specifier|static
name|tree
name|generic_initializer
parameter_list|(
name|desc
parameter_list|,
name|target
parameter_list|)
name|tree
name|desc
decl_stmt|;
name|tree
name|target
decl_stmt|;
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|desc
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of pointer TYPE.    DESC provides information about the particular type_info derivation,    which adds target type and qualifier flags members to the type_info base.  */
end_comment

begin_function
specifier|static
name|tree
name|ptr_initializer
parameter_list|(
name|desc
parameter_list|,
name|target
parameter_list|,
name|non_public_ptr
parameter_list|)
name|tree
name|desc
decl_stmt|;
name|tree
name|target
decl_stmt|;
name|int
modifier|*
name|non_public_ptr
decl_stmt|;
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|desc
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|tree
name|to
init|=
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|qualifier_flags
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|incomplete
init|=
name|target_incomplete_p
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|incomplete
condition|)
block|{
name|flags
operator||=
literal|8
expr_stmt|;
operator|*
name|non_public_ptr
operator|=
literal|1
expr_stmt|;
block|}
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_tinfo_decl
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of pointer to member data TYPE.    DESC provides information about the particular type_info derivation,    which adds class, target type and qualifier flags members to the type_info    base.  */
end_comment

begin_function
specifier|static
name|tree
name|ptm_initializer
parameter_list|(
name|desc
parameter_list|,
name|target
parameter_list|,
name|non_public_ptr
parameter_list|)
name|tree
name|desc
decl_stmt|;
name|tree
name|target
decl_stmt|;
name|int
modifier|*
name|non_public_ptr
decl_stmt|;
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|desc
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|tree
name|to
init|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|tree
name|klass
init|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|qualifier_flags
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|incomplete
init|=
name|target_incomplete_p
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|incomplete
condition|)
block|{
name|flags
operator||=
literal|0x8
expr_stmt|;
operator|*
name|non_public_ptr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|klass
argument_list|)
condition|)
block|{
name|flags
operator||=
literal|0x10
expr_stmt|;
operator|*
name|non_public_ptr
operator|=
literal|1
expr_stmt|;
block|}
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_tinfo_decl
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_tinfo_decl
argument_list|(
name|klass
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Check base BINFO to set hint flags in *DATA, which is really an int.    We use CLASSTYPE_MARKED to tag types we've found as non-virtual bases and    CLASSTYPE_MARKED2 to tag those which are virtual bases. Remember it is    possible for a type to be both a virtual and non-virtual base.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_class_hint_mark
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
modifier|*
name|hint
init|=
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
condition|)
operator|*
name|hint
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
condition|)
operator|*
name|hint
operator||=
literal|2
expr_stmt|;
name|SET_CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
operator|||
name|CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
condition|)
operator|*
name|hint
operator||=
literal|1
expr_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
operator|!=
name|binfo
condition|)
operator|*
name|hint
operator||=
literal|4
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Clear the base's dfs marks, after searching for duplicate bases. */
end_comment

begin_function
specifier|static
name|tree
name|dfs_class_hint_unmark
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLEAR_CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Determine the hint flags describing the features of a class's hierarchy.  */
end_comment

begin_function
specifier|static
name|int
name|class_hint_flags
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|hint_flags
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_class_hint_mark
argument_list|,
name|NULL
argument_list|,
operator|&
name|hint_flags
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_class_hint_unmark
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|hint_flags
operator||=
literal|0x8
expr_stmt|;
block|}
return|return
name|hint_flags
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of class TYPE.    DESC provides information about the particular __class_type_info derivation,    which adds hint flags and TRAIL initializers to the type_info base.  */
end_comment

begin_function
specifier|static
name|tree
name|class_initializer
parameter_list|(
name|desc
parameter_list|,
name|target
parameter_list|,
name|trail
parameter_list|)
name|tree
name|desc
decl_stmt|;
name|tree
name|target
decl_stmt|;
name|tree
name|trail
decl_stmt|;
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|desc
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|=
name|trail
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the typeinfo for type should be placed in     the runtime library.  */
end_comment

begin_function
specifier|static
name|int
name|typeinfo_in_lib_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* The typeinfo objects for `T*' and `const T*' are in the runtime      library for simple types T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_QUAL_CONST
operator|||
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a pseudo_type_info VAR_DECL suitable for the supplied    TARGET_TYPE and given the REAL_NAME. This is the structure expected by    the runtime, and therefore has additional fields.  If we need not emit a    definition (because the runtime must contain it), return NULL_TREE,    otherwise return the VAR_DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|synthesize_tinfo_var
parameter_list|(
name|target_type
parameter_list|,
name|real_name
parameter_list|)
name|tree
name|target_type
decl_stmt|;
name|tree
name|real_name
decl_stmt|;
block|{
name|tree
name|var_init
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|var_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|non_public
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|var_type
operator|=
name|ptm_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|ptm_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|,
operator|&
name|non_public
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|typeinfo_in_lib_p
argument_list|(
name|target_type
argument_list|)
operator|&&
operator|!
name|doing_runtime
condition|)
comment|/* These are in the runtime.  */
return|return
name|NULL_TREE
return|;
name|var_type
operator|=
name|ptr_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|ptr_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|,
operator|&
name|non_public
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|var_type
operator|=
name|enum_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|generic_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|var_type
operator|=
name|func_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|generic_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|var_type
operator|=
name|ary_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|generic_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|var_type
operator|=
name|ptm_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|ptm_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|,
operator|&
name|non_public
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
comment|/* Emit a non-public class_type_info.  */
name|non_public
operator|=
literal|1
expr_stmt|;
name|var_type
operator|=
name|class_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|class_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|var_type
operator|=
name|class_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|class_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if this has a single public non-virtual base, it's easier */
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|target_type
argument_list|)
decl_stmt|;
name|int
name|nbases
init|=
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|base_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|base_inits
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|is_simple
init|=
name|nbases
operator|==
literal|1
decl_stmt|;
name|int
name|ix
decl_stmt|;
comment|/* Generate the base information initializer.  */
for|for
control|(
name|ix
operator|=
name|nbases
init|;
name|ix
operator|--
condition|;
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|tree
name|base_init
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|tree
name|tinfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|flags
operator||=
literal|2
expr_stmt|;
name|tinfo
operator|=
name|get_tinfo_decl
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|tinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
comment|/* We store the vtable offset at which the virtual        		      base offset can be found.  */
name|offset
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|target_type
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|flags
operator||=
literal|1
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* is it a single public inheritance? */
if|if
condition|(
name|is_simple
operator|&&
name|flags
operator|==
literal|2
operator|&&
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
block|}
name|is_simple
operator|=
literal|0
expr_stmt|;
comment|/* combine offset and flags into one field */
name|offset
operator|=
name|cp_build_binary_op
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|offset
argument_list|,
name|build_int_2
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cp_build_binary_op
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|offset
argument_list|,
name|build_int_2
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|base_init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|offset
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
name|base_init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
name|base_init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_init
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_simple
condition|)
name|var_type
operator|=
name|si_class_desc_type_node
expr_stmt|;
else|else
block|{
name|int
name|hint
init|=
name|class_hint_flags
argument_list|(
name|target_type
argument_list|)
decl_stmt|;
name|base_inits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_inits
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Prepend the number of bases.  */
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|nbases
argument_list|,
literal|0
argument_list|)
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
comment|/* Prepend the hint flags. */
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|hint
argument_list|,
literal|0
argument_list|)
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
name|var_type
operator|=
name|get_vmi_pseudo_type_info
argument_list|(
name|nbases
argument_list|)
expr_stmt|;
block|}
name|var_init
operator|=
name|class_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|typeinfo_in_lib_p
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|doing_runtime
condition|)
comment|/* These are guaranteed to be in the runtime.  */
return|return
name|NULL_TREE
return|;
name|var_type
operator|=
name|bltn_desc_type_node
expr_stmt|;
name|var_init
operator|=
name|generic_initializer
argument_list|(
name|var_type
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|create_real_tinfo_var
argument_list|(
name|target_type
argument_list|,
name|real_name
argument_list|,
name|TINFO_PSEUDO_TYPE
argument_list|(
name|var_type
argument_list|)
argument_list|,
name|var_init
argument_list|,
name|non_public
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create the real typeinfo variable.  NON_PUBLIC indicates that we cannot    make this variable public (comdat). */
end_comment

begin_function
specifier|static
name|tree
name|create_real_tinfo_var
parameter_list|(
name|target_type
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|,
name|non_public
parameter_list|)
name|tree
name|target_type
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|non_public
decl_stmt|;
block|{
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|hidden_name
decl_stmt|;
name|char
name|hidden
index|[
literal|30
index|]
decl_stmt|;
comment|/* We cannot give this the name NAME, as that already is globally      bound to the tinfo_decl we originally created for this type in      get_tinfo_decl. */
name|sprintf
argument_list|(
name|hidden
argument_list|,
literal|"__ti_%d"
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
name|hidden_name
operator|=
name|get_identifier
argument_list|(
name|hidden
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|hidden_name
argument_list|,
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|non_public
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_weak
operator|||
operator|!
name|typeinfo_in_lib_p
argument_list|(
name|target_type
argument_list|)
condition|)
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Generate the RECORD_TYPE containing the data layout of a type_info    derivative as used by the runtime. This layout must be consistent with    that defined in the runtime support. Also generate the VAR_DECL for the    type's vtable. We explicitly manage the vtable member, and name it for    real type as used in the runtime. The RECORD type has a different name,    to avoid collisions.  Return a TREE_LIST who's TINFO_PSEUDO_TYPE    is the generated type and TINFO_VTABLE_DECL is the vtable decl.        REAL_NAME is the runtime's name of the type. Trailing arguments are    additional FIELD_DECL's for the structure. The final argument must be    NULL.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|create_pseudo_type_info
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|real_name
operator|,
name|int
name|ident
operator|,
operator|...
operator|)
argument_list|)
block|{
name|tree
name|real_type
decl_stmt|,
name|pseudo_type
decl_stmt|;
name|char
modifier|*
name|pseudo_name
decl_stmt|;
name|tree
name|vtable_decl
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|tree
name|fields
index|[
literal|10
index|]
decl_stmt|;
name|tree
name|field_decl
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|ident
argument_list|)
expr_stmt|;
comment|/* Generate the pseudo type name. */
name|pseudo_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|real_name
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pseudo_name
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pseudo_name
argument_list|,
literal|"_pseudo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
condition|)
name|sprintf
argument_list|(
name|pseudo_name
operator|+
name|strlen
argument_list|(
name|pseudo_name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
comment|/* Get the vtable decl. */
name|real_type
operator|=
name|xref_tag
argument_list|(
name|class_type_node
argument_list|,
name|get_identifier
argument_list|(
name|real_name
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|real_type
argument_list|)
condition|)
block|{
comment|/* We never saw a definition of this type, so we need to tell the 	 compiler that this is an exported class, as indeed all of the 	 __*_type_info classes are.  */
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|real_type
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|real_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|vtable_decl
operator|=
name|get_vtable_decl
argument_list|(
name|real_type
argument_list|,
comment|/*complete=*/
literal|1
argument_list|)
expr_stmt|;
name|vtable_decl
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtable_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need to point into the middle of the vtable.  */
name|vtable_decl
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtable_decl
argument_list|)
argument_list|,
name|vtable_decl
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_int
argument_list|(
literal|2
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vtable_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* First field is the pseudo type_info base class. */
name|fields
index|[
literal|0
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ti_desc_type_node
argument_list|)
expr_stmt|;
comment|/* Now add the derived fields.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
operator|(
name|field_decl
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|)
operator|)
condition|;
control|)
name|fields
index|[
operator|++
name|ix
index|]
operator|=
name|field_decl
expr_stmt|;
comment|/* Create the pseudo type. */
name|pseudo_type
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|pseudo_type
argument_list|,
name|pseudo_name
argument_list|,
name|fields
argument_list|,
name|ix
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|pseudo_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TINFO_VTABLE_DECL
argument_list|(
name|result
argument_list|)
operator|=
name|vtable_decl
expr_stmt|;
name|TINFO_PSEUDO_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|pseudo_type
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return a descriptor for a vmi type with NUM_BASES bases.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vmi_pseudo_type_info
parameter_list|(
name|num_bases
parameter_list|)
name|int
name|num_bases
decl_stmt|;
block|{
name|tree
name|desc
decl_stmt|;
name|tree
name|array_domain
decl_stmt|,
name|base_array
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|vmi_class_desc_type_node
argument_list|)
operator|<=
name|num_bases
condition|)
block|{
name|int
name|ix
decl_stmt|;
name|tree
name|extend
init|=
name|make_tree_vec
argument_list|(
name|num_bases
operator|+
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|vmi_class_desc_type_node
argument_list|)
init|;
name|ix
operator|--
condition|;
control|)
name|TREE_VEC_ELT
argument_list|(
name|extend
argument_list|,
name|ix
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|vmi_class_desc_type_node
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|vmi_class_desc_type_node
operator|=
name|extend
expr_stmt|;
block|}
name|desc
operator|=
name|TREE_VEC_ELT
argument_list|(
name|vmi_class_desc_type_node
argument_list|,
name|num_bases
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
condition|)
return|return
name|desc
return|;
comment|/* Add number of bases and trailing array of base_class_type_info.  */
name|array_domain
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|num_bases
argument_list|)
argument_list|)
expr_stmt|;
name|base_array
operator|=
name|build_array_type
argument_list|(
name|base_desc_type_node
argument_list|,
name|array_domain
argument_list|)
expr_stmt|;
name|push_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
name|desc
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__vmi_class_type_info"
argument_list|,
name|num_bases
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|base_array
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vmi_class_desc_type_node
argument_list|,
name|num_bases
argument_list|)
operator|=
name|desc
expr_stmt|;
return|return
name|desc
return|;
block|}
end_function

begin_comment
comment|/* Make sure the required builtin types exist for generating the type_info    varable definitions.  */
end_comment

begin_function
specifier|static
name|void
name|create_tinfo_types
parameter_list|()
block|{
name|tree
name|ptr_type_info
decl_stmt|;
if|if
condition|(
name|bltn_desc_type_node
condition|)
return|return;
name|push_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
name|ptr_type_info
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|type_info_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the internal type_info structure. This is used as a base for      the other structures.  */
block|{
name|tree
name|fields
index|[
literal|2
index|]
decl_stmt|;
name|ti_desc_type_node
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|ti_desc_type_node
argument_list|,
literal|"__type_info_pseudo"
argument_list|,
name|fields
argument_list|,
literal|1
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ti_desc_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Fundamental type_info */
name|bltn_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__fundamental_type_info"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Array, function and enum type_info. No additional fields. */
name|ary_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__array_type_info"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|func_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__function_type_info"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|enum_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__enum_type_info"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Class type_info. Add a flags field.  */
name|class_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__class_type_info"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Single public non-virtual base class. Add pointer to base class.       This is really a descendant of __class_type_info.  */
name|si_class_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__si_class_type_info"
argument_list|,
literal|0
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_info
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Base class internal helper. Pointer to base type, offset to base,      flags. */
block|{
name|tree
name|fields
index|[
literal|2
index|]
decl_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_info
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_types
index|[
name|itk_long
index|]
argument_list|)
expr_stmt|;
name|base_desc_type_node
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|base_desc_type_node
argument_list|,
literal|"__base_class_type_info_pseudo"
argument_list|,
name|fields
argument_list|,
literal|1
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|base_desc_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* General hierarchy is created as necessary in this vector. */
name|vmi_class_desc_type_node
operator|=
name|make_tree_vec
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Pointer type_info. Adds two fields, qualification mask      and pointer to the pointed to type.  This is really a descendant of      __pbase_type_info. */
name|ptr_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__pointer_type_info"
argument_list|,
literal|0
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_info
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pointer to member data type_info.  Add qualifications flags,      pointer to the member's type info and pointer to the class.      This is really a descendant of __pbase_type_info.  */
name|ptm_desc_type_node
operator|=
name|create_pseudo_type_info
argument_list|(
literal|"__pointer_to_member_type_info"
argument_list|,
literal|0
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_info
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_info
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the type_info descriptors which are guaranteed to be in the runtime    support.  Generating them here guarantees consistency with the other    structures.  We use the following heuristic to determine when the runtime    is being generated.  If std::__fundamental_type_info is defined, and its    destructor is defined, then the runtime is being built.  */
end_comment

begin_function
name|void
name|emit_support_tinfos
parameter_list|()
block|{
specifier|static
name|tree
modifier|*
specifier|const
name|fundamentals
index|[]
init|=
block|{
operator|&
name|void_type_node
block|,
operator|&
name|boolean_type_node
block|,
operator|&
name|wchar_type_node
block|,
operator|&
name|char_type_node
block|,
operator|&
name|signed_char_type_node
block|,
operator|&
name|unsigned_char_type_node
block|,
operator|&
name|short_integer_type_node
block|,
operator|&
name|short_unsigned_type_node
block|,
operator|&
name|integer_type_node
block|,
operator|&
name|unsigned_type_node
block|,
operator|&
name|long_integer_type_node
block|,
operator|&
name|long_unsigned_type_node
block|,
operator|&
name|long_long_integer_type_node
block|,
operator|&
name|long_long_unsigned_type_node
block|,
operator|&
name|float_type_node
block|,
operator|&
name|double_type_node
block|,
operator|&
name|long_double_type_node
block|,
literal|0
block|}
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|tree
name|bltn_type
decl_stmt|,
name|dtor
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
name|bltn_type
operator|=
name|xref_tag
argument_list|(
name|class_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"__fundamental_type_info"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|bltn_type
argument_list|)
condition|)
return|return;
name|dtor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|bltn_type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|dtor
argument_list|)
condition|)
return|return;
name|doing_runtime
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fundamentals
index|[
name|ix
index|]
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|bltn
init|=
operator|*
name|fundamentals
index|[
name|ix
index|]
decl_stmt|;
name|tree
name|bltn_ptr
init|=
name|build_pointer_type
argument_list|(
name|bltn
argument_list|)
decl_stmt|;
name|tree
name|bltn_const_ptr
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|bltn
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tinfo
decl_stmt|;
name|tinfo
operator|=
name|get_tinfo_decl
argument_list|(
name|bltn
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|tinfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tinfo
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tinfo
operator|=
name|get_tinfo_decl
argument_list|(
name|bltn_ptr
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|tinfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tinfo
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tinfo
operator|=
name|get_tinfo_decl
argument_list|(
name|bltn_const_ptr
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|tinfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tinfo
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero, iff T is a type_info variable which has not had a    definition emitted for it.  */
end_comment

begin_function
name|int
name|tinfo_decl_p
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
operator|(
name|t
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|tinfo_decl_type
operator|&&
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit a suitable type_info definition for the type_info decl pointed to by    DECL_PTR. We emit a completely new variable, of the correct type for the    actual type this is describing. The DECL_ASSEMBLER_NAME of the generated    definition is set to that of the supplied decl, so that they can be tied    up. Mark the supplied decl as having been dealt with. Emitting one    definition might cause other definitions to be required.        We need to do things this way, because we're trying to do something like           struct B : A {         ...       };           extern const A tinfo_var;           const B tinfo_var = {...};        which is not permitted. Also, we've not necessarily seen the definition of B.    So we do something like the following,           extern const A tinfo_var;           struct pseudo_A {         const void *vtable_ptr;         const char *name;       };       struct pseudo_B {         pseudo_A base;         ...       };              const pseudo_B proxy_tinfo_var attribute((assembler_name="tinfo_var")) =       {         {&B::vtable, "..."},         ...       };        pseudo_A and pseudo_B must be layout equivalent to the real definitions in    the runtime.  */
end_comment

begin_function
name|int
name|emit_tinfo_decl
parameter_list|(
name|decl_ptr
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|decl_ptr
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|tinfo_decl
init|=
operator|*
name|decl_ptr
decl_stmt|;
name|tree
name|tinfo_type
decl_stmt|,
name|decl
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|tinfo_decl
argument_list|)
operator|==
name|tinfo_decl_type
argument_list|,
literal|20000121
argument_list|)
expr_stmt|;
name|tinfo_type
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|tinfo_decl
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|tinfo_type
operator|!=
name|NULL_TREE
argument_list|,
literal|20000120
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NEEDED_P
argument_list|(
name|tinfo_decl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Say we've dealt with it.  */
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|tinfo_decl
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|create_tinfo_types
argument_list|()
expr_stmt|;
name|decl
operator|=
name|synthesize_tinfo_var
argument_list|(
name|tinfo_type
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tinfo_decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
operator|!=
literal|0
return|;
block|}
end_function

end_unit

