begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions dealing with signatures and signature pointers/references.    Copyright (C) 1992, 93-97, 1998 Free Software Foundation, Inc.    Contributed by Gerald Baumgartner (gb@cs.purdue.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|save_this
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_sptr_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_member_function_pointer
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|undo_casts
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_signature_pointer_or_reference_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_signature_pointer_or_reference_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_signature_pointer_or_reference_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_sigtable_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_signature_table_constructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_method_types
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_sigtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to help generate globally unique names for signature tables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_sigtable_name_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build an identifier for a signature pointer or reference, so we    can use it's name in function name mangling.  */
end_comment

begin_function
specifier|static
name|tree
name|build_signature_pointer_or_reference_name
parameter_list|(
name|to_type
parameter_list|,
name|type_quals
parameter_list|,
name|refp
parameter_list|)
name|tree
name|to_type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|int
name|refp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|sig_name
init|=
name|TYPE_NAME_STRING
argument_list|(
name|to_type
argument_list|)
decl_stmt|;
name|int
name|name_len
init|=
name|TYPE_NAME_LENGTH
argument_list|(
name|to_type
argument_list|)
operator|+
literal|3
comment|/* Enough room for 						   C,V,R.  */
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|const_rep
init|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
condition|?
literal|"C"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|restrict_rep
init|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
condition|?
literal|"R"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|volatile_rep
init|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
condition|?
literal|"C"
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|refp
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|name_len
operator|+
sizeof|sizeof
argument_list|(
name|SIGNATURE_REFERENCE_NAME
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|SIGNATURE_REFERENCE_NAME_FORMAT
argument_list|,
name|const_rep
argument_list|,
name|volatile_rep
argument_list|,
name|restrict_rep
argument_list|,
name|sig_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|name_len
operator|+
sizeof|sizeof
argument_list|(
name|SIGNATURE_POINTER_NAME
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|SIGNATURE_POINTER_NAME_FORMAT
argument_list|,
name|const_rep
argument_list|,
name|volatile_rep
argument_list|,
name|restrict_rep
argument_list|,
name|sig_name
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a DECL node for a signature pointer or reference, so we can    tell the debugger the structure of signature pointers/references.    This function is called at most eight times for a given signature,    once for each [const] [volatile] signature pointer/reference.  */
end_comment

begin_function
specifier|static
name|void
name|build_signature_pointer_or_reference_decl
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
comment|/* We don't enter this declaration in any sort of symbol table.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of pointers or references to    signature TO_TYPE.  If such a type has already been constructed,    reuse it. If TYPE_QUALS are specified, qualify the `optr'.  If we    are constructing a const/volatile type variant and the main type    variant doesn't exist yet, it is built as well.  If REFP is 1, we    construct a signature reference, otherwise a signature pointer is    constructed.     This function is a subroutine of `build_signature_pointer_type' and    `build_signature_reference_type'.  */
end_comment

begin_function
specifier|static
name|tree
name|build_signature_pointer_or_reference_type
parameter_list|(
name|to_type
parameter_list|,
name|type_quals
parameter_list|,
name|refp
parameter_list|)
name|tree
name|to_type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|int
name|refp
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|,
name|m
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
name|m
operator|=
name|refp
condition|?
name|SIGNATURE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
else|:
name|SIGNATURE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
expr_stmt|;
comment|/* If we don't have the main variant yet, construct it.  */
if|if
condition|(
name|m
operator|==
name|NULL_TREE
operator|&&
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|m
operator|=
name|build_signature_pointer_or_reference_type
argument_list|(
name|to_type
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|,
name|refp
argument_list|)
expr_stmt|;
comment|/* Treat any nonzero argument as 1.  */
name|refp
operator|=
operator|!
operator|!
name|refp
expr_stmt|;
comment|/* If not generating auxiliary info, search the chain of variants to see      if there is already one there just like the one we need to have.  If so,      use that existing one.       We don't do this in the case where we are generating aux info because      in that case we want each typedef names to get it's own distinct type      node, even if the type of this new typedef is the same as some other      (existing) type.  */
if|if
condition|(
name|m
operator|&&
operator|!
name|flag_gen_aux_info
condition|)
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|type_quals
operator|==
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|to_type
argument_list|)
condition|)
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
comment|/* A signature pointer or reference to a signature `s' looks like this:         struct {          void * optr; 	 const s * sptr;        };       A `const' signature pointer/reference is a         struct {          const void * optr; 	 const s * sptr;        };       Similarly, for `volatile' and `const volatile'.  */
name|t
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
block|{
name|tree
name|obj_type
init|=
name|build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|type_quals
argument_list|)
decl_stmt|;
name|tree
name|optr_type
init|=
name|build_pointer_type
argument_list|(
name|obj_type
argument_list|)
decl_stmt|;
name|tree
name|optr
decl_stmt|,
name|sptr
decl_stmt|;
name|optr
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|SIGNATURE_OPTR_NAME
argument_list|)
argument_list|,
name|optr_type
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|optr
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|optr
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|m
condition|)
comment|/* We can share the `sptr' field among type variants.  */
name|sptr
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|sig_tbl_type
init|=
name|cp_build_qualified_type
argument_list|(
name|to_type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
decl_stmt|;
name|sptr
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|SIGNATURE_SPTR_NAME
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|sig_tbl_type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|sptr
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|sptr
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|sptr
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|optr
argument_list|)
operator|=
name|sptr
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|optr
expr_stmt|;
comment|/* Allow signature pointers/references to be grabbed 2 words at a time.        For this to work on a Sparc, we need 8-byte alignment.  */
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|optr_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A signature pointer/reference type isn't a `real' class type.  */
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
name|name
init|=
name|build_signature_pointer_or_reference_name
argument_list|(
name|to_type
argument_list|,
name|type_quals
argument_list|,
name|refp
argument_list|)
decl_stmt|;
comment|/* Build a DECL node for this type, so the debugger has access to it.  */
name|build_signature_pointer_or_reference_decl
argument_list|(
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IS_SIGNATURE_POINTER
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|refp
expr_stmt|;
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|t
argument_list|)
operator|=
name|refp
expr_stmt|;
name|SIGNATURE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|to_type
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
comment|/* Add this type to the chain of variants of TYPE. 	 Every type has to be its own TYPE_MAIN_VARIANT.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refp
condition|)
comment|/* Record this type as the reference to TO_TYPE.  */
name|SIGNATURE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
else|else
comment|/* Record this type as the pointer to TO_TYPE.  */
name|SIGNATURE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Lay out the type.  This function has many callers that are concerned      with expression-construction, and this simplifies them all.      Also, it guarantees the TYPE_SIZE is permanent if the type is.  */
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
comment|/* Output debug information for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of pointers to signature TO_TYPE.  */
end_comment

begin_function
name|tree
name|build_signature_pointer_type
parameter_list|(
name|to_type
parameter_list|)
name|tree
name|to_type
decl_stmt|;
block|{
return|return
name|build_signature_pointer_or_reference_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|to_type
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of pointers to signature TO_TYPE.  */
end_comment

begin_function
name|tree
name|build_signature_reference_type
parameter_list|(
name|to_type
parameter_list|)
name|tree
name|to_type
decl_stmt|;
block|{
return|return
name|build_signature_pointer_or_reference_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|to_type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the signature table (as an IDENTIFIER_NODE)    for the given signature type SIG_TYPE and rhs type RHS_TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_sigtable_name
parameter_list|(
name|sig_type
parameter_list|,
name|rhs_type
parameter_list|)
name|tree
name|sig_type
decl_stmt|,
name|rhs_type
decl_stmt|;
block|{
name|tree
name|sig_type_id
init|=
name|build_typename_overload
argument_list|(
name|sig_type
argument_list|)
decl_stmt|;
name|tree
name|rhs_type_id
init|=
name|build_typename_overload
argument_list|(
name|rhs_type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|SIGTABLE_NAME_FORMAT_LONG
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|sig_type_id
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|rhs_type_id
argument_list|)
operator|+
literal|20
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sig_ptr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|sig_type_id
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rhs_ptr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|rhs_type_id
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig_ptr
index|[
name|i
index|]
operator|==
name|OPERATOR_TYPENAME_FORMAT
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
while|while
condition|(
name|sig_ptr
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|sig_ptr
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
name|i
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|rhs_ptr
index|[
name|j
index|]
operator|==
name|OPERATOR_TYPENAME_FORMAT
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
while|while
condition|(
name|rhs_ptr
index|[
name|j
index|]
operator|>=
literal|'0'
operator|&&
name|rhs_ptr
index|[
name|j
index|]
operator|<=
literal|'9'
condition|)
name|j
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|rhs_type
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|SIGTABLE_NAME_FORMAT_LONG
argument_list|,
name|sig_ptr
operator|+
name|i
argument_list|,
name|rhs_ptr
operator|+
name|j
argument_list|,
name|global_sigtable_name_counter
operator|++
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
name|SIGTABLE_NAME_FORMAT
argument_list|,
name|sig_ptr
operator|+
name|i
argument_list|,
name|rhs_ptr
operator|+
name|j
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a field decl that points to a signature member function.  */
end_comment

begin_function
specifier|static
name|tree
name|build_member_function_pointer
parameter_list|(
name|member
parameter_list|)
name|tree
name|member
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|namstr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|member
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|namlen
init|=
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|member
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|entry
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|namlen
operator|+
sizeof|sizeof
argument_list|(
name|SIGNATURE_FIELD_NAME
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|SIGNATURE_FIELD_NAME_FORMAT
argument_list|,
name|namstr
argument_list|)
expr_stmt|;
comment|/* @@ Do we really want to xref signature table fields?  */
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|entry
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|sigtable_entry_type
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* @@ Do we really want to xref signature table fields?  */
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* For each FUNCTION_DECL in a signature we construct a member function    pointer of the appropriate type.  We also need two flags to test    whether the member function pointer points to a virtual function or    to a default implementation.  Those flags will be the two lower order    bits of the member function pointer (or the two higher order bits,    based on the configuration).     The new FIELD_DECLs are appended at the end of the last (and only)    sublist of `list_of_fieldlists.'     T is the signature type.       As a side effect, each member function in the signature gets the    `decl.ignored' bit turned on, so we don't output debug info for it.  */
end_comment

begin_function
name|void
name|append_signature_fields
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|tree
name|mfptr
decl_stmt|;
name|tree
name|last_mfptr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|mfptr_list
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|mfptr
operator|=
name|build_member_function_pointer
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|DECL_MEMFUNC_POINTER_TO
argument_list|(
name|x
argument_list|)
operator|=
name|mfptr
expr_stmt|;
name|DECL_MEMFUNC_POINTING_TO
argument_list|(
name|mfptr
argument_list|)
operator|=
name|x
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|mfptr
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|mfptr_list
condition|)
name|mfptr_list
operator|=
name|last_mfptr
operator|=
name|mfptr
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_mfptr
argument_list|)
operator|=
name|mfptr
expr_stmt|;
name|last_mfptr
operator|=
name|mfptr
expr_stmt|;
block|}
block|}
block|}
comment|/* The member function pointers must come after the TYPE_DECLs, in      this case, because build_signature_table_constructor depends on      finding opaque TYPE_DECLS before the functions that make use of      them.  */
if|if
condition|(
name|last_mfptr
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|mfptr_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare the types of a signature member function and a class member    function.  Returns 1 if the types are in the C++ `<=' relationship.     If we have a signature pointer/reference as argument or return type    we don't want to do a recursive conformance check.  The conformance    check only succeeds if both LHS and RHS refer to the same signature    pointer.  Otherwise we need to keep information about parameter types    around at run time to initialize the signature table correctly.  */
end_comment

begin_function
specifier|static
name|int
name|match_method_types
parameter_list|(
name|sig_mtype
parameter_list|,
name|class_mtype
parameter_list|)
name|tree
name|sig_mtype
decl_stmt|,
name|class_mtype
decl_stmt|;
block|{
name|tree
name|sig_return_type
init|=
name|TREE_TYPE
argument_list|(
name|sig_mtype
argument_list|)
decl_stmt|;
name|tree
name|sig_arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|sig_mtype
argument_list|)
decl_stmt|;
name|tree
name|class_return_type
init|=
name|TREE_TYPE
argument_list|(
name|class_mtype
argument_list|)
decl_stmt|;
name|tree
name|class_arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|class_mtype
argument_list|)
decl_stmt|;
comment|/* The return types have to be the same.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|sig_return_type
argument_list|,
name|class_return_type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compare the first argument `this.'  */
block|{
comment|/* Get the type of what the `optr' is pointing to.  */
name|tree
name|sig_this
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|sig_arg_types
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|class_this
init|=
name|TREE_VALUE
argument_list|(
name|class_arg_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class_this
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
comment|/* Is `this' a sig ptr?  */
name|class_this
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|class_this
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|class_this
operator|=
name|TREE_TYPE
argument_list|(
name|class_this
argument_list|)
expr_stmt|;
comment|/* If a signature method's `this' is const or volatile, so has to be        the corresponding class method's `this.'  */
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|class_this
argument_list|,
name|sig_this
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|sig_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|sig_arg_types
argument_list|)
expr_stmt|;
name|class_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|class_arg_types
argument_list|)
expr_stmt|;
comment|/* The number of arguments and the argument types have to be the same.  */
return|return
name|compparms
argument_list|(
name|sig_arg_types
argument_list|,
name|class_arg_types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Undo casts of opaque type variables to the RHS types.  */
end_comment

begin_function
specifier|static
name|void
name|undo_casts
parameter_list|(
name|sig_ty
parameter_list|)
name|tree
name|sig_ty
decl_stmt|;
block|{
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|sig_ty
argument_list|)
decl_stmt|;
comment|/* Since all the FIELD_DECLs for the signature table entries are at the end      of the chain (see `append_signature_fields'), we can do it this way.  */
for|for
control|(
init|;
name|field
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|opaque_type_node
condition|)
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the type checking necessary to see whether the `rhs' conforms to    the lhs's `sig_ty'.  Depending on the type of `rhs' return a NULL_TREE,    an integer_zero_node, a constructor, or an expression offsetting the    `rhs' signature table.  */
end_comment

begin_function
specifier|static
name|tree
name|build_signature_table_constructor
parameter_list|(
name|sig_ty
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|sig_ty
decl_stmt|,
name|rhs
decl_stmt|;
block|{
name|tree
name|rhstype
init|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|tree
name|sig_field
init|=
name|TYPE_FIELDS
argument_list|(
name|sig_ty
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|first_rhs_field
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|last_rhs_field
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|sig_ptr_p
init|=
name|IS_SIGNATURE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
name|int
name|offset_p
init|=
name|sig_ptr_p
decl_stmt|;
name|rhstype
operator|=
name|sig_ptr_p
condition|?
name|rhstype
else|:
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TAGS
argument_list|(
name|sig_ty
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"conformance check with signature containing class declarations"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
for|for
control|(
init|;
name|sig_field
condition|;
name|sig_field
operator|=
name|TREE_CHAIN
argument_list|(
name|sig_field
argument_list|)
control|)
block|{
name|tree
name|basetype_path
decl_stmt|,
name|baselink
decl_stmt|,
name|basetypes
decl_stmt|;
name|tree
name|sig_method
decl_stmt|,
name|sig_mname
decl_stmt|,
name|sig_mtype
decl_stmt|;
name|tree
name|rhs_method
decl_stmt|,
name|tbl_entry
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sig_field
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|sig_field_type
init|=
name|TREE_TYPE
argument_list|(
name|sig_field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|sig_field_type
argument_list|)
operator|==
name|opaque_type_node
condition|)
block|{
comment|/* We've got an opaque type here.  */
name|tree
name|oty_name
init|=
name|DECL_NAME
argument_list|(
name|sig_field
argument_list|)
decl_stmt|;
name|tree
name|oty_type
init|=
name|lookup_field
argument_list|(
name|rhstype
argument_list|,
name|oty_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|oty_type
operator|==
name|NULL_TREE
operator|||
name|oty_type
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"class `%T' does not contain type `%T'"
argument_list|,
name|rhstype
argument_list|,
name|oty_type
argument_list|)
expr_stmt|;
name|undo_casts
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|oty_type
operator|=
name|TREE_TYPE
argument_list|(
name|oty_type
argument_list|)
expr_stmt|;
comment|/* Cast `sig_field' to be of type `oty_type'.  This will be 		 undone in `undo_casts' by walking over all the TYPE_DECLs.  */
name|TREE_TYPE
argument_list|(
name|sig_field_type
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|oty_type
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have an opaque type, we can ignore the `typedef'.  */
continue|continue;
block|}
comment|/* Find the signature method corresponding to `sig_field'.  */
name|sig_method
operator|=
name|DECL_MEMFUNC_POINTING_TO
argument_list|(
name|sig_field
argument_list|)
expr_stmt|;
name|sig_mname
operator|=
name|DECL_NAME
argument_list|(
name|sig_method
argument_list|)
expr_stmt|;
name|sig_mtype
operator|=
name|TREE_TYPE
argument_list|(
name|sig_method
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
name|baselink
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|sig_mname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|baselink
operator|==
name|NULL_TREE
operator|||
name|baselink
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|IS_DEFAULT_IMPLEMENTATION
argument_list|(
name|sig_method
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"class `%T' does not contain method `%D'"
argument_list|,
name|rhstype
argument_list|,
name|sig_mname
argument_list|)
expr_stmt|;
name|undo_casts
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* We use the signature's default implementation.  */
name|rhs_method
operator|=
name|sig_method
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Find the class method of the correct type.  */
name|tree
name|rhs_methods
decl_stmt|;
name|basetypes
operator|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetypes
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|basetypes
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|rhs_methods
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rhs_methods
condition|;
name|rhs_methods
operator|=
name|OVL_NEXT
argument_list|(
name|rhs_methods
argument_list|)
control|)
if|if
condition|(
operator|(
name|rhs_method
operator|=
name|OVL_CURRENT
argument_list|(
name|rhs_methods
argument_list|)
operator|)
operator|&&
name|sig_mname
operator|==
name|DECL_NAME
argument_list|(
name|rhs_method
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|rhs_method
argument_list|)
operator|&&
name|match_method_types
argument_list|(
name|sig_mtype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs_method
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|rhs_methods
operator|==
name|NULL_TREE
operator|||
operator|!
name|accessible_p
argument_list|(
name|basetypes
argument_list|,
name|rhs_method
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' does not contain a method conforming to `%#D'"
argument_list|,
name|rhstype
argument_list|,
name|sig_method
argument_list|)
expr_stmt|;
name|undo_casts
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|sig_ptr_p
operator|&&
name|rhs_method
operator|!=
name|sig_method
condition|)
block|{
name|tree
name|rhs_field
init|=
name|DECL_MEMFUNC_POINTER_TO
argument_list|(
name|rhs_method
argument_list|)
decl_stmt|;
if|if
condition|(
name|first_rhs_field
operator|==
name|NULL_TREE
condition|)
block|{
name|first_rhs_field
operator|=
name|rhs_field
expr_stmt|;
name|last_rhs_field
operator|=
name|rhs_field
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|last_rhs_field
argument_list|)
operator|==
name|rhs_field
condition|)
name|last_rhs_field
operator|=
name|rhs_field
expr_stmt|;
else|else
name|offset_p
operator|=
literal|0
expr_stmt|;
name|tbl_entry
operator|=
name|build_component_ref
argument_list|(
name|rhs
argument_list|,
name|DECL_NAME
argument_list|(
name|rhs_field
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tag
decl_stmt|,
name|vb_off
decl_stmt|,
name|delta
decl_stmt|,
name|idx
decl_stmt|,
name|pfn
init|=
name|NULL_TREE
decl_stmt|,
name|vt_off
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tag_decl
decl_stmt|,
name|vb_off_decl
decl_stmt|,
name|delta_decl
decl_stmt|,
name|index_decl
decl_stmt|;
name|tree
name|pfn_decl
decl_stmt|,
name|vt_off_decl
decl_stmt|;
if|if
condition|(
name|rhs_method
operator|==
name|sig_method
condition|)
block|{
comment|/* default implementation */
name|tag
operator|=
name|build_unary_op
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vb_off
operator|=
name|build_unary_op
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta
operator|=
name|integer_zero_node
expr_stmt|;
name|idx
operator|=
name|integer_zero_node
expr_stmt|;
name|pfn
operator|=
name|build_addr_func
argument_list|(
name|rhs_method
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|rhs_method
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
operator|=
name|ptr_type_node
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|rhs_method
argument_list|)
operator|=
literal|1
expr_stmt|;
name|offset_p
operator|=
literal|0
expr_stmt|;
comment|/* we can't offset the rhs sig table */
block|}
elseif|else
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|rhs_method
argument_list|)
condition|)
block|{
comment|/* virtual member function */
name|tag
operator|=
name|integer_one_node
expr_stmt|;
name|vb_off
operator|=
name|build_unary_op
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|delta
operator|=
name|BINFO_OFFSET
argument_list|(
name|get_binfo
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|rhs_method
argument_list|)
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|delta
operator|=
name|BINFO_OFFSET
argument_list|(
name|get_binfo
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|rhs_method
argument_list|)
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|DECL_VINDEX
argument_list|(
name|rhs_method
argument_list|)
expr_stmt|;
name|vt_off
operator|=
name|get_vfield_offset
argument_list|(
name|get_binfo
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|rhs_method
argument_list|)
argument_list|,
name|rhstype
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* non-virtual member function */
name|tag
operator|=
name|integer_zero_node
expr_stmt|;
name|vb_off
operator|=
name|build_unary_op
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta
operator|=
name|BINFO_OFFSET
argument_list|(
name|get_binfo
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|rhs_method
argument_list|)
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|integer_zero_node
expr_stmt|;
name|pfn
operator|=
name|build_addr_func
argument_list|(
name|rhs_method
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|rhs_method
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
operator|=
name|ptr_type_node
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|rhs_method
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Since digest_init doesn't handle initializing selected fields 	     of a struct (i.e., anonymous union), we build the constructor 	     by hand, without calling digest_init.  */
name|tag_decl
operator|=
name|TYPE_FIELDS
argument_list|(
name|sigtable_entry_type
argument_list|)
expr_stmt|;
name|vb_off_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|tag_decl
argument_list|)
expr_stmt|;
name|delta_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|vb_off_decl
argument_list|)
expr_stmt|;
name|index_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|delta_decl
argument_list|)
expr_stmt|;
name|pfn_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|index_decl
argument_list|)
expr_stmt|;
name|vt_off_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|pfn_decl
argument_list|)
expr_stmt|;
name|tag
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|tag_decl
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|vb_off
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|vb_off_decl
argument_list|)
argument_list|,
name|vb_off
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|delta_decl
argument_list|)
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|idx
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_decl
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|rhs_method
argument_list|)
condition|)
block|{
name|vt_off
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|vt_off_decl
argument_list|)
argument_list|,
name|vt_off
argument_list|)
expr_stmt|;
name|tbl_entry
operator|=
name|build_tree_list
argument_list|(
name|vt_off_decl
argument_list|,
name|vt_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pfn
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn_decl
argument_list|)
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|tbl_entry
operator|=
name|build_tree_list
argument_list|(
name|pfn_decl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
name|tbl_entry
operator|=
name|tree_cons
argument_list|(
name|delta_decl
argument_list|,
name|delta
argument_list|,
name|tree_cons
argument_list|(
name|index_decl
argument_list|,
name|idx
argument_list|,
name|tbl_entry
argument_list|)
argument_list|)
expr_stmt|;
name|tbl_entry
operator|=
name|tree_cons
argument_list|(
name|tag_decl
argument_list|,
name|tag
argument_list|,
name|tree_cons
argument_list|(
name|vb_off_decl
argument_list|,
name|vb_off
argument_list|,
name|tbl_entry
argument_list|)
argument_list|)
expr_stmt|;
name|tbl_entry
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|sigtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|,
name|tbl_entry
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|tbl_entry
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Chain those function address expressions together.  */
if|if
condition|(
name|result
condition|)
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tbl_entry
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|tbl_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* The signature was empty, we don't need a signature table.  */
name|undo_casts
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|offset_p
condition|)
block|{
if|if
condition|(
name|first_rhs_field
operator|==
name|TYPE_FIELDS
argument_list|(
name|rhstype
argument_list|)
condition|)
block|{
comment|/* The sptr field on the lhs can be copied from the rhs.  */
name|undo_casts
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
return|return
name|integer_zero_node
return|;
block|}
else|else
block|{
comment|/* The sptr field on the lhs will point into the rhs sigtable.  */
name|undo_casts
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|rhs
argument_list|,
name|DECL_NAME
argument_list|(
name|first_rhs_field
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
comment|/* We need to construct a new signature table.  */
name|result
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
operator|!
name|sig_ptr_p
expr_stmt|;
name|undo_casts
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a signature table declaration and initialize it or return an    existing one if we built one already.  If we don't get a constructor    as initialization expression, we don't need a new signature table    variable and just hand back the init expression.     The declaration processing is done by hand instead of using `cp_finish_decl'    so that we can make signature pointers global variables instead of    static ones.  */
end_comment

begin_function
specifier|static
name|tree
name|build_sigtable
parameter_list|(
name|sig_type
parameter_list|,
name|rhs_type
parameter_list|,
name|init_from
parameter_list|)
name|tree
name|sig_type
decl_stmt|,
name|rhs_type
decl_stmt|,
name|init_from
decl_stmt|;
block|{
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|init_expr
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|rhs_type
argument_list|)
condition|)
block|{
name|name
operator|=
name|get_sigtable_name
argument_list|(
name|sig_type
argument_list|,
name|rhs_type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We allow only one signature table to be generated for signatures 	 with opaque types.  Otherwise we create a loophole in the type 	 system since we could cast data from one classes implementation 	 of the opaque type to that of another class.  */
if|if
condition|(
name|SIGNATURE_HAS_OPAQUE_TYPEDECLS
argument_list|(
name|sig_type
argument_list|)
operator|&&
name|SIGTABLE_HAS_BEEN_GENERATED
argument_list|(
name|sig_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"signature with opaque type implemented by multiple classes"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|SIGTABLE_HAS_BEEN_GENERATED
argument_list|(
name|sig_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init_expr
operator|=
name|build_signature_table_constructor
argument_list|(
name|sig_type
argument_list|,
name|init_from
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_expr
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|init_expr
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
return|return
name|init_expr
return|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
name|name
operator|=
name|get_sigtable_name
argument_list|(
name|sig_type
argument_list|,
name|rhs_type
argument_list|)
expr_stmt|;
block|{
name|tree
name|context
init|=
name|current_function_decl
decl_stmt|;
comment|/* Make the signature table global, not just static in whichever 	   function a signature pointer/ref is used for the first time.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|sig_type
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|context
expr_stmt|;
block|}
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|rhs_type
argument_list|)
condition|)
block|{
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GDB-4.7 doesn't find the initialization value of a signature table 	 when it is constant.  */
block|TREE_READONLY (decl) = 1;
endif|#
directive|endif
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|rhs_type
argument_list|)
condition|)
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a constructor or modify expression if the LHS of an assignment    is a signature pointer or a signature reference.  If LHS is a record    type node, we build a constructor, otherwise a compound expression.  */
end_comment

begin_function
name|tree
name|build_signature_pointer_constructor
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
name|int
name|initp
init|=
operator|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
decl_stmt|;
name|tree
name|lhstype
init|=
name|initp
condition|?
name|lhs
else|:
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|rhstype
init|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|tree
name|sig_ty
init|=
name|SIGNATURE_TYPE
argument_list|(
name|lhstype
argument_list|)
decl_stmt|;
name|tree
name|sig_tbl
decl_stmt|,
name|sptr_expr
decl_stmt|,
name|optr_expr
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
operator|||
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|rhstype
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|rhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid assignment to signature pointer or reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|sig_ty
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"undefined signature `%T' used in signature %s declaration"
argument_list|,
name|sig_ty
argument_list|,
name|IS_SIGNATURE_POINTER
argument_list|(
name|lhstype
argument_list|)
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If SIG_TY is permanent, make the signature table constructor and      the signature pointer/reference constructor permanent too.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|sig_ty
argument_list|)
condition|)
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|rhstype
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|rhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|rhstype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|SIGNATURE_TYPE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|sig_ty
condition|)
block|{
comment|/* LHS and RHS are signature pointers/refs of the same signature.  */
name|optr_expr
operator|=
name|build_optr_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|sptr_expr
operator|=
name|build_sptr_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to create a new signature table and copy 	     elements from the rhs signature table.  */
name|tree
name|rhs_sptr_ref
init|=
name|build_sptr_ref
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|tree
name|rhs_tbl
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|SIGNATURE_TYPE
argument_list|(
name|rhstype
argument_list|)
argument_list|,
name|rhs_sptr_ref
argument_list|)
decl_stmt|;
name|sig_tbl
operator|=
name|build_sigtable
argument_list|(
name|sig_ty
argument_list|,
name|SIGNATURE_TYPE
argument_list|(
name|rhstype
argument_list|)
argument_list|,
name|rhs_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_tbl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|optr_expr
operator|=
name|build_optr_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_tbl
operator|==
name|NULL_TREE
condition|)
comment|/* The signature was empty.  The signature pointer is 	       pretty useless, but the user has been warned.  */
name|sptr_expr
operator|=
name|copy_node
argument_list|(
name|null_pointer_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sig_tbl
operator|==
name|integer_zero_node
condition|)
name|sptr_expr
operator|=
name|rhs_sptr_ref
expr_stmt|;
else|else
name|sptr_expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|sig_tbl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|sptr_expr
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sig_tbl
operator|=
name|build_sigtable
argument_list|(
name|sig_ty
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_tbl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|optr_expr
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|sig_tbl
operator|==
name|NULL_TREE
condition|)
comment|/* The signature was empty.  The signature pointer is 	   pretty useless, but the user has been warned.  */
block|{
name|sptr_expr
operator|=
name|copy_node
argument_list|(
name|null_pointer_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|sptr_expr
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|sig_ty
argument_list|)
expr_stmt|;
block|}
else|else
name|sptr_expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|sig_tbl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initp
condition|)
block|{
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|optr_expr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|sptr_expr
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|digest_init
argument_list|(
name|lhstype
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|lhstype
argument_list|)
condition|)
name|readonly_error
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|optr_expr
operator|=
name|build_modify_expr
argument_list|(
name|build_optr_ref
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|NOP_EXPR
argument_list|,
name|optr_expr
argument_list|)
expr_stmt|;
name|sptr_expr
operator|=
name|build_modify_expr
argument_list|(
name|build_sptr_ref
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|NOP_EXPR
argument_list|,
name|sptr_expr
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|optr_expr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sptr_expr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|lhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_compound_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a temporary variable declaration for the instance of a signature    member function call if it isn't a declaration node already.  Simply    using a SAVE_EXPR doesn't work since we need `this' in both branches    of a conditional expression.  */
end_comment

begin_function
specifier|static
name|tree
name|save_this
parameter_list|(
name|instance
parameter_list|)
name|tree
name|instance
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|decl
operator|=
name|instance
expr_stmt|;
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Build a signature member function call.  Looks up the signature table    entry corresponding to FUNCTION.  Depending on the value of the CODE    field, either call the function in PFN directly, or use OFFSET to    index the object's virtual function table.  */
end_comment

begin_function
name|tree
name|build_signature_method_call
parameter_list|(
name|function
parameter_list|,
name|parms
parameter_list|)
name|tree
name|function
decl_stmt|,
name|parms
decl_stmt|;
block|{
name|tree
name|instance
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|tree
name|saved_instance
init|=
name|save_this
argument_list|(
name|instance
argument_list|)
decl_stmt|;
comment|/* Create temp for `this'.  */
name|tree
name|object_ptr
init|=
name|build_optr_ref
argument_list|(
name|saved_instance
argument_list|)
decl_stmt|;
name|tree
name|new_object_ptr
decl_stmt|,
name|new_parms
decl_stmt|;
name|tree
name|signature_tbl_ptr
init|=
name|build_sptr_ref
argument_list|(
name|saved_instance
argument_list|)
decl_stmt|;
name|tree
name|sig_field_name
init|=
name|DECL_NAME
argument_list|(
name|DECL_MEMFUNC_POINTER_TO
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|basetype_path
init|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|tree
name|tbl_entry
init|=
name|build_component_ref
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|basetype
argument_list|,
name|signature_tbl_ptr
argument_list|)
argument_list|,
name|sig_field_name
argument_list|,
name|basetype_path
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|tag
decl_stmt|,
name|delta
decl_stmt|,
name|pfn
decl_stmt|,
name|vt_off
decl_stmt|,
name|idx
decl_stmt|,
name|vfn
decl_stmt|;
name|tree
name|deflt_call
init|=
name|NULL_TREE
decl_stmt|,
name|direct_call
decl_stmt|,
name|virtual_call
decl_stmt|,
name|result
decl_stmt|;
name|tbl_entry
operator|=
name|save_expr
argument_list|(
name|tbl_entry
argument_list|)
expr_stmt|;
name|tag
operator|=
name|build_component_ref
argument_list|(
name|tbl_entry
argument_list|,
name|tag_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build_component_ref
argument_list|(
name|tbl_entry
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|build_component_ref
argument_list|(
name|tbl_entry
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vt_off
operator|=
name|build_component_ref
argument_list|(
name|tbl_entry
argument_list|,
name|vt_off_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|idx
operator|=
name|build_component_ref
argument_list|(
name|tbl_entry
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DEFAULT_IMPLEMENTATION
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|pfn
operator|=
name|save_expr
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|deflt_call
operator|=
name|build_function_call
argument_list|(
name|pfn
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
name|new_object_ptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|object_ptr
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|object_ptr
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|new_parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_object_ptr
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Cast the signature method to have `this' of a normal pointer type.  */
name|tree
name|old_this
init|=
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_qualified_type
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_QUALS
argument_list|(
name|old_this
argument_list|)
argument_list|)
expr_stmt|;
name|direct_call
operator|=
name|build_function_call
argument_list|(
name|pfn
argument_list|,
name|new_parms
argument_list|)
expr_stmt|;
block|{
name|tree
name|vfld
decl_stmt|,
name|vtbl
decl_stmt|,
name|aref
decl_stmt|;
name|vfld
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vtbl_type_node
argument_list|)
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|object_ptr
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|vt_off
argument_list|)
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|vfld
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|vfn
operator|=
name|aref
expr_stmt|;
else|else
name|vfn
operator|=
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfn
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|virtual_call
operator|=
name|build_function_call
argument_list|(
name|vfn
argument_list|,
name|new_parms
argument_list|)
expr_stmt|;
block|}
comment|/* Undo the cast, make `this' a signature pointer again.  */
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
name|old_this
expr_stmt|;
block|}
comment|/* Once the function was found, there should be no reason why we      couldn't build the member function pointer call.  */
if|if
condition|(
operator|!
name|direct_call
operator|||
name|direct_call
operator|==
name|error_mark_node
operator|||
operator|!
name|virtual_call
operator|||
name|virtual_call
operator|==
name|error_mark_node
operator|||
operator|(
name|IS_DEFAULT_IMPLEMENTATION
argument_list|(
name|function
argument_list|)
operator|&&
operator|(
operator|!
name|deflt_call
operator|||
name|deflt_call
operator|==
name|error_mark_node
operator|)
operator|)
condition|)
block|{
name|compiler_error
argument_list|(
literal|"cannot build call of signature member function `%s'"
argument_list|,
name|fndecl_as_string
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|IS_DEFAULT_IMPLEMENTATION
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|tree
name|test
init|=
name|build_binary_op_nodefault
argument_list|(
name|LT_EXPR
argument_list|,
name|tag
argument_list|,
name|integer_zero_node
argument_list|,
name|LT_EXPR
argument_list|)
decl_stmt|;
name|result
operator|=
name|build_conditional_expr
argument_list|(
name|tag
argument_list|,
name|build_conditional_expr
argument_list|(
name|test
argument_list|,
name|deflt_call
argument_list|,
name|virtual_call
argument_list|)
argument_list|,
name|direct_call
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|build_conditional_expr
argument_list|(
name|tag
argument_list|,
name|virtual_call
argument_list|,
name|direct_call
argument_list|)
expr_stmt|;
comment|/* If we created a temporary variable for `this', initialize it first.  */
if|if
condition|(
name|instance
operator|!=
name|saved_instance
condition|)
name|result
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|saved_instance
argument_list|,
name|NOP_EXPR
argument_list|,
name|instance
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Create a COMPONENT_REF expression for referencing the OPTR field    of a signature pointer or reference.  */
end_comment

begin_function
name|tree
name|build_optr_ref
parameter_list|(
name|instance
parameter_list|)
name|tree
name|instance
decl_stmt|;
block|{
name|tree
name|field
init|=
name|get_identifier
argument_list|(
name|SIGNATURE_OPTR_NAME
argument_list|)
decl_stmt|;
return|return
name|build_component_ref
argument_list|(
name|instance
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a COMPONENT_REF expression for referencing the SPTR field    of a signature pointer or reference.  */
end_comment

begin_function
specifier|static
name|tree
name|build_sptr_ref
parameter_list|(
name|instance
parameter_list|)
name|tree
name|instance
decl_stmt|;
block|{
name|tree
name|field
init|=
name|get_identifier
argument_list|(
name|SIGNATURE_SPTR_NAME
argument_list|)
decl_stmt|;
return|return
name|build_component_ref
argument_list|(
name|instance
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

