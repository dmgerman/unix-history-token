begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Name mangling for the 3.0 C++ ABI.    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.    Written by Alex Samuel<samuel@codesourcery.com>     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file implements mangling of C++ names according to the IA64    C++ ABI specification.  A mangled name encodes a function or    variable's name, scope, type, and/or template arguments into a text    identifier.  This identifier is used as the function's or    variable's linkage name, to preserve compatibility between C++'s    language features (templates, scoping, and overloading) and C    linkers.     Additionally, g++ uses mangled names internally.  To support this,    mangling of types is allowed, even though the mangled name of a    type should not appear by itself as an exported name.  Ditto for    uninstantiated templates.     The primary entry point for this module is mangle_decl, which    returns an identifier containing the mangled name for a decl.    Additional entry points are provided to build mangled names of    particular constructs when the appropriate decl for that construct    is not available.  These are:       mangle_typeinfo_for_type:		typeinfo data      mangle_typeinfo_string_for_type:	typeinfo type name      mangle_vtbl_for_type:		virtual table data      mangle_vtt_for_type:		VTT data      mangle_ctor_vtbl_for_type:		`C-in-B' constructor virtual table data      mangle_thunk:			thunk function or entry  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Debugging support.  */
end_comment

begin_comment
comment|/* Define DEBUG_MANGLE to enable very verbose trace messages.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_MANGLE
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_MANGLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros for tracing the write_* functions.  */
end_comment

begin_if
if|#
directive|if
name|DEBUG_MANGLE
end_if

begin_define
define|#
directive|define
name|MANGLE_TRACE
parameter_list|(
name|FN
parameter_list|,
name|INPUT
parameter_list|)
define|\
value|fprintf (stderr, "  %-24s: %-24s\n", (FN), (INPUT))
end_define

begin_define
define|#
directive|define
name|MANGLE_TRACE_TREE
parameter_list|(
name|FN
parameter_list|,
name|NODE
parameter_list|)
define|\
value|fprintf (stderr, "  %-24s: %-24s (%p)\n", \ 	   (FN), tree_code_name[TREE_CODE (NODE)], (void *) (NODE))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MANGLE_TRACE
parameter_list|(
name|FN
parameter_list|,
name|INPUT
parameter_list|)
end_define

begin_define
define|#
directive|define
name|MANGLE_TRACE_TREE
parameter_list|(
name|FN
parameter_list|,
name|NODE
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if NODE is a class template-id.  We can't rely on    CLASSTYPE_USE_TEMPLATE here because of tricky bugs in the parser    that hard to distinguish A<T> from A, where A<T> is the type as    instantiated outside of the template, and A is the type used    without parameters inside the template.  */
end_comment

begin_define
define|#
directive|define
name|CLASSTYPE_TEMPLATE_ID_P
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(TYPE_LANG_SPECIFIC (NODE) != NULL					\&& (TREE_CODE (NODE) == BOUND_TEMPLATE_TEMPLATE_PARM			\        || (CLASSTYPE_TEMPLATE_INFO (NODE) != NULL			\&& (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE))))))
end_define

begin_comment
comment|/* Things we only need one of.  This module is not reentrant.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|globals
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* An array of the current substitution candidates, in the order      we've seen them.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|substitutions
expr_stmt|;
comment|/* The entity that is being mangled.  */
name|tree
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|entity
block|;
comment|/* True if the mangling will be different in a future version of the      ABI.  */
name|bool
name|need_abi_warning
block|; }
end_typedef

begin_expr_stmt
name|globals
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|globals
name|G
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The obstack on which we build mangled names.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
modifier|*
name|mangle_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The obstack on which we build mangled names that are not going to    be IDENTIFIER_NODEs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|name_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first object on the name_obstack; we use this to free memory    allocated on the name_obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|name_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An incomplete mangled name.  There will be no NUL terminator.  If    there is no incomplete mangled name, this variable is NULL.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|partially_mangled_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters in the PARTIALLY_MANGLED_NAME.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|partially_mangled_name_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indices into subst_identifiers.  These are identifiers used in    special substitution rules.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SUBID_ALLOCATOR
block|,
name|SUBID_BASIC_STRING
block|,
name|SUBID_CHAR_TRAITS
block|,
name|SUBID_BASIC_ISTREAM
block|,
name|SUBID_BASIC_OSTREAM
block|,
name|SUBID_BASIC_IOSTREAM
block|,
name|SUBID_MAX
block|}
name|substitution_identifier_index_t
typedef|;
end_typedef

begin_comment
comment|/* For quick substitution checks, look up these common identifiers    once only.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|subst_identifiers
index|[
name|SUBID_MAX
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Single-letter codes for builtin integer types, defined in<builtin-type>.  These are indexed by integer_type_kind values.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|integer_type_codes
index|[
name|itk_none
index|]
init|=
block|{
literal|'c'
block|,
comment|/* itk_char */
literal|'a'
block|,
comment|/* itk_signed_char */
literal|'h'
block|,
comment|/* itk_unsigned_char */
literal|'s'
block|,
comment|/* itk_short */
literal|'t'
block|,
comment|/* itk_unsigned_short */
literal|'i'
block|,
comment|/* itk_int */
literal|'j'
block|,
comment|/* itk_unsigned_int */
literal|'l'
block|,
comment|/* itk_long */
literal|'m'
block|,
comment|/* itk_unsigned_long */
literal|'x'
block|,
comment|/* itk_long_long */
literal|'y'
comment|/* itk_unsigned_long_long */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|decl_is_template_id
parameter_list|(
specifier|const
name|tree
parameter_list|,
name|tree
modifier|*
specifier|const
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for handling substitutions.  */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|tree
name|canonicalize_for_substitution
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_substitution
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|is_std_substitution
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|substitution_identifier_index_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|is_std_substitution_char
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|substitution_identifier_index_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_substitution
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mangle_call_offset
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for emitting mangled representations of things.  */
end_comment

begin_function_decl
specifier|static
name|void
name|write_mangled_name
parameter_list|(
specifier|const
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_encoding
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_name
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_unscoped_name
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_unscoped_template_name
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_nested_name
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_prefix
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_template_prefix
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_unqualified_name
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_conversion_operator_name
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_source_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwint_to_ascii
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
specifier|const
name|unsigned
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_number
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_integer_cst
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_real_cst
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_identifier
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_special_name_constructor
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_special_name_destructor
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_CV_qualifiers_for_type
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_builtin_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_function_type
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_bare_function_type
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_method_parms
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_class_enum_type
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_template_args
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_expression
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_template_arg_literal
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_template_arg
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_template_template_arg
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_array_type
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_pointer_to_member_type
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_template_param
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_template_template_param
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_substitution
parameter_list|(
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|discriminator_for_local_entity
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|discriminator_for_string_literal
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_discriminator
parameter_list|(
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_local_name
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|tree
parameter_list|,
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_substitution_candidates
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|mangle_decl_string
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Control functions.  */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|start_mangling
parameter_list|(
specifier|const
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|finish_mangling
parameter_list|(
specifier|const
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mangle_special_for_type
parameter_list|(
specifier|const
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Foreign language functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|write_java_integer_type_codes
parameter_list|(
specifier|const
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Append a single character to the end of the mangled    representation.  */
end_comment

begin_define
define|#
directive|define
name|write_char
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|obstack_1grow (mangle_obstack, (CHAR))
end_define

begin_comment
comment|/* Append a sized buffer to the end of the mangled representation.  */
end_comment

begin_define
define|#
directive|define
name|write_chars
parameter_list|(
name|CHAR
parameter_list|,
name|LEN
parameter_list|)
define|\
value|obstack_grow (mangle_obstack, (CHAR), (LEN))
end_define

begin_comment
comment|/* Append a NUL-terminated string to the end of the mangled    representation.  */
end_comment

begin_define
define|#
directive|define
name|write_string
parameter_list|(
name|STRING
parameter_list|)
define|\
value|obstack_grow (mangle_obstack, (STRING), strlen (STRING))
end_define

begin_comment
comment|/* Nonzero if NODE1 and NODE2 are both TREE_LIST nodes and have the    same purpose (context, which may be a type) and value (template    decl).  See write_template_prefix for more information on what this    is used for.  */
end_comment

begin_define
define|#
directive|define
name|NESTED_TEMPLATE_MATCH
parameter_list|(
name|NODE1
parameter_list|,
name|NODE2
parameter_list|)
define|\
value|(TREE_CODE (NODE1) == TREE_LIST					\&& TREE_CODE (NODE2) == TREE_LIST					\&& ((TYPE_P (TREE_PURPOSE (NODE1))					\&& same_type_p (TREE_PURPOSE (NODE1), TREE_PURPOSE (NODE2)))	\        || TREE_PURPOSE (NODE1) == TREE_PURPOSE (NODE2))			\&& TREE_VALUE (NODE1) == TREE_VALUE (NODE2))
end_define

begin_comment
comment|/* Write out an unsigned quantity in base 10.  */
end_comment

begin_define
define|#
directive|define
name|write_unsigned_number
parameter_list|(
name|NUMBER
parameter_list|)
define|\
value|write_number ((NUMBER),
comment|/*unsigned_p=*/
value|1, 10)
end_define

begin_comment
comment|/* Save the current (incomplete) mangled name and release the obstack    storage holding it.  This function should be used during mangling    when making a call that could result in a call to get_identifier,    as such a call will clobber the same obstack being used for    mangling.  This function may not be called twice without an    intervening call to restore_partially_mangled_name.  */
end_comment

begin_function
specifier|static
name|void
name|save_partially_mangled_name
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mangle_obstack
operator|==
operator|&
name|ident_hash
operator|->
name|stack
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|partially_mangled_name
argument_list|)
expr_stmt|;
name|partially_mangled_name_len
operator|=
name|obstack_object_size
argument_list|(
name|mangle_obstack
argument_list|)
expr_stmt|;
name|partially_mangled_name
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|partially_mangled_name_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|partially_mangled_name
argument_list|,
name|obstack_base
argument_list|(
name|mangle_obstack
argument_list|)
argument_list|,
name|partially_mangled_name_len
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
name|mangle_obstack
argument_list|,
name|obstack_finish
argument_list|(
name|mangle_obstack
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore the incomplete mangled name saved with    save_partially_mangled_name.  */
end_comment

begin_function
specifier|static
name|void
name|restore_partially_mangled_name
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|partially_mangled_name
condition|)
block|{
name|obstack_grow
argument_list|(
name|mangle_obstack
argument_list|,
name|partially_mangled_name
argument_list|,
name|partially_mangled_name_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|partially_mangled_name
argument_list|)
expr_stmt|;
name|partially_mangled_name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If DECL is a template instance, return nonzero and, if    TEMPLATE_INFO is non-NULL, set *TEMPLATE_INFO to its template info.    Otherwise return zero.  */
end_comment

begin_function
specifier|static
name|int
name|decl_is_template_id
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|,
name|tree
modifier|*
specifier|const
name|template_info
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* TYPE_DECLs are handled specially.  Look at its type to decide 	 if this is a template instantiation.  */
specifier|const
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_ID_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|template_info
operator|!=
name|NULL
condition|)
comment|/* For a templated TYPE_DECL, the template info is hanging 	       off the type.  */
operator|*
name|template_info
operator|=
name|TYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* Check if this is a primary template.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|template_info
operator|!=
name|NULL
condition|)
comment|/* For most templated decls, the template info is hanging 	       off the decl.  */
operator|*
name|template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* It's not a template id.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Produce debugging output of current substitution candidates.  */
end_comment

begin_function
specifier|static
name|void
name|dump_substitution_candidates
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|tree
name|el
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ substitutions  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|G
operator|.
name|substitutions
argument_list|,
name|i
argument_list|,
name|el
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|"???"
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|el
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|el
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|el
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|el
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|el
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|el
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" S%d_ = "
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|el
argument_list|)
operator|&&
operator|(
name|CP_TYPE_RESTRICT_P
argument_list|(
name|el
argument_list|)
operator|||
name|CP_TYPE_VOLATILE_P
argument_list|(
name|el
argument_list|)
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|el
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CV-"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (%s at %p)\n"
argument_list|,
name|name
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|el
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|el
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Both decls and types can be substitution candidates, but sometimes    they refer to the same thing.  For instance, a TYPE_DECL and    RECORD_TYPE for the same class refer to the same thing, and should    be treated accordingly in substitutions.  This function returns a    canonicalized tree node representing NODE that is used when adding    and substitution candidates and finding matches.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|canonicalize_for_substitution
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
comment|/* For a TYPE_DECL, use the type instead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|node
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
name|node
operator|=
name|canonical_type_variant
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Add NODE as a substitution candidate.  NODE must not already be on    the list of candidates.  */
end_comment

begin_function
specifier|static
name|void
name|add_substitution
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ add_substitution (%s at %10p)\n"
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
comment|/* Get the canonicalized substitution candidate for NODE.  */
name|c
operator|=
name|canonicalize_for_substitution
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
operator|&&
name|c
operator|!=
name|node
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ using candidate (%s at %10p)\n"
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|c
expr_stmt|;
if|#
directive|if
name|ENABLE_CHECKING
comment|/* Make sure NODE isn't already a candidate.  */
block|{
name|int
name|i
decl_stmt|;
name|tree
name|candidate
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|G
operator|.
name|substitutions
argument_list|,
name|i
argument_list|,
name|candidate
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|gcc_assert
argument_list|(
operator|!
operator|(
name|DECL_P
argument_list|(
name|node
argument_list|)
operator|&&
name|node
operator|==
name|candidate
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|candidate
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|node
argument_list|,
name|candidate
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ENABLE_CHECKING */
comment|/* Put the decl onto the varray of substitution candidates.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|G
operator|.
name|substitutions
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|dump_substitution_candidates
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for find_substitution.  Returns nonzero if NODE,    which may be a decl or a CLASS_TYPE, is a template-id with template    name of substitution_index[INDEX] in the ::std namespace.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_std_substitution
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|substitution_identifier_index_t
name|index
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL
decl_stmt|;
name|tree
name|decl
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|decl
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|type
operator|=
name|node
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* These are not the droids you're looking for.  */
return|return
literal|0
return|;
return|return
operator|(
name|DECL_NAMESPACE_STD_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|subst_identifiers
index|[
name|index
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for find_substitution.  Returns nonzero if NODE,    which may be a decl or a CLASS_TYPE, is the template-id    ::std::identifier<char>, where identifier is    substitution_index[INDEX].  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_std_substitution_char
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|substitution_identifier_index_t
name|index
parameter_list|)
block|{
name|tree
name|args
decl_stmt|;
comment|/* Check NODE's name is ::std::identifier.  */
if|if
condition|(
operator|!
name|is_std_substitution
argument_list|(
name|node
argument_list|,
name|index
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Figure out its template args.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
comment|/* Oops, not a template.  */
return|return
literal|0
return|;
comment|/* NODE's template arg list should be<char>.  */
return|return
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
operator|==
name|char_type_node
return|;
block|}
end_function

begin_comment
comment|/* Check whether a substitution should be used to represent NODE in    the mangling.     First, check standard special-case substitutions.<substitution> ::= St 	 # ::std  		    ::= Sa 	 # ::std::allocator  		    ::= Sb 	 # ::std::basic_string  		    ::= Ss 	 # ::std::basic_string<char, 			       ::std::char_traits<char>, 			       ::std::allocator<char>>  		    ::= Si 	 # ::std::basic_istream<char, ::std::char_traits<char>>  		    ::= So 	 # ::std::basic_ostream<char, ::std::char_traits<char>>  		    ::= Sd 	 # ::std::basic_iostream<char, ::std::char_traits<char>>     Then examine the stack of currently available substitution    candidates for entities appearing earlier in the same mangling     If a substitution is found, write its mangled representation and    return nonzero.  If none is found, just return zero.  */
end_comment

begin_function
specifier|static
name|int
name|find_substitution
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|size
init|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|G
operator|.
name|substitutions
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ find_substitution (%s at %p)\n"
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
comment|/* Obtain the canonicalized substitution representation for NODE.      This is what we'll compare against.  */
name|node
operator|=
name|canonicalize_for_substitution
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Check for builtin substitutions.  */
name|decl
operator|=
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
else|:
name|node
expr_stmt|;
name|type
operator|=
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|?
name|node
else|:
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Check for std::allocator.  */
if|if
condition|(
name|decl
operator|&&
name|is_std_substitution
argument_list|(
name|decl
argument_list|,
name|SUBID_ALLOCATOR
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"Sa"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Check for std::basic_string.  */
if|if
condition|(
name|decl
operator|&&
name|is_std_substitution
argument_list|(
name|decl
argument_list|,
name|SUBID_BASIC_STRING
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|/* If this is a type (i.e. a fully-qualified template-id), 	     check for 		 std::basic_string<char, 				    std::char_traits<char>, 				    std::allocator<char>> .  */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|==
literal|3
operator|&&
name|same_type_p
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
operator|&&
name|is_std_substitution_char
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SUBID_CHAR_TRAITS
argument_list|)
operator|&&
name|is_std_substitution_char
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|SUBID_ALLOCATOR
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"Ss"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
else|else
comment|/* Substitute for the template name only if this isn't a type.  */
block|{
name|write_string
argument_list|(
literal|"Sb"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Check for basic_{i,o,io}stream.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
operator|&&
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* First, check for the template 	 args<char, std::char_traits<char>> .  */
name|tree
name|args
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|==
literal|2
operator|&&
name|TYPE_P
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
operator|&&
name|is_std_substitution_char
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SUBID_CHAR_TRAITS
argument_list|)
condition|)
block|{
comment|/* Got them.  Is this basic_istream?  */
if|if
condition|(
name|is_std_substitution
argument_list|(
name|decl
argument_list|,
name|SUBID_BASIC_ISTREAM
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"Si"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Or basic_ostream?  */
elseif|else
if|if
condition|(
name|is_std_substitution
argument_list|(
name|decl
argument_list|,
name|SUBID_BASIC_OSTREAM
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"So"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Or basic_iostream?  */
elseif|else
if|if
condition|(
name|is_std_substitution
argument_list|(
name|decl
argument_list|,
name|SUBID_BASIC_IOSTREAM
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"Sd"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Check for namespace std.  */
if|if
condition|(
name|decl
operator|&&
name|DECL_NAMESPACE_STD_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"St"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now check the list of available substitutions for this mangling      operation.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|candidate
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|G
operator|.
name|substitutions
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* NODE is a matched to a candidate if it's the same decl node or 	 if it's the same type.  */
if|if
condition|(
name|decl
operator|==
name|candidate
operator|||
operator|(
name|TYPE_P
argument_list|(
name|candidate
argument_list|)
operator|&&
name|type
operator|&&
name|TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|type
argument_list|,
name|candidate
argument_list|)
operator|)
operator|||
name|NESTED_TEMPLATE_MATCH
argument_list|(
name|node
argument_list|,
name|candidate
argument_list|)
condition|)
block|{
name|write_substitution
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* No substitution found.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TOP_LEVEL is true, if this is being called at outermost level of   mangling. It should be false when mangling a decl appearing in an   expression within some other mangling.<mangled-name>      ::= _Z<encoding>  */
end_comment

begin_function
specifier|static
name|void
name|write_mangled_name
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|,
name|bool
name|top_level
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"mangled-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* The names of `extern "C"' functions are not mangled.  */
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|decl
argument_list|)
comment|/* But overloaded operator names *are* mangled.  */
operator|&&
operator|!
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|unmangled_name
label|:
empty_stmt|;
if|if
condition|(
name|top_level
condition|)
name|write_string
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The standard notes: "The<encoding> of an extern "C" 	     function is treated like global-scope data, i.e. as its<source-name> without a type."  We cannot write 	     overloaded operators that way though, because it contains 	     characters invalid in assembler.  */
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
else|else
name|G
operator|.
name|need_abi_warning
operator|=
name|true
expr_stmt|;
name|write_source_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* The names of non-static global variables aren't mangled.  */
operator|&&
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|global_namespace
comment|/* And neither are `extern "C"' variables.  */
operator|||
name|DECL_EXTERN_C_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|top_level
operator|||
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
goto|goto
name|unmangled_name
goto|;
else|else
block|{
name|G
operator|.
name|need_abi_warning
operator|=
name|true
expr_stmt|;
goto|goto
name|mangled_name
goto|;
block|}
block|}
else|else
block|{
name|mangled_name
label|:
empty_stmt|;
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_encoding
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* We need a distinct mangled name for these entities, but 	   we should never actually output it.  So, we append some 	   characters the assembler won't like.  */
name|write_string
argument_list|(
literal|" *INTERNAL* "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<encoding>		::=<function name><bare-function-type> 			::=<data name>  */
end_comment

begin_function
specifier|static
name|void
name|write_encoding
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"encoding"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* For overloaded operators write just the mangled name 	 without arguments.  */
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_name
argument_list|(
name|decl
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
else|else
name|write_source_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|write_name
argument_list|(
name|decl
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|fn_type
decl_stmt|;
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|save_partially_mangled_name
argument_list|()
expr_stmt|;
name|fn_type
operator|=
name|get_mostly_instantiated_function_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|restore_partially_mangled_name
argument_list|()
expr_stmt|;
comment|/* FN_TYPE will not have parameter types for in-charge or 	     VTT parameters.  Therefore, we pass NULL_TREE to 	     write_bare_function_type -- otherwise, it will get 	     confused about which artificial parameters to skip.  */
name|d
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|d
operator|=
name|decl
expr_stmt|;
block|}
name|write_bare_function_type
argument_list|(
name|fn_type
argument_list|,
operator|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
operator|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<name> ::=<unscoped-name> 	  ::=<unscoped-template-name><template-args> 	  ::=<nested-name> 	  ::=<local-name>     If IGNORE_LOCAL_SCOPE is nonzero, this production of<name> is    called from<local-name>, which mangles the enclosing scope    elsewhere and then uses this function to mangle just the part    underneath the function scope.  So don't use the<local-name>    production, to avoid an infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|write_name
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|int
name|ignore_local_scope
parameter_list|)
block|{
name|tree
name|context
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* In case this is a typedef, fish out the corresponding 	 TYPE_DECL for the main variant.  */
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|context
operator|=
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* A decl in :: or ::std scope is treated specially.  The former is      mangled using<unscoped-name> or<unscoped-template-name>, the      latter with a special substitution.  Also, a name that is      directly in a local function scope is also mangled with<unscoped-name> rather than a full<nested-name>.  */
if|if
condition|(
name|context
operator|==
name|NULL
operator|||
name|context
operator|==
name|global_namespace
operator|||
name|DECL_NAMESPACE_STD_P
argument_list|(
name|context
argument_list|)
operator|||
operator|(
name|ignore_local_scope
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|tree
name|template_info
decl_stmt|;
comment|/* Is this a template instance?  */
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
condition|)
block|{
comment|/* Yes: use<unscoped-template-name>.  */
name|write_unscoped_template_name
argument_list|(
name|TI_TEMPLATE
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Everything else gets an<unqualified-name>.  */
name|write_unscoped_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle local names, unless we asked not to (that is, invoked 	 under<local-name>, to handle only the part of the name under 	 the local scope).  */
if|if
condition|(
operator|!
name|ignore_local_scope
condition|)
block|{
comment|/* Scan up the list of scope context, looking for a 	     function.  If we find one, this entity is in local 	     function scope.  local_entity tracks context one scope 	     level down, so it will contain the element that's 	     directly in that function's scope, either decl or one of 	     its enclosing scopes.  */
name|tree
name|local_entity
init|=
name|decl
decl_stmt|;
while|while
condition|(
name|context
operator|!=
name|NULL
operator|&&
name|context
operator|!=
name|global_namespace
condition|)
block|{
comment|/* Make sure we're always dealing with decls.  */
if|if
condition|(
name|context
operator|!=
name|NULL
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Is this a function?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Yes, we have local scope.  Use the<local-name> 		     production for the innermost function scope.  */
name|write_local_name
argument_list|(
name|context
argument_list|,
name|local_entity
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Up one scope level.  */
name|local_entity
operator|=
name|context
expr_stmt|;
name|context
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* No local scope found?  Fall through to<nested-name>.  */
block|}
comment|/* Other decls get a<nested-name> to encode their scope.  */
name|write_nested_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<unscoped-name> ::=<unqualified-name> 		   ::= St<unqualified-name>   # ::std::  */
end_comment

begin_function
specifier|static
name|void
name|write_unscoped_name
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|context
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"unscoped-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Is DECL in ::std?  */
if|if
condition|(
name|DECL_NAMESPACE_STD_P
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"St"
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If not, it should be either in the global namespace, or directly 	 in a local function scope.  */
name|gcc_assert
argument_list|(
name|context
operator|==
name|global_namespace
operator|||
name|context
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<unscoped-template-name> ::=<unscoped-name> 			    ::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_unscoped_template_name
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"unscoped-template-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|write_unscoped_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_substitution
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the nested name, including CV-qualifiers, of DECL.<nested-name> ::= N [<CV-qualifiers>]<prefix><unqualified-name> E 		 ::= N [<CV-qualifiers>]<template-prefix><template-args> E<CV-qualifiers> ::= [r] [V] [K]  */
end_comment

begin_function
specifier|static
name|void
name|write_nested_name
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|template_info
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"nested-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
comment|/* Write CV-qualifiers, if this is a member function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_VOLATILE_MEMFUNC_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_char
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONST_MEMFUNC_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_char
argument_list|(
literal|'K'
argument_list|)
expr_stmt|;
block|}
comment|/* Is this a template instance?  */
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
condition|)
block|{
comment|/* Yes, use<template-prefix>.  */
name|write_template_prefix
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No, just use<prefix>  */
name|write_prefix
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<prefix> ::=<prefix><unqualified-name> 	    ::=<template-param> 	    ::=<template-prefix><template-args> 	    ::= # empty 	    ::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_prefix
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Non-NULL if NODE represents a template-id.  */
name|tree
name|template_info
init|=
name|NULL
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"prefix"
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
operator|||
name|node
operator|==
name|global_namespace
condition|)
return|return;
if|if
condition|(
name|find_substitution
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|/* If this is a function decl, that means we've hit function 	 scope, so this prefix must be for a local name.  In this 	 case, we're under the<local-name> production, which encodes 	 the enclosing function scope elsewhere.  So don't continue 	 here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
name|decl
operator|=
name|node
expr_stmt|;
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Node is a type.  */
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_ID_P
argument_list|(
name|node
argument_list|)
condition|)
name|template_info
operator|=
name|TYPE_TEMPLATE_INFO
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* In G++ 3.2, the name of the template parameter was used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|&&
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|G
operator|.
name|need_abi_warning
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|&&
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|write_template_param
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|template_info
operator|!=
name|NULL
condition|)
comment|/* Templated.  */
block|{
name|write_template_prefix
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not templated.  */
block|{
name|write_prefix
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|add_substitution
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<template-prefix> ::=<prefix><template component> 		     ::=<template-param> 		     ::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_template_prefix
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|)
block|{
name|tree
name|decl
init|=
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|?
name|node
else|:
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
else|:
name|node
decl_stmt|;
name|tree
name|context
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|template_info
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|tree
name|substitution
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-prefix"
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Find the template decl.  */
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
condition|)
name|template
operator|=
name|TI_TEMPLATE
argument_list|(
name|template_info
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|CLASSTYPE_TEMPLATE_ID_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* For a member template, though, the template name for the      innermost name must have all the outer template levels      instantiated.  For instance, consider         template<typename T> struct Outer { 	 template<typename U> struct Inner {};        };       The template name for `Inner' in `Outer<int>::Inner<float>' is      `Outer<int>::Inner<U>'.  In g++, we don't instantiate the template      levels separately, so there's no TEMPLATE_DECL available for this      (there's only `Outer<T>::Inner<U>').       In order to get the substitutions right, we create a special      TREE_LIST to represent the substitution candidate for a nested      template.  The TREE_PURPOSE is the template's context, fully      instantiated, and the TREE_VALUE is the TEMPLATE_DECL for the inner      template.       So, for the example above, `Outer<int>::Inner' is represented as a      substitution candidate by a TREE_LIST whose purpose is `Outer<int>'      and whose value is `Outer<T>::Inner<U>'.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|substitution
operator|=
name|build_tree_list
argument_list|(
name|context
argument_list|,
name|template
argument_list|)
expr_stmt|;
else|else
name|substitution
operator|=
name|template
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|substitution
argument_list|)
condition|)
return|return;
comment|/* In G++ 3.2, the name of the template template parameter was used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|G
operator|.
name|need_abi_warning
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|write_template_param
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|write_prefix
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|add_substitution
argument_list|(
name|substitution
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We don't need to handle thunks, vtables, or VTTs here.  Those are    mangled through special entry points.<unqualified-name>  ::=<operator-name> 			::=<special-name> 			::=<source-name> 			::=<local-source-name><local-source-name>	::= L<source-name><discriminator> */
end_comment

begin_function
specifier|static
name|void
name|write_unqualified_name
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"unqualified-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_special_name_constructor
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_special_name_destructor
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|write_source_name
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Conversion operator. Handle it right here.<operator> ::= cv<type>  */
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|tree
name|fn_type
decl_stmt|;
name|save_partially_mangled_name
argument_list|()
expr_stmt|;
name|fn_type
operator|=
name|get_mostly_instantiated_function_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|restore_partially_mangled_name
argument_list|()
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|DECL_CONV_FN_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|write_conversion_operator_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|operator_name_info_t
modifier|*
name|oni
decl_stmt|;
if|if
condition|(
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|oni
operator|=
name|assignment_operator_name_info
expr_stmt|;
else|else
name|oni
operator|=
name|operator_name_info
expr_stmt|;
name|write_string
argument_list|(
name|oni
index|[
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
index|]
operator|.
name|mangled_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_linkage
argument_list|(
name|decl
argument_list|)
operator|==
name|lk_internal
condition|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"local-source-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|write_source_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The default discriminator is 1, and that's all we ever use, 	 so there's no code to output one here.  */
block|}
else|else
name|write_source_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the unqualified-name for a conversion operator to TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|write_conversion_operator_name
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
name|write_string
argument_list|(
literal|"cv"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<source-name>.  IDENTIFIER is an IDENTIFIER_NODE.<source-name> ::=</length/ number><identifier>  */
end_comment

begin_function
specifier|static
name|void
name|write_source_name
parameter_list|(
name|tree
name|identifier
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"source-name"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* Never write the whole template-id name including the template      arguments; we only want the template name.  */
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|identifier
argument_list|)
condition|)
name|identifier
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
name|write_unsigned_number
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
name|write_identifier
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert NUMBER to ascii using base BASE and generating at least    MIN_DIGITS characters. BUFFER points to the _end_ of the buffer    into which to store the characters. Returns the number of    characters generated (these will be layed out in advance of where    BUFFER points).  */
end_comment

begin_function
specifier|static
name|int
name|hwint_to_ascii
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|number
parameter_list|,
specifier|const
name|unsigned
name|int
name|base
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|unsigned
name|int
name|min_digits
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|base_digits
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
name|unsigned
name|digits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|number
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|d
init|=
name|number
operator|/
name|base
decl_stmt|;
operator|*
operator|--
name|buffer
operator|=
name|base_digits
index|[
name|number
operator|-
name|d
operator|*
name|base
index|]
expr_stmt|;
name|digits
operator|++
expr_stmt|;
name|number
operator|=
name|d
expr_stmt|;
block|}
while|while
condition|(
name|digits
operator|<
name|min_digits
condition|)
block|{
operator|*
operator|--
name|buffer
operator|=
name|base_digits
index|[
literal|0
index|]
expr_stmt|;
name|digits
operator|++
expr_stmt|;
block|}
return|return
name|digits
return|;
block|}
end_function

begin_comment
comment|/* Non-terminal<number>.<number> ::= [n]</decimal integer/>  */
end_comment

begin_function
specifier|static
name|void
name|write_number
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|number
parameter_list|,
specifier|const
name|int
name|unsigned_p
parameter_list|,
specifier|const
name|unsigned
name|int
name|base
parameter_list|)
block|{
name|char
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|*
literal|8
index|]
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|unsigned_p
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|number
operator|<
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|number
operator|=
operator|-
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|number
operator|)
expr_stmt|;
block|}
name|count
operator|=
name|hwint_to_ascii
argument_list|(
name|number
argument_list|,
name|base
argument_list|,
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_chars
argument_list|(
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out an integral CST in decimal. Most numbers are small, and    representable in a HOST_WIDE_INT. Occasionally we'll have numbers    bigger than that, which we must deal with.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|write_integer_cst
parameter_list|(
specifier|const
name|tree
name|cst
parameter_list|)
block|{
name|int
name|sign
init|=
name|tree_int_cst_sgn
argument_list|(
name|cst
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|cst
argument_list|)
operator|+
operator|(
name|sign
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* A bignum. We do this in chunks, each of which fits in a 	 HOST_WIDE_INT.  */
name|char
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|*
literal|8
operator|*
literal|2
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|chunk
decl_stmt|;
name|unsigned
name|chunk_digits
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|tree
name|n
decl_stmt|,
name|base
decl_stmt|,
name|type
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* HOST_WIDE_INT must be at least 32 bits, so 10^9 is 	 representable.  */
name|chunk
operator|=
literal|1000000000
expr_stmt|;
name|chunk_digits
operator|=
literal|9
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|>=
literal|8
condition|)
block|{
comment|/* It is at least 64 bits, so 10^18 is representable.  */
name|chunk_digits
operator|=
literal|18
expr_stmt|;
name|chunk
operator|*=
name|chunk
expr_stmt|;
block|}
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
literal|1
argument_list|,
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_int_cstu
argument_list|(
name|type
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|n
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|n
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|tree
name|d
init|=
name|fold_build2
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|tree
name|tmp
init|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|d
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|unsigned
name|c
decl_stmt|;
name|done
operator|=
name|integer_zerop
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|c
operator|=
name|hwint_to_ascii
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|10
argument_list|,
name|ptr
argument_list|,
name|done
condition|?
literal|1
else|:
name|chunk_digits
argument_list|)
expr_stmt|;
name|ptr
operator|-=
name|c
expr_stmt|;
name|count
operator|+=
name|c
expr_stmt|;
name|n
operator|=
name|d
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|write_chars
argument_list|(
name|ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A small num.  */
name|unsigned
name|HOST_WIDE_INT
name|low
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
decl_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|low
operator|=
operator|-
name|low
expr_stmt|;
block|}
name|write_unsigned_number
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out a floating-point literal.      "Floating-point literals are encoded using the bit pattern of the     target processor's internal representation of that number, as a     fixed-length lowercase hexadecimal string, high-order bytes first     (even if the target processor would store low-order bytes first).     The "n" prefix is not used for floating-point literals; the sign     bit is encoded with the rest of the number.      Here are some examples, assuming the IEEE standard representation     for floating point numbers.  (Spaces are for readability, not     part of the encoding.)  	1.0f			Lf 3f80 0000 E        -1.0f			Lf bf80 0000 E 	1.17549435e-38f		Lf 0080 0000 E 	1.40129846e-45f		Lf 0000 0001 E 	0.0f			Lf 0000 0000 E"     Caller is responsible for the Lx and the E.  */
end_comment

begin_function
specifier|static
name|void
name|write_real_cst
parameter_list|(
specifier|const
name|tree
name|value
parameter_list|)
block|{
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|long
name|target_real
index|[
literal|4
index|]
decl_stmt|;
comment|/* largest supported float */
name|char
name|buffer
index|[
literal|9
index|]
decl_stmt|;
comment|/* eight hex digits in a 32-bit number */
name|int
name|i
decl_stmt|,
name|limit
decl_stmt|,
name|dir
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|int
name|words
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|/
literal|32
decl_stmt|;
name|real_to_target
argument_list|(
name|target_real
argument_list|,
operator|&
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The value in target_real is in the target word order, 	 so we must write it out backward if that happens to be 	 little-endian.  write_number cannot be used, it will 	 produce uppercase.  */
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|i
operator|=
literal|0
operator|,
name|limit
operator|=
name|words
operator|,
name|dir
operator|=
literal|1
expr_stmt|;
else|else
name|i
operator|=
name|words
operator|-
literal|1
operator|,
name|limit
operator|=
operator|-
literal|1
operator|,
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|limit
condition|;
name|i
operator|+=
name|dir
control|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|target_real
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|write_chars
argument_list|(
name|buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* In G++ 3.3 and before the REAL_VALUE_TYPE was written out 	 literally.  Note that compatibility with 3.2 is impossible, 	 because the old floating-point emulator used a different 	 format for REAL_VALUE_TYPE.  */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
name|write_number
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
operator|)
index|[
name|i
index|]
argument_list|,
comment|/*unsigned_p*/
literal|1
argument_list|,
comment|/*base*/
literal|16
argument_list|)
expr_stmt|;
name|G
operator|.
name|need_abi_warning
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-terminal<identifier>.<identifier> ::=</unqualified source code identifier>  */
end_comment

begin_function
specifier|static
name|void
name|write_identifier
parameter_list|(
specifier|const
name|char
modifier|*
name|identifier
parameter_list|)
block|{
name|MANGLE_TRACE
argument_list|(
literal|"identifier"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle constructor productions of non-terminal<special-name>.    CTOR is a constructor FUNCTION_DECL.<special-name> ::= C1   # complete object constructor 		    ::= C2   # base object constructor 		    ::= C3   # complete object allocating constructor     Currently, allocating constructors are never used.     We also need to provide mangled names for the maybe-in-charge    constructor, so we treat it here too.  mangle_decl_string will    append *INTERNAL* to that, to make sure we never emit it.  */
end_comment

begin_function
specifier|static
name|void
name|write_special_name_constructor
parameter_list|(
specifier|const
name|tree
name|ctor
parameter_list|)
block|{
if|if
condition|(
name|DECL_BASE_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"C2"
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|DECL_COMPLETE_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
comment|/* Even though we don't ever emit a definition of 		     the old-style destructor, we still have to 		     consider entities (like static variables) nested 		     inside it.  */
operator|||
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"C1"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle destructor productions of non-terminal<special-name>.    DTOR is a destructor FUNCTION_DECL.<special-name> ::= D0 # deleting (in-charge) destructor 		    ::= D1 # complete object (in-charge) destructor 		    ::= D2 # base object (not-in-charge) destructor     We also need to provide mangled names for the maybe-incharge    destructor, so we treat it here too.  mangle_decl_string will    append *INTERNAL* to that, to make sure we never emit it.  */
end_comment

begin_function
specifier|static
name|void
name|write_special_name_destructor
parameter_list|(
specifier|const
name|tree
name|dtor
parameter_list|)
block|{
if|if
condition|(
name|DECL_DELETING_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"D0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_BASE_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"D2"
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|DECL_COMPLETE_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
comment|/* Even though we don't ever emit a definition of 		     the old-style destructor, we still have to 		     consider entities (like static variables) nested 		     inside it.  */
operator|||
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"D1"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the discriminator for ENTITY appearing inside    FUNCTION.  The discriminator is the lexical ordinal of VAR among    entities with the same name in the same FUNCTION.  */
end_comment

begin_function
specifier|static
name|int
name|discriminator_for_local_entity
parameter_list|(
name|tree
name|entity
parameter_list|)
block|{
comment|/* Assume this is the only local entity with this name.  */
name|int
name|discriminator
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_DISCRIMINATOR_P
argument_list|(
name|entity
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|entity
argument_list|)
condition|)
name|discriminator
operator|=
name|DECL_DISCRIMINATOR
argument_list|(
name|entity
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|entity
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|int
name|ix
decl_stmt|;
comment|/* Scan the list of local classes.  */
name|entity
operator|=
name|TREE_TYPE
argument_list|(
name|entity
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|type
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|local_classes
argument_list|,
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|entity
condition|)
break|break;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|entity
argument_list|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CONTEXT
argument_list|(
name|entity
argument_list|)
condition|)
operator|++
name|discriminator
expr_stmt|;
block|}
block|}
return|return
name|discriminator
return|;
block|}
end_function

begin_comment
comment|/* Return the discriminator for STRING, a string literal used inside    FUNCTION.  The discriminator is the lexical ordinal of STRING among    string literals used in FUNCTION.  */
end_comment

begin_function
specifier|static
name|int
name|discriminator_for_string_literal
parameter_list|(
name|tree
name|function
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* For now, we don't discriminate amongst string literals.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*<discriminator> := _<number>     The discriminator is used only for the second and later occurrences    of the same name within a single function. In this case<number> is    n - 2, if this is the nth occurrence, in lexical order.  */
end_comment

begin_function
specifier|static
name|void
name|write_discriminator
parameter_list|(
specifier|const
name|int
name|discriminator
parameter_list|)
block|{
comment|/* If discriminator is zero, don't write anything.  Otherwise...  */
if|if
condition|(
name|discriminator
operator|>
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|write_unsigned_number
argument_list|(
name|discriminator
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mangle the name of a function-scope entity.  FUNCTION is the    FUNCTION_DECL for the enclosing function.  ENTITY is the decl for    the entity itself.  LOCAL_ENTITY is the entity that's directly    scoped in FUNCTION_DECL, either ENTITY itself or an enclosing scope    of ENTITY.<local-name> := Z<function encoding> E<entity name> [<discriminator>] 		  := Z<function encoding> E s [<discriminator>]  */
end_comment

begin_function
specifier|static
name|void
name|write_local_name
parameter_list|(
specifier|const
name|tree
name|function
parameter_list|,
specifier|const
name|tree
name|local_entity
parameter_list|,
specifier|const
name|tree
name|entity
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"local-name"
argument_list|,
name|entity
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
name|write_encoding
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|entity
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|write_char
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|write_discriminator
argument_list|(
name|discriminator_for_string_literal
argument_list|(
name|function
argument_list|,
name|entity
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Now the<entity name>.  Let write_name know its being called 	 from<local-name>, so it doesn't try to process the enclosing 	 function scope again.  */
name|write_name
argument_list|(
name|entity
argument_list|,
comment|/*ignore_local_scope=*/
literal|1
argument_list|)
expr_stmt|;
name|write_discriminator
argument_list|(
name|discriminator_for_local_entity
argument_list|(
name|local_entity
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-terminals<type> and<CV-qualifier>.<type> ::=<builtin-type> 	    ::=<function-type> 	    ::=<class-enum-type> 	    ::=<array-type> 	    ::=<pointer-to-member-type> 	    ::=<template-param> 	    ::=<substitution> 	    ::=<CV-qualifier> 	    ::= P<type>    # pointer-to 	    ::= R<type>    # reference-to 	    ::= C<type>    # complex pair (C 2000) 	    ::= G<type>    # imaginary (C 2000)     [not supported] 	    ::= U<source-name><type>   # vendor extended type qualifier     TYPE is a type node.  */
end_comment

begin_function
specifier|static
name|void
name|write_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* This gets set to nonzero if TYPE turns out to be a (possibly      CV-qualified) builtin type.  */
name|int
name|is_builtin_type
init|=
literal|0
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|find_substitution
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|write_CV_qualifiers_for_type
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
comment|/* If TYPE was CV-qualified, we just wrote the qualifiers; now        mangle the unqualified type.  The recursive call is needed here        since both the qualified and unqualified types are substitution        candidates.  */
name|write_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
comment|/* It is important not to use the TYPE_MAIN_VARIANT of TYPE here        so that the cv-qualification of the element type is available        in write_array_type.  */
name|write_array_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* See through any typedefs.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
name|write_pointer_to_member_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
comment|/* Includes wchar_t.  */
case|case
name|REAL_TYPE
case|:
block|{
comment|/* Handle any target-specific fundamental types.  */
specifier|const
name|char
modifier|*
name|target_mangling
init|=
name|targetm
operator|.
name|mangle_fundamental_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_mangling
condition|)
block|{
name|write_string
argument_list|(
name|target_mangling
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is a typedef, TYPE may not be one of 	     the standard builtin type nodes, but an alias of one.  Use 	     TYPE_MAIN_VARIANT to get to the underlying builtin type.  */
name|write_builtin_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|is_builtin_type
expr_stmt|;
break|break;
block|}
case|case
name|COMPLEX_TYPE
case|:
name|write_char
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|write_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* A pointer-to-member function is represented as a special 	     RECORD_TYPE, so check for this first.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|write_pointer_to_member_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|write_class_enum_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
comment|/* We handle TYPENAME_TYPEs and UNBOUND_CLASS_TEMPLATEs like 	     ordinary nested names.  */
name|write_nested_name
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|write_char
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|write_char
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|write_template_param
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
name|write_template_template_param
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|write_template_template_param
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
name|write_string
argument_list|(
literal|"U8__vector"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Types other than builtin types are substitution candidates.  */
if|if
condition|(
operator|!
name|is_builtin_type
condition|)
name|add_substitution
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<CV-qualifiers> for type nodes.  Returns the number of    CV-qualifiers written for TYPE.<CV-qualifiers> ::= [r] [V] [K]  */
end_comment

begin_function
specifier|static
name|int
name|write_CV_qualifiers_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
name|int
name|num_qualifiers
init|=
literal|0
decl_stmt|;
comment|/* The order is specified by:         "In cases where multiple order-insensitive qualifiers are        present, they should be ordered 'K' (closest to the base type),        'V', 'r', and 'U' (farthest from the base type) ..."       Note that we do not use cp_type_quals below; given "const      int[3]", the "const" is emitted with the "int", not with the      array.  */
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
block|{
name|write_char
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
operator|++
name|num_qualifiers
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
block|{
name|write_char
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
operator|++
name|num_qualifiers
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_QUAL_CONST
condition|)
block|{
name|write_char
argument_list|(
literal|'K'
argument_list|)
expr_stmt|;
operator|++
name|num_qualifiers
expr_stmt|;
block|}
return|return
name|num_qualifiers
return|;
block|}
end_function

begin_comment
comment|/* Non-terminal<builtin-type>.<builtin-type> ::= v   # void 		    ::= b   # bool 		    ::= w   # wchar_t 		    ::= c   # char 		    ::= a   # signed char 		    ::= h   # unsigned char 		    ::= s   # short 		    ::= t   # unsigned short 		    ::= i   # int 		    ::= j   # unsigned int 		    ::= l   # long 		    ::= m   # unsigned long 		    ::= x   # long long, __int64 		    ::= y   # unsigned long long, __int64 		    ::= n   # __int128 		    ::= o   # unsigned __int128 		    ::= f   # float 		    ::= d   # double 		    ::= e   # long double, __float80 		    ::= g   # __float128          [not supported] 		    ::= u<source-name>  # vendor extended type */
end_comment

begin_function
specifier|static
name|void
name|write_builtin_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
name|write_char
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
name|write_char
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
comment|/* If this is size_t, get the underlying int type.  */
if|if
condition|(
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* TYPE may still be wchar_t, since that isn't in 	 integer_type_nodes.  */
if|if
condition|(
name|type
operator|==
name|wchar_type_node
condition|)
name|write_char
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
name|write_java_integer_type_codes
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|itk
decl_stmt|;
comment|/* Assume TYPE is one of the shared integer type nodes.  Find 	     it in the array of these nodes.  */
name|iagain
label|:
for|for
control|(
name|itk
operator|=
literal|0
init|;
name|itk
operator|<
name|itk_none
condition|;
operator|++
name|itk
control|)
if|if
condition|(
name|type
operator|==
name|integer_types
index|[
name|itk
index|]
condition|)
block|{
comment|/* Print the corresponding single-letter code.  */
name|write_char
argument_list|(
name|integer_type_codes
index|[
name|itk
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|itk
operator|==
name|itk_none
condition|)
block|{
name|tree
name|t
init|=
name|c_common_type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|t
condition|)
block|{
name|type
operator|=
name|t
expr_stmt|;
goto|goto
name|iagain
goto|;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
literal|128
condition|)
name|write_char
argument_list|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|'o'
else|:
literal|'n'
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Allow for cases where TYPE is not one of the shared 		     integer type nodes and write a "vendor extended builtin 		     type" with a name the form intN or uintN, respectively. 		     Situations like this can happen if you have an 		     __attribute__((__mode__(__SI__))) type and use exotic 		     switches like '-mint8' on AVR.  Of course, this is 		     undefined by the C++ ABI (and '-mint8' is not even 		     Standard C conforming), but when using such special 		     options you're pretty much in nowhere land anyway.  */
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
name|prec
index|[
literal|11
index|]
decl_stmt|;
comment|/* up to ten digits for an unsigned */
name|prefix
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|"uint"
else|:
literal|"int"
expr_stmt|;
name|sprintf
argument_list|(
name|prec
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
comment|/* "vendor extended builtin type" */
name|write_unsigned_number
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|prec
argument_list|)
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|prec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|float_type_node
operator|||
name|type
operator|==
name|java_float_type_node
condition|)
name|write_char
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
operator|||
name|type
operator|==
name|java_double_type_node
condition|)
name|write_char
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|write_char
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-terminal<function-type>.  NODE is a FUNCTION_TYPE or    METHOD_TYPE.  The return type is mangled before the parameter    types.<function-type> ::= F [Y]<bare-function-type> E   */
end_comment

begin_function
specifier|static
name|void
name|write_function_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"function-type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* For a pointer to member function, the function type may have      cv-qualifiers, indicating the quals for the artificial 'this'      parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* The first parameter must be a POINTER_TYPE pointing to the 	 `this' parameter.  */
name|tree
name|this_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|write_CV_qualifiers_for_type
argument_list|(
name|this_type
argument_list|)
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
comment|/* We don't track whether or not a type is `extern "C"'.  Note that      you can have an `extern "C"' function that does not have      `extern "C"' type, and vice versa:         extern "C" typedef void function_t();        function_t f; // f has C++ linkage, but its type is 		     // `extern "C"'         typedef void function_t();        extern "C" function_t f; // Vice versa.       See [dcl.link].  */
name|write_bare_function_type
argument_list|(
name|type
argument_list|,
comment|/*include_return_type_p=*/
literal|1
argument_list|,
comment|/*decl=*/
name|NULL
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<bare-function-type>.  TYPE is a FUNCTION_TYPE or    METHOD_TYPE.  If INCLUDE_RETURN_TYPE is nonzero, the return value    is mangled before the parameter types.  If non-NULL, DECL is    FUNCTION_DECL for the function whose type is being emitted.     If DECL is a member of a Java type, then a literal 'J'    is output and the return type is mangled as if INCLUDE_RETURN_TYPE    were nonzero.<bare-function-type> ::= [J]</signature/ type>+  */
end_comment

begin_function
specifier|static
name|void
name|write_bare_function_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|,
specifier|const
name|int
name|include_return_type_p
parameter_list|,
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|int
name|java_method_p
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"bare-function-type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Detect Java methods and emit special encoding.  */
if|if
condition|(
name|decl
operator|!=
name|NULL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|java_method_p
operator|=
literal|1
expr_stmt|;
name|write_char
argument_list|(
literal|'J'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|java_method_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Mangle the return type, if requested.  */
if|if
condition|(
name|include_return_type_p
operator|||
name|java_method_p
condition|)
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now mangle the types of the arguments.  */
name|write_method_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the mangled representation of a method parameter list of    types given in PARM_TYPES.  If METHOD_P is nonzero, the function is    considered a non-static method, and the this parameter is omitted.    If non-NULL, DECL is the FUNCTION_DECL for the function whose    parameters are being emitted.  */
end_comment

begin_function
specifier|static
name|void
name|write_method_parms
parameter_list|(
name|tree
name|parm_types
parameter_list|,
specifier|const
name|int
name|method_p
parameter_list|,
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|first_parm_type
decl_stmt|;
name|tree
name|parm_decl
init|=
name|decl
condition|?
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
comment|/* Assume this parameter type list is variable-length.  If it ends      with a void type, then it's not.  */
name|int
name|varargs_p
init|=
literal|1
decl_stmt|;
comment|/* If this is a member function, skip the first arg, which is the      this pointer.        "Member functions do not encode the type of their implicit this        parameter."       Similarly, there's no need to mangle artificial parameters, like      the VTT parameters for constructors and destructors.  */
if|if
condition|(
name|method_p
condition|)
block|{
name|parm_types
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
expr_stmt|;
name|parm_decl
operator|=
name|parm_decl
condition|?
name|TREE_CHAIN
argument_list|(
name|parm_decl
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|parm_decl
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|parm_decl
argument_list|)
condition|)
block|{
name|parm_types
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
expr_stmt|;
name|parm_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_decl
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|first_parm_type
operator|=
name|parm_types
init|;
name|parm_types
condition|;
name|parm_types
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|parm_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|parm
operator|==
name|void_type_node
condition|)
block|{
comment|/* "Empty parameter lists, whether declared as () or 	     conventionally as (void), are encoded with a void parameter 	     (v)."  */
if|if
condition|(
name|parm_types
operator|==
name|first_parm_type
condition|)
name|write_type
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* If the parm list is terminated with a void type, it's 	     fixed-length.  */
name|varargs_p
operator|=
literal|0
expr_stmt|;
comment|/* A void type better be the last one.  */
name|gcc_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|write_type
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|varargs_p
condition|)
comment|/*<builtin-type> ::= z  # ellipsis  */
name|write_char
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<class-enum-type> ::=<name>  */
end_comment

begin_function
specifier|static
name|void
name|write_class_enum_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
name|write_name
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<template-args>.  ARGS is a TREE_VEC of template    arguments.<template-args> ::= I<template-arg>+ E  */
end_comment

begin_function
specifier|static
name|void
name|write_template_args
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-args"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
comment|/* We have nested template args.  We want the innermost template 	 argument list.  */
name|args
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|write_template_arg
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<expression> ::=<unary operator-name><expression> 		::=<binary operator-name><expression><expression> 		::=<expr-primary><expr-primary> ::=<template-param> 		  ::= L<type><value number> E		# literal 		  ::= L<mangled-name> E		# external name 		  ::= sr<type><unqualified-name> 		  ::= sr<type><unqualified-name><template-args> */
end_comment

begin_function
specifier|static
name|void
name|write_expression
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Skip NOP_EXPRs.  They can occur when (say) a pointer argument      is converted (via qualification conversions) to another      type.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BASELINK
condition|)
block|{
name|expr
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Handle pointers-to-members by making them look like expression      nodes.  */
if|if
condition|(
name|code
operator|==
name|PTRMEM_CST
condition|)
block|{
name|expr
operator|=
name|build_nt
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|PTRMEM_CST_CLASS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|expr
argument_list|)
argument_list|,
comment|/*template_p=*/
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Handle template parameters.  */
if|if
condition|(
name|code
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|code
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|code
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
name|write_template_param
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Handle literals.  */
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_constant
operator|||
operator|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|code
operator|==
name|CONST_DECL
operator|)
condition|)
name|write_template_arg_literal
argument_list|(
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* G++ 3.2 incorrectly mangled non-type template arguments of 	 enumeration type using their names.  */
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
name|G
operator|.
name|need_abi_warning
operator|=
literal|1
expr_stmt|;
name|write_char
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|write_mangled_name
argument_list|(
name|expr
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SIZEOF_EXPR
operator|&&
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"st"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|tree
name|scope
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|member
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If the MEMBER is a real declaration, then the qualifying 	 scope was not dependent.  Ideally, we would not have a 	 SCOPE_REF in those cases, but sometimes we do.  If the second 	 argument is a DECL, then the name must not have been 	 dependent.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|member
argument_list|)
condition|)
name|write_expression
argument_list|(
name|member
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|template_args
decl_stmt|;
name|write_string
argument_list|(
literal|"sr"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* If MEMBER is a template-id, separate the template 	     from the arguments.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|template_args
operator|=
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|member
operator|=
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|template_args
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Write out the name of the MEMBER.  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|member
argument_list|)
condition|)
name|write_conversion_operator_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled_name
init|=
name|NULL
decl_stmt|;
comment|/* Unfortunately, there is no easy way to go from the 		 name of the operator back to the corresponding tree 		 code.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_CPLUS_TREE_CODE
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|operator_name_info
index|[
name|i
index|]
operator|.
name|identifier
operator|==
name|member
condition|)
block|{
comment|/* The ABI says that we prefer binary operator 		       names to unary operator names.  */
if|if
condition|(
name|operator_name_info
index|[
name|i
index|]
operator|.
name|arity
operator|==
literal|2
condition|)
block|{
name|mangled_name
operator|=
name|operator_name_info
index|[
name|i
index|]
operator|.
name|mangled_name
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|mangled_name
condition|)
name|mangled_name
operator|=
name|operator_name_info
index|[
name|i
index|]
operator|.
name|mangled_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|assignment_operator_name_info
index|[
name|i
index|]
operator|.
name|identifier
operator|==
name|member
condition|)
block|{
name|mangled_name
operator|=
name|assignment_operator_name_info
index|[
name|i
index|]
operator|.
name|mangled_name
expr_stmt|;
break|break;
block|}
name|write_string
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
block|}
else|else
name|write_source_name
argument_list|(
name|member
argument_list|)
expr_stmt|;
comment|/* Write out the template arguments.  */
if|if
condition|(
name|template_args
condition|)
name|write_template_args
argument_list|(
name|template_args
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* When we bind a variable or function to a non-type template 	 argument with reference type, we create an ADDR_EXPR to show 	 the fact that the entity's address has been taken.  But, we 	 don't actually want to output a mangling code for the `&'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|write_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* If it wasn't any of those, recursively expand the expression.  */
name|write_string
argument_list|(
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|mangled_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CALL_EXPR
case|:
name|sorry
argument_list|(
literal|"call_expr cannot be mangled due to a defect in the C++ ABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAST_EXPR
case|:
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There is no way to mangle a zero-operand cast like 	     "T()".  */
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"zero-operand casts cannot be mangled due to a defect "
literal|"in the C++ ABI"
argument_list|)
expr_stmt|;
else|else
name|write_expression
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|write_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle pointers-to-members specially.  */
case|case
name|SCOPE_REF
case|:
name|write_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|write_source_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|template_id
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|template_id
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: What about operators?  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
name|write_source_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* G++ 3.2 incorrectly put out both the "sr" code and 		 the nested name of the qualified name.  */
name|G
operator|.
name|need_abi_warning
operator|=
literal|1
expr_stmt|;
name|write_encoding
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|operand
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* As a GNU extension, the middle operand of a 		 conditional may be omitted.  Since expression 		 manglings are supposed to represent the input token 		 stream, there's no good way to mangle such an 		 expression without extending the C++ ABI.  */
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|i
operator|==
literal|1
operator|&&
operator|!
name|operand
condition|)
block|{
name|error
argument_list|(
literal|"omitted middle operand to %<?:%> operand "
literal|"cannot be mangled"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|write_expression
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Literal subcase of non-terminal<template-arg>.       "Literal arguments, e.g. "A<42L>", are encoded with their type      and value. Negative integer values are preceded with "n"; for      example, "A<-42L>" becomes "1AILln42EE". The bool value false is      encoded as 0, true as 1."  */
end_comment

begin_function
specifier|static
name|void
name|write_template_arg_literal
parameter_list|(
specifier|const
name|tree
name|value
parameter_list|)
block|{
name|write_char
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
name|write_integer_cst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
name|gcc_assert
argument_list|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|boolean_type_node
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|value
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|write_integer_cst
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|write_real_cst
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<template-arg>.<template-arg> ::=<type>				# type 		    ::= L<type></value/ number> E	# literal 		    ::= LZ<name> E			# external name 		    ::= X<expression> E		# expression  */
end_comment

begin_function
specifier|static
name|void
name|write_template_arg
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-arg"
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* A template template parameter's argument list contains TREE_LIST      nodes of which the value field is the actual argument.  */
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
block|{
name|node
operator|=
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* If it's a decl, deal with its type instead.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|node
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Template parameters can be of reference type. To maintain 	 internal consistency, such arguments use a conversion from 	 address of object to reference type.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|G
operator|.
name|need_abi_warning
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
name|write_type
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* A template appearing as a template arg is a template template arg.  */
name|write_template_template_arg
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_constant
operator|&&
name|code
operator|!=
name|PTRMEM_CST
operator|)
operator|||
operator|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|code
operator|==
name|CONST_DECL
operator|)
condition|)
name|write_template_arg_literal
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|/* Until ABI version 2, non-type template arguments of 	 enumeration type were mangled using their names.  */
if|if
condition|(
name|code
operator|==
name|CONST_DECL
operator|&&
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|G
operator|.
name|need_abi_warning
operator|=
literal|1
expr_stmt|;
name|write_char
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
comment|/* Until ABI version 3, the underscore before the mangled name 	 was incorrectly omitted.  */
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|3
argument_list|)
condition|)
block|{
name|G
operator|.
name|need_abi_warning
operator|=
literal|1
expr_stmt|;
name|write_char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
block|}
else|else
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_encoding
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Template arguments may be expressions.  */
name|write_char
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|write_expression
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<template-template-arg> 			::=<name> 			::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_template_template_arg
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-template-arg"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|write_name
argument_list|(
name|decl
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
name|add_substitution
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<array-type>.  TYPE is an ARRAY_TYPE.<array-type> ::= A [</dimension/ number>] _</element/ type> 		  ::= A<expression> _</element/ type>       "Array types encode the dimension (number of elements) and the      element type. For variable length arrays, the dimension (but not      the '_' separator) is omitted."  */
end_comment

begin_function
specifier|static
name|void
name|write_array_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
name|write_char
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|index_type
decl_stmt|;
name|tree
name|max
decl_stmt|;
name|index_type
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The INDEX_TYPE gives the upper and lower bounds of the 	 array.  */
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* The ABI specifies that we should mangle the number of 	     elements in the array, not the largest allowed index.  */
name|max
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|max
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
name|write_unsigned_number
argument_list|(
name|tree_low_cst
argument_list|(
name|max
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|TREE_OPERAND
argument_list|(
name|max
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
block|{
comment|/* value_dependent_expression_p presumes nothing is 		 dependent when PROCESSING_TEMPLATE_DECL is zero.  */
operator|++
name|processing_template_decl
expr_stmt|;
if|if
condition|(
operator|!
name|value_dependent_expression_p
argument_list|(
name|max
argument_list|)
condition|)
name|G
operator|.
name|need_abi_warning
operator|=
literal|1
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
block|}
name|write_expression
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<pointer-to-member-type> for pointer-to-member    variables.  TYPE is a pointer-to-member POINTER_TYPE.<pointer-to-member-type> ::= M</class/ type></member/ type>  */
end_comment

begin_function
specifier|static
name|void
name|write_pointer_to_member_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
name|write_char
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<template-param>.  PARM is a TEMPLATE_TYPE_PARM,    TEMPLATE_TEMPLATE_PARM, BOUND_TEMPLATE_TEMPLATE_PARM or a    TEMPLATE_PARM_INDEX.<template-param> ::= T</parameter/ number> _  */
end_comment

begin_function
specifier|static
name|void
name|write_template_param
parameter_list|(
specifier|const
name|tree
name|parm
parameter_list|)
block|{
name|int
name|parm_index
decl_stmt|;
name|int
name|parm_level
decl_stmt|;
name|tree
name|parm_type
init|=
name|NULL_TREE
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-parm"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|parm_index
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm_level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|parm_index
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm_level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm_type
operator|=
name|TREE_TYPE
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
comment|/* NUMBER as it appears in the mangling is (-1)-indexed, with the      earliest template param denoted by `_'.  */
if|if
condition|(
name|parm_index
operator|>
literal|0
condition|)
name|write_unsigned_number
argument_list|(
name|parm_index
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<template-template-param> 			::=<template-param> 			::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_template_template_param
parameter_list|(
specifier|const
name|tree
name|parm
parameter_list|)
block|{
name|tree
name|template
init|=
name|NULL_TREE
decl_stmt|;
comment|/* PARM, a TEMPLATE_TEMPLATE_PARM, is an instantiation of the      template template parameter.  The substitution candidate here is      only the template.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|template
operator|=
name|TI_TEMPLATE
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|template
argument_list|)
condition|)
return|return;
block|}
comment|/*<template-param> encodes only the template parameter position,      not its template arguments, which is fine here.  */
name|write_template_param
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|template
condition|)
name|add_substitution
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<substitution>.<substitution> ::= S<seq-id> _ 		     ::= S_  */
end_comment

begin_function
specifier|static
name|void
name|write_substitution
parameter_list|(
specifier|const
name|int
name|seq_id
parameter_list|)
block|{
name|MANGLE_TRACE
argument_list|(
literal|"substitution"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_id
operator|>
literal|0
condition|)
name|write_number
argument_list|(
name|seq_id
operator|-
literal|1
argument_list|,
comment|/*unsigned=*/
literal|1
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start mangling ENTITY.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|start_mangling
parameter_list|(
specifier|const
name|tree
name|entity
parameter_list|,
specifier|const
name|bool
name|ident_p
parameter_list|)
block|{
name|G
operator|.
name|entity
operator|=
name|entity
expr_stmt|;
name|G
operator|.
name|need_abi_warning
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|ident_p
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|name_obstack
argument_list|,
name|name_base
argument_list|)
expr_stmt|;
name|mangle_obstack
operator|=
operator|&
name|name_obstack
expr_stmt|;
name|name_base
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|name_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mangle_obstack
operator|=
operator|&
name|ident_hash
operator|->
name|stack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Done with mangling.  Return the generated mangled name.  If WARN is    true, and the name of G.entity will be mangled differently in a    future version of the ABI, issue a warning.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|finish_mangling
parameter_list|(
specifier|const
name|bool
name|warn
parameter_list|)
block|{
if|if
condition|(
name|warn_abi
operator|&&
name|warn
operator|&&
name|G
operator|.
name|need_abi_warning
condition|)
name|warning
argument_list|(
name|OPT_Wabi
argument_list|,
literal|"the mangled name of %qD will change in a future "
literal|"version of GCC"
argument_list|,
name|G
operator|.
name|entity
argument_list|)
expr_stmt|;
comment|/* Clear all the substitutions.  */
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|G
operator|.
name|substitutions
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Null-terminate the string.  */
name|write_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
name|mangle_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize data structures for mangling.  */
end_comment

begin_function
name|void
name|init_mangle
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|name_obstack
argument_list|)
expr_stmt|;
name|name_base
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|name_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|G
operator|.
name|substitutions
operator|=
name|NULL
expr_stmt|;
comment|/* Cache these identifiers for quick comparison when checking for      standard substitutions.  */
name|subst_identifiers
index|[
name|SUBID_ALLOCATOR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"allocator"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_STRING
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_string"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_CHAR_TRAITS
index|]
operator|=
name|get_identifier
argument_list|(
literal|"char_traits"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_ISTREAM
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_istream"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_OSTREAM
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_ostream"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_IOSTREAM
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_iostream"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the mangled name of DECL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mangle_decl_string
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|(
name|decl
argument_list|,
comment|/*ident_p=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|write_mangled_name
argument_list|(
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|(
comment|/*warn=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_decl_string = '%s'\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like get_identifier, except that NAME is assumed to have been    allocated on the obstack used by the identifier hash table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|get_identifier_nocopy
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|hashnode
name|ht_node
init|=
name|ht_lookup
argument_list|(
name|ident_hash
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|HT_ALLOCED
argument_list|)
decl_stmt|;
return|return
name|HT_IDENT_TO_GCC_IDENT
argument_list|(
name|ht_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the external mangled name of DECL.  */
end_comment

begin_function
name|void
name|mangle_decl
parameter_list|(
specifier|const
name|tree
name|decl
parameter_list|)
block|{
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier_nocopy
argument_list|(
name|mangle_decl_string
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the mangled representation of TYPE.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mangle_type_string
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|(
name|type
argument_list|,
comment|/*ident_p=*/
name|false
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|(
comment|/*warn=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_type_string = '%s'\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled name of a special component    for belonging to TYPE.  CODE is the ABI-specified code for this    component.  */
end_comment

begin_function
specifier|static
name|tree
name|mangle_special_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|code
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
comment|/* We don't have an actual decl here for the special component, so      we can't just process the<encoded-name>.  Instead, fake it.  */
name|start_mangling
argument_list|(
name|type
argument_list|,
comment|/*ident_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Start the mangling.  */
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Add the type.  */
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|(
comment|/*warn=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_special_for_type = %s\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|get_identifier_nocopy
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled representation of the typeinfo    structure for TYPE.  */
end_comment

begin_function
name|tree
name|mangle_typeinfo_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TI"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled name of the NTBS containing    the mangled name of TYPE.  */
end_comment

begin_function
name|tree
name|mangle_typeinfo_string_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TS"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled name of the vtable for TYPE.  */
end_comment

begin_function
name|tree
name|mangle_vtbl_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TV"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns an identifier for the mangled name of the VTT for TYPE.  */
end_comment

begin_function
name|tree
name|mangle_vtt_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TT"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for a construction vtable group.  TYPE is    the most derived class in the hierarchy; BINFO is the base    subobject for which this construction vtable group will be used.     This mangling isn't part of the ABI specification; in the ABI    specification, the vtable group is dumped in the same COMDAT as the    main vtable, and is referenced only from that vtable, so it doesn't    need an external name.  For binary formats without COMDAT sections,    though, we need external names for the vtable groups.     We use the production<special-name> ::= CT<type><offset number> _<base type>  */
end_comment

begin_function
name|tree
name|mangle_ctor_vtbl_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|,
specifier|const
name|tree
name|binfo
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|(
name|type
argument_list|,
comment|/*ident_p=*/
name|true
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"TC"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_integer_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|(
comment|/*warn=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_ctor_vtbl_for_type = %s\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|get_identifier_nocopy
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mangle a this pointer or result pointer adjustment.<call-offset> ::= h<fixed offset number> _ 		 ::= v<fixed offset number> _<virtual offset number> _ */
end_comment

begin_function
specifier|static
name|void
name|mangle_call_offset
parameter_list|(
specifier|const
name|tree
name|fixed_offset
parameter_list|,
specifier|const
name|tree
name|virtual_offset
parameter_list|)
block|{
name|write_char
argument_list|(
name|virtual_offset
condition|?
literal|'v'
else|:
literal|'h'
argument_list|)
expr_stmt|;
comment|/* For either flavor, write the fixed offset.  */
name|write_integer_cst
argument_list|(
name|fixed_offset
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
comment|/* For a virtual thunk, add the virtual offset.  */
if|if
condition|(
name|virtual_offset
condition|)
block|{
name|write_integer_cst
argument_list|(
name|virtual_offset
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an identifier for the mangled name of a this-adjusting or    covariant thunk to FN_DECL.  FIXED_OFFSET is the initial adjustment    to this used to find the vptr.  If VIRTUAL_OFFSET is non-NULL, this    is a virtual thunk, and it is the vtbl offset in    bytes. THIS_ADJUSTING is nonzero for a this adjusting thunk and    zero for a covariant thunk. Note, that FN_DECL might be a covariant    thunk itself. A covariant thunk name always includes the adjustment    for the this pointer, even if there is none.<special-name> ::= T<call-offset><base encoding> 		  ::= Tc<this_adjust call-offset><result_adjust call-offset><base encoding>  */
end_comment

begin_function
name|tree
name|mangle_thunk
parameter_list|(
name|tree
name|fn_decl
parameter_list|,
specifier|const
name|int
name|this_adjusting
parameter_list|,
name|tree
name|fixed_offset
parameter_list|,
name|tree
name|virtual_offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|(
name|fn_decl
argument_list|,
comment|/*ident_p=*/
name|true
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_adjusting
condition|)
block|{
comment|/* Covariant thunk with no this adjustment */
name|write_char
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|mangle_call_offset
argument_list|(
name|integer_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|mangle_call_offset
argument_list|(
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_THUNK_P
argument_list|(
name|fn_decl
argument_list|)
condition|)
comment|/* Plain this adjusting thunk.  */
name|mangle_call_offset
argument_list|(
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This adjusting thunk to covariant thunk.  */
name|write_char
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|mangle_call_offset
argument_list|(
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
name|fixed_offset
operator|=
name|ssize_int
argument_list|(
name|THUNK_FIXED_OFFSET
argument_list|(
name|fn_decl
argument_list|)
argument_list|)
expr_stmt|;
name|virtual_offset
operator|=
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|fn_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_offset
condition|)
name|virtual_offset
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|virtual_offset
argument_list|)
expr_stmt|;
name|mangle_call_offset
argument_list|(
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
name|fn_decl
operator|=
name|THUNK_TARGET
argument_list|(
name|fn_decl
argument_list|)
expr_stmt|;
block|}
comment|/* Scoped name.  */
name|write_encoding
argument_list|(
name|fn_decl
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|(
comment|/*warn=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_thunk = %s\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|get_identifier_nocopy
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This hash table maps TYPEs to the IDENTIFIER for a conversion    operator to TYPE.  The nodes are IDENTIFIERs whose TREE_TYPE is the    TYPE.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (union tree_node))
argument_list|)
name|htab_t
name|conv_type_names
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hash a node (VAL1) in the table.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_type
parameter_list|(
specifier|const
name|void
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|hashval_t
operator|)
name|TYPE_UID
argument_list|(
name|TREE_TYPE
argument_list|(
operator|(
name|tree
operator|)
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare VAL1 (a node in the table) with VAL2 (a TYPE).  */
end_comment

begin_function
specifier|static
name|int
name|compare_type
parameter_list|(
specifier|const
name|void
modifier|*
name|val1
parameter_list|,
specifier|const
name|void
modifier|*
name|val2
parameter_list|)
block|{
return|return
name|TREE_TYPE
argument_list|(
operator|(
name|tree
operator|)
name|val1
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|val2
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for the mangled unqualified name for a    conversion operator to TYPE.  This mangling is not specified by the    ABI spec; it is only used internally.  */
end_comment

begin_function
name|tree
name|mangle_conv_op_name_for_type
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|conv_type_names
operator|==
name|NULL
condition|)
name|conv_type_names
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
operator|&
name|hash_type
argument_list|,
operator|&
name|compare_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|conv_type_names
argument_list|,
name|type
argument_list|,
operator|(
name|hashval_t
operator|)
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|identifier
operator|=
operator|(
name|tree
operator|)
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|identifier
condition|)
block|{
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
comment|/* Create a unique name corresponding to TYPE.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"operator %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|htab_elements
argument_list|(
name|conv_type_names
argument_list|)
argument_list|)
expr_stmt|;
name|identifier
operator|=
name|get_identifier
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|identifier
expr_stmt|;
comment|/* Hang TYPE off the identifier so it can be found easily later 	 when performing conversions.  */
name|TREE_TYPE
argument_list|(
name|identifier
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Set bits on the identifier so we know later it's a conversion.  */
name|IDENTIFIER_OPNAME_P
argument_list|(
name|identifier
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|identifier
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|identifier
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for the name of an initialization guard    variable for indicated VARIABLE.  */
end_comment

begin_function
name|tree
name|mangle_guard_variable
parameter_list|(
specifier|const
name|tree
name|variable
parameter_list|)
block|{
name|start_mangling
argument_list|(
name|variable
argument_list|,
comment|/*ident_p=*/
name|true
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"_ZGV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|,
literal|"_ZGR"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* The name of a guard variable for a reference temporary should refer        to the reference, not the temporary.  */
name|write_string
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|variable
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
name|write_name
argument_list|(
name|variable
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_identifier_nocopy
argument_list|(
name|finish_mangling
argument_list|(
comment|/*warn=*/
name|false
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for the name of a temporary variable used to    initialize a static reference.  This isn't part of the ABI, but we might    as well call them something readable.  */
end_comment

begin_function
name|tree
name|mangle_ref_init_variable
parameter_list|(
specifier|const
name|tree
name|variable
parameter_list|)
block|{
name|start_mangling
argument_list|(
name|variable
argument_list|,
comment|/*ident_p=*/
name|true
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"_ZGR"
argument_list|)
expr_stmt|;
name|write_name
argument_list|(
name|variable
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_identifier_nocopy
argument_list|(
name|finish_mangling
argument_list|(
comment|/*warn=*/
name|false
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Foreign language type mangling section.  */
end_comment

begin_comment
comment|/* How to write the type codes for the integer Java type.  */
end_comment

begin_function
specifier|static
name|void
name|write_java_integer_type_codes
parameter_list|(
specifier|const
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|java_int_type_node
condition|)
name|write_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_short_type_node
condition|)
name|write_char
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_byte_type_node
condition|)
name|write_char
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_char_type_node
condition|)
name|write_char
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_long_type_node
condition|)
name|write_char
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_boolean_type_node
condition|)
name|write_char
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-mangle.h"
end_include

end_unit

