begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Name mangling for the 3.0 C++ ABI.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Alex Samuel<sameul@codesourcery.com>     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU CC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with GNU CC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file implements mangling of C++ names according to the IA64    C++ ABI specification.  A mangled name encodes a function or    variable's name, scope, type, and/or template arguments into a text    identifier.  This identifier is used as the function's or    variable's linkage name, to preserve compatibility between C++'s    language features (templates, scoping, and overloading) and C    linkers.     Additionally, g++ uses mangled names internally.  To support this,    mangling of types is allowed, even though the mangled name of a    type should not appear by itself as an exported name.  Ditto for    uninstantiated templates.     The primary entry point for this module is mangle_decl, which    returns an identifier containing the mangled name for a decl.    Additional entry points are provided to build mangled names of    particular constructs when the appropriate decl for that construct    is not available.  These are:       mangle_typeinfo_for_type:        typeinfo data      mangle_typeinfo_string_for_type: typeinfo type name      mangle_vtbl_for_type:            virtual table data      mangle_vtt_for_type:             VTT data      mangle_ctor_vtbl_for_type:       `C-in-B' constructor virtual table data      mangle_thunk:                    thunk function or entry  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_comment
comment|/* Debugging support.  */
end_comment

begin_comment
comment|/* Define DEBUG_MANGLE to enable very verbose trace messages.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_MANGLE
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_MANGLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros for tracing the write_* functions.  */
end_comment

begin_if
if|#
directive|if
name|DEBUG_MANGLE
end_if

begin_define
define|#
directive|define
name|MANGLE_TRACE
parameter_list|(
name|FN
parameter_list|,
name|INPUT
parameter_list|)
define|\
value|fprintf (stderr, "  %-24s: %-24s\n", (FN), (INPUT))
end_define

begin_define
define|#
directive|define
name|MANGLE_TRACE_TREE
parameter_list|(
name|FN
parameter_list|,
name|NODE
parameter_list|)
define|\
value|fprintf (stderr, "  %-24s: %-24s (%p)\n", \            (FN), tree_code_name[TREE_CODE (NODE)], (void *) (NODE))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MANGLE_TRACE
parameter_list|(
name|FN
parameter_list|,
name|INPUT
parameter_list|)
end_define

begin_define
define|#
directive|define
name|MANGLE_TRACE_TREE
parameter_list|(
name|FN
parameter_list|,
name|NODE
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-zero if NODE is a class template-id.  We can't rely on    CLASSTYPE_USE_TEMPLATE here because of tricky bugs in the parser    that hard to distinguish A<T> from A, where A<T> is the type as    instantiated outside of the template, and A is the type used    without parameters inside the template.  */
end_comment

begin_define
define|#
directive|define
name|CLASSTYPE_TEMPLATE_ID_P
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(TYPE_LANG_SPECIFIC (NODE) != NULL 				      \&& CLASSTYPE_TEMPLATE_INFO (NODE) != NULL                          \&& (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE))))
end_define

begin_comment
comment|/* Things we only need one of.  This module is not reentrant.  */
end_comment

begin_struct
specifier|static
struct|struct
name|globals
block|{
comment|/* The name in which we're building the mangled name.  */
name|struct
name|obstack
name|name_obstack
decl_stmt|;
comment|/* An array of the current substitution candidates, in the order      we've seen them.  */
name|varray_type
name|substitutions
decl_stmt|;
block|}
name|G
struct|;
end_struct

begin_comment
comment|/* Indices into subst_identifiers.  These are identifiers used in    special substitution rules.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SUBID_ALLOCATOR
block|,
name|SUBID_BASIC_STRING
block|,
name|SUBID_CHAR_TRAITS
block|,
name|SUBID_BASIC_ISTREAM
block|,
name|SUBID_BASIC_OSTREAM
block|,
name|SUBID_BASIC_IOSTREAM
block|,
name|SUBID_MAX
block|}
name|substitution_identifier_index_t
typedef|;
end_typedef

begin_comment
comment|/* For quick substitution checks, look up these common identifiers    once only.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|subst_identifiers
index|[
name|SUBID_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Single-letter codes for builtin integer types, defined in<builtin-type>.  These are indexed by integer_type_kind values.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|integer_type_codes
index|[
name|itk_none
index|]
init|=
block|{
literal|'c'
block|,
comment|/* itk_char */
literal|'a'
block|,
comment|/* itk_signed_char */
literal|'h'
block|,
comment|/* itk_unsigned_char */
literal|'s'
block|,
comment|/* itk_short */
literal|'t'
block|,
comment|/* itk_unsigned_short */
literal|'i'
block|,
comment|/* itk_int */
literal|'j'
block|,
comment|/* itk_unsigned_int */
literal|'l'
block|,
comment|/* itk_long */
literal|'m'
block|,
comment|/* itk_unsigned_long */
literal|'x'
block|,
comment|/* itk_long_long */
literal|'y'
comment|/* itk_unsigned_long_long */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decl_is_template_id
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions for handling substitutions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|tree
name|canonicalize_for_substitution
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_substitution
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|is_std_substitution
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|substitution_identifier_index_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|is_std_substitution_char
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|substitution_identifier_index_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_substitution
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions for emitting mangled representations of things.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|write_mangled_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_encoding
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_unscoped_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_unscoped_template_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_nested_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_prefix
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_template_prefix
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_unqualified_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_source_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hwint_to_ascii
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_number
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_integer_cst
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_identifier
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_special_name_constructor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_special_name_destructor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_CV_qualifiers_for_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_builtin_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_function_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_bare_function_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_method_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_class_enum_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_template_args
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_expression
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_template_arg_literal
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_template_arg
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_template_template_arg
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_array_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_pointer_to_member_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_template_param
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_template_template_param
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_substitution
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discriminator_for_local_entity
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discriminator_for_string_literal
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_discriminator
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_local_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_substitution_candidates
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mangle_decl_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|start_mangling
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|finish_mangling
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|mangle_special_for_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Foreign language functions. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|write_java_integer_type_codes
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Append a single character to the end of the mangled    representation.  */
end_comment

begin_define
define|#
directive|define
name|write_char
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|obstack_1grow (&G.name_obstack, (CHAR))
end_define

begin_comment
comment|/* Append a sized buffer to the end of the mangled representation. */
end_comment

begin_define
define|#
directive|define
name|write_chars
parameter_list|(
name|CHAR
parameter_list|,
name|LEN
parameter_list|)
define|\
value|obstack_grow (&G.name_obstack, (CHAR), (LEN))
end_define

begin_comment
comment|/* Append a NUL-terminated string to the end of the mangled    representation.  */
end_comment

begin_define
define|#
directive|define
name|write_string
parameter_list|(
name|STRING
parameter_list|)
define|\
value|obstack_grow (&G.name_obstack, (STRING), strlen (STRING))
end_define

begin_comment
comment|/* Return the position at which the next character will be appended to    the mangled representation.  */
end_comment

begin_define
define|#
directive|define
name|mangled_position
parameter_list|()
define|\
value|obstack_object_size (&G.name_obstack)
end_define

begin_comment
comment|/* Non-zero if NODE1 and NODE2 are both TREE_LIST nodes and have the    same purpose (context, which may be a type) and value (template    decl).  See write_template_prefix for more information on what this    is used for.  */
end_comment

begin_define
define|#
directive|define
name|NESTED_TEMPLATE_MATCH
parameter_list|(
name|NODE1
parameter_list|,
name|NODE2
parameter_list|)
define|\
value|(TREE_CODE (NODE1) == TREE_LIST                                     \&& TREE_CODE (NODE2) == TREE_LIST                                  \&& ((TYPE_P (TREE_PURPOSE (NODE1))                                 \&& same_type_p (TREE_PURPOSE (NODE1), TREE_PURPOSE (NODE2)))\        || TREE_PURPOSE (NODE1) == TREE_PURPOSE (NODE2))             \&& TREE_VALUE (NODE1) == TREE_VALUE (NODE2))
end_define

begin_comment
comment|/* Write out a signed quantity in base 10.  */
end_comment

begin_define
define|#
directive|define
name|write_signed_number
parameter_list|(
name|NUMBER
parameter_list|)
define|\
value|write_number ((NUMBER),
comment|/*unsigned_p=*/
value|0, 10)
end_define

begin_comment
comment|/* Write out an unsigned quantity in base 10.  */
end_comment

begin_define
define|#
directive|define
name|write_unsigned_number
parameter_list|(
name|NUMBER
parameter_list|)
define|\
value|write_number ((NUMBER),
comment|/*unsigned_p=*/
value|1, 10)
end_define

begin_comment
comment|/* If DECL is a template instance, return non-zero and, if    TEMPLATE_INFO is non-NULL, set *TEMPLATE_INFO to its template info.    Otherwise return zero.  */
end_comment

begin_function
specifier|static
name|int
name|decl_is_template_id
parameter_list|(
name|decl
parameter_list|,
name|template_info
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
modifier|*
name|template_info
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* TYPE_DECLs are handled specially.  Look at its type to decide 	 if this is a template instantiation.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_ID_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|template_info
operator|!=
name|NULL
condition|)
comment|/* For a templated TYPE_DECL, the template info is hanging 	       off the type.  */
operator|*
name|template_info
operator|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* Check if this is a primary template.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|template_info
operator|!=
name|NULL
condition|)
comment|/* For most templated decls, the template info is hanging 	       off the decl.  */
operator|*
name|template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* It's not a template id.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Produce debugging output of current substitution candidates.  */
end_comment

begin_function
specifier|static
name|void
name|dump_substitution_candidates
parameter_list|()
block|{
name|unsigned
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ substitutions  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|G
operator|.
name|substitutions
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|el
init|=
name|VARRAY_TREE
argument_list|(
name|G
operator|.
name|substitutions
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|"???"
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|el
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|el
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|el
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|el
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|el
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|el
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" S%d_ = "
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|el
argument_list|)
operator|&&
operator|(
name|CP_TYPE_RESTRICT_P
argument_list|(
name|el
argument_list|)
operator|||
name|CP_TYPE_VOLATILE_P
argument_list|(
name|el
argument_list|)
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|el
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CV-"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (%s at %p)\n"
argument_list|,
name|name
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|el
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|el
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Both decls and types can be substitution candidates, but sometimes    they refer to the same thing.  For instance, a TYPE_DECL and    RECORD_TYPE for the same class refer to the same thing, and should    be treated accordinginly in substitutions.  This function returns a    canonicalized tree node representing NODE that is used when adding    and substitution candidates and finding matches.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|canonicalize_for_substitution
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
comment|/* For a TYPE_DECL, use the type instead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|node
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
name|node
operator|=
name|canonical_type_variant
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Add NODE as a substitution candidate.  NODE must not already be on    the list of candidates.  */
end_comment

begin_function
specifier|static
name|void
name|add_substitution
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|c
decl_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ add_substitution (%s at %10p)\n"
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
comment|/* Get the canonicalized substitution candidate for NODE.  */
name|c
operator|=
name|canonicalize_for_substitution
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
operator|&&
name|c
operator|!=
name|node
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ using candidate (%s at %10p)\n"
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|c
expr_stmt|;
if|#
directive|if
name|ENABLE_CHECKING
comment|/* Make sure NODE isn't already a candidate.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|G
operator|.
name|substitutions
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|tree
name|candidate
init|=
name|VARRAY_TREE
argument_list|(
name|G
operator|.
name|substitutions
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|DECL_P
argument_list|(
name|node
argument_list|)
operator|&&
name|node
operator|==
name|candidate
operator|)
operator|||
operator|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|candidate
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|node
argument_list|,
name|candidate
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ENABLE_CHECKING */
comment|/* Put the decl onto the varray of substitution candidates.  */
name|VARRAY_PUSH_TREE
argument_list|(
name|G
operator|.
name|substitutions
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|dump_substitution_candidates
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for find_substitution.  Returns non-zero if NODE,    which may be a decl or a CLASS_TYPE, is a template-id with template    name of substitution_index[INDEX] in the ::std namespace.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_std_substitution
parameter_list|(
name|node
parameter_list|,
name|index
parameter_list|)
name|tree
name|node
decl_stmt|;
name|substitution_identifier_index_t
name|index
decl_stmt|;
block|{
name|tree
name|type
init|=
name|NULL
decl_stmt|;
name|tree
name|decl
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|decl
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|type
operator|=
name|node
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* These are not the droids you're looking for.  */
return|return
literal|0
return|;
return|return
operator|(
name|DECL_NAMESPACE_STD_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|subst_identifiers
index|[
name|index
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for find_substitution.  Returns non-zero if NODE,    which may be a decl or a CLASS_TYPE, is the template-id    ::std::identifier<char>, where identifier is    substitution_index[INDEX].  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_std_substitution_char
parameter_list|(
name|node
parameter_list|,
name|index
parameter_list|)
name|tree
name|node
decl_stmt|;
name|substitution_identifier_index_t
name|index
decl_stmt|;
block|{
name|tree
name|args
decl_stmt|;
comment|/* Check NODE's name is ::std::identifier.  */
if|if
condition|(
operator|!
name|is_std_substitution
argument_list|(
name|node
argument_list|,
name|index
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Figure out its template args.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
comment|/* Oops, not a template.  */
return|return
literal|0
return|;
comment|/* NODE's template arg list should be<char>.  */
return|return
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
operator|==
name|char_type_node
return|;
block|}
end_function

begin_comment
comment|/* Check whether a substitution should be used to represent NODE in    the mangling.     First, check standard special-case substitutions.<substitution> ::= St               # ::std                      ::= Sa      	 # ::std::allocator                      ::= Sb               # ::std::basic_string                      ::= Ss           # ::std::basic_string<char, 			       ::std::char_traits<char>, 			       ::std::allocator<char>>                      ::= Si           # ::std::basic_istream<char, ::std::char_traits<char>>                      ::= So           # ::std::basic_ostream<char, ::std::char_traits<char>>                      ::= Sd           # ::std::basic_iostream<char, ::std::char_traits<char>>        Then examine the stack of currently available substitution    candidates for entities appearing earlier in the same mangling     If a substitution is found, write its mangled representation and    return non-zero.  If none is found, just return zero.  */
end_comment

begin_function
specifier|static
name|int
name|find_substitution
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|size
init|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|G
operator|.
name|substitutions
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ++ find_substitution (%s at %p)\n"
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
comment|/* Obtain the canonicalized substitution representation for NODE.      This is what we'll compare against.  */
name|node
operator|=
name|canonicalize_for_substitution
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Check for builtin substitutions.  */
name|decl
operator|=
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
else|:
name|node
expr_stmt|;
name|type
operator|=
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|?
name|node
else|:
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Check for std::allocator.  */
if|if
condition|(
name|decl
operator|&&
name|is_std_substitution
argument_list|(
name|decl
argument_list|,
name|SUBID_ALLOCATOR
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"Sa"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Check for std::basic_string.  */
if|if
condition|(
name|decl
operator|&&
name|is_std_substitution
argument_list|(
name|decl
argument_list|,
name|SUBID_BASIC_STRING
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|/* If this is a type (i.e. a fully-qualified template-id),  	     check for    	         std::basic_string<char, 		 		    std::char_traits<char>, 				    std::allocator<char>> .  */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|==
literal|3
operator|&&
name|same_type_p
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
operator|&&
name|is_std_substitution_char
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SUBID_CHAR_TRAITS
argument_list|)
operator|&&
name|is_std_substitution_char
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
argument_list|,
name|SUBID_ALLOCATOR
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"Ss"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
else|else
comment|/* Substitute for the template name only if this isn't a type.  */
block|{
name|write_string
argument_list|(
literal|"Sb"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Check for basic_{i,o,io}stream.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
operator|&&
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* First, check for the template  	 args<char, std::char_traits<char>> .  */
name|tree
name|args
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|==
literal|2
operator|&&
name|same_type_p
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
operator|&&
name|is_std_substitution_char
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SUBID_CHAR_TRAITS
argument_list|)
condition|)
block|{
comment|/* Got them.  Is this basic_istream?  */
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|subst_identifiers
index|[
name|SUBID_BASIC_ISTREAM
index|]
condition|)
block|{
name|write_string
argument_list|(
literal|"Si"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Or basic_ostream?  */
elseif|else
if|if
condition|(
name|name
operator|==
name|subst_identifiers
index|[
name|SUBID_BASIC_OSTREAM
index|]
condition|)
block|{
name|write_string
argument_list|(
literal|"So"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Or basic_iostream?  */
elseif|else
if|if
condition|(
name|name
operator|==
name|subst_identifiers
index|[
name|SUBID_BASIC_IOSTREAM
index|]
condition|)
block|{
name|write_string
argument_list|(
literal|"Sd"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Check for namespace std.  */
if|if
condition|(
name|decl
operator|&&
name|DECL_NAMESPACE_STD_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"St"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now check the list of available substitutions for this mangling      operation.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|candidate
init|=
name|VARRAY_TREE
argument_list|(
name|G
operator|.
name|substitutions
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* NODE is a matched to a candidate if it's the same decl node or 	 if it's the same type.  */
if|if
condition|(
name|decl
operator|==
name|candidate
operator|||
operator|(
name|TYPE_P
argument_list|(
name|candidate
argument_list|)
operator|&&
name|type
operator|&&
name|TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|type
argument_list|,
name|candidate
argument_list|)
operator|)
operator|||
name|NESTED_TEMPLATE_MATCH
argument_list|(
name|node
argument_list|,
name|candidate
argument_list|)
condition|)
block|{
name|write_substitution
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* No substitution found.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*<mangled-name>      ::= _Z<encoding>  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|write_mangled_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"mangled-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The standard notes:          "The<encoding> of an extern "C" function is treated like 	 global-scope data, i.e. as its<source-name> without a type."        We cannot write overloaded operators that way though,        because it contains characters invalid in assembler.  */
name|write_source_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* C++ name; needs to be mangled.  */
block|{
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_encoding
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<encoding>		::=<function name><bare-function-type> 			::=<data name>  */
end_comment

begin_function
specifier|static
name|void
name|write_encoding
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"encoding"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* For overloaded operators write just the mangled name 	 without arguments.  */
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_name
argument_list|(
name|decl
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
else|else
name|write_source_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|write_name
argument_list|(
name|decl
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|fn_type
decl_stmt|;
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
condition|)
name|fn_type
operator|=
name|get_mostly_instantiated_function_type
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|write_bare_function_type
argument_list|(
name|fn_type
argument_list|,
operator|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
operator|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<name> ::=<unscoped-name>           ::=<unscoped-template-name><template-args> 	  ::=<nested-name> 	  ::=<local-name>       If IGNORE_LOCAL_SCOPE is non-zero, this production of<name> is    called from<local-name>, which mangles the enclosing scope    elsewhere and then uses this function to mangle just the part    underneath the function scope.  So don't use the<local-name>    production, to avoid an infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|write_name
parameter_list|(
name|decl
parameter_list|,
name|ignore_local_scope
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|ignore_local_scope
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* In case this is a typedef, fish out the corresponding 	 TYPE_DECL for the main variant.  */
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|context
operator|=
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* A decl in :: or ::std scope is treated specially.  The former is      mangled using<unscoped-name> or<unscoped-template-name>, the      latter with a special substitution.  Also, a name that is      directly in a local function scope is also mangled with<unscoped-name> rather than a full<nested-name>.  */
if|if
condition|(
name|context
operator|==
name|NULL
operator|||
name|context
operator|==
name|global_namespace
operator|||
name|DECL_NAMESPACE_STD_P
argument_list|(
name|context
argument_list|)
operator|||
operator|(
name|ignore_local_scope
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|tree
name|template_info
decl_stmt|;
comment|/* Is this a template instance?  */
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
condition|)
block|{
comment|/* Yes: use<unscoped-template-name>.  */
name|write_unscoped_template_name
argument_list|(
name|TI_TEMPLATE
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Everything else gets an<unqualified-name>.  */
name|write_unscoped_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle local names, unless we asked not to (that is, invoked          under<local-name>, to handle only the part of the name under          the local scope).  */
if|if
condition|(
operator|!
name|ignore_local_scope
condition|)
block|{
comment|/* Scan up the list of scope context, looking for a 	     function.  If we find one, this entity is in local 	     function scope.  local_entity tracks context one scope 	     level down, so it will contain the element that's 	     directly in that function's scope, either decl or one of 	     its enclosing scopes.  */
name|tree
name|local_entity
init|=
name|decl
decl_stmt|;
while|while
condition|(
name|context
operator|!=
name|NULL
operator|&&
name|context
operator|!=
name|global_namespace
condition|)
block|{
comment|/* Make sure we're always dealing with decls.  */
if|if
condition|(
name|context
operator|!=
name|NULL
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Is this a function?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Yes, we have local scope.  Use the<local-name> 		     production for the innermost function scope.  */
name|write_local_name
argument_list|(
name|context
argument_list|,
name|local_entity
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Up one scope level.  */
name|local_entity
operator|=
name|context
expr_stmt|;
name|context
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* No local scope found?  Fall through to<nested-name>.  */
block|}
comment|/* Other decls get a<nested-name> to encode their scope.  */
name|write_nested_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<unscoped-name> ::=<unqualified-name>                    ::= St<unqualified-name>   # ::std::  */
end_comment

begin_function
specifier|static
name|void
name|write_unscoped_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"unscoped-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Is DECL in ::std?  */
if|if
condition|(
name|DECL_NAMESPACE_STD_P
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|write_string
argument_list|(
literal|"St"
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* If not, it should be either in the global namespace, or directly      in a local function scope.  */
elseif|else
if|if
condition|(
name|context
operator|==
name|global_namespace
operator|||
name|context
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<unscoped-template-name> ::=<unscoped-name>                             ::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_unscoped_template_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"unscoped-template-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|write_unscoped_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_substitution
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the nested name, including CV-qualifiers, of DECL.<nested-name> ::= N [<CV-qualifiers>]<prefix><unqualified-name> E                    ::= N [<CV-qualifiers>]<template-prefix><template-args> E<CV-qualifiers> ::= [r] [V] [K]  */
end_comment

begin_function
specifier|static
name|void
name|write_nested_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|template_info
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"nested-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
comment|/* Write CV-qualifiers, if this is a member function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_VOLATILE_MEMFUNC_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_char
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONST_MEMFUNC_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_char
argument_list|(
literal|'K'
argument_list|)
expr_stmt|;
block|}
comment|/* Is this a template instance?  */
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
condition|)
block|{
comment|/* Yes, use<template-prefix>.  */
name|write_template_prefix
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No, just use<prefix>  */
name|write_prefix
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<prefix> ::=<prefix><unqualified-name>>             ::=<template-prefix><template-args> 	    ::= # empty 	    ::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_prefix
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Non-NULL if NODE represents a template-id.  */
name|tree
name|template_info
init|=
name|NULL
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"prefix"
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
operator|||
name|node
operator|==
name|global_namespace
condition|)
return|return;
if|if
condition|(
name|find_substitution
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
comment|/* Node is a decl.  */
block|{
comment|/* If this is a function decl, that means we've hit function 	 scope, so this prefix must be for a local name.  In this 	 case, we're under the<local-name> production, which encodes 	 the enclosing function scope elsewhere.  So don't continue 	 here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
name|decl
operator|=
name|node
expr_stmt|;
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Node is a type.  */
block|{
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_ID_P
argument_list|(
name|node
argument_list|)
condition|)
name|template_info
operator|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|template_info
operator|!=
name|NULL
condition|)
comment|/* Templated.  */
block|{
name|write_template_prefix
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not templated.  */
block|{
name|write_prefix
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|add_substitution
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<template-prefix> ::=<prefix><template component>                      ::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_template_prefix
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|?
name|node
else|:
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
else|:
name|node
decl_stmt|;
name|tree
name|context
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|template_info
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|tree
name|substitution
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-prefix"
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Find the template decl.  */
if|if
condition|(
name|decl_is_template_id
argument_list|(
name|decl
argument_list|,
operator|&
name|template_info
argument_list|)
condition|)
name|template
operator|=
name|TI_TEMPLATE
argument_list|(
name|template_info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_ID_P
argument_list|(
name|type
argument_list|)
condition|)
name|template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
comment|/* Oops, not a template.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* For a member template, though, the template name for the      innermost name must have all the outer template levels      instantiated.  For instance, consider         template<typename T> struct Outer { 	 template<typename U> struct Inner {};        };       The template name for `Inner' in `Outer<int>::Inner<float>' is      `Outer<int>::Inner<U>'.  In g++, we don't instantiate the template      levels separately, so there's no TEMPLATE_DECL available for this      (there's only `Outer<T>::Inner<U>').       In order to get the substitutions right, we create a special      TREE_LIST to represent the substitution candidate for a nested      template.  The TREE_PURPOSE is the template's context, fully      instantiated, and the TREE_VALUE is the TEMPLATE_DECL for the inner      template.       So, for the example above, `Outer<int>::Inner' is represented as a      substitution candidate by a TREE_LIST whose purpose is `Outer<int>'      and whose value is `Outer<T>::Inner<U>'.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|substitution
operator|=
name|build_tree_list
argument_list|(
name|context
argument_list|,
name|template
argument_list|)
expr_stmt|;
else|else
name|substitution
operator|=
name|template
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|substitution
argument_list|)
condition|)
return|return;
name|write_prefix
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|write_unqualified_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_substitution
argument_list|(
name|substitution
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We don't need to handle thunks, vtables, or VTTs here.  Those are    mangled through special entry points.<unqualified-name>  ::=<operator-name> 			::=<special-name>   			::=<source-name>  */
end_comment

begin_function
specifier|static
name|void
name|write_unqualified_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"unqualified-name"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_special_name_constructor
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|write_special_name_destructor
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Conversion operator. Handle it right here.<operator> ::= cv<type>  */
name|write_string
argument_list|(
literal|"cv"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|operator_name_info_t
modifier|*
name|oni
decl_stmt|;
if|if
condition|(
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|oni
operator|=
name|assignment_operator_name_info
expr_stmt|;
else|else
name|oni
operator|=
name|operator_name_info
expr_stmt|;
name|write_string
argument_list|(
name|oni
index|[
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
index|]
operator|.
name|mangled_name
argument_list|)
expr_stmt|;
block|}
else|else
name|write_source_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-termial<source-name>.  IDENTIFIER is an IDENTIFIER_NODE.<source-name> ::=</length/ number><identifier>  */
end_comment

begin_function
specifier|static
name|void
name|write_source_name
parameter_list|(
name|identifier
parameter_list|)
name|tree
name|identifier
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"source-name"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* Never write the whole template-id name including the template      arguments; we only want the template name.  */
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|identifier
argument_list|)
condition|)
name|identifier
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
name|write_unsigned_number
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
name|write_identifier
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert NUMBER to ascii using base BASE and generating at least    MIN_DIGITS characters. BUFFER points to the _end_ of the buffer    into which to store the characters. Returns the number of    characters generated (these will be layed out in advance of where    BUFFER points).  */
end_comment

begin_function
specifier|static
name|int
name|hwint_to_ascii
parameter_list|(
name|number
parameter_list|,
name|base
parameter_list|,
name|buffer
parameter_list|,
name|min_digits
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|number
decl_stmt|;
name|unsigned
name|int
name|base
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|min_digits
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|base_digits
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
name|unsigned
name|digits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|number
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|d
init|=
name|number
operator|/
name|base
decl_stmt|;
operator|*
operator|--
name|buffer
operator|=
name|base_digits
index|[
name|number
operator|-
name|d
operator|*
name|base
index|]
expr_stmt|;
name|digits
operator|++
expr_stmt|;
name|number
operator|=
name|d
expr_stmt|;
block|}
while|while
condition|(
name|digits
operator|<
name|min_digits
condition|)
block|{
operator|*
operator|--
name|buffer
operator|=
name|base_digits
index|[
literal|0
index|]
expr_stmt|;
name|digits
operator|++
expr_stmt|;
block|}
return|return
name|digits
return|;
block|}
end_function

begin_comment
comment|/* Non-terminal<number>.<number> ::= [n]</decimal integer/>  */
end_comment

begin_function
specifier|static
name|void
name|write_number
parameter_list|(
name|number
parameter_list|,
name|unsigned_p
parameter_list|,
name|base
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|number
decl_stmt|;
name|int
name|unsigned_p
decl_stmt|;
name|unsigned
name|int
name|base
decl_stmt|;
block|{
name|char
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|*
literal|8
index|]
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|unsigned_p
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|number
operator|<
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|number
operator|=
operator|-
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|number
operator|)
expr_stmt|;
block|}
name|count
operator|=
name|hwint_to_ascii
argument_list|(
name|number
argument_list|,
name|base
argument_list|,
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_chars
argument_list|(
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out an integral CST in decimal. Most numbers are small, and    representable in a HOST_WIDE_INT. Occasionally we'll have numbers    bigger than that, which we must deal with. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|write_integer_cst
parameter_list|(
name|cst
parameter_list|)
name|tree
name|cst
decl_stmt|;
block|{
name|int
name|sign
init|=
name|tree_int_cst_sgn
argument_list|(
name|cst
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|cst
argument_list|)
operator|+
operator|(
name|sign
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* A bignum. We do this in chunks, each of which fits in a 	 HOST_WIDE_INT. */
name|char
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|*
literal|8
operator|*
literal|2
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|chunk
decl_stmt|;
name|unsigned
name|chunk_digits
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|tree
name|n
decl_stmt|,
name|base
decl_stmt|,
name|type
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* HOST_WIDE_INT must be at least 32 bits, so 10^9 is 	 representable. */
name|chunk
operator|=
literal|1000000000
expr_stmt|;
name|chunk_digits
operator|=
literal|9
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|>=
literal|8
condition|)
block|{
comment|/* It is at least 64 bits, so 10^18 is representable. */
name|chunk_digits
operator|=
literal|18
expr_stmt|;
name|chunk
operator|*=
name|chunk
expr_stmt|;
block|}
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
literal|1
argument_list|,
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_int_2
argument_list|(
name|chunk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|n
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|tree
name|d
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
name|base
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmp
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|d
argument_list|,
name|base
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|c
decl_stmt|;
name|done
operator|=
name|integer_zerop
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|hwint_to_ascii
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|10
argument_list|,
name|ptr
argument_list|,
name|done
condition|?
literal|1
else|:
name|chunk_digits
argument_list|)
expr_stmt|;
name|ptr
operator|-=
name|c
expr_stmt|;
name|count
operator|+=
name|c
expr_stmt|;
name|n
operator|=
name|d
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|write_chars
argument_list|(
name|ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A small num.  */
name|unsigned
name|HOST_WIDE_INT
name|low
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
decl_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|low
operator|=
operator|-
name|low
expr_stmt|;
block|}
name|write_unsigned_number
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-terminal<identifier>.<identifier> ::=</unqualified source code identifier>  */
end_comment

begin_function
specifier|static
name|void
name|write_identifier
parameter_list|(
name|identifier
parameter_list|)
specifier|const
name|char
modifier|*
name|identifier
decl_stmt|;
block|{
name|MANGLE_TRACE
argument_list|(
literal|"identifier"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle constructor productions of non-terminal<special-name>.    CTOR is a constructor FUNCTION_DECL.<special-name> ::= C1   # complete object constructor                     ::= C2   # base object constructor                     ::= C3   # complete object allocating constructor     Currently, allocating constructors are never used.      We also need to provide mangled names for the maybe-in-charge    constructor, so we treat it here too.  mangle_decl_string will    append *INTERNAL* to that, to make sure we never emit it.  */
end_comment

begin_function
specifier|static
name|void
name|write_special_name_constructor
parameter_list|(
name|ctor
parameter_list|)
name|tree
name|ctor
decl_stmt|;
block|{
if|if
condition|(
name|DECL_COMPLETE_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
comment|/* Even though we don't ever emit a definition of the 	 old-style destructor, we still have to consider entities 	 (like static variables) nested inside it.  */
operator|||
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"C1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_BASE_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"C2"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle destructor productions of non-terminal<special-name>.    DTOR is a destructor FUNCTION_DECL.<special-name> ::= D0 # deleting (in-charge) destructor                     ::= D1 # complete object (in-charge) destructor                     ::= D2 # base object (not-in-charge) destructor     We also need to provide mangled names for the maybe-incharge    destructor, so we treat it here too.  mangle_decl_string will    append *INTERNAL* to that, to make sure we never emit it.  */
end_comment

begin_function
specifier|static
name|void
name|write_special_name_destructor
parameter_list|(
name|dtor
parameter_list|)
name|tree
name|dtor
decl_stmt|;
block|{
if|if
condition|(
name|DECL_DELETING_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"D0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_COMPLETE_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
comment|/* Even though we don't ever emit a definition of the 	      old-style destructor, we still have to consider entities 	      (like static variables) nested inside it.  */
operator|||
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"D1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_BASE_DESTRUCTOR_P
argument_list|(
name|dtor
argument_list|)
condition|)
name|write_string
argument_list|(
literal|"D2"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the discriminator for ENTITY appearing inside    FUNCTION.  The discriminator is the lexical ordinal of VAR among    entities with the same name in the same FUNCTION.  */
end_comment

begin_function
specifier|static
name|int
name|discriminator_for_local_entity
parameter_list|(
name|entity
parameter_list|)
name|tree
name|entity
decl_stmt|;
block|{
name|tree
modifier|*
name|type
decl_stmt|;
name|int
name|discriminator
decl_stmt|;
comment|/* Assume this is the only local entity with this name.  */
name|discriminator
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_DISCRIMINATOR_P
argument_list|(
name|entity
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|entity
argument_list|)
condition|)
name|discriminator
operator|=
name|DECL_DISCRIMINATOR
argument_list|(
name|entity
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|entity
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Scan the list of local classes.  */
name|entity
operator|=
name|TREE_TYPE
argument_list|(
name|entity
argument_list|)
expr_stmt|;
for|for
control|(
name|type
operator|=
operator|&
name|VARRAY_TREE
argument_list|(
name|local_classes
argument_list|,
literal|0
argument_list|)
init|;
operator|*
name|type
operator|!=
name|entity
condition|;
operator|++
name|type
control|)
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|entity
argument_list|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|TYPE_CONTEXT
argument_list|(
name|entity
argument_list|)
condition|)
operator|++
name|discriminator
expr_stmt|;
block|}
return|return
name|discriminator
return|;
block|}
end_function

begin_comment
comment|/* Return the discriminator for STRING, a string literal used inside    FUNCTION.  The disciminator is the lexical ordinal of STRING among    string literals used in FUNCTION.  */
end_comment

begin_function
specifier|static
name|int
name|discriminator_for_string_literal
parameter_list|(
name|function
parameter_list|,
name|string
parameter_list|)
name|tree
name|function
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|string
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* For now, we don't discriminate amongst string literals.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*<discriminator> := _<number>        The discriminator is used only for the second and later occurrences    of the same name within a single function. In this case<number> is    n - 2, if this is the nth occurrence, in lexical order.  */
end_comment

begin_function
specifier|static
name|void
name|write_discriminator
parameter_list|(
name|discriminator
parameter_list|)
name|int
name|discriminator
decl_stmt|;
block|{
comment|/* If discriminator is zero, don't write anything.  Otherwise... */
if|if
condition|(
name|discriminator
operator|>
literal|0
condition|)
block|{
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|write_unsigned_number
argument_list|(
name|discriminator
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mangle the name of a function-scope entity.  FUNCTION is the    FUNCTION_DECL for the enclosing function.  ENTITY is the decl for    the entity itself.  LOCAL_ENTITY is the entity that's directly    scoped in FUNCTION_DECL, either ENTITY itself or an enclosing scope    of ENTITY.<local-name> := Z<function encoding> E<entity name> [<discriminator>]                   := Z<function encoding> E s [<discriminator>]  */
end_comment

begin_function
specifier|static
name|void
name|write_local_name
parameter_list|(
name|function
parameter_list|,
name|local_entity
parameter_list|,
name|entity
parameter_list|)
name|tree
name|function
decl_stmt|;
name|tree
name|local_entity
decl_stmt|;
name|tree
name|entity
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"local-name"
argument_list|,
name|entity
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
name|write_encoding
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|entity
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|write_char
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|write_discriminator
argument_list|(
name|discriminator_for_string_literal
argument_list|(
name|function
argument_list|,
name|entity
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Now the<entity name>.  Let write_name know its being called 	 from<local-name>, so it doesn't try to process the enclosing 	 function scope again.  */
name|write_name
argument_list|(
name|entity
argument_list|,
comment|/*ignore_local_scope=*/
literal|1
argument_list|)
expr_stmt|;
name|write_discriminator
argument_list|(
name|discriminator_for_local_entity
argument_list|(
name|local_entity
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-terminals<type> and<CV-qualifier>.<type> ::=<builtin-type>             ::=<function-type>             ::=<class-enum-type>             ::=<array-type>             ::=<pointer-to-member-type>             ::=<template-param>             ::=<substitution>             ::=<CV-qualifier>             ::= P<type>    # pointer-to             ::= R<type>    # reference-to             ::= C<type>    # complex pair (C 2000)             ::= G<type>    # imaginary (C 2000)     [not supported]             ::= U<source-name><type>   # vendor extended type qualifier      TYPE is a type node.  */
end_comment

begin_function
specifier|static
name|void
name|write_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* This gets set to non-zero if TYPE turns out to be a (possibly      CV-qualified) builtin type.  */
name|int
name|is_builtin_type
init|=
literal|0
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|find_substitution
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|write_CV_qualifiers_for_type
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
comment|/* If TYPE was CV-qualified, we just wrote the qualifiers; now        mangle the unqualified type.  The recursive call is needed here        since both the qualified and uqualified types are substitution        candidates.  */
name|write_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* See through any typedefs.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
comment|/* Includes wchar_t.  */
case|case
name|REAL_TYPE
case|:
comment|/* If this is a typedef, TYPE may not be one of 	     the standard builtin type nodes, but an alias of one.  Use 	     TYPE_MAIN_VARIANT to get to the underlying builtin type.  */
name|write_builtin_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|is_builtin_type
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|write_char
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|write_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* A pointer-to-member function is represented as a special 	     RECORD_TYPE, so check for this first.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|write_pointer_to_member_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|write_class_enum_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
comment|/* We handle TYPENAME_TYPEs and UNBOUND_CLASS_TEMPLATEs like 	     ordinary nested names.  */
name|write_nested_name
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|write_array_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
comment|/* A pointer-to-member variable is represented by a POINTER_TYPE 	     to an OFFSET_TYPE, so check for this first.  */
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
name|write_pointer_to_member_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|write_char
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|write_char
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|write_template_param
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
name|write_template_template_param
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|write_template_template_param
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_template_args
argument_list|(
name|TI_ARGS
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|write_pointer_to_member_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
name|write_string
argument_list|(
literal|"U8__vector"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Types other than builtin types are substitution candidates.  */
if|if
condition|(
operator|!
name|is_builtin_type
condition|)
name|add_substitution
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<CV-qualifiers> for type nodes.  Returns the number of    CV-qualifiers written for TYPE.<CV-qualifiers> ::= [r] [V] [K]  */
end_comment

begin_function
specifier|static
name|int
name|write_CV_qualifiers_for_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|num_qualifiers
init|=
literal|0
decl_stmt|;
comment|/* The order is specified by:         "In cases where multiple order-insensitive qualifiers are        present, they should be ordered 'K' (closest to the base type),        'V', 'r', and 'U' (farthest from the base type) ..."  */
if|if
condition|(
name|CP_TYPE_RESTRICT_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|write_char
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
operator|++
name|num_qualifiers
expr_stmt|;
block|}
if|if
condition|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|write_char
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
operator|++
name|num_qualifiers
expr_stmt|;
block|}
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|write_char
argument_list|(
literal|'K'
argument_list|)
expr_stmt|;
operator|++
name|num_qualifiers
expr_stmt|;
block|}
return|return
name|num_qualifiers
return|;
block|}
end_function

begin_comment
comment|/* Non-terminal<builtin-type>.<builtin-type> ::= v   # void                      ::= b   # bool                     ::= w   # wchar_t                     ::= c   # char                     ::= a   # signed char                     ::= h   # unsigned char                     ::= s   # short                     ::= t   # unsigned short                     ::= i   # int                     ::= j   # unsigned int                     ::= l   # long                     ::= m   # unsigned long                     ::= x   # long long, __int64                     ::= y   # unsigned long long, __int64                       ::= n   # __int128            [not supported]                     ::= o   # unsigned __int128   [not supported]                      ::= f   # float                     ::= d   # double                     ::= e   # long double, __float80                      ::= g   # __float128          [not supported]                     ::= u<source-name>  # vendor extended type */
end_comment

begin_function
specifier|static
name|void
name|write_builtin_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
name|write_char
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
name|write_char
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
comment|/* If this is size_t, get the underlying int type.  */
if|if
condition|(
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* TYPE may still be wchar_t, since that isn't in 	 integer_type_nodes.  */
if|if
condition|(
name|type
operator|==
name|wchar_type_node
condition|)
name|write_char
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
name|write_java_integer_type_codes
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|itk
decl_stmt|;
comment|/* Assume TYPE is one of the shared integer type nodes.  Find 	     it in the array of these nodes.  */
name|iagain
label|:
for|for
control|(
name|itk
operator|=
literal|0
init|;
name|itk
operator|<
name|itk_none
condition|;
operator|++
name|itk
control|)
if|if
condition|(
name|type
operator|==
name|integer_types
index|[
name|itk
index|]
condition|)
block|{
comment|/* Print the corresponding single-letter code.  */
name|write_char
argument_list|(
name|integer_type_codes
index|[
name|itk
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|itk
operator|==
name|itk_none
condition|)
block|{
name|tree
name|t
init|=
name|type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|t
condition|)
comment|/* Couldn't find this type.  */
name|abort
argument_list|()
expr_stmt|;
name|type
operator|=
name|t
expr_stmt|;
goto|goto
name|iagain
goto|;
block|}
block|}
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|float_type_node
operator|||
name|type
operator|==
name|java_float_type_node
condition|)
name|write_char
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
operator|||
name|type
operator|==
name|java_double_type_node
condition|)
name|write_char
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|write_char
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-terminal<function-type>.  NODE is a FUNCTION_TYPE or    METHOD_TYPE.  The return type is mangled before the parameter    types.<function-type> ::= F [Y]<bare-function-type> E   */
end_comment

begin_function
specifier|static
name|void
name|write_function_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"function-type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
comment|/* We don't track whether or not a type is `extern "C"'.  Note that      you can have an `extern "C"' function that does not have      `extern "C"' type, and vice versa:         extern "C" typedef void function_t();        function_t f; // f has C++ linkage, but its type is                      // `extern "C"'         typedef void function_t();        extern "C" function_t f; // Vice versa.       See [dcl.link].  */
name|write_bare_function_type
argument_list|(
name|type
argument_list|,
comment|/*include_return_type_p=*/
literal|1
argument_list|,
comment|/*decl=*/
name|NULL
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<bare-function-type>.  TYPE is a FUNCTION_TYPE or    METHOD_TYPE.  If INCLUDE_RETURN_TYPE is non-zero, the return value    is mangled before the parameter types.  If non-NULL, DECL is    FUNCTION_DECL for the function whose type is being emitted.<bare-function-type> ::=</signature/ type>+  */
end_comment

begin_function
specifier|static
name|void
name|write_bare_function_type
parameter_list|(
name|type
parameter_list|,
name|include_return_type_p
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|include_return_type_p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"bare-function-type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Mangle the return type, if requested.  */
if|if
condition|(
name|include_return_type_p
condition|)
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now mangle the types of the arguments.  */
name|write_method_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the mangled representation of a method parameter list of    types given in PARM_TYPES.  If METHOD_P is non-zero, the function is     considered a non-static method, and the this parameter is omitted.    If non-NULL, DECL is the FUNCTION_DECL for the function whose    parameters are being emitted.  */
end_comment

begin_function
specifier|static
name|void
name|write_method_parms
parameter_list|(
name|parm_types
parameter_list|,
name|method_p
parameter_list|,
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|parm_types
decl_stmt|;
name|int
name|method_p
decl_stmt|;
block|{
name|tree
name|first_parm_type
decl_stmt|;
name|tree
name|parm_decl
init|=
name|decl
condition|?
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
comment|/* Assume this parameter type list is variable-length.  If it ends      with a void type, then it's not.  */
name|int
name|varargs_p
init|=
literal|1
decl_stmt|;
comment|/* If this is a member function, skip the first arg, which is the      this pointer.          "Member functions do not encode the type of their implicit this        parameter."           Similarly, there's no need to mangle artificial parameters, like      the VTT parameters for constructors and destructors.  */
if|if
condition|(
name|method_p
condition|)
block|{
name|parm_types
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
expr_stmt|;
name|parm_decl
operator|=
name|parm_decl
condition|?
name|TREE_CHAIN
argument_list|(
name|parm_decl
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|parm_decl
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|parm_decl
argument_list|)
condition|)
block|{
name|parm_types
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
expr_stmt|;
name|parm_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_decl
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|first_parm_type
operator|=
name|parm_types
init|;
name|parm_types
condition|;
name|parm_types
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|parm_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|parm
operator|==
name|void_type_node
condition|)
block|{
comment|/* "Empty parameter lists, whether declared as () or 	     conventionally as (void), are encoded with a void parameter 	     (v)."  */
if|if
condition|(
name|parm_types
operator|==
name|first_parm_type
condition|)
name|write_type
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* If the parm list is terminated with a void type, it's 	     fixed-length.  */
name|varargs_p
operator|=
literal|0
expr_stmt|;
comment|/* A void type better be the last one.  */
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parm_types
argument_list|)
operator|==
name|NULL
argument_list|,
literal|20000523
argument_list|)
expr_stmt|;
block|}
else|else
name|write_type
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|varargs_p
condition|)
comment|/*<builtin-type> ::= z  # ellipsis  */
name|write_char
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<class-enum-type> ::=<name>  */
end_comment

begin_function
specifier|static
name|void
name|write_class_enum_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|write_name
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<template-args>.  ARGS is a TREE_VEC of template    arguments.<template-args> ::= I<template-arg>+ E  */
end_comment

begin_function
specifier|static
name|void
name|write_template_args
parameter_list|(
name|args
parameter_list|)
name|tree
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-args"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|length
operator|>
literal|0
argument_list|,
literal|20000422
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
comment|/* We have nested template args.  We want the innermost template 	 argument list.  */
name|args
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|write_template_arg
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<expression> ::=<unary operator-name><expression> 		::=<binary operator-name><expression><expression> 		::=<expr-primary><expr-primary> ::=<template-param> 		  ::= L<type><value number> E  # literal 		  ::= L<mangled-name> E         # external name  */
end_comment

begin_function
specifier|static
name|void
name|write_expression
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Handle pointers-to-members by making them look like expression      nodes.  */
if|if
condition|(
name|code
operator|==
name|PTRMEM_CST
condition|)
block|{
name|expr
operator|=
name|build_nt
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|PTRMEM_CST_CLASS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Handle template parameters. */
if|if
condition|(
name|code
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|code
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|code
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
name|write_template_param
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Handle literals.  */
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
name|write_template_arg_literal
argument_list|(
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|write_char
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|write_mangled_name
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Skip NOP_EXPRs.  They can occur when (say) a pointer argument 	 is converted (via qualification conversions) to another 	 type.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* When we bind a variable or function to a non-type template 	 argument with reference type, we create an ADDR_EXPR to show 	 the fact that the entity's address has been taken.  But, we 	 don't actually want to output a mangling code for the `&'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|write_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* If it wasn't any of those, recursively expand the expression.  */
name|write_string
argument_list|(
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|mangled_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CAST_EXPR
case|:
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|write_expression
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|write_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle pointers-to-members specially.  */
case|case
name|SCOPE_REF
case|:
name|write_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|write_source_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|write_encoding
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
operator|++
name|i
control|)
name|write_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Literal subcase of non-terminal<template-arg>.         "Literal arguments, e.g. "A<42L>", are encoded with their type      and value. Negative integer values are preceded with "n"; for      example, "A<-42L>" becomes "1AILln42EE". The bool value false is      encoded as 0, true as 1. If floating-point arguments are accepted      as an extension, their values should be encoded using a      fixed-length lowercase hexadecimal string corresponding to the      internal representation (IEEE on IA-64), high-order bytes first,      without leading zeroes. For example: "Lfbff000000E" is -1.0f."  */
end_comment

begin_function
specifier|static
name|void
name|write_template_arg_literal
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|write_char
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|write_integer_cst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|boolean_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|boolean_false_node
operator|||
name|integer_zerop
argument_list|(
name|value
argument_list|)
condition|)
name|write_unsigned_number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|boolean_true_node
condition|)
name|write_unsigned_number
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|write_integer_cst
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
ifdef|#
directive|ifdef
name|CROSS_COMPILE
specifier|static
name|int
name|explained
decl_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|sorry
argument_list|(
literal|"real-valued template parameters when cross-compiling"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
name|write_number
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
operator|)
index|[
name|i
index|]
argument_list|,
comment|/*unsigned_p=*/
literal|1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<tempalate-arg>.<template-arg> ::=<type>                        # type                     ::= L<type></value/ number> E   # literal                     ::= LZ<name> E                   # external name                     ::= X<expression> E              # expression  */
end_comment

begin_function
specifier|static
name|void
name|write_template_arg
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-arg"
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* A template template paramter's argument list contains TREE_LIST      nodes of which the value field is the the actual argument.  */
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
block|{
name|node
operator|=
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* If it's a decl, deal with its type instead.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|node
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
name|write_type
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* A template appearing as a template arg is a template template arg.  */
name|write_template_template_arg
argument_list|(
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|write_char
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
name|write_encoding
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|code
operator|!=
name|PTRMEM_CST
condition|)
name|write_template_arg_literal
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Template arguments may be expressions.  */
name|write_char
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|write_expression
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*<template-template-arg> 			::=<name> 			::=<substitution>  */
end_comment

begin_function
name|void
name|write_template_template_arg
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-template-arg"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|write_name
argument_list|(
name|decl
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
name|add_substitution
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<array-type>.  TYPE is an ARRAY_TYPE.<array-type> ::= A [</dimension/ number>] _</element/ type>                     ::= A<expression> _</element/ type>       "Array types encode the dimension (number of elements) and the      element type. For variable length arrays, the dimension (but not      the '_' separator) is omitted."  */
end_comment

begin_function
specifier|static
name|void
name|write_array_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|write_char
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|index_type
decl_stmt|;
name|tree
name|max
decl_stmt|;
name|index_type
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The INDEX_TYPE gives the upper and lower bounds of the 	 array.  */
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* The ABI specifies that we should mangle the number of 	     elements in the array, not the largest allowed index.  */
name|max
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|max
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
name|write_unsigned_number
argument_list|(
name|tree_low_cst
argument_list|(
name|max
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|write_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|max
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<pointer-to-member-type> for pointer-to-member    variables.  TYPE is a pointer-to-member POINTER_TYPE.<pointer-to-member-type> ::= M</class/ type></member/ type>  */
end_comment

begin_function
specifier|static
name|void
name|write_pointer_to_member_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|write_char
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
comment|/* For a pointer-to-function member, the class type may be      cv-qualified, but that won't be reflected in      TYPE_PTRMEM_CLASS_TYPE.  So, we go fishing around in      TYPE_PTRMEM_POINTED_TO_TYPE instead.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|fn_type
decl_stmt|;
name|tree
name|this_type
decl_stmt|;
name|fn_type
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The first parameter must be a POINTER_TYPE pointing to the 	 `this' parameter.  */
name|this_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fn_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|this_type
argument_list|)
expr_stmt|;
block|}
comment|/* For a pointer-to-data member, things are simpler.  */
else|else
name|write_type
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<template-param>.  PARM is a TEMPLATE_TYPE_PARM,    TEMPLATE_TEMPLATE_PARM, BOUND_TEMPLATE_TEMPLATE_PARM or a    TEMPLATE_PARM_INDEX.<template-param> ::= T</parameter/ number> _  */
end_comment

begin_function
specifier|static
name|void
name|write_template_param
parameter_list|(
name|parm
parameter_list|)
name|tree
name|parm
decl_stmt|;
block|{
name|int
name|parm_index
decl_stmt|;
name|MANGLE_TRACE_TREE
argument_list|(
literal|"template-parm"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|parm_index
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|parm_index
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|write_char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
comment|/* NUMBER as it appears in the mangling is (-1)-indexed, with the      earliest template param denoted by `_'.  */
if|if
condition|(
name|parm_index
operator|>
literal|0
condition|)
name|write_unsigned_number
argument_list|(
name|parm_index
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<template-template-param>                         ::=<template-param>  			::=<substitution>  */
end_comment

begin_function
specifier|static
name|void
name|write_template_template_param
parameter_list|(
name|parm
parameter_list|)
name|tree
name|parm
decl_stmt|;
block|{
name|tree
name|template
init|=
name|NULL_TREE
decl_stmt|;
comment|/* PARM, a TEMPLATE_TEMPLATE_PARM, is an instantiation of the      template template parameter.  The substitution candidate here is      only the template.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|template
operator|=
name|TI_TEMPLATE
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_substitution
argument_list|(
name|template
argument_list|)
condition|)
return|return;
block|}
comment|/*<template-param> encodes only the template parameter position,      not its template arguments, which is fine here.  */
name|write_template_param
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|template
condition|)
name|add_substitution
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-terminal<substitution>.<substitution> ::= S<seq-id> _                      ::= S_  */
end_comment

begin_function
specifier|static
name|void
name|write_substitution
parameter_list|(
name|seq_id
parameter_list|)
name|int
name|seq_id
decl_stmt|;
block|{
name|MANGLE_TRACE
argument_list|(
literal|"substitution"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_id
operator|>
literal|0
condition|)
name|write_number
argument_list|(
name|seq_id
operator|-
literal|1
argument_list|,
comment|/*unsigned=*/
literal|1
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start mangling a new name or type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|start_mangling
parameter_list|()
block|{
name|obstack_free
argument_list|(
operator|&
name|G
operator|.
name|name_obstack
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|G
operator|.
name|name_obstack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Done with mangling.  Return the generated mangled name.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|finish_mangling
parameter_list|()
block|{
comment|/* Clear all the substitutions.  */
name|VARRAY_POP_ALL
argument_list|(
name|G
operator|.
name|substitutions
argument_list|)
expr_stmt|;
comment|/* Null-terminate the string.  */
name|write_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|G
operator|.
name|name_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize data structures for mangling.  */
end_comment

begin_function
name|void
name|init_mangle
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|G
operator|.
name|name_obstack
argument_list|)
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|G
operator|.
name|substitutions
argument_list|,
literal|1
argument_list|,
literal|"mangling substitutions"
argument_list|)
expr_stmt|;
comment|/* Cache these identifiers for quick comparison when checking for      standard substitutions.  */
name|subst_identifiers
index|[
name|SUBID_ALLOCATOR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"allocator"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_STRING
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_string"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_CHAR_TRAITS
index|]
operator|=
name|get_identifier
argument_list|(
literal|"char_traits"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_ISTREAM
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_istream"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_OSTREAM
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_ostream"
argument_list|)
expr_stmt|;
name|subst_identifiers
index|[
name|SUBID_BASIC_IOSTREAM
index|]
operator|=
name|get_identifier
argument_list|(
literal|"basic_iostream"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the mangled name of DECL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mangle_decl_string
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|write_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
comment|/* The names of `extern "C"' functions are not mangled.  */
operator|(
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|decl
argument_list|)
comment|/* But overloaded operator names *are* mangled.  */
operator|&&
operator|!
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* The names of global variables aren't mangled either.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|global_namespace
operator|)
comment|/* And neither are `extern "C"' variables.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|write_string
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|write_mangled_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* We need a distinct mangled name for these entities, but 	   we should never actually output it.  So, we append some 	   characters the assembler won't like.  */
name|write_string
argument_list|(
literal|" *INTERNAL* "
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|finish_mangling
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_decl_string = '%s'\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the external mangled name of DECL.  */
end_comment

begin_function
name|void
name|mangle_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|mangle_decl_string
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the mangled representation of TYPE.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mangle_type_string
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|()
expr_stmt|;
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_type_string = '%s'\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled representation of TYPE.  */
end_comment

begin_function
name|tree
name|mangle_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|get_identifier
argument_list|(
name|mangle_type_string
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled name of a special component    for belonging to TYPE.  CODE is the ABI-specified code for this    component.  */
end_comment

begin_function
specifier|static
name|tree
name|mangle_special_for_type
parameter_list|(
name|type
parameter_list|,
name|code
parameter_list|)
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|code
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
comment|/* We don't have an actual decl here for the special component, so      we can't just process the<encoded-name>.  Instead, fake it.  */
name|start_mangling
argument_list|()
expr_stmt|;
comment|/* Start the mangling.  */
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Add the type.  */
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_special_for_type = %s\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled representation of the typeinfo    structure for TYPE.  */
end_comment

begin_function
name|tree
name|mangle_typeinfo_for_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TI"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled name of the NTBS containing    the mangled name of TYPE.  */
end_comment

begin_function
name|tree
name|mangle_typeinfo_string_for_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TS"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an identifier for the mangled name of the vtable for TYPE.  */
end_comment

begin_function
name|tree
name|mangle_vtbl_for_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TV"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns an identifier for the mangled name of the VTT for TYPE.  */
end_comment

begin_function
name|tree
name|mangle_vtt_for_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|mangle_special_for_type
argument_list|(
name|type
argument_list|,
literal|"TT"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for a construction vtable group.  TYPE is    the most derived class in the hierarchy; BINFO is the base    subobject for which this construction vtable group will be used.       This mangling isn't part of the ABI specification; in the ABI    specification, the vtable group is dumped in the same COMDAT as the    main vtable, and is referenced only from that vtable, so it doesn't    need an external name.  For binary formats without COMDAT sections,    though, we need external names for the vtable groups.       We use the production<special-name> ::= CT<type><offset number> _<base type>  */
end_comment

begin_function
name|tree
name|mangle_ctor_vtbl_for_type
parameter_list|(
name|type
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|()
expr_stmt|;
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"TC"
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_integer_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|write_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_ctor_vtbl_for_type = %s\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for the mangled name of a thunk to FN_DECL.    OFFSET is the initial adjustment to this used to find the vptr.  If    VCALL_OFFSET is non-NULL, this is a virtual thunk, and it is the    vtbl offset in bytes.<special-name> ::= Th<offset number> _<base encoding>                    ::= Tv<offset number> _<vcall offset number> _<base encoding> */
end_comment

begin_function
name|tree
name|mangle_thunk
parameter_list|(
name|fn_decl
parameter_list|,
name|offset
parameter_list|,
name|vcall_offset
parameter_list|)
name|tree
name|fn_decl
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|vcall_offset
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|start_mangling
argument_list|()
expr_stmt|;
name|write_string
argument_list|(
literal|"_Z"
argument_list|)
expr_stmt|;
comment|/* The<special-name> for virtual thunks is Tv, for non-virtual      thunks Th.  */
name|write_char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcall_offset
operator|!=
literal|0
condition|)
name|write_char
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
else|else
name|write_char
argument_list|(
literal|'h'
argument_list|)
expr_stmt|;
comment|/* For either flavor, write the offset to this.  */
name|write_integer_cst
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
comment|/* For a virtual thunk, add the vcall offset.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
comment|/* Virtual thunk.  Write the vcall offset and base type name.  */
name|write_integer_cst
argument_list|(
name|vcall_offset
argument_list|)
expr_stmt|;
name|write_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
comment|/* Scoped name.  */
name|write_encoding
argument_list|(
name|fn_decl
argument_list|)
expr_stmt|;
name|result
operator|=
name|finish_mangling
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG_MANGLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mangle_thunk = %s\n\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for the mangled unqualified name for a    conversion operator to TYPE.  This mangling is not specified by the    ABI spec; it is only used internally.  */
end_comment

begin_function
name|tree
name|mangle_conv_op_name_for_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|identifier
decl_stmt|;
comment|/* Build the mangling for TYPE.  */
specifier|const
name|char
modifier|*
name|mangled_type
init|=
name|mangle_type_string
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Allocate a temporary buffer for the complete name.  */
name|char
modifier|*
name|op_name
init|=
name|concat
argument_list|(
literal|"operator "
argument_list|,
name|mangled_type
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* Find or create an identifier.  */
name|identifier
operator|=
name|get_identifier
argument_list|(
name|op_name
argument_list|)
expr_stmt|;
comment|/* Done with the temporary buffer.  */
name|free
argument_list|(
name|op_name
argument_list|)
expr_stmt|;
comment|/* Set bits on the identifier so we know later it's a conversion.  */
name|IDENTIFIER_OPNAME_P
argument_list|(
name|identifier
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|identifier
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Hang TYPE off the identifier so it can be found easily later when      performing conversions.  */
name|TREE_TYPE
argument_list|(
name|identifier
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|identifier
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for the name of an initialization guard    variable for indicated VARIABLE.  */
end_comment

begin_function
name|tree
name|mangle_guard_variable
parameter_list|(
name|variable
parameter_list|)
name|tree
name|variable
decl_stmt|;
block|{
name|start_mangling
argument_list|()
expr_stmt|;
name|write_string
argument_list|(
literal|"_ZGV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|,
literal|"_ZGR"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* The name of a guard variable for a reference temporary should refer        to the reference, not the temporary.  */
name|write_string
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|variable
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
name|write_name
argument_list|(
name|variable
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|finish_mangling
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an identifier for the name of a temporary variable used to    initialize a static reference.  This isn't part of the ABI, but we might    as well call them something readable.  */
end_comment

begin_function
name|tree
name|mangle_ref_init_variable
parameter_list|(
name|variable
parameter_list|)
name|tree
name|variable
decl_stmt|;
block|{
name|start_mangling
argument_list|()
expr_stmt|;
name|write_string
argument_list|(
literal|"_ZGR"
argument_list|)
expr_stmt|;
name|write_name
argument_list|(
name|variable
argument_list|,
comment|/*ignore_local_scope=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|finish_mangling
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Foreign language type mangling section.  */
end_comment

begin_comment
comment|/* How to write the type codes for the integer Java type.  */
end_comment

begin_function
specifier|static
name|void
name|write_java_integer_type_codes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|java_int_type_node
condition|)
name|write_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_short_type_node
condition|)
name|write_char
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_byte_type_node
condition|)
name|write_char
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_char_type_node
condition|)
name|write_char
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_long_type_node
condition|)
name|write_char
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|java_boolean_type_node
condition|)
name|write_char
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

