begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002  Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"../hash.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|attribute_spec
modifier|*
name|lang_attribute_table
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BOOL_TYPE_SIZE
end_ifndef

begin_comment
comment|/* `bool' has size and alignment `1', on all platforms.  */
end_comment

begin_define
define|#
directive|define
name|BOOL_TYPE_SIZE
value|CHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|grokparms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|redeclaration_error_message
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_binding_level
name|PARAMS
argument_list|(
operator|(
expr|struct
name|binding_level
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_binding_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|suspend_binding_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resume_binding_level
name|PARAMS
argument_list|(
operator|(
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|declare_namespace_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decl_jump_unsafe
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|storedecls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|require_complete_types_for_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ambi_op_p
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unary_op_p
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|store_bindings
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_tag_reverse
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|obscure_complex_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_name_real
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_local_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_extern_redeclared_static
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|grok_reference_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|grokfndecl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
expr|enum
name|overload_flags
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|grokvardecl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|RID_BIT_TYPE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_tag
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_identifier_type_value_with_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_unknown_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_library_fn_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|member_function_or_else
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|enum
name|overload_flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bad_specifiers
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_process_template_type_declaration
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_for_uninitialized_const_var
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|typename_hash
name|PARAMS
argument_list|(
operator|(
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|typename_compare
name|PARAMS
argument_list|(
operator|(
name|hash_table_key
operator|,
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_binding
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_binding
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_binding
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|local_variable_p_walkfn
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|find_binding
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|select_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_flags
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|qualify_lookup
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|record_builtin_java_type
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tag_name
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tag_types
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_class_binding_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|innermost_nonclass_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_about_implicit_typename_lookup
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|walk_namespaces_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|walk_namespaces_fn
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|walk_globals_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_decl_to_level
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|make_label_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|use_label
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_previous_goto_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_previous_goto
name|PARAMS
argument_list|(
operator|(
expr|struct
name|named_label_use_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_switch_goto
name|PARAMS
argument_list|(
operator|(
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_previous_gotos
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_label
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_labels
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_deduce_size_from_array_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|layout_var_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_commonize_var
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|check_initializer
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_rtl_for_nonlocal_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_cp_function_context
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_cp_function_context
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_binding_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_named_label_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_cp_function_context
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_saved_scope
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_lang_function
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cp_language_function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_function_data
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_function_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|destroy_local_var
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|begin_constructor_body
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_constructor_body
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|begin_destructor_body
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_destructor_body
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|create_array_type_for_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_atexit_node
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_dso_handle_node
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|start_cleanup_fn
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_cleanup_fn
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|cp_make_fname_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_predefined_identifiers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|check_special_function_return_type
name|PARAMS
argument_list|(
operator|(
name|special_function_kind
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|push_cp_library_fn
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_cp_library_fn
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_parm_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_missing_noreturn_ok_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|indent
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Erroneous argument lists can use this *IFF* they do not modify it.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following symbols are subsumed in the cp_global_trees array, and    listed here individually for documentation purposes.     C++ extensions 	tree wchar_decl_node;  	tree vtable_entry_type; 	tree delta_type_node; 	tree __t_desc_type_node;         tree ti_desc_type_node; 	tree bltn_desc_type_node, ptr_desc_type_node; 	tree ary_desc_type_node, func_desc_type_node, enum_desc_type_node; 	tree class_desc_type_node, si_class_desc_type_node, vmi_class_desc_type_node; 	tree ptm_desc_type_node; 	tree base_desc_type_node;  	tree class_type_node, record_type_node, union_type_node, enum_type_node; 	tree unknown_type_node;     Array type `vtable_entry_type[]'  	tree vtbl_type_node; 	tree vtbl_ptr_type_node;     Namespaces,  	tree std_node; 	tree abi_node;     A FUNCTION_DECL which can call `abort'.  Not necessarily the    one that the user will declare, but sufficient to be called    by routines that want to abort the program.  	tree abort_fndecl;     The FUNCTION_DECL for the default `::operator delete'.  	tree global_delete_fndecl;     Used by RTTI 	tree type_info_type_node, tinfo_decl_id, tinfo_decl_type; 	tree tinfo_var_id;  */
end_comment

begin_decl_stmt
name|tree
name|cp_global_trees
index|[
name|CPTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates that there is a type value in some namespace, although    that is not necessarily in scope at the moment.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|global_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expect only namespace names now. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|only_namespace_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used only for jumps to as-yet undefined labels, since jumps to    defined labels can have their validity checked immediately.  */
end_comment

begin_struct
struct|struct
name|named_label_use_list
block|{
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|names_in_scope
decl_stmt|;
name|tree
name|label_decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename_o_goto
decl_stmt|;
name|int
name|lineno_o_goto
decl_stmt|;
name|struct
name|named_label_use_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|named_label_uses
value|cp_function_chain->x_named_label_uses
end_define

begin_define
define|#
directive|define
name|local_names
value|cp_function_chain->x_local_names
end_define

begin_comment
comment|/* A list of objects which have constructors or destructors    which reside in the global scope.  The decl is stored in    the TREE_VALUE slot and the initializer is stored    in the TREE_PURPOSE slot.  */
end_comment

begin_decl_stmt
name|tree
name|static_aggregates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- end of C++ */
end_comment

begin_comment
comment|/* A node for the integer constants 2, and 3.  */
end_comment

begin_decl_stmt
name|tree
name|integer_two_node
decl_stmt|,
name|integer_three_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of all LABEL_DECLs in the function that have names.  Here so    we can clear out their names' definitions at the end of the    function, and so we can check the validity of jumps to these labels.  */
end_comment

begin_struct
struct|struct
name|named_label_list
block|{
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|names_in_scope
decl_stmt|;
name|tree
name|old_value
decl_stmt|;
name|tree
name|label_decl
decl_stmt|;
name|tree
name|bad_decls
decl_stmt|;
name|struct
name|named_label_list
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|in_try_scope
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|in_catch_scope
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|named_labels
value|cp_function_chain->x_named_labels
end_define

begin_comment
comment|/* Nonzero means use the ISO C94 dialect of C.  */
end_comment

begin_decl_stmt
name|int
name|flag_isoc94
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use the ISO C99 dialect of C.  */
end_comment

begin_decl_stmt
name|int
name|flag_isoc99
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we are a hosted implementation for code shared with C.  */
end_comment

begin_decl_stmt
name|int
name|flag_hosted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means add default format_arg attributes for functions not    in ISO C.  */
end_comment

begin_decl_stmt
name|int
name|flag_noniso_default_format_attributes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to conserve space in the .o files.  We do this    by putting uninitialized data and runtime initialized data into    .common instead of .data at the expense of not flagging multiple    definitions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_conserve_space
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* C and C++ flags are in decl2.c.  */
end_comment

begin_comment
comment|/* A expression of value 0 with the same precision as a sizetype    node, but signed.  */
end_comment

begin_decl_stmt
name|tree
name|signed_size_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the anonymous namespace, throughout this translation    unit.  */
end_comment

begin_decl_stmt
name|tree
name|anonymous_namespace_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of function bodies which we are currently processing.    (Zero if we are at namespace scope, one inside the body of a    function, two inside the body of a function in a local class, etc.)  */
end_comment

begin_decl_stmt
name|int
name|function_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* States indicating how grokdeclarator() should handle declspecs marked    with __attribute__((deprecated)).  An object declared as    __attribute__((deprecated)) suppresses warnings of uses of other    deprecated items.  */
end_comment

begin_enum
enum|enum
name|deprecated_states
block|{
name|DEPRECATED_NORMAL
block|,
name|DEPRECATED_SUPPRESS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|deprecated_states
name|deprecated_state
init|=
name|DEPRECATED_NORMAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by add_implicitly_declared_members() to keep those members from    being flagged as deprecated or reported as using deprecated    types.  */
end_comment

begin_decl_stmt
name|int
name|adding_implicit_members
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure    which records the names defined in that contour.    Contours include:     0) the global one     1) one for each function definition,        where internal declarations of the parameters appear.     2) one for each compound statement,        to record its declarations.     The current meaning of a name can be found by searching the levels    from the current one out to the global one.     Off to the side, may be the class_binding_level.  This exists only    to catch class-local declarations.  It is otherwise nonexistent.     Also there may be binding levels that catch cleanups that must be    run when exceptions occur.  Thus, to see whether a name is bound in    the current scope, it is not enough to look in the    CURRENT_BINDING_LEVEL.  You should use lookup_name_current_level    instead.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,        and typedef types.  These are in the reverse of the order        supplied.  There may be OVERLOADs on this list, too, but they        are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions, for looking up        tag names.        It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,        or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,        or ENUMERAL_TYPE node.         C++: the TREE_VALUE nodes can be simple types for        component_bindings.  */
name|tree
name|tags
decl_stmt|;
comment|/* A list of USING_DECL nodes. */
name|tree
name|usings
decl_stmt|;
comment|/* A list of used namespaces. PURPOSE is the namespace,        VALUE the common ancestor with this binding_level's namespace. */
name|tree
name|using_directives
decl_stmt|;
comment|/* If this binding level is the binding level for a class, then        class_shadowed is a TREE_LIST.  The TREE_PURPOSE of each node        is the name of an entity bound in the class.  The TREE_TYPE is        the DECL bound by this name in the class.  */
name|tree
name|class_shadowed
decl_stmt|;
comment|/* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and        is used for all binding levels. In addition the TREE_VALUE is the        IDENTIFIER_TYPE_VALUE before we entered the class.  */
name|tree
name|type_shadowed
decl_stmt|;
comment|/* A TREE_LIST.  Each TREE_VALUE is the LABEL_DECL for a local        label in this scope.  The TREE_PURPOSE is the previous value of        the IDENTIFIER_LABEL VALUE.  */
name|tree
name|shadowed_labels
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of BLOCK nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The _TYPE node for this level, if parm_flag == 2.  */
name|tree
name|this_class
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* List of decls in `names' that have incomplete        structure or union types.  */
name|tree
name|incomplete
decl_stmt|;
comment|/* List of VAR_DECLS saved from a previous for statement.        These would be dead in ISO-conforming code, but might        be referenced in ARM-era code.  These are stored in a        TREE_LIST; the TREE_VALUE is the actual declaration.  */
name|tree
name|dead_vars_from_for
decl_stmt|;
comment|/* 1 for the level that holds the parameters of a function.        2 for the level that holds a class declaration.  */
name|unsigned
name|parm_flag
range|:
literal|2
decl_stmt|;
comment|/* 1 means make a BLOCK for this level regardless of all else.        2 for temporary binding contours created by the compiler.  */
name|unsigned
name|keep
range|:
literal|2
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|unsigned
name|tag_transparent
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level can safely have additional        cleanup-needing variables added to it.  */
name|unsigned
name|more_cleanups_ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|have_cleanups
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this scope is for storing the decls for template        parameters and generic decls; these decls will be discarded and        replaced with a TEMPLATE_DECL.  */
name|unsigned
name|template_parms_p
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this scope corresponds to the `<>' in a        `template<>' clause.  Whenever this flag is set,        TEMPLATE_PARMS_P will be set as well.  */
name|unsigned
name|template_spec_p
range|:
literal|1
decl_stmt|;
comment|/* This is set for a namespace binding level.  */
name|unsigned
name|namespace_p
range|:
literal|1
decl_stmt|;
comment|/* True if this level is that of a for-statement where we need to        worry about ambiguous (ARM or ISO) scope rules.  */
name|unsigned
name|is_for_scope
range|:
literal|1
decl_stmt|;
comment|/* True if this level corresponds to a TRY block.  Currently this        information is only available while building the tree structure.  */
name|unsigned
name|is_try_scope
range|:
literal|1
decl_stmt|;
comment|/* True if this level corresponds to a CATCH block.  Currently this        information is only available while building the tree structure.  */
name|unsigned
name|is_catch_scope
range|:
literal|1
decl_stmt|;
comment|/* Three bits left for this word.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
comment|/* Binding depth at which this level began.  */
name|unsigned
name|binding_depth
decl_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|((struct binding_level *) NULL)
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_define
define|#
directive|define
name|current_binding_level
define|\
value|(cfun&& cp_function_chain->bindings		\    ? cp_function_chain->bindings		\    : scope_chain->bindings)
end_define

begin_comment
comment|/* The binding level of the current class, if any.  */
end_comment

begin_define
define|#
directive|define
name|class_binding_level
value|scope_chain->class_bindings
end_define

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|binding_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_class_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|indent
parameter_list|()
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|binding_depth
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pushdecl_with_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_binding_level
parameter_list|(
name|newlevel
parameter_list|,
name|tag_transparent
parameter_list|,
name|keep
parameter_list|)
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
name|int
name|tag_transparent
decl_stmt|,
name|keep
decl_stmt|;
block|{
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newlevel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
expr_stmt|;
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|tag_transparent
operator|=
name|tag_transparent
expr_stmt|;
name|newlevel
operator|->
name|more_cleanups_ok
operator|=
literal|1
expr_stmt|;
name|newlevel
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|newlevel
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"push %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|newlevel
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
end_function

begin_comment
comment|/* Find the innermost enclosing class scope, and reset    CLASS_BINDING_LEVEL appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|find_class_binding_level
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|level
operator|&&
name|level
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|level
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|level
operator|&&
name|level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|class_binding_level
operator|=
name|level
expr_stmt|;
else|else
name|class_binding_level
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_binding_level
parameter_list|()
block|{
if|if
condition|(
name|global_binding_level
condition|)
block|{
comment|/* Cannot pop a level, if there are none left to pop.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|binding_depth
operator|--
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pop  %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|current_binding_level
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_class_level
operator|!=
operator|(
name|current_binding_level
operator|==
name|class_binding_level
operator|)
condition|)
block|{
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX is_class_level != (current_binding_level == class_binding_level)\n"
argument_list|)
expr_stmt|;
block|}
name|is_class_level
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
if|#
directive|if
literal|0
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|if (level->binding_depth != binding_depth)       abort ();
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|free_binding_level
operator|=
name|level
expr_stmt|;
name|find_class_binding_level
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|suspend_binding_level
parameter_list|()
block|{
if|if
condition|(
name|class_binding_level
condition|)
name|current_binding_level
operator|=
name|class_binding_level
expr_stmt|;
if|if
condition|(
name|global_binding_level
condition|)
block|{
comment|/* Cannot suspend a level, if there are none left to suspend.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Suspend the current level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|binding_depth
operator|--
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"suspend  %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|current_binding_level
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_class_level
operator|!=
operator|(
name|current_binding_level
operator|==
name|class_binding_level
operator|)
condition|)
block|{
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX is_class_level != (current_binding_level == class_binding_level)\n"
argument_list|)
expr_stmt|;
block|}
name|is_class_level
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|find_class_binding_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_binding_level
parameter_list|(
name|b
parameter_list|)
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
comment|/* Resuming binding levels is meant only for namespaces,      and those cannot nest into classes. */
name|my_friendly_assert
argument_list|(
operator|!
name|class_binding_level
argument_list|,
literal|386
argument_list|)
expr_stmt|;
comment|/* Also, resuming a non-directly nested namespace is a no-no.  */
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|level_chain
operator|==
name|current_binding_level
argument_list|,
literal|386
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|b
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"resume %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|b
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new `struct binding_level'.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|()
block|{
comment|/* NOSTRICT */
return|return
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost binding level that is not for a class scope.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|innermost_nonclass_level
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in a toplevel binding level.  This    means either the global binding level or a namespace in a toplevel    binding level.  Since there are no non-toplevel namespace levels,    this really means any namespace or template parameter level.  We    also include a class whose context is toplevel.  */
end_comment

begin_function
name|int
name|toplevel_bindings_p
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|namespace_p
operator|||
name|b
operator|->
name|template_parms_p
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if this is a namespace scope, or if we are defining a class    which is itself at namespace scope, or whose enclosing class is    such a class, etc.  */
end_comment

begin_function
name|int
name|namespace_bindings_p
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|namespace_p
return|;
block|}
end_function

begin_comment
comment|/* If KEEP is non-zero, make a BLOCK node for the next binding level,    unconditionally.  Otherwise, use the normal logic to decide whether    or not to create a BLOCK.  */
end_comment

begin_function
name|void
name|keep_next_level
parameter_list|(
name|keep
parameter_list|)
name|int
name|keep
decl_stmt|;
block|{
name|keep_next_level_flag
operator|=
name|keep
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|int
name|kept_level_p
parameter_list|()
block|{
return|return
operator|(
name|current_binding_level
operator|->
name|blocks
operator|!=
name|NULL_TREE
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
name|NULL_TREE
operator|||
operator|(
name|current_binding_level
operator|->
name|tags
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|current_binding_level
operator|->
name|tag_transparent
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_namespace_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|namespace_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if this scope was created to store template    parameters.  */
end_comment

begin_function
name|int
name|template_parm_scope_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|template_parms_p
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of template specialization we are currently    processing, given that it's declaration contained N_CLASS_SCOPES    explicit scope qualifications.  */
end_comment

begin_function
name|tmpl_spec_kind
name|current_tmpl_spec_kind
parameter_list|(
name|n_class_scopes
parameter_list|)
name|int
name|n_class_scopes
decl_stmt|;
block|{
name|int
name|n_template_parm_scopes
init|=
literal|0
decl_stmt|;
name|int
name|seen_specialization_p
init|=
literal|0
decl_stmt|;
name|int
name|innermost_specialization_p
init|=
literal|0
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Scan through the template parameter scopes.  */
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
operator|->
name|template_parms_p
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
comment|/* If we see a specialization scope inside a parameter scope, 	 then something is wrong.  That corresponds to a declaration 	 like:  	    template<class T> template<> ...  	 which is always illegal since [temp.expl.spec] forbids the 	 specialization of a class member template if the enclosing 	 class templates are not explicitly specialized as well.  */
if|if
condition|(
name|b
operator|->
name|template_spec_p
condition|)
block|{
if|if
condition|(
name|n_template_parm_scopes
operator|==
literal|0
condition|)
name|innermost_specialization_p
operator|=
literal|1
expr_stmt|;
else|else
name|seen_specialization_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_specialization_p
operator|==
literal|1
condition|)
return|return
name|tsk_invalid_member_spec
return|;
operator|++
name|n_template_parm_scopes
expr_stmt|;
block|}
comment|/* Handle explicit instantiations.  */
if|if
condition|(
name|processing_explicit_instantiation
condition|)
block|{
if|if
condition|(
name|n_template_parm_scopes
operator|!=
literal|0
condition|)
comment|/* We've seen a template parameter list during an explicit 	   instantiation.  For example:  	     template<class T> template void f(int);  	   This is erroneous.  */
return|return
name|tsk_invalid_expl_inst
return|;
else|else
return|return
name|tsk_expl_inst
return|;
block|}
if|if
condition|(
name|n_template_parm_scopes
operator|<
name|n_class_scopes
condition|)
comment|/* We've not seen enough template headers to match all the        specialized classes present.  For example:           template<class T> void R<T>::S<T>::f(int);         This is illegal; there needs to be one set of template        parameters for each class.  */
return|return
name|tsk_insufficient_parms
return|;
elseif|else
if|if
condition|(
name|n_template_parm_scopes
operator|==
name|n_class_scopes
condition|)
comment|/* We're processing a non-template declaration (even though it may        be a member of a template class.)  For example:           template<class T> void S<T>::f(int);         The `class T' maches the `S<T>', leaving no template headers        corresponding to the `f'.  */
return|return
name|tsk_none
return|;
elseif|else
if|if
condition|(
name|n_template_parm_scopes
operator|>
name|n_class_scopes
operator|+
literal|1
condition|)
comment|/* We've got too many template headers.  For example:           template<> template<class T> void f (T);         There need to be more enclosing classes.  */
return|return
name|tsk_excessive_parms
return|;
else|else
comment|/* This must be a template.  It's of the form:           template<class T> template<class U> void S<T>::f(U);         This is a specialization if the innermost level was a        specialization; otherwise it's just a definition of the        template.  */
return|return
name|innermost_specialization_p
condition|?
name|tsk_expl_spec
else|:
name|tsk_template
return|;
block|}
end_function

begin_function
name|void
name|set_class_shadows
parameter_list|(
name|shadows
parameter_list|)
name|tree
name|shadows
decl_stmt|;
block|{
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|shadows
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
if|if
condition|(
name|cfun
operator|&&
operator|!
name|doing_semantic_analysis_p
argument_list|()
condition|)
return|return;
comment|/* Reuse or create a struct for this binding level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
if|if
condition|(
literal|0
condition|)
else|#
directive|else
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
if|if
condition|(
name|free_binding_level
condition|)
endif|#
directive|endif
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
name|push_binding_level
argument_list|(
name|newlevel
argument_list|,
name|tag_transparent
argument_list|,
name|keep_next_level_flag
argument_list|)
expr_stmt|;
name|GNU_xref_start_scope
argument_list|(
operator|(
name|size_t
operator|)
name|newlevel
argument_list|)
expr_stmt|;
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're defining an object of type TYPE.  If it needs a cleanup, but    we're not allowed to add any more objects with cleanups to the current    scope, create a new binding level.  */
end_comment

begin_function
name|void
name|maybe_push_cleanup_level
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|==
literal|0
condition|)
block|{
name|keep_next_level
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|1
argument_list|,
comment|/*partial_p=*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter a new scope.  The KIND indicates what kind of scope is being    created.  */
end_comment

begin_function
name|void
name|begin_scope
parameter_list|(
name|sk
parameter_list|)
name|scope_kind
name|sk
decl_stmt|;
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sk
condition|)
block|{
case|case
name|sk_template_spec
case|:
name|current_binding_level
operator|->
name|template_spec_p
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|sk_template_parms
case|:
name|current_binding_level
operator|->
name|template_parms_p
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Exit the current scope.  */
end_comment

begin_function
name|void
name|finish_scope
parameter_list|()
block|{
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_level_for_for
parameter_list|()
block|{
name|current_binding_level
operator|->
name|is_for_scope
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that the current binding level represents a try block.  */
end_comment

begin_function
name|void
name|note_level_for_try
parameter_list|()
block|{
name|current_binding_level
operator|->
name|is_try_scope
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that the current binding level represents a catch block.  */
end_comment

begin_function
name|void
name|note_level_for_catch
parameter_list|()
block|{
name|current_binding_level
operator|->
name|is_catch_scope
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a binding between a name and an entity at a block scope,    this is the `struct binding_level' for the block.  */
end_comment

begin_define
define|#
directive|define
name|BINDING_LEVEL
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(((struct tree_binding*)(NODE))->scope.level)
end_define

begin_comment
comment|/* A free list of CPLUS_BINDING nodes, connected by their    TREE_CHAINs.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|free_bindings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make DECL the innermost binding for ID.  The LEVEL is the binding    level at which this declaration is being bound.  */
end_comment

begin_function
specifier|static
name|void
name|push_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|,
name|level
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
block|{
name|tree
name|binding
decl_stmt|;
if|if
condition|(
name|free_bindings
condition|)
block|{
name|binding
operator|=
name|free_bindings
expr_stmt|;
name|free_bindings
operator|=
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
expr_stmt|;
block|}
else|else
name|binding
operator|=
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
expr_stmt|;
comment|/* Now, fill in the binding information.  */
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BINDING_LEVEL
argument_list|(
name|binding
argument_list|)
operator|=
name|level
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOCAL_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
operator|(
name|level
operator|!=
name|class_binding_level
operator|)
expr_stmt|;
name|BINDING_HAS_LEVEL_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* And put it on the front of the list of bindings for ID.  */
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|binding
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ID is already bound in the current scope.  But, DECL is an    additional binding for ID in the same scope.  This is the `struct    stat' hack whereby a non-typedef class-name or enum-name can be    bound at the same level as some other kind of entity.  It's the    responsibility of the caller to check that inserting this name is    legal here.  Returns nonzero if the new binding was successful.  */
end_comment

begin_function
specifier|static
name|int
name|add_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binding
init|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The new name is the type name.  */
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
condition|)
comment|/* This situation arises when push_class_level_binding moves an        inherited type-binding out of the way to make room for a new        value binding.  */
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The old binding was a type name.  It was placed in 	 BINDING_VALUE because it was thought, at the point it was 	 declared, to be the only entity with such a name.  Move the 	 type name into the type slot; it is now hidden by the new 	 binding.  */
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|&&
operator|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
argument_list|)
comment|/* If either type involves template parameters, we must 		  wait until instantiation.  */
operator|||
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* We have two typedef-names, both naming the same type to have        the same name.  This is OK because of:           [dcl.typedef]  	 In a given scope, a typedef specifier can be used to redefine 	 the name of any type declared in that scope to refer to the 	 type to which it already refers.  */
name|ok
operator|=
literal|0
expr_stmt|;
comment|/* There can be two block-scope declarations of the same variable,      so long as they are `extern' declarations.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
condition|)
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with previous declaration `%#D'"
argument_list|,
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Add DECL to the list of things declared in B.  */
end_comment

begin_function
specifier|static
name|void
name|add_decl_to_level
parameter_list|(
name|decl
parameter_list|,
name|b
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
comment|/* We build up the list in reverse order, and reverse it later if      necessary.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind DECL to ID in the current_binding_level, assumed to be a local    binding level.  If PUSH_USING is set in FLAGS, we know that DECL    doesn't really belong to this binding level, that it got here    through a using-declaration.  */
end_comment

begin_function
name|void
name|push_local_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Skip over any local classes.  This makes sense if we call      push_local_binding with a friend decl of a local class.  */
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|lookup_name_current_level
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|/* Supplement the existing binding.  */
if|if
condition|(
operator|!
name|add_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
condition|)
comment|/* It didn't work.  Something else must be bound at this 	   level.  Do not add DECL to the list of things to pop 	   later.  */
return|return;
block|}
else|else
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
condition|)
comment|/* We must put the OVERLOAD into a TREE_LIST since the        TREE_CHAIN of an OVERLOAD is already used.  Similarly for        decls that got here through a using-declaration.  */
name|decl
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* And put DECL on the list of things declared by the current      binding level.  */
name|add_decl_to_level
argument_list|(
name|decl
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind DECL to ID in the class_binding_level.  Returns nonzero if the    binding was successful.  */
end_comment

begin_function
name|int
name|push_class_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|result
init|=
literal|1
decl_stmt|;
name|tree
name|binding
init|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|context
decl_stmt|;
comment|/* Note that we declared this value so that we can issue an error if      this an illegal redeclaration of a name already used for some      other purpose.  */
name|note_name_declared_in_class
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|BINDING_LEVEL
argument_list|(
name|binding
argument_list|)
operator|==
name|class_binding_level
condition|)
comment|/* Supplement the existing binding.  */
name|result
operator|=
name|add_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
comment|/* Update the IDENTIFIER_CLASS_VALUE for this ID to be the      class-level declaration.  Note that we do not use DECL here      because of the possibility of the `struct stat' hack; if DECL is      a class-name or enum-name we might prefer a field-name, or some      such.  */
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a binding from a base class, mark it as such.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* Any implicit typename must be from a base-class.  The 	 context for an implicit typename declaration is always 	 the derived class in which the lookup was done, so the checks 	 based on the context of DECL below will not trigger.  */
if|if
condition|(
name|IMPLICIT_TYPENAME_TYPE_DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|context
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|current_class_type
argument_list|,
name|context
argument_list|)
condition|)
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
condition|)
comment|/* We only encounter a TREE_LIST when push_class_decls detects an        ambiguity.  Such an ambiguity can be overridden by a definition        in this class.  */
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Remove the binding for DECL which should be the innermost binding    for ID.  */
end_comment

begin_function
specifier|static
name|void
name|pop_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binding
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL_TREE
condition|)
comment|/* It's easiest to write the loops that call this function without        checking whether or not the entities involved have names.  We        get here for such an entity.  */
return|return;
comment|/* Get the innermost binding for ID.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* The name should be bound.  */
name|my_friendly_assert
argument_list|(
name|binding
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The DECL will be either the ordinary binding or the type      binding for this identifier.  Remove that binding.  */
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
condition|)
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
condition|)
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|&&
operator|!
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
condition|)
block|{
comment|/* We're completely done with the innermost binding for this 	 identifier.  Unhook it from the list of bindings.  */
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
expr_stmt|;
comment|/* Add it to the free list.  */
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|free_bindings
expr_stmt|;
name|free_bindings
operator|=
name|binding
expr_stmt|;
comment|/* Clear the BINDING_LEVEL so the garbage collector doesn't walk 	 it.  */
name|BINDING_LEVEL
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* When a label goes out of scope, check to see if that label was used    in a valid manner, and issue any appropriate warnings or errors.  */
end_comment

begin_function
specifier|static
name|void
name|pop_label
parameter_list|(
name|label
parameter_list|,
name|old_value
parameter_list|)
name|tree
name|label
decl_stmt|;
name|tree
name|old_value
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|doing_semantic_analysis_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"label `%D' used but not defined"
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
literal|1
argument_list|,
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused_label
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"label `%D' defined but not used"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of a function, all labels declared within the function    go out of scope.  BLOCK is the top-level block for the    function.  */
end_comment

begin_function
specifier|static
name|void
name|pop_labels
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|struct
name|named_label_list
modifier|*
name|link
decl_stmt|;
comment|/* Clear out the definitions of all label names, since their scopes      end here.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|pop_label
argument_list|(
name|link
operator|->
name|label_decl
argument_list|,
name|link
operator|->
name|old_value
argument_list|)
expr_stmt|;
comment|/* Put the labels into the "variables" of the top-level block, 	 so debugger can see them.  */
name|TREE_CHAIN
argument_list|(
name|link
operator|->
name|label_decl
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|link
operator|->
name|label_decl
expr_stmt|;
block|}
name|named_labels
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP == 1, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|int
name|tmp
init|=
name|functionbody
decl_stmt|;
name|int
name|real_functionbody
decl_stmt|;
name|tree
name|tags
decl_stmt|;
name|tree
name|subblocks
decl_stmt|;
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|leaving_for_scope
decl_stmt|;
if|if
condition|(
name|cfun
operator|&&
operator|!
name|doing_semantic_analysis_p
argument_list|()
condition|)
return|return
name|NULL_TREE
return|;
name|my_friendly_assert
argument_list|(
name|current_binding_level
operator|->
name|parm_flag
operator|!=
literal|2
argument_list|,
literal|19990916
argument_list|)
expr_stmt|;
name|real_functionbody
operator|=
operator|(
name|current_binding_level
operator|->
name|keep
operator|==
literal|2
condition|?
operator|(
operator|(
name|functionbody
operator|=
literal|0
operator|)
operator|,
name|tmp
operator|)
else|:
name|functionbody
operator|)
expr_stmt|;
name|tags
operator|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|tags
else|:
literal|0
expr_stmt|;
name|subblocks
operator|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|blocks
else|:
literal|0
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|current_binding_level
operator|->
name|class_shadowed
argument_list|,
literal|19990414
argument_list|)
expr_stmt|;
comment|/* We used to use KEEP == 2 to indicate that the new block should go      at the beginning of the list of blocks at this binding level,      rather than the end.  This hack is no longer used.  */
name|my_friendly_assert
argument_list|(
name|keep
operator|==
literal|0
operator|||
name|keep
operator|==
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|size_t
operator|)
name|current_binding_level
argument_list|,
operator|(
name|size_t
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|keep
operator|==
literal|1
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
comment|/* Any uses of undefined labels, and any defined labels, now operate      under constraints of next binding contour.  */
if|if
condition|(
name|cfun
operator|&&
operator|!
name|functionbody
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
name|level_chain
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|level_chain
condition|)
block|{
name|struct
name|named_label_use_list
modifier|*
name|uses
decl_stmt|;
name|struct
name|named_label_list
modifier|*
name|labels
decl_stmt|;
for|for
control|(
name|labels
operator|=
name|named_labels
init|;
name|labels
condition|;
name|labels
operator|=
name|labels
operator|->
name|next
control|)
if|if
condition|(
name|labels
operator|->
name|binding_level
operator|==
name|current_binding_level
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|is_try_scope
condition|)
name|labels
operator|->
name|in_try_scope
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|is_catch_scope
condition|)
name|labels
operator|->
name|in_catch_scope
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|labels
operator|->
name|names_in_scope
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|decl_jump_unsafe
argument_list|(
name|decl
argument_list|)
condition|)
name|labels
operator|->
name|bad_decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|labels
operator|->
name|bad_decls
argument_list|)
expr_stmt|;
name|labels
operator|->
name|binding_level
operator|=
name|level_chain
expr_stmt|;
name|labels
operator|->
name|names_in_scope
operator|=
name|level_chain
operator|->
name|names
expr_stmt|;
block|}
for|for
control|(
name|uses
operator|=
name|named_label_uses
init|;
name|uses
condition|;
name|uses
operator|=
name|uses
operator|->
name|next
control|)
if|if
condition|(
name|uses
operator|->
name|binding_level
operator|==
name|current_binding_level
condition|)
block|{
name|uses
operator|->
name|binding_level
operator|=
name|level_chain
expr_stmt|;
name|uses
operator|->
name|names_in_scope
operator|=
name|level_chain
operator|->
name|names
expr_stmt|;
block|}
block|}
block|}
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* Output any nested inline functions within this block      if they weren't already output.  */
for|for
control|(
name|decl
operator|=
name|decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
condition|)
block|{
comment|/* If this decl was copied from a file-scope decl 	   on account of a block-scope extern decl, 	   propagate TREE_ADDRESSABLE to the file-scope decl.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|push_function_context
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* When not in function-at-a-time mode, expand_end_bindings will      warn about unused variables.  But, in function-at-a-time mode      expand_end_bindings is not passed the list of variables in the      current scope, and therefore no warning is emitted.  So, we      explicitly warn here.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|warn_about_unused_variables
argument_list|(
name|getdecls
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|keep
operator|==
literal|1
operator|||
name|functionbody
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
name|NULL_TREE
condition|)
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
if|if
condition|(
name|keep
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* We still support the old for-scope rules, whereby the variables      in a for-init statement were in scope after the for-statement      ended.  We only use the new rules in flag_new_for_scope is      nonzero.  */
name|leaving_for_scope
operator|=
name|current_binding_level
operator|->
name|is_for_scope
operator|&&
name|flag_new_for_scope
operator|==
literal|1
expr_stmt|;
comment|/* Remove declarations for all the DECLs in this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|leaving_for_scope
operator|&&
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|tree
name|outer_binding
init|=
name|TREE_CHAIN
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ns_binding
decl_stmt|;
if|if
condition|(
operator|!
name|outer_binding
condition|)
name|ns_binding
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_binding
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|outer_binding
operator|&&
operator|(
name|BINDING_LEVEL
argument_list|(
name|outer_binding
argument_list|)
operator|==
name|current_binding_level
operator|->
name|level_chain
operator|)
condition|)
comment|/* We have something like:  	         int i; 	         for (int i; ;);  	       and we are leaving the `for' scope.  There's no reason to 	       keep the binding of the inner `i' in this case.  */
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|outer_binding
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|||
operator|(
name|ns_binding
operator|&&
name|TREE_CODE
argument_list|(
name|ns_binding
argument_list|)
operator|==
name|TYPE_DECL
operator|)
condition|)
comment|/* Here, we have something like:  		 typedef int I;  		 void f () { 		   for (int I; ;); 		 }  	       We must pop the for-scope binding so we know what's a 	       type and what isn't.  */
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Mark this VAR_DECL as dead so that we can tell we left it 		 there only for backward compatibility.  */
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Keep track of what should of have happenned when we 		 popped the binding.  */
if|if
condition|(
name|outer_binding
operator|&&
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
condition|)
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|link
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
expr_stmt|;
comment|/* Add it to the list of dead variables in the next 		 outermost binding to that we can remove these when we 		 leave that binding.  */
name|current_binding_level
operator|->
name|level_chain
operator|->
name|dead_vars_from_for
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|link
argument_list|,
name|current_binding_level
operator|->
name|level_chain
operator|->
name|dead_vars_from_for
argument_list|)
expr_stmt|;
comment|/* Although we don't pop the CPLUS_BINDING, we do clear 		 its BINDING_LEVEL since the level is going away now.  */
name|BINDING_LEVEL
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Remove the binding.  */
name|decl
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Remove declarations for any `for' variables from inner scopes      that we kept around.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|dead_vars_from_for
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the IDENTIFIER_TYPE_VALUEs.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|type_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the IDENTIFIER_LABEL_VALUEs for local labels.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|pop_label
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs      list if a `using' declaration put them there.  The debugging      back-ends won't understand OVERLOAD, so we remove them here.      Because the BLOCK_VARS are (temporarily) shared with      CURRENT_BINDING_LEVEL->NAMES we must do this fixup after we have      popped all the bindings.  */
if|if
condition|(
name|block
condition|)
block|{
name|tree
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
operator|*
name|d
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
condition|)
operator|*
name|d
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the level being exited is the top level of a function,      check over all the labels.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* Since this is the top level block of a function, the vars are 	 the function's parameters.  Don't leave them in the BLOCK 	 because they are found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pop_labels
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
name|pop_binding_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|functionbody
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
comment|/* Each and every BLOCK node created here in `poplevel' is important      (e.g. for proper debugging information) so if we created one      earlier, mark it as "used".  */
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Take care of compiler's internal binding structures.  */
if|if
condition|(
name|tmp
operator|==
literal|2
condition|)
block|{
name|tree
name|scope_stmts
decl_stmt|;
name|scope_stmts
operator|=
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|0
argument_list|,
comment|/*partial_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|scope_stmts
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_VALUE
argument_list|(
name|scope_stmts
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
name|block
operator|=
name|poplevel
argument_list|(
name|keep
argument_list|,
name|reverse
argument_list|,
name|functionbody
argument_list|)
expr_stmt|;
block|}
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Delete the node BLOCK from the current binding level.    This is used for the block inside a stmt expr ({...})    so that the block can be reinserted where appropriate.  */
end_comment

begin_function
name|void
name|delete_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|blocks
operator|==
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|blocks
init|;
name|t
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|block
condition|)
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Clear TREE_USED which is always set by poplevel.      The flag is set again if insert_block is called.  */
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the    current binding level.  This is used when a BIND_EXPR is expanded,    to handle the BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope    (the one we are currently in).  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* The RTL expansion machinery requires us to provide this callback,      but it is not applicable in function-at-a-time mode.  */
name|my_friendly_assert
argument_list|(
name|cfun
operator|&&
operator|!
name|doing_semantic_analysis_p
argument_list|()
argument_list|,
literal|20000911
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a pushlevel for class declarations.  */
end_comment

begin_function
name|void
name|pushlevel_class
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
if|if
condition|(
literal|0
condition|)
else|#
directive|else
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
if|if
condition|(
name|free_binding_level
condition|)
endif|#
directive|endif
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|push_binding_level
argument_list|(
name|newlevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|class_binding_level
operator|->
name|parm_flag
operator|=
literal|2
expr_stmt|;
name|class_binding_level
operator|->
name|this_class
operator|=
name|current_class_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ...and a poplevel for class declarations.  */
end_comment

begin_function
name|void
name|poplevel_class
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|class_binding_level
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|level
operator|!=
literal|0
argument_list|,
literal|354
argument_list|)
expr_stmt|;
comment|/* If we're leaving a toplevel class, don't bother to do the setting      of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot      shouldn't even be used when current_class_type isn't set, and second,      if we don't touch it here, we're able to use the cache effect if the      next time we're entering a class scope, it is the same class.  */
if|if
condition|(
name|current_class_depth
operator|!=
literal|1
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Clear out our IDENTIFIER_CLASS_VALUEs.  */
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Find the next enclosing class, and recreate 	 IDENTIFIER_CLASS_VALUEs appropriate for that class.  */
name|b
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
while|while
condition|(
name|b
operator|&&
name|b
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
condition|)
for|for
control|(
name|shadowed
operator|=
name|b
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|&&
name|BINDING_LEVEL
argument_list|(
name|t
argument_list|)
operator|!=
name|b
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Remember to save what IDENTIFIER's were bound in this scope so we        can recover from cache misses.  */
block|{
name|previous_class_type
operator|=
name|current_class_type
expr_stmt|;
name|previous_class_values
operator|=
name|class_binding_level
operator|->
name|class_shadowed
expr_stmt|;
block|}
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|type_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the bindings for all of the class-level declarations.  */
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|pop_binding
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|size_t
operator|)
name|class_binding_level
argument_list|,
operator|(
name|size_t
operator|)
name|class_binding_level
operator|->
name|level_chain
argument_list|,
name|class_binding_level
operator|->
name|parm_flag
argument_list|,
name|class_binding_level
operator|->
name|keep
argument_list|)
expr_stmt|;
comment|/* Now, pop out of the binding level which we created up in the      `pushlevel_class' routine.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|pop_binding_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE    for any names in enclosing classes.  */
end_comment

begin_function
name|void
name|clear_identifier_class_values
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|class_binding_level
condition|)
return|return;
for|for
control|(
name|t
operator|=
name|class_binding_level
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T is a virtual function table.  */
end_comment

begin_function
name|int
name|vtable_decl_p
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T is a TYPE_DECL for a type with virtual    functions.  */
end_comment

begin_function
name|int
name|vtype_decl_p
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the declarations that are members of the namespace NS.  */
end_comment

begin_function
name|tree
name|cp_namespace_decls
parameter_list|(
name|ns
parameter_list|)
name|tree
name|ns
decl_stmt|;
block|{
return|return
name|NAMESPACE_LEVEL
argument_list|(
name|ns
argument_list|)
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Walk all the namespaces contained NAMESPACE, including NAMESPACE    itself, calling F for each.  The DATA is passed to F as well.  */
end_comment

begin_function
specifier|static
name|int
name|walk_namespaces_r
parameter_list|(
name|namespace
parameter_list|,
name|f
parameter_list|,
name|data
parameter_list|)
name|tree
name|namespace
decl_stmt|;
name|walk_namespaces_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|current
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|result
operator||=
call|(
modifier|*
name|f
call|)
argument_list|(
name|namespace
argument_list|,
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|cp_namespace_decls
argument_list|(
name|namespace
argument_list|)
init|;
name|current
condition|;
name|current
operator|=
name|TREE_CHAIN
argument_list|(
name|current
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|||
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|current
argument_list|)
condition|)
continue|continue;
comment|/* We found a namespace.  */
name|result
operator||=
name|walk_namespaces_r
argument_list|(
name|current
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Walk all the namespaces, calling F for each.  The DATA is passed to    F as well.  */
end_comment

begin_function
name|int
name|walk_namespaces
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|)
name|walk_namespaces_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
return|return
name|walk_namespaces_r
argument_list|(
name|global_namespace
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|walk_globals_data
block|{
name|walk_globals_pred
name|p
decl_stmt|;
name|walk_globals_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Walk the global declarations in NAMESPACE.  Whenever one is found    for which P returns non-zero, call F with its address.  If any call    to F returns a non-zero value, return a non-zero value.  */
end_comment

begin_function
specifier|static
name|int
name|walk_globals_r
parameter_list|(
name|namespace
parameter_list|,
name|data
parameter_list|)
name|tree
name|namespace
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|walk_globals_data
modifier|*
name|wgd
init|=
operator|(
expr|struct
name|walk_globals_data
operator|*
operator|)
name|data
decl_stmt|;
name|walk_globals_pred
name|p
init|=
name|wgd
operator|->
name|p
decl_stmt|;
name|walk_globals_fn
name|f
init|=
name|wgd
operator|->
name|f
decl_stmt|;
name|void
modifier|*
name|d
init|=
name|wgd
operator|->
name|data
decl_stmt|;
name|tree
modifier|*
name|t
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|t
operator|=
operator|&
name|NAMESPACE_LEVEL
argument_list|(
name|namespace
argument_list|)
operator|->
name|names
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|tree
name|glbl
init|=
operator|*
name|t
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|p
call|)
argument_list|(
name|glbl
argument_list|,
name|d
argument_list|)
condition|)
name|result
operator||=
call|(
modifier|*
name|f
call|)
argument_list|(
name|t
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* If F changed *T, then *T still points at the next item to 	 examine.  */
if|if
condition|(
operator|*
name|t
operator|==
name|glbl
condition|)
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Walk the global declarations.  Whenever one is found for which P    returns non-zero, call F with its address.  If any call to F    returns a non-zero value, return a non-zero value.  */
end_comment

begin_function
name|int
name|walk_globals
parameter_list|(
name|p
parameter_list|,
name|f
parameter_list|,
name|data
parameter_list|)
name|walk_globals_pred
name|p
decl_stmt|;
name|walk_globals_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|walk_globals_data
name|wgd
decl_stmt|;
name|wgd
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|wgd
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|wgd
operator|.
name|data
operator|=
name|data
expr_stmt|;
return|return
name|walk_namespaces
argument_list|(
name|walk_globals_r
argument_list|,
operator|&
name|wgd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call wrapup_globals_declarations for the globals in NAMESPACE.  If    DATA is non-NULL, this is the last time we will call    wrapup_global_declarations for this NAMESPACE.  */
end_comment

begin_function
name|int
name|wrapup_globals_for_namespace
parameter_list|(
name|namespace
parameter_list|,
name|data
parameter_list|)
name|tree
name|namespace
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|globals
init|=
name|cp_namespace_decls
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|list_length
argument_list|(
name|globals
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|vec
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|last_time
init|=
operator|(
name|data
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|last_time
operator|&&
name|namespace
operator|==
name|global_namespace
condition|)
comment|/* Let compile_file handle the global namespace.  */
return|return
literal|0
return|;
comment|/* Process the decls in reverse order--earliest first.      Put them into VEC from back to front, then take out from front.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|decl
operator|=
name|globals
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|vec
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|last_time
condition|)
block|{
name|check_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Temporarily mark vtables as external.  That prevents      wrapup_global_declarations from writing them out; we must process      them ourselves in finish_vtable_vardecl.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vtable_decl_p
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Write out any globals that need to be output.  */
name|result
operator|=
name|wrapup_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Undo the hack to DECL_EXTERNAL above.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vtable_decl_p
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
operator|&&
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark ARG (which is really a struct binding_level **) for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_binding_level
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|lvl
init|=
operator|*
operator|(
expr|struct
name|binding_level
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
for|for
control|(
init|;
name|lvl
condition|;
name|lvl
operator|=
name|lvl
operator|->
name|level_chain
control|)
block|{
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|names
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|tags
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|usings
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|using_directives
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|shadowed_labels
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|this_class
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|incomplete
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lvl
operator|->
name|dead_vars_from_for
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mark_named_label_lists
parameter_list|(
name|labs
parameter_list|,
name|uses
parameter_list|)
name|void
modifier|*
name|labs
decl_stmt|;
name|void
modifier|*
name|uses
decl_stmt|;
block|{
name|struct
name|named_label_list
modifier|*
name|l
init|=
operator|*
operator|(
expr|struct
name|named_label_list
operator|*
operator|*
operator|)
name|labs
decl_stmt|;
name|struct
name|named_label_use_list
modifier|*
name|u
init|=
operator|*
operator|(
expr|struct
name|named_label_use_list
operator|*
operator|*
operator|)
name|uses
decl_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|ggc_mark
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|mark_binding_level
argument_list|(
name|l
operator|->
name|binding_level
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|l
operator|->
name|old_value
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|l
operator|->
name|label_decl
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|l
operator|->
name|bad_decls
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|u
condition|;
name|u
operator|=
name|u
operator|->
name|next
control|)
name|ggc_mark
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_print_functions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_print_builtins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_binding_level
parameter_list|(
name|lvl
parameter_list|)
name|struct
name|binding_level
modifier|*
name|lvl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" blocks="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|lvl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" n_incomplete=%d parm_flag=%d keep=%d"
argument_list|,
name|list_length
argument_list|(
name|lvl
operator|->
name|incomplete
argument_list|)
argument_list|,
name|lvl
operator|->
name|parm_flag
argument_list|,
name|lvl
operator|->
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|tag_transparent
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tag-transparent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|more_cleanups_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" more-cleanups-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|have_cleanups
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" have-cleanups"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|names
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" names:\t"
argument_list|)
expr_stmt|;
comment|/* We can probably fit 3 names to a line?  */
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|no_print_functions
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|no_print_builtins
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"<built-in>"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Function decls tend to have longer names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|len
operator|=
literal|3
expr_stmt|;
else|else
name|len
operator|=
literal|2
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
break|break;
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|tags
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tags:\t"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|tags
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<unnamed-typedef"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<typedef"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|class_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" class-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|type_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_other_binding_stack
parameter_list|(
name|stack
parameter_list|)
name|struct
name|binding_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|stack
init|;
name|level
operator|!=
name|global_binding_level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"binding level "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_binding_stack
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nclass_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nglobal_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|global_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
for|for
control|(
name|b
operator|=
name|class_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
if|if
condition|(
name|b
operator|==
name|current_binding_level
condition|)
break|break;
if|if
condition|(
name|b
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
block|}
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|print_other_binding_stack
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"global:\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|global_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Namespace binding access routines: The namespace_bindings field of    the identifier is polymorphic, with three possible values:    NULL_TREE, a list of CPLUS_BINDINGS, or any other tree_node    indicating the BINDING_VALUE of global_namespace. */
end_comment

begin_comment
comment|/* Check whether the a binding for the name to scope is known.    Assumes that the bindings of the name are already a list    of bindings. Returns the binding found, or NULL_TREE. */
end_comment

begin_function
specifier|static
name|tree
name|find_binding
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|iter
decl_stmt|,
name|prev
init|=
name|NULL_TREE
decl_stmt|;
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|iter
argument_list|)
operator|==
name|CPLUS_BINDING
argument_list|,
literal|374
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINDING_SCOPE
argument_list|(
name|iter
argument_list|)
operator|==
name|scope
condition|)
block|{
comment|/* Move binding found to the front of the list, so              subsequent lookups will find it faster. */
if|if
condition|(
name|prev
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|iter
expr_stmt|;
block|}
return|return
name|iter
return|;
block|}
name|prev
operator|=
name|iter
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Always returns a binding for name in scope. If the    namespace_bindings is not a list, convert it to one first.    If no binding is found, make a new one. */
end_comment

begin_function
name|tree
name|binding_for_name
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|b
init|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|&&
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CPLUS_BINDING
condition|)
block|{
comment|/* Get rid of optimization for global scope. */
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|global_namespace
argument_list|)
argument_list|)
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|&&
operator|(
name|result
operator|=
name|find_binding
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
operator|)
condition|)
return|return
name|result
return|;
comment|/* Not found, make a new one. */
name|result
operator|=
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|result
argument_list|)
operator|=
name|b
expr_stmt|;
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|result
expr_stmt|;
name|BINDING_SCOPE
argument_list|(
name|result
argument_list|)
operator|=
name|scope
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the binding value for name in scope, considering that    namespace_binding may or may not be a list of CPLUS_BINDINGS. */
end_comment

begin_function
name|tree
name|namespace_binding
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|b
init|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CPLUS_BINDING
condition|)
return|return
operator|(
name|scope
operator|==
name|global_namespace
operator|)
condition|?
name|b
else|:
name|NULL_TREE
return|;
name|name
operator|=
name|find_binding
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
return|return
name|name
return|;
return|return
name|BINDING_VALUE
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the binding value for name in scope. If modifying the binding    of global_namespace is attempted, try to optimize it. */
end_comment

begin_function
name|void
name|set_namespace_binding
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|,
name|val
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|tree
name|val
decl_stmt|;
block|{
name|tree
name|b
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|global_namespace
condition|)
block|{
name|b
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CPLUS_BINDING
condition|)
block|{
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|val
expr_stmt|;
return|return;
block|}
block|}
name|b
operator|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|b
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we    select a name that is unique to this compilation unit.  */
end_comment

begin_function
name|void
name|push_namespace
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|d
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|need_new
init|=
literal|1
decl_stmt|;
name|int
name|implicit_use
init|=
literal|0
decl_stmt|;
name|int
name|global
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|global_namespace
condition|)
block|{
comment|/* This must be ::. */
name|my_friendly_assert
argument_list|(
name|name
operator|==
name|get_identifier
argument_list|(
literal|"::"
argument_list|)
argument_list|,
literal|377
argument_list|)
expr_stmt|;
name|global
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|name
condition|)
block|{
comment|/* The name of anonymous namespace is unique for the translation          unit.  */
if|if
condition|(
operator|!
name|anonymous_namespace_name
condition|)
name|anonymous_namespace_name
operator|=
name|get_file_function_name
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
name|name
operator|=
name|anonymous_namespace_name
expr_stmt|;
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
comment|/* Reopening anonymous namespace.  */
name|need_new
operator|=
literal|0
expr_stmt|;
name|implicit_use
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Check whether this is an extended namespace definition. */
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|need_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"namespace alias `%D' not allowed here, assuming `%D'"
argument_list|,
name|d
argument_list|,
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need_new
condition|)
block|{
comment|/* Make a new namespace, binding the name to it. */
name|d
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* The global namespace is not pushed, and the global binding 	 level is set elsewhere.  */
if|if
condition|(
operator|!
name|global
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
name|d
operator|=
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_namespace_level
argument_list|()
expr_stmt|;
name|NAMESPACE_LEVEL
argument_list|(
name|d
argument_list|)
operator|=
name|current_binding_level
expr_stmt|;
block|}
block|}
else|else
name|resume_binding_level
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|implicit_use
condition|)
name|do_using_directive
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Enter the name space. */
name|current_namespace
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop from the scope of the current namespace.  */
end_comment

begin_function
name|void
name|pop_namespace
parameter_list|()
block|{
name|my_friendly_assert
argument_list|(
name|current_namespace
operator|!=
name|global_namespace
argument_list|,
literal|20010801
argument_list|)
expr_stmt|;
name|current_namespace
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* The binding level is not popped, as it might be re-opened later.  */
name|suspend_binding_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push into the scope of the namespace NS, even if it is deeply    nested within another namespace.  */
end_comment

begin_function
name|void
name|push_nested_namespace
parameter_list|(
name|ns
parameter_list|)
name|tree
name|ns
decl_stmt|;
block|{
if|if
condition|(
name|ns
operator|==
name|global_namespace
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
else|else
block|{
name|push_nested_namespace
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|ns
argument_list|)
argument_list|)
expr_stmt|;
name|push_namespace
argument_list|(
name|DECL_NAME
argument_list|(
name|ns
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pop back from the scope of the namespace NS, which was previously    entered with push_nested_namespace.  */
end_comment

begin_function
name|void
name|pop_nested_namespace
parameter_list|(
name|ns
parameter_list|)
name|tree
name|ns
decl_stmt|;
block|{
while|while
condition|(
name|ns
operator|!=
name|global_namespace
condition|)
block|{
name|pop_namespace
argument_list|()
expr_stmt|;
name|ns
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines for reverting temporarily to top-level for instantiation    of templates and such.  We actually need to clear out the class- and    local-value slots of all identifiers, so that only the global values    are at all visible.  Simply setting current_binding_level to the global    scope isn't enough, because more binding levels may be pushed.  */
end_comment

begin_decl_stmt
name|struct
name|saved_scope
modifier|*
name|scope_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark ARG (which is really a struct saved_scope **) for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_saved_scope
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|saved_scope
modifier|*
name|t
init|=
operator|*
operator|(
expr|struct
name|saved_scope
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|mark_binding_level
argument_list|(
operator|&
name|t
operator|->
name|class_bindings
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|old_bindings
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|old_namespace
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|decl_ns_list
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|class_name
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|class_type
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|access_specifier
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|lang_base
condition|)
name|ggc_mark_tree_varray
argument_list|(
name|t
operator|->
name|lang_base
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|lang_name
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|template_parms
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|x_previous_class_type
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|x_previous_class_values
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|x_saved_tree
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|incomplete
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|t
operator|->
name|lookups
argument_list|)
expr_stmt|;
name|mark_stmt_tree
argument_list|(
operator|&
name|t
operator|->
name|x_stmt_tree
argument_list|)
expr_stmt|;
name|mark_binding_level
argument_list|(
operator|&
name|t
operator|->
name|bindings
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|store_bindings
parameter_list|(
name|names
parameter_list|,
name|old_bindings
parameter_list|)
name|tree
name|names
decl_stmt|,
name|old_bindings
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|search_bindings
init|=
name|old_bindings
decl_stmt|;
for|for
control|(
name|t
operator|=
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binding
decl_stmt|,
name|t1
decl_stmt|,
name|id
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|id
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
comment|/* Note that we may have an IDENTIFIER_CLASS_VALUE even when 	     we have no IDENTIFIER_BINDING if we have left the class 	     scope, but cached the class-level declarations.  */
operator|||
operator|!
operator|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|||
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|t1
operator|=
name|search_bindings
init|;
name|t1
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
operator|==
name|id
condition|)
goto|goto
name|skip_it
goto|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|135
argument_list|)
expr_stmt|;
name|binding
operator|=
name|make_tree_vec
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|0
argument_list|)
operator|=
name|id
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|1
argument_list|)
operator|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|2
argument_list|)
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|3
argument_list|)
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|old_bindings
expr_stmt|;
name|old_bindings
operator|=
name|binding
expr_stmt|;
name|skip_it
label|:
empty_stmt|;
block|}
return|return
name|old_bindings
return|;
block|}
end_function

begin_function
name|void
name|maybe_push_to_top_level
parameter_list|(
name|pseudo
parameter_list|)
name|int
name|pseudo
decl_stmt|;
block|{
name|struct
name|saved_scope
modifier|*
name|s
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|old_bindings
decl_stmt|;
name|int
name|need_pop
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|saved_scope
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|saved_scope
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|scope_chain
condition|?
name|current_binding_level
else|:
literal|0
expr_stmt|;
comment|/* If we're in the middle of some function, save our state.  */
if|if
condition|(
name|cfun
condition|)
block|{
name|need_pop
operator|=
literal|1
expr_stmt|;
name|push_function_context_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|need_pop
operator|=
literal|0
expr_stmt|;
name|old_bindings
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|scope_chain
operator|&&
name|previous_class_type
condition|)
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|previous_class_values
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Have to include global_binding_level, because class-level decls      aren't listed anywhere useful.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Template IDs are inserted into the global level. If they were 	 inserted into namespace level, finish_file wouldn't find them 	 when doing pending instantiations. Therefore, don't stop at 	 namespace level, but continue until :: .  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
operator|||
operator|(
name|pseudo
operator|&&
name|b
operator|->
name|template_parms_p
operator|)
condition|)
break|break;
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|b
operator|->
name|names
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* We also need to check class_shadowed to save class-level type 	 bindings, since pushclass doesn't fill in b->names.  */
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|b
operator|->
name|class_shadowed
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Unwind type-value slots back to top level.  */
for|for
control|(
name|t
operator|=
name|b
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|prev
operator|=
name|scope_chain
expr_stmt|;
name|s
operator|->
name|old_bindings
operator|=
name|old_bindings
expr_stmt|;
name|s
operator|->
name|bindings
operator|=
name|b
expr_stmt|;
name|s
operator|->
name|need_pop_function_context
operator|=
name|need_pop
expr_stmt|;
name|s
operator|->
name|function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|scope_chain
operator|=
name|s
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|current_lang_base
argument_list|,
literal|10
argument_list|,
literal|"current_lang_base"
argument_list|)
expr_stmt|;
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
name|current_namespace
operator|=
name|global_namespace
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_to_top_level
parameter_list|()
block|{
name|maybe_push_to_top_level
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_from_top_level
parameter_list|()
block|{
name|struct
name|saved_scope
modifier|*
name|s
init|=
name|scope_chain
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Clear out class-level bindings cache.  */
if|if
condition|(
name|previous_class_type
condition|)
name|invalidate_class_lookup_cache
argument_list|()
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|current_lang_base
argument_list|)
expr_stmt|;
name|scope_chain
operator|=
name|s
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|->
name|old_bindings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* If we were in the middle of compiling a function, restore our      state.  */
if|if
condition|(
name|s
operator|->
name|need_pop_function_context
condition|)
name|pop_function_context_from
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition of struct, union or enum tag "name".    into binding_level "b".   "type" should be the type node,    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be a NULL_TREE.     C++ gratuitously puts all these tags in the name space.  */
end_comment

begin_comment
comment|/* When setting the IDENTIFIER_TYPE_VALUE field of an identifier ID,    record the shadowed value for this binding contour.  TYPE is    the type that ID maps to.  */
end_comment

begin_function
specifier|static
name|void
name|set_identifier_type_value_with_scope
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|,
name|b
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|b
operator|->
name|namespace_p
condition|)
block|{
comment|/* Shadow the marker, not the real thing, so that the marker 	 gets restored later. */
name|tree
name|old_type_value
init|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|b
operator|->
name|type_shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_type_value
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|binding
init|=
name|binding_for_name
argument_list|(
name|id
argument_list|,
name|current_namespace
argument_list|)
decl_stmt|;
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Store marker instead of real type. */
name|type
operator|=
name|global_type_node
expr_stmt|;
block|}
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As set_identifier_type_value_with_scope, but using current_binding_level.  */
end_comment

begin_function
name|void
name|set_identifier_type_value
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|set_identifier_type_value_with_scope
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type associated with id. */
end_comment

begin_function
name|tree
name|identifier_type_value
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
comment|/* There is no type with that name, anywhere. */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* This is not the type marker, but the real thing. */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|!=
name|global_type_node
condition|)
return|return
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
return|;
comment|/* Have to search for it. It must be on the global level, now.      Ask lookup_name not to return non-types. */
name|id
operator|=
name|lookup_name_real
argument_list|(
name|id
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Pop off extraneous binding levels left over due to syntax errors.     We don't pop past namespaces, as they might be valid.  */
end_comment

begin_function
name|void
name|pop_everything
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX entering pop_everything ()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
else|else
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX leaving pop_everything ()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The type TYPE is being declared.  If it is a class template, or a    specialization of a class template, do any processing required and    perform error-checking.  If IS_FRIEND is non-zero, this TYPE is    being declared a friend.  B is the binding level at which this TYPE    should be bound.     Returns the TYPE_DECL for TYPE, which may have been altered by this    processing.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_process_template_type_declaration
parameter_list|(
name|type
parameter_list|,
name|globalize
parameter_list|,
name|b
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|globalize
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_parmlist
condition|)
comment|/* You can't declare a new template type in a template parameter        list.  But, you can declare a non-template type:           template<class A*> struct S;         is a forward-declaration of `A'.  */
empty_stmt|;
else|else
block|{
name|maybe_check_template_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* This may change after the call to 	     push_template_decl_real, but we want the original value.  */
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
comment|/* If the current binding level is the binding level for the 	     template parameters (see the comment in 	     begin_template_parm_list) and the enclosing level is a class 	     scope, and we're not looking at a friend, push the 	     declaration of the member class into the class scope.  In the 	     friend case, push_template_decl will already have put the 	     friend into global scope, if appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
name|globalize
operator|&&
name|b
operator|->
name|template_parms_p
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|finish_member_declaration
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put this tag on the list of tags for the class, since 		 that won't happen below because B is not the class 		 binding level, but is instead the pseudo-global level.  */
name|b
operator|->
name|level_chain
operator|->
name|tags
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|level_chain
operator|->
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|level_chain
operator|->
name|tags
expr_stmt|;
block|}
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* In C++, you don't have to write `struct S' to refer to `S'; you    can just use `S'.  We accomplish this by creating a TYPE_DECL as    if the user had written `typedef struct S S'.  Create and return    the TYPE_DECL for TYPE.  */
end_comment

begin_function
name|tree
name|create_implicit_typedef
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* There are other implicit type declarations, like the one *within*      a class that allows you to write `S::S'.  We must distinguish      amongst these.  */
name|SET_DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Remember a local name for name-mangling purposes.  */
end_comment

begin_function
specifier|static
name|void
name|push_local_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|,
name|nelts
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|local_names
condition|)
name|VARRAY_TREE_INIT
argument_list|(
name|local_names
argument_list|,
literal|8
argument_list|,
literal|"local_names"
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|local_names
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|VARRAY_TREE
argument_list|(
name|local_names
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_DISCRIMINATOR
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_DISCRIMINATOR
argument_list|(
name|t
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|DECL_DISCRIMINATOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VARRAY_TREE
argument_list|(
name|local_names
argument_list|,
name|i
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return;
block|}
block|}
name|VARRAY_PUSH_TREE
argument_list|(
name|local_names
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a tag name NAME for struct/class/union/enum type TYPE.    Normally put it into the inner-most non-tag-transparent scope,    but if GLOBALIZE is true, put it in the inner-most non-class scope.    The latter is needed for implicit declarations.  */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
operator|||
operator|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
operator|&&
operator|(
name|globalize
comment|/* We may be defining a new type in the initializer 		    of a static member variable. We allow this when 		    not pedantic, and it is particularly useful for 		    type punning via an anonymous union. */
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|b
operator|->
name|this_class
argument_list|)
operator|)
operator|)
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|b
operator|->
name|tags
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Do C++ gratuitous typedefing.  */
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|type
condition|)
block|{
specifier|register
name|tree
name|d
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|in_class
init|=
literal|0
decl_stmt|;
name|tree
name|context
init|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|globalize
condition|)
name|context
operator|=
name|cs
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_P
argument_list|(
name|cs
argument_list|)
condition|)
comment|/* When declaring a friend class of a local class, we want 		   to inject the newly named class into the scope 		   containing the local class, not the namespace scope.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|get_type_decl
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|current_namespace
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|->
name|template_parms_p
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|parm_flag
operator|==
literal|2
operator|)
operator|||
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|in_class
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|create_implicit_typedef
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_class
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|d
operator|=
name|maybe_process_template_type_declaration
argument_list|(
name|type
argument_list|,
name|globalize
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
comment|/* Put this TYPE_DECL on the TYPE_FIELDS list for the 		   class.  But if it's a member template class, we 		   want the TEMPLATE_DECL, not the TYPE_DECL, so this 		   is done later.  */
name|finish_member_declaration
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* FIXME what if it gets a name from typedef?  */
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* If this is a local class, keep track of it.  We need this 	     information for name-mangling, and so that it is possible to find 	     all function definitions in a translation unit in a convenient 	     way.  (It's otherwise tricky to find a member function definition 	     it's only pointed to from within a local class.)  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|processing_template_decl
condition|)
name|VARRAY_PUSH_TREE
argument_list|(
name|local_classes
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|tags
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Use the canonical TYPE_DECL for this node.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE 	 will be the tagged type we just added to the current 	 binding level.  This fake NULL-named TYPE_DECL node helps 	 dwarfout.c to know when it needs to output a 	 representation of a tagged type, and it also gives us a 	 convenient place to record the "scope start" address for 	 the tagged type.  */
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Counter used to create anonymous type names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|anon_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an IDENTIFIER which can be used as a name for    anonymous structs and unions.  */
end_comment

begin_function
name|tree
name|make_anon_name
parameter_list|()
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_AGGRNAME_FORMAT
argument_list|,
name|anon_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the TREE_PURPOSE slot of tags which have anonymous typenames.    This keeps dbxout from getting confused.  */
end_comment

begin_function
name|void
name|clear_anon_tags
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
specifier|register
name|tree
name|tags
decl_stmt|;
specifier|static
name|int
name|last_cnt
init|=
literal|0
decl_stmt|;
comment|/* Fast out if no new anon names were declared.  */
if|if
condition|(
name|last_cnt
operator|==
name|anon_cnt
condition|)
return|return;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|tags
operator|=
name|b
operator|->
name|tags
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
comment|/* A NULL purpose means we have already processed all tags 	 from here to the end of the list.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
name|last_cnt
operator|=
name|anon_cnt
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of duplicate_decls: return truthvalue of whether    or not types of these decls match.     For C++, we must compare the parameter list so that `int' can match    `int&' in a parameter position, but `int&' is not confused with    `const int&'.  */
end_comment

begin_function
name|int
name|decls_match
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|int
name|types_match
decl_stmt|;
if|if
condition|(
name|newdecl
operator|==
name|olddecl
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* If the two DECLs are not even the same kind of thing, we're not        interested in their types.  */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|f1
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
decl_stmt|;
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CP_DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|p2
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
operator|||
operator|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|||
operator|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|void_list_node
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
elseif|else
if|if
condition|(
name|p1
operator|==
name|NULL_TREE
operator|&&
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|types_match
operator|=
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
name|types_match
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|types_match
operator|=
literal|1
expr_stmt|;
else|else
name|types_match
operator|=
name|decls_match
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
else|else
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|COMPARE_REDECLARATION
argument_list|)
expr_stmt|;
block|}
return|return
name|types_match
return|;
block|}
end_function

begin_comment
comment|/* If NEWDECL is `static' and an `extern' was seen previously,    warn about it.  OLDDECL is the previous declaration.     Note that this does not apply to the C++ case of declaring    a variable `extern const' and then later `const'.     Don't complain about built-in functions, since they are beyond    the user's control.  */
end_comment

begin_function
specifier|static
name|void
name|warn_extern_redeclared_static
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|explicit_extern_static_warning
init|=
literal|"`%D' was declared `extern' and later `static'"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|implicit_extern_static_warning
init|=
literal|"`%D' was declared implicitly `extern' and later `static'"
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|CONST_DECL
condition|)
return|return;
comment|/* Don't get confused by static member functions; that's a different      use of `static'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return;
comment|/* If the old declaration was `static', or the new one isn't, then      then everything is OK.  */
if|if
condition|(
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|DECL_THIS_STATIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return;
comment|/* It's OK to declare a builtin function as `static'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|?
name|implicit_extern_static_warning
else|:
name|explicit_extern_static_warning
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"previous declaration of `%D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL has the same name as an old    one OLDDECL in the same binding contour.  Prints an error message    if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|int
name|olddecl_friend
init|=
literal|0
decl_stmt|,
name|types_match
init|=
literal|0
decl_stmt|;
name|int
name|new_defines_function
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|newdecl
operator|==
name|olddecl
condition|)
return|return
literal|1
return|;
name|types_match
operator|=
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If either the type of the new decl or the type of the old decl is an      error_mark_node, then that implies that we have already issued an      error (earlier) for some bogus type specification, and in that case,      it is rather pointless to harass the user with yet more error message      about the same declaration, so just pretend the types match here.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
comment|/* Already warned elsewhere.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
comment|/* Already warned.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"function `%s' redeclared as inline"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of function `%s' with attribute noinline"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"function `%s' redeclared with attribute noinline"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of function `%s' was inline"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for redeclaration and other discrepancies. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* If you declare a built-in or predefined function name as static, 	     the old definition is overridden, but optionally warn this was a 	     bad choice of name.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|warn_shadow
condition|)
name|warning
argument_list|(
literal|"shadowing %s function `%#D'"
argument_list|,
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|?
literal|"built-in"
else|:
literal|"library"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
literal|0
return|;
block|}
comment|/* If the built-in is not ansi, then programs can override 	     it even globally without an error.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"library function `%#D' redeclared as non-function `%#D'"
argument_list|,
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with built-in declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
if|if
condition|(
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* A near match; override the builtin.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"new declaration `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"ambiguates built-in declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_shadow
condition|)
name|warning
argument_list|(
literal|"shadowing %s function `%#D'"
argument_list|,
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|?
literal|"built-in"
else|:
literal|"library"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Discard the old built-in function.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|DECL_THIS_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* If a builtin function is redeclared as `static', merge 	     the declarations, but make the original one static.  */
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Make the old declaration consistent with the new one so 	     that all remnants of the builtin-ness of this function 	     will be banished.  */
name|SET_DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We do nothing special here, because C++ does such nasty 	     things with TYPE_DECLs.  Instead, just let the TYPE_DECL 	     get shadowed, and know that if we need to find a TYPE_DECL 	     for a given name, we can look in the IDENTIFIER_TYPE_VALUE 	     slot of the identifier.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|"`%#D' redeclared as different kind of symbol"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration of `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one => 	 tell caller to replace the old one.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CP_DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* These are certainly not duplicate declarations; they're 	   from different scopes.  */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* The name of a class template may not be declared to refer to 	     any other template, class, function, object, namespace, value, 	     or type in the same scope.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"declaration of template `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with previous declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"new declaration `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"ambiguates old declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of C function `%#D' conflicts with"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration `%#D' here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"new declaration `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"ambiguates old declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* Already complained about this, so don't do so again.  */
elseif|else
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"conflicting types for `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration as `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_TI_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
comment|/* It's OK to have a template specialization and a non-template        with the same type, or to have specializations of two        different templates with the same type.  Note that if one is a        specialization, and the other is an instantiation of the same        template, that we do not exit at this point.  That situation        can occur if we instantiate a template class, and then        specialize one of its methods.  This situation is legal, but        the declarations must be merged in the usual way.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|||
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
comment|/* One of the declarations is a template instantiation, and the        other is not a template at all.  That's OK.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* Redeclaration of namespace alias, ignore it. */
return|return
literal|1
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|error
argument_list|(
name|errmsg
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_error_at
argument_list|(
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|namespace_bindings_p
argument_list|()
operator|)
condition|?
literal|"`%#D' previously defined here"
else|:
literal|"`%#D' previously declared here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Prototype decl follows defn w/o prototype.  */
name|cp_warning_at
argument_list|(
literal|"prototype for `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"follows non-prototype definition here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* extern "C" int foo (); 	     int foo () { bar (); } 	     is OK.  */
if|if
condition|(
name|current_lang_depth
argument_list|()
operator|==
literal|0
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"previous declaration of `%#D' with %L linkage"
argument_list|,
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with new declaration with %L linkage"
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|t1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t1
operator|&&
name|t1
operator|!=
name|void_list_node
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
literal|1
operator|==
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"default argument given for parameter %d of `%#D'"
argument_list|,
name|i
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"after previous specification in `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"default argument given for parameter %d of `%#D'"
argument_list|,
name|i
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"after previous specification in `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|warn_inline
condition|)
block|{
name|warning
argument_list|(
literal|"`%#D' was used before it was declared inline"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"previous non-inline declaration here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If new decl is `static' and an `extern' was seen previously,      warn about it.  */
name|warn_extern_redeclared_static
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* We have committed to returning 1 at this point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Now that functions must hold information normally held 	 by field decls, there is extra work to do so that 	 declaration information does not get destroyed during 	 definition.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_VINDEX
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_THIS_STATIC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|newdecl
argument_list|,
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|new_defines_function
operator|=
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
comment|/* Optionally warn about more than one declaration for the same          name, but don't warn about a function declaration followed by a          definition.  */
if|if
condition|(
name|warn_redundant_decls
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|new_defines_function
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
operator|)
comment|/* Don't warn about extern decl followed by definition. */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
comment|/* Don't warn about friends, let add_friend take care of it. */
operator|&&
operator|!
operator|(
name|DECL_FRIEND_P
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"redundant redeclaration of `%D' in same scope"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"previous declaration of `%D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deal with C++: must preserve virtual function table size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|register
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|newtype
operator|!=
name|error_mark_node
operator|&&
name|oldtype
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|newtype
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|oldtype
argument_list|)
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|newtype
argument_list|)
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|newtype
argument_list|)
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
block|}
name|DECL_ORIGINAL_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.  */
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_decl_attributes
call|)
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the new declaration is a definition, update the file and 	 line information on the declaration.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Automatically handles default parameters.  */
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
decl_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|newtype
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If common_type produces a non-typedef type, just use the old type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|newtype
operator|==
name|DECL_ORIGINAL_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|newtype
operator|=
name|oldtype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Do this after calling `common_type' so that default 	 parameters don't confuse us.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pedantic
operator|||
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|flag_exceptions
operator|&&
operator|!
name|comp_except_specs
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%F' throws different exceptions"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"than previous declaration `%F'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
operator|(
name|processing_template_decl
operator|&&
name|uses_template_parms
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|!
operator|(
name|processing_template_decl
operator|&&
name|uses_template_parms
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_SAVED_TREE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the section attribute.          We want to issue an error if the sections conflict but that must be 	 done later in decl_attributes since we are called before attributes 	 are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Keep the old rtl since we can safely use it.  */
name|COPY_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_LIMIT_STACK
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_LIMIT_STACK
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
comment|/* Clean out any memory we had of the old declaration.  */
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|olddecl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
name|TREE_VALUE
argument_list|(
name|oldstatic
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
name|DECL_WEAK
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_WEAK
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_ONE_ONLY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_DEFER_OUTPUT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INTERFACE_KNOWN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_COMDAT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't really know how much of the language-specific 	 values we should copy from old to new.  */
name|DECL_IN_AGGR_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_IN_AGGR_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ACCESS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ACCESS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NONCONVERTING_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_NONCONVERTING_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|olddecl_friend
operator|=
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Only functions have DECL_BEFRIENDING_CLASSES.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|newdecl
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If newdecl is not a specialization, then it is not a 	     template-related function at all.  And that means that we 	     shoud have exited above, returning 0.  */
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|newdecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* From [temp.expl.spec]:  	       If a template, a member template or the member of a class 	       template is explicitly specialized then that 	       specialization shall be declared before the first use of 	       that specialization that would cause an implicit 	       instantiation to take place, in every translation unit in 	       which such a use occurs.  */
name|error
argument_list|(
literal|"explicit specialization of %D after first use"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If either decl says `inline', this fn is inline, unless its          definition was passed already.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|=
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
expr_stmt|;
comment|/* Preserve abstractness on cloned [cd]tors.  */
name|DECL_ABSTRACT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ABSTRACT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|SET_DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|types_match
operator|||
name|new_defines_function
condition|)
block|{
comment|/* These need to be copied so that the names are available. 	     Note that if the types do match, we'll preserve inline 	     info and other bits, but if not, we won't.  */
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_defines_function
condition|)
comment|/* If defining a function declared with other language 	   linkage, use the previously declared language linkage.  */
name|SET_DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* If redeclaring a builtin function, and not a definition, 	     it stays built in.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If we're keeping the built-in definition, keep the rtl, 		 regardless of declaration matches.  */
name|SET_DECL_RTL
argument_list|(
name|newdecl
argument_list|,
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_NUM_STMTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_NUM_STMTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't clear out the arguments if we're redefining a function.  */
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|NAMESPACE_LEVEL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|NAMESPACE_LEVEL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Now preserve various other info from the definition.  */
name|TREE_ADDRESSABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_COMMON
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|function_size
decl_stmt|;
name|function_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
name|function_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If newdecl is a template instantiation, it is possible that 	     the following sequence of events has occurred:  	     o A friend function was declared in a class template.  The 	     class template was instantiated.  	     o The instantiation of the friend declaration was 	     recorded on the instantiation list, and is newdecl.  	     o Later, however, instantiate_class_template called pushdecl 	     on the newdecl to perform name injection.  But, pushdecl in 	     turn called duplicate_decls when it discovered that another 	     declaration of a global function with the same name already 	     existed.  	     o Here, in duplicate_decls, we decided to clobber newdecl.  	     If we're going to do that, we'd better make sure that 	     olddecl, and not newdecl, is on the list of 	     instantiations so that if we try to do the instantiation 	     again we won't get the clobbered declaration.  */
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|decls
init|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|decls
condition|;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
operator|==
name|newdecl
condition|)
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
operator|=
name|olddecl
expr_stmt|;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
if|if
condition|(
name|olddecl_friend
condition|)
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* NEWDECL contains the merged attribute lists.      Update OLDDECL to be the same.  */
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|tree
name|name
decl_stmt|;
name|int
name|need_new_binding
decl_stmt|;
comment|/* We shouldn't be calling pushdecl when we're generating RTL for a      function that we already did semantic analysis on previously.  */
name|my_friendly_assert
argument_list|(
operator|!
name|cfun
operator|||
name|doing_semantic_analysis_p
argument_list|()
argument_list|,
literal|19990913
argument_list|)
expr_stmt|;
name|need_new_binding
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Template parameters have no context; they are not X::T even        when declared within a class or namespace.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
comment|/* A local declaration for a function doesn't constitute              nesting.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|)
comment|/* A local declaration for an `extern' variable is in the 	     scope of the current namespace, not the current 	     function.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* If this is the declaration for a namespace-scope function, 	 but the declaration itself is in a local scope, mark the 	 declaration.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
condition|)
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|int
name|different_binding_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In case this decl was explicitly namespace-qualified, look it 	 up in its namespace context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|namespace_bindings_p
argument_list|()
condition|)
name|t
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* [basic.link] If there is a visible declaration of an entity 	 with linkage having the same name and type, ignoring entities 	 declared outside the innermost enclosing namespace scope, the 	 block scope declaration declares that same entity and 	 receives the linkage of the previous declaration.  */
if|if
condition|(
operator|!
name|t
operator|&&
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Look in block scope.  */
name|t
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Or in the innermost namespace.  */
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Does it have linkage?  Note that if this isn't a DECL, it's an 	     OVERLOAD, which is OK.  */
if|if
condition|(
name|t
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|different_binding_level
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are declaring a function, and the result of name-lookup 	 was an OVERLOAD, look for an overloaded instance that is 	 actually the same as the function we are declaring.  (If 	 there is one, we have to merge our declaration with the 	 previous declaration.)  */
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
name|tree
name|match
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
for|for
control|(
name|match
operator|=
name|t
init|;
name|match
condition|;
name|match
operator|=
name|OVL_NEXT
argument_list|(
name|match
argument_list|)
control|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|OVL_CURRENT
argument_list|(
name|match
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
break|break;
block|}
else|else
comment|/* Just choose one.  */
name|match
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|match
condition|)
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|match
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
comment|/* error_mark_node is 0 for a while during initialization!  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"`%#D' used prior to declaration"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|different_binding_level
condition|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
comment|/* The standard only says that the local extern 		   inherits linkage from the previous decl; in 		   particular, default args are not shared.  It would 		   be nice to propagate inlining info, though.  FIXME.  */
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* This is probaby caused by too many errors, but calling 		   abort will say that if errors have occurred.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Check for duplicate params.  */
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Don't do anything just yet. */
empty_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|wchar_decl_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"redeclaration of `wchar_t' as `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Throw away the redeclaration.  */
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|check_default_args
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* A redeclaration of main, but not a duplicate of the 		 previous one.  		 [basic.start.main]  	         This function shall not be overloaded.  */
name|cp_error_at
argument_list|(
literal|"invalid redeclaration of `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"as `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* We don't try to push this declaration since that 		 causes a crash.  */
return|return
name|x
return|;
block|}
block|}
name|check_template_shadow
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a function conjured up by the backend, massage it 	 so it looks friendly.  */
if|if
condition|(
name|DECL_NON_THUNK_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|retrofit_lang_decl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|x
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NON_THUNK_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|x
condition|)
return|return
name|t
return|;
if|if
condition|(
operator|!
name|namespace_bindings_p
argument_list|()
condition|)
comment|/* We do not need to create a binding for this name; 	       push_overloaded_decl will have already done so if 	       necessary.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_GLOBAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|x
condition|)
name|add_decl_to_level
argument_list|(
name|x
argument_list|,
name|NAMESPACE_LEVEL
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* If declaring a type as a typedef, copy the type (unless we're 	 at line 0), and install this TYPE_DECL as the new type's typedef 	 name.  See the extensive comment in ../c-decl.c (pushdecl). */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|x
comment|/* We don't want to copy the type when all we're 		      doing is making a TYPE_DECL for the purposes of 		      inlining.  */
operator|&&
operator|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|type
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
block|}
comment|/* Multiple external decls of the same identifier ought to match.  	 We get warnings about inline functions where they are defined. 	 We get warnings about other functions from push_overloaded_decl.  	 Avoid duplicate warnings where they are used.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|decl
operator|=
name|OVL_FUNCTION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|decl
operator|!=
name|error_mark_node
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* If different sort of thing, we already gave an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"type mismatch with previous external decl"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"previous external decl of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|namespace_bindings_p
argument_list|()
condition|)
block|{
comment|/* Install a global value.  */
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Bind the name for the entity.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"`%D' was previously implicitly declared to return `int'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If new decl is `static' and an `extern' was seen previously, 	     warn about it.  */
if|if
condition|(
name|x
operator|!=
name|NULL_TREE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
name|warn_extern_redeclared_static
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_new_binding
condition|)
block|{
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Because push_local_binding will hook X on to the 		 current_binding_level's name list, we don't want to 		 do that again below.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a TYPE_DECL, push it into the type value slot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
comment|/* Clear out any TYPE_DECL shadowed by a namespace so that 	     we won't think this is a type.  The C struct hack doesn't 	     go through namespaces.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlocal
condition|)
block|{
name|tree
name|d
init|=
name|oldlocal
decl_stmt|;
while|while
condition|(
name|oldlocal
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|oldlocal
argument_list|)
condition|)
name|oldlocal
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|oldlocal
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
condition|)
name|oldlocal
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
name|decls_match
argument_list|(
name|x
argument_list|,
name|oldglobal
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"extern declaration of `%#D' doesn't match"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"global declaration `%#D'"
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|oldglobal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* Inline decls shadow nothing.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|bool
name|err
init|=
name|false
decl_stmt|;
comment|/* Don't complain if it's from an enclosing function.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* Go to where the parms should be and see if we find 		     them there.  */
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
comment|/* ARM $8.3 */
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%#D' shadows a parameter"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|err
condition|)
name|shadow_warning
argument_list|(
literal|"a parameter"
argument_list|,
name|name
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|current_class_ptr
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"declaration of `%s' shadows a member of `this'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|shadow_warning
argument_list|(
literal|"a previous local"
argument_list|,
name|name
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|VAR_DECL
condition|)
comment|/* XXX shadow warnings in outer-more namespaces */
name|shadow_warning
argument_list|(
literal|"a global declaration"
argument_list|,
name|name
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|check_default_args
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Keep count of variables in this level with incomplete type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
operator|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ARRAY_TYPE
argument_list|)
operator|)
comment|/* RTTI TD entries are created while defining the type_info.  */
operator|||
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|namespace_bindings_p
argument_list|()
condition|)
name|namespace_scope_incomplete
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|namespace_scope_incomplete
argument_list|)
expr_stmt|;
else|else
name|current_binding_level
operator|->
name|incomplete
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|current_binding_level
operator|->
name|incomplete
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_new_binding
condition|)
name|add_decl_to_level
argument_list|(
name|x
argument_list|,
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|?
name|NAMESPACE_LEVEL
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|current_binding_level
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the    caller to set DECL_CONTEXT properly.  */
end_comment

begin_function
specifier|static
name|tree
name|pushdecl_with_scope
parameter_list|(
name|x
parameter_list|,
name|level
parameter_list|)
name|tree
name|x
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|function_decl
init|=
name|current_function_decl
decl_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|b
operator|=
name|class_binding_level
expr_stmt|;
name|class_binding_level
operator|=
name|level
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|level
expr_stmt|;
name|x
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|function_decl
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the current namespace,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_namespace_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|pushdecl_with_scope
argument_list|(
name|x
argument_list|,
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, the type_shadowed stack may screw us.  Munge it so it does      what we want.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|newval
decl_stmt|;
name|tree
modifier|*
name|ptr
init|=
operator|(
name|tree
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
init|;
name|b
operator|!=
name|global_binding_level
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|shadowed
init|=
name|b
operator|->
name|type_shadowed
decl_stmt|;
for|for
control|(
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|name
condition|)
block|{
name|ptr
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
comment|/* Can't break out of the loop here because sometimes 		   a binding level will have duplicate bindings for 		   PT names.  It's gross, but I haven't time to fix it.  */
block|}
block|}
name|newval
operator|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|tree
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* @@ This shouldn't be needed.  My test case "zstring.cc" trips              up here if this is changed to an assertion.  --KR  */
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|=
name|newval
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|push_to_top_level
argument_list|()
expr_stmt|;
name|x
operator|=
name|pushdecl_namespace_level
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Make the declaration of X appear in CLASS scope.  */
end_comment

begin_function
name|void
name|pushdecl_class_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* Don't use DECL_ASSEMBLER_NAME here!  Everything that looks in class      scope looks for the pre-mangled name.  */
specifier|register
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|x
operator|=
name|OVL_CURRENT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
name|pushdecl_class_level
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter DECL into the symbol table, if that's appropriate.  Returns    DECL, or a modified version thereof.  */
end_comment

begin_function
name|tree
name|maybe_push_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Add this decl to the current binding level, but not if it comes      from another scope, e.g. a static member variable.  TEM may equal      DECL or it may be a previous decl of the same name.  */
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
comment|/* Definitions of namespace members outside their namespace are 	     possible. */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|namespace_bindings_p
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNKNOWN_TYPE
comment|/* The declaration of a template specialization does not affect 	 the functions available for overload resolution, so we do not 	 call pushdecl.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|decl
return|;
else|else
return|return
name|pushdecl
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make the declaration(s) of X appear in CLASS scope    under the name NAME.  */
end_comment

begin_function
name|void
name|push_class_level_binding
parameter_list|(
name|name
parameter_list|,
name|x
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|binding
decl_stmt|;
comment|/* The class_binding_level will be NULL if x is a template      parameter name in a member template.  */
if|if
condition|(
operator|!
name|class_binding_level
condition|)
return|return;
comment|/* Make sure that this new member does not have the same name      as a template parameter.  */
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|check_template_shadow
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this declaration shadows a declaration from an enclosing      class, then we will need to restore IDENTIFIER_CLASS_VALUE when      we leave this class.  Record the shadowed declaration here.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|)
operator|||
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|)
condition|)
block|{
name|tree
name|shadow
decl_stmt|;
name|tree
name|old_decl
decl_stmt|;
comment|/* If the old binding was from a base class, and was for a tag 	 name, slide it over to make room for the new binding.  The 	 old binding is still visible if explicitly qualified with a 	 class-key.  */
if|if
condition|(
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|&&
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|old_decl
operator|=
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|old_decl
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
comment|/* Find the previous binding of name on the class-shadowed          list, and update it.  */
for|for
control|(
name|shadow
operator|=
name|class_binding_level
operator|->
name|class_shadowed
init|;
name|shadow
condition|;
name|shadow
operator|=
name|TREE_CHAIN
argument_list|(
name|shadow
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadow
argument_list|)
operator|==
name|name
operator|&&
name|TREE_TYPE
argument_list|(
name|shadow
argument_list|)
operator|==
name|old_decl
condition|)
block|{
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|x
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|shadow
argument_list|)
operator|=
name|x
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we didn't replace an existing binding, put the binding on the      stack of bindings for the identifier, and update the shadowed list.  */
if|if
condition|(
name|push_class_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
comment|/* Record the value we are binding NAME to so that we can know 	 what to pop later.  */
name|TREE_TYPE
argument_list|(
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert another USING_DECL into the current binding level, returning    this declaration. If this is a redeclaration, do nothing, and    return NULL_TREE if this not in namespace scope (in namespace    scope, a using decl might extend any previous bindings).  */
end_comment

begin_function
name|tree
name|push_using_decl
parameter_list|(
name|scope
parameter_list|,
name|name
parameter_list|)
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|383
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|384
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|usings
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|scope
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|name
condition|)
break|break;
if|if
condition|(
name|decl
condition|)
return|return
name|namespace_bindings_p
argument_list|()
condition|?
name|decl
else|:
name|NULL_TREE
return|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|USING_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|scope
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_binding_level
operator|->
name|usings
expr_stmt|;
name|current_binding_level
operator|->
name|usings
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Add namespace to using_directives. Return NULL_TREE if nothing was    changed (i.e. there was already a directive), or the fresh    TREE_LIST otherwise.  */
end_comment

begin_function
name|tree
name|push_using_directive
parameter_list|(
name|used
parameter_list|)
name|tree
name|used
decl_stmt|;
block|{
name|tree
name|ud
init|=
name|current_binding_level
operator|->
name|using_directives
decl_stmt|;
name|tree
name|iter
decl_stmt|,
name|ancestor
decl_stmt|;
comment|/* Check if we already have this. */
if|if
condition|(
name|purpose_member
argument_list|(
name|used
argument_list|,
name|ud
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Recursively add all namespaces used. */
for|for
control|(
name|iter
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|used
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
name|push_using_directive
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|ancestor
operator|=
name|namespace_ancestor
argument_list|(
name|current_decl_namespace
argument_list|()
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ud
operator|=
name|current_binding_level
operator|->
name|using_directives
expr_stmt|;
name|ud
operator|=
name|tree_cons
argument_list|(
name|used
argument_list|,
name|ancestor
argument_list|,
name|ud
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|using_directives
operator|=
name|ud
expr_stmt|;
return|return
name|ud
return|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL for a non-member function, which may have    other definitions already in place.  We get around this by making    the value of the identifier point to a list of all the things that    want to be referenced by that name.  It is then up to the users of    that name to decide what to do with that list.     DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its    DECL_TEMPLATE_RESULT.  It is dealt with the same way.     FLAGS is a bitwise-or of the following values:      PUSH_LOCAL: Bind DECL in the current scope, rather than at                  namespace scope.      PUSH_USING: DECL is being pushed as the result of a using                  declaration.     The value returned may be a previous declaration if we guessed wrong    about what language DECL should belong to (C or C++).  Otherwise,    it's always DECL (and never something that's not a _DECL).  */
end_comment

begin_function
name|tree
name|push_overloaded_decl
parameter_list|(
name|decl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|old
decl_stmt|;
name|tree
name|new_binding
decl_stmt|;
name|int
name|doing_global
init|=
operator|(
name|namespace_bindings_p
argument_list|()
operator|||
operator|!
operator|(
name|flags
operator|&
name|PUSH_LOCAL
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|old
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|warn_shadow
operator|&&
operator|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|old
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"`%#D' hides constructor for `%#T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|old
init|;
name|tmp
condition|;
name|tmp
operator|=
name|OVL_NEXT
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|OVL_USED
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%#D' conflicts with previous using declaration `%#D'"
argument_list|,
name|decl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|old
operator|==
name|error_mark_node
condition|)
comment|/* Ignore the undefined symbol marker.  */
name|old
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"previous non-function declaration `%#D'"
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with function declaration `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
if|if
condition|(
name|old
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|ovl_cons
argument_list|(
name|old
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PUSH_USING
condition|)
name|OVL_USED
argument_list|(
name|new_binding
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* NAME is not ambiguous.  */
name|new_binding
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|set_namespace_binding
argument_list|(
name|name
argument_list|,
name|current_namespace
argument_list|,
name|new_binding
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We only create an OVERLOAD if there was a previous binding at 	 this level, or if decl is a template. In the former case, we 	 need to remove the old binding and replace it with the new 	 binding.  We must also run through the NAMES on the binding 	 level where the name was bound to update the chain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_binding
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|old
condition|)
block|{
name|tree
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|BINDING_LEVEL
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
operator|->
name|names
init|;
operator|*
name|d
condition|;
name|d
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
control|)
if|if
condition|(
operator|*
name|d
operator|==
name|old
operator|||
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|old
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* Just replace the old binding with the new.  */
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|=
name|new_binding
expr_stmt|;
else|else
comment|/* Build a TREE_LIST to wrap the OVERLOAD.  */
operator|*
name|d
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_binding
argument_list|,
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And update the CPLUS_BINDING node.  */
name|BINDING_VALUE
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
operator|=
name|new_binding
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* We should always find a previous binding in this case.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Install the new binding.  */
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|new_binding
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ISO standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_implicit
comment|/* Only one warning per identifier.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"implicit declaration of function `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Because C++ can put things into name space for free, 	 constructs like "typedef struct foo { ... } foo" 	 would look like an erroneous redeclaration.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|"redefinition of `%#D'"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If this is a pure function, its olddecl will actually be 	 the original initialization to `0' (which we force to call 	 abort()).  Don't complain about redefinition in this case.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If both functions come from different namespaces, this is not 	 a redeclaration - this is a conflict with a used function. */
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"`%D' conflicts with used function"
return|;
comment|/* We'll complain about linkage mismatches in          warn_extern_redeclared_static.  */
comment|/* Defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|"`%#D' not declared in class"
return|;
else|else
return|return
literal|"redefinition of `%#D'"
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|"redefinition of `%#D'"
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
operator|||
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject two definitions.  */
return|return
literal|"redefinition of `%#D'"
return|;
block|}
else|else
block|{
comment|/* Objects declared with block scope:  */
comment|/* Reject two definitions, and reject a definition 	 together with an external reference.  */
if|if
condition|(
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|"redeclaration of `%#D'"
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new label, named ID.  */
end_comment

begin_function
specifier|static
name|tree
name|make_label_decl
parameter_list|(
name|id
parameter_list|,
name|local_p
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|local_p
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanding_p
condition|)
comment|/* Make sure every label has an rtx.  */
name|label_rtx
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
operator|=
name|local_p
expr_stmt|;
comment|/* Say where one reference is to the label, for the sake of the      error if it is not defined.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
comment|/* Record the fact that this identifier is bound to this label.  */
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Record this label on the list of used labels so that we can check    at the end of the function to see whether or not the label was    actually defined, and so we can check when the label is defined whether    this use is valid.  */
end_comment

begin_function
specifier|static
name|void
name|use_label
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|named_label_uses
operator|==
name|NULL
operator|||
name|named_label_uses
operator|->
name|names_in_scope
operator|!=
name|current_binding_level
operator|->
name|names
operator|||
name|named_label_uses
operator|->
name|label_decl
operator|!=
name|decl
condition|)
block|{
name|struct
name|named_label_use_list
modifier|*
name|new_ent
decl_stmt|;
name|new_ent
operator|=
operator|(
operator|(
expr|struct
name|named_label_use_list
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|named_label_use_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|new_ent
operator|->
name|label_decl
operator|=
name|decl
expr_stmt|;
name|new_ent
operator|->
name|names_in_scope
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|new_ent
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|new_ent
operator|->
name|lineno_o_goto
operator|=
name|lineno
expr_stmt|;
name|new_ent
operator|->
name|filename_o_goto
operator|=
name|input_filename
expr_stmt|;
name|new_ent
operator|->
name|next
operator|=
name|named_label_uses
expr_stmt|;
name|named_label_uses
operator|=
name|new_ent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look for a label named ID in the current function.  If one cannot    be found, create one.  (We keep track of used, but undefined,    labels, and complain about them at the end of a function.)  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|struct
name|named_label_list
modifier|*
name|ent
decl_stmt|;
comment|/* You can't use labels at global scope.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"label `%s' referenced outside of any function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* See if we've already got this label.  */
name|decl
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
condition|)
return|return
name|decl
return|;
comment|/* Record this label on the list of labels used in this function.      We do this before calling make_label_decl so that we get the      IDENTIFIER_LABEL_VALUE before the new label is declared.  */
name|ent
operator|=
operator|(
operator|(
expr|struct
name|named_label_list
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|named_label_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ent
operator|->
name|old_value
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|named_labels
expr_stmt|;
name|named_labels
operator|=
name|ent
expr_stmt|;
comment|/* We need a new label.  */
name|decl
operator|=
name|make_label_decl
argument_list|(
name|id
argument_list|,
comment|/*local_p=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Now fill in the information we didn't have before.  */
name|ent
operator|->
name|label_decl
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Declare a local label named ID.  */
end_comment

begin_function
name|tree
name|declare_local_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Add a new entry to the SHADOWED_LABELS list so that when we leave      this scope we can restore the old value of      IDENTIFIER_TYPE_VALUE.  */
name|current_binding_level
operator|->
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|current_binding_level
operator|->
name|shadowed_labels
argument_list|)
expr_stmt|;
comment|/* Look for the label.  */
name|decl
operator|=
name|make_label_decl
argument_list|(
name|id
argument_list|,
comment|/*local_p=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Now fill in the information we didn't have before.  */
name|TREE_VALUE
argument_list|(
name|current_binding_level
operator|->
name|shadowed_labels
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it is ill-formed to jump past the declaration of    DECL.  Returns 2 if it's also a real problem.  */
end_comment

begin_function
specifier|static
name|int
name|decl_jump_unsafe
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|pod_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This is really only important if we're crossing an initialization.      The POD stuff is just pedantry; why should it matter if the class      contains a field of pointer to member type?  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check that a single previously seen jump to a newly defined label    is OK.  DECL is the LABEL_DECL or 0; LEVEL is the binding_level for    the jump context; NAMES are the names in scope in LEVEL at the jump    context; FILE and LINE are the source position of the jump or 0.  */
end_comment

begin_function
specifier|static
name|void
name|check_previous_goto_1
parameter_list|(
name|decl
parameter_list|,
name|level
parameter_list|,
name|names
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
name|tree
name|names
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|identified
init|=
literal|0
decl_stmt|;
name|int
name|saw_eh
init|=
literal|0
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|new_decls
init|=
name|b
operator|->
name|names
decl_stmt|;
name|tree
name|old_decls
init|=
operator|(
name|b
operator|==
name|level
condition|?
name|names
else|:
name|NULL_TREE
operator|)
decl_stmt|;
for|for
control|(
init|;
name|new_decls
operator|!=
name|old_decls
condition|;
name|new_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|new_decls
argument_list|)
control|)
block|{
name|int
name|problem
init|=
name|decl_jump_unsafe
argument_list|(
name|new_decls
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|problem
condition|)
continue|continue;
if|if
condition|(
operator|!
name|identified
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|pedwarn
argument_list|(
literal|"jump to label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"jump to case label"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|pedwarn_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"  from here"
argument_list|)
expr_stmt|;
name|identified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|problem
operator|>
literal|1
condition|)
name|cp_error_at
argument_list|(
literal|"  crosses initialization of `%#D'"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn_at
argument_list|(
literal|"  enters scope of non-POD `%#D'"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
name|level
condition|)
break|break;
if|if
condition|(
operator|(
name|b
operator|->
name|is_try_scope
operator|||
name|b
operator|->
name|is_catch_scope
operator|)
operator|&&
operator|!
name|saw_eh
condition|)
block|{
if|if
condition|(
operator|!
name|identified
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|pedwarn
argument_list|(
literal|"jump to label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"jump to case label"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|pedwarn_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"  from here"
argument_list|)
expr_stmt|;
name|identified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|is_try_scope
condition|)
name|error
argument_list|(
literal|"  enters try block"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"  enters catch block"
argument_list|)
expr_stmt|;
name|saw_eh
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_previous_goto
parameter_list|(
name|use
parameter_list|)
name|struct
name|named_label_use_list
modifier|*
name|use
decl_stmt|;
block|{
name|check_previous_goto_1
argument_list|(
name|use
operator|->
name|label_decl
argument_list|,
name|use
operator|->
name|binding_level
argument_list|,
name|use
operator|->
name|names_in_scope
argument_list|,
name|use
operator|->
name|filename_o_goto
argument_list|,
name|use
operator|->
name|lineno_o_goto
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_switch_goto
parameter_list|(
name|level
parameter_list|)
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
block|{
name|check_previous_goto_1
argument_list|(
name|NULL_TREE
argument_list|,
name|level
argument_list|,
name|level
operator|->
name|names
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that any previously seen jumps to a newly defined label DECL    are OK.  Called by define_label.  */
end_comment

begin_function
specifier|static
name|void
name|check_previous_gotos
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|named_label_use_list
modifier|*
modifier|*
name|usep
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
for|for
control|(
name|usep
operator|=
operator|&
name|named_label_uses
init|;
operator|*
name|usep
condition|;
control|)
block|{
name|struct
name|named_label_use_list
modifier|*
name|use
init|=
operator|*
name|usep
decl_stmt|;
if|if
condition|(
name|use
operator|->
name|label_decl
operator|==
name|decl
condition|)
block|{
name|check_previous_goto
argument_list|(
name|use
argument_list|)
expr_stmt|;
operator|*
name|usep
operator|=
name|use
operator|->
name|next
expr_stmt|;
block|}
else|else
name|usep
operator|=
operator|&
operator|(
name|use
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check that a new jump to a label DECL is OK.  Called by    finish_goto_stmt.  */
end_comment

begin_function
name|void
name|check_goto
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|identified
init|=
literal|0
decl_stmt|;
name|tree
name|bad
decl_stmt|;
name|struct
name|named_label_list
modifier|*
name|lab
decl_stmt|;
comment|/* We can't know where a computed goto is jumping.  So we assume      that it's OK.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If the label hasn't been defined yet, defer checking.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|use_label
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|lab
operator|=
name|named_labels
init|;
name|lab
condition|;
name|lab
operator|=
name|lab
operator|->
name|next
control|)
if|if
condition|(
name|decl
operator|==
name|lab
operator|->
name|label_decl
condition|)
break|break;
comment|/* If the label is not on named_labels it's a gcc local label, so      it must be in an outer scope, so jumping to it is always OK.  */
if|if
condition|(
name|lab
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|lab
operator|->
name|in_try_scope
operator|||
name|lab
operator|->
name|in_catch_scope
operator|||
name|lab
operator|->
name|bad_decls
operator|)
operator|&&
operator|!
name|identified
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"jump to label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"  from here"
argument_list|)
expr_stmt|;
name|identified
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|bad
operator|=
name|lab
operator|->
name|bad_decls
init|;
name|bad
condition|;
name|bad
operator|=
name|TREE_CHAIN
argument_list|(
name|bad
argument_list|)
control|)
block|{
name|tree
name|b
init|=
name|TREE_VALUE
argument_list|(
name|bad
argument_list|)
decl_stmt|;
name|int
name|u
init|=
name|decl_jump_unsafe
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|>
literal|1
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|b
argument_list|)
condition|)
comment|/* Can't skip init of __exception_info.  */
name|cp_error_at
argument_list|(
literal|"  enters catch block"
argument_list|,
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|>
literal|1
condition|)
name|cp_error_at
argument_list|(
literal|"  skips initialization of `%#D'"
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn_at
argument_list|(
literal|"  enters scope of non-POD `%#D'"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lab
operator|->
name|in_try_scope
condition|)
name|error
argument_list|(
literal|"  enters try block"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lab
operator|->
name|in_catch_scope
condition|)
name|error
argument_list|(
literal|"  enters catch block"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|named_label_list
modifier|*
name|ent
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|named_labels
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|label_decl
operator|==
name|decl
condition|)
break|break;
comment|/* After labels, make any new cleanups in the function go into their      own new (temporary) binding contour.  */
for|for
control|(
name|p
operator|=
name|current_binding_level
init|;
operator|!
operator|(
name|p
operator|->
name|parm_flag
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|level_chain
control|)
name|p
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|get_identifier
argument_list|(
literal|"wchar_t"
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"label named wchar_t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"duplicate label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Say where in the source.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|ent
condition|)
block|{
name|ent
operator|->
name|names_in_scope
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|ent
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
block|}
name|check_previous_gotos
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|cp_switch
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
name|struct
name|cp_switch
modifier|*
name|next
decl_stmt|;
comment|/* The SWITCH_STMT being built.  */
name|tree
name|switch_stmt
decl_stmt|;
comment|/* A splay-tree mapping the low element of a case range to the high      element, or NULL_TREE if there is no high element.  Used to      determine whether or not a new case label duplicates an old case      label.  We need a tree, rather than simply a hash table, because      of the GNU case range extension.  */
name|splay_tree
name|cases
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A stack of the currently active switch statements.  The innermost    switch statement is on the top of the stack.  There is no need to    mark the stack for garbage collection because it is only active    during the processing of the body of a function, and we never    collect at that point.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cp_switch
modifier|*
name|switch_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called right after a switch-statement condition is parsed.    SWITCH_STMT is the switch statement being parsed.  */
end_comment

begin_function
name|void
name|push_switch
parameter_list|(
name|switch_stmt
parameter_list|)
name|tree
name|switch_stmt
decl_stmt|;
block|{
name|struct
name|cp_switch
modifier|*
name|p
init|=
operator|(
expr|struct
name|cp_switch
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cp_switch
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|level
operator|=
name|current_binding_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|switch_stack
expr_stmt|;
name|p
operator|->
name|switch_stmt
operator|=
name|switch_stmt
expr_stmt|;
name|p
operator|->
name|cases
operator|=
name|splay_tree_new
argument_list|(
name|case_compare
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|switch_stack
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_switch
parameter_list|()
block|{
name|struct
name|cp_switch
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|switch_stack
expr_stmt|;
name|splay_tree_delete
argument_list|(
name|cs
operator|->
name|cases
argument_list|)
expr_stmt|;
name|switch_stack
operator|=
name|switch_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that we've seen a definition of a case label, and complain if this    is a bad place for one.  */
end_comment

begin_function
name|tree
name|finish_case_label
parameter_list|(
name|low_value
parameter_list|,
name|high_value
parameter_list|)
name|tree
name|low_value
decl_stmt|;
name|tree
name|high_value
decl_stmt|;
block|{
name|tree
name|cond
decl_stmt|,
name|r
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|switch_stack
condition|)
block|{
if|if
condition|(
name|high_value
condition|)
name|error
argument_list|(
literal|"case label not within a switch statement"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|low_value
condition|)
name|error
argument_list|(
literal|"case label `%E' not within a switch statement"
argument_list|,
name|low_value
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`default' label not within a switch statement"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|label
decl_stmt|;
comment|/* For templates, just add the case label; we'll do semantic 	 analysis at instantiation-time.  */
name|label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|,
name|label
argument_list|)
argument_list|)
return|;
block|}
comment|/* Find the condition on which this switch statement depends.  */
name|cond
operator|=
name|SWITCH_COND
argument_list|(
name|switch_stack
operator|->
name|switch_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|cond
operator|=
name|TREE_VALUE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|r
operator|=
name|c_add_case_label
argument_list|(
name|switch_stack
operator|->
name|cases
argument_list|,
name|cond
argument_list|,
name|low_value
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|error_mark_node
condition|)
name|r
operator|=
name|NULL_TREE
expr_stmt|;
name|check_switch_goto
argument_list|(
name|switch_stack
operator|->
name|level
argument_list|)
expr_stmt|;
comment|/* After labels, make any new cleanups in the function go into their      own new (temporary) binding contour.  */
for|for
control|(
name|p
operator|=
name|current_binding_level
init|;
operator|!
operator|(
name|p
operator|->
name|parm_flag
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|level_chain
control|)
name|p
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    FORM says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, and it's not a template, an error is    reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|form
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|form
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
comment|/* Non-zero if, we should look past a template parameter level, even      if THISLEVEL_ONLY.  */
name|int
name|allow_template_parms_p
init|=
literal|1
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
comment|/* There's no need for error checking here, because 	       anon names are unique throughout the compilation.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|level
operator|->
name|namespace_p
condition|)
comment|/* Do namespace lookup. */
for|for
control|(
name|tail
operator|=
name|current_namespace
init|;
literal|1
condition|;
name|tail
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|tree
name|old
init|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|tail
argument_list|)
decl_stmt|;
comment|/* If we just skipped past a template parameter level, 	       even though THISLEVEL_ONLY, and we find a template 	       class declaration, then we use the _TYPE node for the 	       template.  See the example below.  */
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|allow_template_parms_p
operator|&&
name|old
operator|&&
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
name|old
operator|=
name|TREE_TYPE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
name|BINDING_TYPE
argument_list|(
name|old
argument_list|)
expr_stmt|;
comment|/* If it has an original type, it is a typedef, and we 	       should not return it.  */
if|if
condition|(
name|old
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
name|old
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|form
operator|&&
operator|!
operator|(
name|form
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%#D' redeclared as %C"
argument_list|,
name|old
argument_list|,
name|form
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|old
condition|)
return|return
name|old
return|;
if|if
condition|(
name|thislevel_only
operator|||
name|tail
operator|==
name|global_namespace
condition|)
return|return
name|NULL_TREE
return|;
block|}
else|else
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Should tighten this up; it'll probably permit 		   UNION_TYPE and a struct template, for example.  */
if|if
condition|(
name|code
operator|!=
name|form
operator|&&
operator|!
operator|(
name|form
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|code
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|error
argument_list|(
literal|"`%#D' redeclared as %C"
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|level
operator|->
name|tag_transparent
condition|)
block|{
if|if
condition|(
name|level
operator|->
name|template_parms_p
operator|&&
name|allow_template_parms_p
condition|)
block|{
comment|/* We must deal with cases like this:  	           template<class T> struct S; 		   template<class T> struct S {};  		 When looking up `S', for the second declaration, we 		 would like to find the first declaration.  But, we 		 are in the pseudo-global level created for the 		 template parameters, rather than the (surrounding) 		 namespace level.  Thus, we keep going one more level, 		 even though THISLEVEL_ONLY is non-zero.  */
name|allow_template_parms_p
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void set_current_level_tags_transparency (tags_transparent)      int tags_transparent; {   current_binding_level->tag_transparent = tags_transparent; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  However, the value can never be 0    in the cases in which this is used.     C++: If NAME is non-zero, this is the new name to install.  This is    done when replacing anonymous tags with real tag names.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up NAME in the NAMESPACE.  */
end_comment

begin_function
name|tree
name|lookup_namespace_name
parameter_list|(
name|namespace
parameter_list|,
name|name
parameter_list|)
name|tree
name|namespace
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|template_id
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|370
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
comment|/* This happens for A::B<int> when B is a namespace. */
return|return
name|name
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This happens for A::B where B is a template, and there are no 	 template arguments.  */
name|error
argument_list|(
literal|"invalid use of `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|template_id
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|373
argument_list|)
expr_stmt|;
name|val
operator|=
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|namespace
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|val
operator|=
name|BINDING_VALUE
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_id
condition|)
block|{
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|lookup_template_class
argument_list|(
name|val
argument_list|,
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
argument_list|,
comment|/*in_decl=*/
name|NULL_TREE
argument_list|,
comment|/*context=*/
name|NULL_TREE
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|val
operator|=
name|lookup_template_function
argument_list|(
name|val
argument_list|,
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"`%D::%D' is not a template"
argument_list|,
name|namespace
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* If we have a single function from a using decl, pull it out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|OVL_FUNCTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|error
argument_list|(
literal|"`%D' undeclared in namespace `%D'"
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|typename_hash
parameter_list|(
name|k
parameter_list|)
name|hash_table_key
name|k
decl_stmt|;
block|{
name|unsigned
name|long
name|hash
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|k
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|)
operator|^
operator|(
operator|(
name|unsigned
name|long
operator|)
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */
end_comment

begin_function
specifier|static
name|bool
name|typename_compare
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|)
name|hash_table_key
name|k1
decl_stmt|;
name|hash_table_key
name|k2
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
name|tree
name|d1
decl_stmt|;
name|tree
name|d2
decl_stmt|;
name|t1
operator|=
operator|(
name|tree
operator|)
name|k1
expr_stmt|;
name|t2
operator|=
operator|(
name|tree
operator|)
name|k2
expr_stmt|;
name|d1
operator|=
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
expr_stmt|;
return|return
operator|(
name|DECL_NAME
argument_list|(
name|d1
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|d2
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|==
operator|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is    the type of `T', NAME is the IDENTIFIER_NODE for `t'.  If BASE_TYPE    is non-NULL, this type is being created by the implicit typename    extension, and BASE_TYPE is a type named `t' in some base class of    `T' which depends on template parameters.     Returns the new TYPENAME_TYPE.  */
end_comment

begin_function
name|tree
name|build_typename_type
parameter_list|(
name|context
parameter_list|,
name|name
parameter_list|,
name|fullname
parameter_list|,
name|base_type
parameter_list|)
name|tree
name|context
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|fullname
decl_stmt|;
name|tree
name|base_type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|d
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|e
decl_stmt|;
specifier|static
name|struct
name|hash_table
name|ht
decl_stmt|;
if|if
condition|(
operator|!
name|ht
operator|.
name|table
condition|)
block|{
specifier|static
name|struct
name|hash_table
modifier|*
name|h
init|=
operator|&
name|ht
decl_stmt|;
name|hash_table_init
argument_list|(
operator|&
name|ht
argument_list|,
operator|&
name|hash_newfunc
argument_list|,
operator|&
name|typename_hash
argument_list|,
operator|&
name|typename_compare
argument_list|)
expr_stmt|;
name|ggc_add_tree_hash_table_root
argument_list|(
operator|&
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Build the TYPENAME_TYPE.  */
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TYPENAME_TYPE
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
operator|=
name|fullname
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|base_type
expr_stmt|;
comment|/* Build the corresponding TYPE_DECL.  */
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* See if we already have this type.  */
name|e
operator|=
name|hash_lookup
argument_list|(
operator|&
name|ht
argument_list|,
name|t
argument_list|,
comment|/*create=*/
name|false
argument_list|,
comment|/*copy=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|t
operator|=
operator|(
name|tree
operator|)
name|e
operator|->
name|key
expr_stmt|;
else|else
comment|/* Insert the type into the table.  */
name|hash_lookup
argument_list|(
operator|&
name|ht
argument_list|,
name|t
argument_list|,
comment|/*create=*/
name|true
argument_list|,
comment|/*copy=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Resolve `typename CONTEXT::NAME'.  Returns an appropriate type,    unless an error occurs, in which case error_mark_node is returned.    If COMPLAIN zero, don't complain about any errors that occur.  */
end_comment

begin_function
name|tree
name|make_typename_type
parameter_list|(
name|context
parameter_list|,
name|name
parameter_list|,
name|complain
parameter_list|)
name|tree
name|context
decl_stmt|,
name|name
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|fullname
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|name
argument_list|)
operator|||
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|name
argument_list|)
operator|)
operator|)
condition|)
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* Create a TEMPLATE_ID_EXPR for the type.  */
name|name
operator|=
name|build_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|name
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|fullname
argument_list|,
literal|0
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"`%D' used without template parameters"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
comment|/* We can get here from typename_sub0 in the explicit_template_type 	 expansion.  Just fail.  */
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no class template named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|context
argument_list|)
operator|||
name|currently_open_class
argument_list|(
name|context
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fullname
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
name|tmpl
operator|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpl
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no class template named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|lookup_template_class
argument_list|(
name|tmpl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fullname
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|context
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no type named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|t
operator|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
comment|/* If the CONTEXT is not a template type, then either the field is      there now or its never going to be.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|context
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no type named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_typename_type
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
name|fullname
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resolve `CONTEXT::template NAME'.  Returns an appropriate type,    unless an error occurs, in which case error_mark_node is returned.    If COMPLAIN zero, don't complain about any errors that occur.  */
end_comment

begin_function
name|tree
name|make_unbound_class_template
parameter_list|(
name|context
parameter_list|,
name|name
parameter_list|,
name|complain
parameter_list|)
name|tree
name|context
decl_stmt|,
name|name
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|context
argument_list|)
operator|||
name|currently_open_class
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
name|tmpl
operator|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpl
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no class template named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|enforce_access
argument_list|(
name|context
argument_list|,
name|tmpl
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|tmpl
return|;
block|}
comment|/* Build the UNBOUND_CLASS_TEMPLATE.  */
name|t
operator|=
name|make_aggr_type
argument_list|(
name|UNBOUND_CLASS_TEMPLATE
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Build the corresponding TEMPLATE_DECL.  */
name|d
operator|=
name|build_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Select the right _DECL from multiple choices. */
end_comment

begin_function
specifier|static
name|tree
name|select_decl
parameter_list|(
name|binding
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binding
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
name|val
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
comment|/* When we implicitly declare some builtin entity, we mark it      DECL_ANTICIPATED, so that we know to ignore it until it is      really declared.  */
if|if
condition|(
name|val
operator|&&
name|DECL_P
argument_list|(
name|val
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|val
argument_list|)
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
block|{
comment|/* We are not interested in types. */
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|val
return|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* If we could have a type and      we have nothing or we need a type and have none.  */
if|if
condition|(
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|&&
operator|(
operator|!
name|val
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|)
condition|)
name|val
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't return non-types if we really prefer types. */
elseif|else
if|if
condition|(
name|val
operator|&&
name|LOOKUP_TYPES_ONLY
argument_list|(
name|flags
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Unscoped lookup of a global: iterate over current namespaces,    considering using-directives.  If SPACESP is non-NULL, store a list    of the namespaces we've considered in it.  */
end_comment

begin_function
name|tree
name|unqualified_namespace_lookup
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|spacesp
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
modifier|*
name|spacesp
decl_stmt|;
block|{
name|tree
name|b
init|=
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
decl_stmt|;
name|tree
name|initial
init|=
name|current_decl_namespace
argument_list|()
decl_stmt|;
name|tree
name|scope
init|=
name|initial
decl_stmt|;
name|tree
name|siter
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|spacesp
condition|)
operator|*
name|spacesp
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
init|;
operator|!
name|val
condition|;
name|scope
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
control|)
block|{
if|if
condition|(
name|spacesp
condition|)
operator|*
name|spacesp
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
operator|*
name|spacesp
argument_list|)
expr_stmt|;
name|val
operator|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|/* Initialize binding for this context. */
name|BINDING_VALUE
argument_list|(
name|b
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|b
argument_list|)
operator|=
name|BINDING_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Add all _DECLs seen through local using-directives. */
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
operator|!
name|level
operator|->
name|namespace_p
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|b
argument_list|,
name|level
operator|->
name|using_directives
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|,
name|spacesp
argument_list|)
condition|)
comment|/* Give up because of error. */
return|return
name|error_mark_node
return|;
comment|/* Add all _DECLs seen through global using-directives. */
comment|/* XXX local and global using lists should work equally. */
name|siter
operator|=
name|initial
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|b
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|siter
argument_list|)
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|,
name|spacesp
argument_list|)
condition|)
comment|/* Give up because of error. */
return|return
name|error_mark_node
return|;
if|if
condition|(
name|siter
operator|==
name|scope
condition|)
break|break;
name|siter
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|siter
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|select_decl
argument_list|(
name|b
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|global_namespace
condition|)
break|break;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Combine prefer_type and namespaces_only into flags.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_flags
parameter_list|(
name|prefer_type
parameter_list|,
name|namespaces_only
parameter_list|)
name|int
name|prefer_type
decl_stmt|,
name|namespaces_only
decl_stmt|;
block|{
if|if
condition|(
name|namespaces_only
condition|)
return|return
name|LOOKUP_PREFER_NAMESPACES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|1
condition|)
return|return
name|LOOKUP_PREFER_TYPES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|0
condition|)
return|return
name|LOOKUP_PREFER_BOTH
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a lookup that returned VAL, use FLAGS to decide if we want to    ignore it or not.  Subroutine of lookup_name_real.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_lookup
parameter_list|(
name|val
parameter_list|,
name|flags
parameter_list|)
name|tree
name|val
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
return|return
name|val
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_NAMESPACES
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|val
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOOKUP_TEMPLATES_EXPECTED
operator|)
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|)
operator|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|flags
operator|&
operator|(
name|LOOKUP_PREFER_NAMESPACES
operator||
name|LOOKUP_PREFER_TYPES
operator|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Any other BINDING overrides an implicit TYPENAME.  Warn about    that.  */
end_comment

begin_function
specifier|static
name|void
name|warn_about_implicit_typename_lookup
parameter_list|(
name|typename
parameter_list|,
name|binding
parameter_list|)
name|tree
name|typename
decl_stmt|;
name|tree
name|binding
decl_stmt|;
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|typename
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|typename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|binding
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|subtype
argument_list|)
operator|&&
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|subtype
argument_list|)
operator|==
name|binding
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|binding
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|binding
argument_list|)
argument_list|,
name|subtype
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"lookup of `%D' finds `%#D'"
argument_list|,
name|name
argument_list|,
name|binding
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  instead of `%D' from dependent base class"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  (use `typename %T::%D' if that's what you meant)"
argument_list|,
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look up NAME in the current binding level and its superiors in the    namespace of variables, functions and typedefs.  Return a ..._DECL    node of some kind representing its definition if there is only one    such declaration, or return a TREE_LIST with all the overloaded    definitions if there are many, or return 0 if it is undefined.     If PREFER_TYPE is> 0, we prefer TYPE_DECLs or namespaces.    If PREFER_TYPE is> 1, we reject non-type decls (e.g. namespaces).    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)    Otherwise we prefer non-TYPE_DECLs.     If NONCLASS is non-zero, we don't look for the NAME in class scope,    using IDENTIFIER_CLASS_VALUE.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_real
parameter_list|(
name|name
parameter_list|,
name|prefer_type
parameter_list|,
name|nonclass
parameter_list|,
name|namespaces_only
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|prefer_type
decl_stmt|,
name|nonclass
decl_stmt|,
name|namespaces_only
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|yylex
init|=
literal|0
decl_stmt|;
name|tree
name|from_obj
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|val_is_implicit_typename
init|=
literal|0
decl_stmt|;
comment|/* Hack: copy flag set by parser, if set. */
if|if
condition|(
name|only_namespace_names
condition|)
name|namespaces_only
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prefer_type
operator|==
operator|-
literal|2
condition|)
block|{
specifier|extern
name|int
name|looking_for_typename
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|yylex
operator|=
literal|1
expr_stmt|;
name|prefer_type
operator|=
name|looking_for_typename
expr_stmt|;
name|flags
operator|=
name|lookup_flags
argument_list|(
name|prefer_type
argument_list|,
name|namespaces_only
argument_list|)
expr_stmt|;
comment|/* If the next thing is '<', class templates are types. */
if|if
condition|(
name|looking_for_template
condition|)
name|flags
operator||=
name|LOOKUP_TEMPLATES_EXPECTED
expr_stmt|;
if|if
condition|(
name|got_scope
condition|)
name|type
operator|=
name|got_scope
expr_stmt|;
elseif|else
if|if
condition|(
name|got_object
operator|!=
name|error_mark_node
condition|)
name|type
operator|=
name|got_object
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|type
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|val
operator|=
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_COMPLAIN
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|val
operator|=
name|select_decl
argument_list|(
name|val
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
comment|/* Someone else will give an error about this if needed.  */
name|val
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|current_class_type
condition|)
name|val
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
name|lookup_member
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|prefer_type
argument_list|)
expr_stmt|;
name|type_access_control
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Restore the containing TYPENAME_TYPE if we looked 		 through it before.  */
if|if
condition|(
name|got_scope
operator|&&
name|got_scope
operator|!=
name|type
operator|&&
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|=
name|got_scope
expr_stmt|;
block|}
block|}
else|else
name|val
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|got_scope
condition|)
goto|goto
name|done
goto|;
elseif|else
if|if
condition|(
name|got_object
operator|&&
name|val
condition|)
block|{
name|from_obj
operator|=
name|val
expr_stmt|;
name|val
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
else|else
block|{
name|flags
operator|=
name|lookup_flags
argument_list|(
name|prefer_type
argument_list|,
name|namespaces_only
argument_list|)
expr_stmt|;
comment|/* If we're not parsing, we need to complain. */
name|flags
operator||=
name|LOOKUP_COMPLAIN
expr_stmt|;
block|}
comment|/* First, look in non-namespace scopes.  */
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|nonclass
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binding
decl_stmt|;
if|if
condition|(
operator|!
name|LOCAL_BINDING_P
argument_list|(
name|t
argument_list|)
operator|&&
name|nonclass
condition|)
comment|/* We're not looking for class-scoped bindings, so keep going.  */
continue|continue;
comment|/* If this is the kind of thing we're looking for, we're done.  */
if|if
condition|(
name|qualify_lookup
argument_list|(
name|BINDING_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|BINDING_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
name|qualify_lookup
argument_list|(
name|BINDING_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|BINDING_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|binding
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Handle access control on types from enclosing or base classes.  */
if|if
condition|(
name|binding
operator|&&
operator|!
name|yylex
operator|&&
name|BINDING_LEVEL
argument_list|(
name|t
argument_list|)
operator|&&
name|BINDING_LEVEL
argument_list|(
name|t
argument_list|)
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|type_access_control
argument_list|(
name|BINDING_LEVEL
argument_list|(
name|t
argument_list|)
operator|->
name|this_class
argument_list|,
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
operator|(
operator|!
name|val
operator|||
operator|!
name|IMPLICIT_TYPENAME_TYPE_DECL_P
argument_list|(
name|binding
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|val_is_implicit_typename
operator|&&
operator|!
name|yylex
condition|)
name|warn_about_implicit_typename_lookup
argument_list|(
name|val
argument_list|,
name|binding
argument_list|)
expr_stmt|;
name|val
operator|=
name|binding
expr_stmt|;
name|val_is_implicit_typename
operator|=
name|IMPLICIT_TYPENAME_TYPE_DECL_P
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val_is_implicit_typename
condition|)
break|break;
block|}
block|}
comment|/* Now lookup in namespace scopes.  */
if|if
condition|(
operator|!
name|val
operator|||
name|val_is_implicit_typename
condition|)
block|{
name|t
operator|=
name|unqualified_namespace_lookup
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|val_is_implicit_typename
operator|&&
operator|!
name|yylex
condition|)
name|warn_about_implicit_typename_lookup
argument_list|(
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|val
operator|=
name|t
expr_stmt|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|val
condition|)
block|{
comment|/* This should only warn about types used in qualified-ids.  */
if|if
condition|(
name|from_obj
operator|&&
name|from_obj
operator|!=
name|val
condition|)
block|{
if|if
condition|(
name|looking_for_typename
operator|&&
name|TREE_CODE
argument_list|(
name|from_obj
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|from_obj
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"\ lookup of `%D' in the scope of `%#T' (`%#D') \ does not match lookup in the current scope (`%#D')"
argument_list|,
name|name
argument_list|,
name|got_object
argument_list|,
name|from_obj
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* We don't change val to from_obj if got_object depends on 	     template parms because that breaks implicit typename for 	     destructor calls.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|got_object
argument_list|)
condition|)
name|val
operator|=
name|from_obj
expr_stmt|;
block|}
comment|/* If we have a single function from a using decl, pull it out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|OVL_FUNCTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_obj
condition|)
name|val
operator|=
name|from_obj
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name_nonclass
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_function_nonclass
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
return|return
name|lookup_arg_dependent
argument_list|(
name|name
argument_list|,
name|lookup_name_nonclass
argument_list|(
name|name
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name_namespace_only
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
comment|/* type-or-namespace, nonclass, namespace_only */
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|,
name|prefer_type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|prefer_type
decl_stmt|;
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|prefer_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only in the innermost non-class    binding level.  */
end_comment

begin_function
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|namespace_p
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* extern "C" function() */
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|&&
name|LOCAL_BINDING_P
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|BINDING_LEVEL
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|b
condition|)
return|return
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|b
operator|->
name|keep
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_name_current_level, but for types.  */
end_comment

begin_function
name|tree
name|lookup_type_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|current_binding_level
operator|->
name|namespace_p
argument_list|,
literal|980716
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|global_type_node
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
condition|)
return|return
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|b
operator|->
name|keep
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|begin_only_namespace_names
parameter_list|()
block|{
name|only_namespace_names
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_only_namespace_names
parameter_list|()
block|{
name|only_namespace_names
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push the declarations of builtin types into the namespace.    RID_INDEX is the index of the builtin type    in the array RID_POINTERS.  NAME is the name used when looking    up the builtin type.  TYPE is the _TYPE node for the builtin type.  */
end_comment

begin_function
name|void
name|record_builtin_type
parameter_list|(
name|rid_index
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|rid
name|rid_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|rname
init|=
name|NULL_TREE
decl_stmt|,
name|tname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tdecl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
name|rname
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|tname
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TYPE_BUILT_IN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tname
condition|)
block|{
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|tname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|tname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
comment|/* Built-in types live in the global namespace. */
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tname
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rname
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|tname
operator|!=
name|NULL_TREE
condition|)
block|{
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|rname
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|rname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record one of the standard Java types.  * Declare it as having the given NAME.  * If SIZE> 0, it is the size of one of the integral types;  * otherwise it is the negative of the size of one of the other types.  */
end_comment

begin_function
specifier|static
name|tree
name|record_builtin_java_type
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|type
operator|=
name|make_signed_type
argument_list|(
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
operator|-
literal|32
condition|)
block|{
comment|/* "__java_char" or ""__java_boolean". */
name|type
operator|=
name|make_unsigned_type
argument_list|(
operator|-
name|size
argument_list|)
expr_stmt|;
comment|/*if (size == -1)	TREE_SET_CODE (type, BOOLEAN_TYPE);*/
block|}
else|else
block|{
comment|/* "__java_float" or ""__java_double". */
name|type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
operator|-
name|size
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Suppress generate debug symbol entries for these types,      since for normal C++ they are just clutter.      However, push_lang_context undoes this if extern "Java" is seen. */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Push a type into the namespace so that the back-ends ignore it. */
end_comment

begin_function
specifier|static
name|void
name|record_unknown_type
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure the "unknown type" typedecl gets ignored for debug info.  */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An string for which we should create an IDENTIFIER_NODE at    startup.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|predefined_identifier
block|{
comment|/* The name of the identifier.  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* The place where the IDENTIFIER_NODE should be stored.  */
name|tree
modifier|*
specifier|const
name|node
decl_stmt|;
comment|/* Non-zero if this is the name of a constructor or destructor.  */
specifier|const
name|int
name|ctor_or_dtor_p
decl_stmt|;
block|}
name|predefined_identifier
typedef|;
end_typedef

begin_comment
comment|/* Create all the predefined identifiers.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_predefined_identifiers
parameter_list|()
block|{
specifier|const
name|predefined_identifier
modifier|*
name|pid
decl_stmt|;
comment|/* A table of identifiers to create at startup.  */
specifier|static
specifier|const
name|predefined_identifier
name|predefined_identifiers
index|[]
init|=
block|{
block|{
literal|"C++"
block|,
operator|&
name|lang_name_cplusplus
block|,
literal|0
block|}
block|,
block|{
literal|"C"
block|,
operator|&
name|lang_name_c
block|,
literal|0
block|}
block|,
block|{
literal|"Java"
block|,
operator|&
name|lang_name_java
block|,
literal|0
block|}
block|,
block|{
name|CTOR_NAME
block|,
operator|&
name|ctor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__base_ctor"
block|,
operator|&
name|base_ctor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__comp_ctor"
block|,
operator|&
name|complete_ctor_identifier
block|,
literal|1
block|}
block|,
block|{
name|DTOR_NAME
block|,
operator|&
name|dtor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__comp_dtor"
block|,
operator|&
name|complete_dtor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__base_dtor"
block|,
operator|&
name|base_dtor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__deleting_dtor"
block|,
operator|&
name|deleting_dtor_identifier
block|,
literal|1
block|}
block|,
block|{
name|IN_CHARGE_NAME
block|,
operator|&
name|in_charge_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"nelts"
block|,
operator|&
name|nelts_identifier
block|,
literal|0
block|}
block|,
block|{
name|THIS_NAME
block|,
operator|&
name|this_identifier
block|,
literal|0
block|}
block|,
block|{
name|VTABLE_DELTA_NAME
block|,
operator|&
name|delta_identifier
block|,
literal|0
block|}
block|,
block|{
name|VTABLE_PFN_NAME
block|,
operator|&
name|pfn_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"_vptr"
block|,
operator|&
name|vptr_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"__vtt_parm"
block|,
operator|&
name|vtt_parm_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"std"
block|,
operator|&
name|std_identifier
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
for|for
control|(
name|pid
operator|=
name|predefined_identifiers
init|;
name|pid
operator|->
name|name
condition|;
operator|++
name|pid
control|)
block|{
operator|*
name|pid
operator|->
name|node
operator|=
name|get_identifier
argument_list|(
name|pid
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|->
name|ctor_or_dtor_p
condition|)
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
operator|*
name|pid
operator|->
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|cxx_init_decl_processing
parameter_list|()
block|{
name|tree
name|void_ftype
decl_stmt|;
name|tree
name|void_ftype_ptr
decl_stmt|;
comment|/* Create all the identifiers we need.  */
name|initialize_predefined_identifiers
argument_list|()
expr_stmt|;
comment|/* Fill in back-end hooks.  */
name|init_lang_status
operator|=
operator|&
name|push_cp_function_context
expr_stmt|;
name|free_lang_status
operator|=
operator|&
name|pop_cp_function_context
expr_stmt|;
name|mark_lang_status
operator|=
operator|&
name|mark_cp_function_context
expr_stmt|;
name|lang_missing_noreturn_ok_p
operator|=
operator|&
name|cp_missing_noreturn_ok_p
expr_stmt|;
name|cp_parse_init
argument_list|()
expr_stmt|;
name|init_decl2
argument_list|()
expr_stmt|;
name|init_pt
argument_list|()
expr_stmt|;
comment|/* Create the global variables.  */
name|push_to_top_level
argument_list|()
expr_stmt|;
comment|/* Enter the global namespace. */
name|my_friendly_assert
argument_list|(
name|global_namespace
operator|==
name|NULL_TREE
argument_list|,
literal|375
argument_list|)
expr_stmt|;
name|push_namespace
argument_list|(
name|get_identifier
argument_list|(
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
name|global_namespace
operator|=
name|current_namespace
expr_stmt|;
name|current_lang_name
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Adjust various flags based on command-line settings.  */
if|if
condition|(
operator|!
name|flag_permissive
operator|&&
operator|!
name|pedantic
condition|)
name|flag_pedantic_errors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
block|{
name|flag_inline_trees
operator|=
literal|1
expr_stmt|;
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag_inline_functions
condition|)
block|{
name|flag_inline_trees
operator|=
literal|2
expr_stmt|;
name|flag_inline_functions
operator|=
literal|0
expr_stmt|;
block|}
comment|/* In C++, we never create builtin functions whose name does not      begin with `__'.  Users should be using headers to get prototypes      in C++.  It would be nice if we could warn when `-fbuiltin' is      used explicitly, but we do not have that information.  */
name|flag_no_builtin
operator|=
literal|1
expr_stmt|;
comment|/* Initially, C.  */
name|current_lang_name
operator|=
name|lang_name_c
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|build_common_tree_nodes
argument_list|(
name|flag_signed_char
argument_list|)
expr_stmt|;
name|error_mark_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_list
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Make the binding_level structure for global names.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
comment|/* The global level is the namespace level of ::.  */
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
operator|=
name|global_binding_level
expr_stmt|;
name|declare_namespace_level
argument_list|()
expr_stmt|;
comment|/* Create the `std' namespace.  */
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|std_node
operator|=
name|current_namespace
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|lang_attribute_table
operator|=
name|cp_attribute_table
expr_stmt|;
name|c_common_nodes_and_builtins
argument_list|()
expr_stmt|;
name|java_byte_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_byte"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|java_short_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_short"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|java_int_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_int"
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|java_long_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_long"
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|java_float_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_float"
argument_list|,
operator|-
literal|32
argument_list|)
expr_stmt|;
name|java_double_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_double"
argument_list|,
operator|-
literal|64
argument_list|)
expr_stmt|;
name|java_char_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_char"
argument_list|,
operator|-
literal|16
argument_list|)
expr_stmt|;
name|java_boolean_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_boolean"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|integer_two_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_two_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_three_node
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_three_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|boolean_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|BOOL_TYPE_SIZE
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|boolean_type_node
argument_list|,
name|BOOLEAN_TYPE
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|boolean_type_node
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|boolean_type_node
argument_list|)
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|boolean_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_BOOL
argument_list|,
literal|"bool"
argument_list|,
name|boolean_type_node
argument_list|)
expr_stmt|;
name|boolean_false_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|boolean_false_node
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
name|boolean_true_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|boolean_true_node
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
name|signed_size_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|signed_size_zero_node
argument_list|)
operator|=
name|make_signed_type
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|empty_except_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|record_builtin_type (RID_MAX, NULL, string_type_node);
endif|#
directive|endif
name|delta_type_node
operator|=
name|ptrdiff_type_node
expr_stmt|;
name|vtable_index_type
operator|=
name|ptrdiff_type_node
expr_stmt|;
name|vtt_parm_type
operator|=
name|build_pointer_type
argument_list|(
name|const_ptr_type_node
argument_list|)
expr_stmt|;
name|lang_type_promotes_to
operator|=
name|convert_type_from_ellipsis
expr_stmt|;
name|void_ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|void_ftype_ptr
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr
operator|=
name|build_exception_variant
argument_list|(
name|void_ftype_ptr
argument_list|,
name|empty_except_spec
argument_list|)
expr_stmt|;
comment|/* C++ extensions */
name|unknown_type_node
operator|=
name|make_node
argument_list|(
name|UNKNOWN_TYPE
argument_list|)
expr_stmt|;
name|record_unknown_type
argument_list|(
name|unknown_type_node
argument_list|,
literal|"unknown type"
argument_list|)
expr_stmt|;
comment|/* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */
name|TREE_TYPE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same      result.  */
name|TYPE_POINTER_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|{
comment|/* Make sure we get a unique function type, so we can give        its pointer type a name.  (This wins for gdb.) */
name|tree
name|vfunc_type
init|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_pointer_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_qualified_type
argument_list|(
name|vtbl_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL
argument_list|,
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL
argument_list|,
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|push_namespace
argument_list|(
name|get_identifier
argument_list|(
literal|"__cxxabiv1"
argument_list|)
argument_list|)
expr_stmt|;
name|abi_node
operator|=
name|current_namespace
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|global_type_node
operator|=
name|make_node
argument_list|(
name|LANG_TYPE
argument_list|)
expr_stmt|;
name|record_unknown_type
argument_list|(
name|global_type_node
argument_list|,
literal|"global type"
argument_list|)
expr_stmt|;
comment|/* Now, C++.  */
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
block|{
name|tree
name|bad_alloc_type_node
decl_stmt|,
name|newtype
decl_stmt|,
name|deltype
decl_stmt|;
name|tree
name|ptr_ftype_sizetype
decl_stmt|;
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|bad_alloc_type_node
operator|=
name|xref_tag
argument_list|(
name|class_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"bad_alloc"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|ptr_ftype_sizetype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|c_size_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|newtype
operator|=
name|build_exception_variant
argument_list|(
name|ptr_ftype_sizetype
argument_list|,
name|add_exception_specifier
argument_list|(
name|NULL_TREE
argument_list|,
name|bad_alloc_type_node
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|deltype
operator|=
name|build_exception_variant
argument_list|(
name|void_ftype_ptr
argument_list|,
name|empty_except_spec
argument_list|)
expr_stmt|;
name|push_cp_library_fn
argument_list|(
name|NEW_EXPR
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
name|push_cp_library_fn
argument_list|(
name|VEC_NEW_EXPR
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
name|global_delete_fndecl
operator|=
name|push_cp_library_fn
argument_list|(
name|DELETE_EXPR
argument_list|,
name|deltype
argument_list|)
expr_stmt|;
name|push_cp_library_fn
argument_list|(
name|VEC_DELETE_EXPR
argument_list|,
name|deltype
argument_list|)
expr_stmt|;
block|}
name|abort_fndecl
operator|=
name|build_library_fn_ptr
argument_list|(
literal|"__cxa_pure_virtual"
argument_list|,
name|void_ftype
argument_list|)
expr_stmt|;
comment|/* Perform other language dependent initializations.  */
name|init_class_processing
argument_list|()
expr_stmt|;
name|init_init_processing
argument_list|()
expr_stmt|;
name|init_search_processing
argument_list|()
expr_stmt|;
name|init_rtti_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_exceptions
condition|)
name|init_exception_processing
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|supports_one_only
argument_list|()
condition|)
name|flag_weak
operator|=
literal|0
expr_stmt|;
name|make_fname_decl
operator|=
name|cp_make_fname_decl
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
comment|/* Show we use EH for cleanups.  */
name|using_eh_for_cleanups
argument_list|()
expr_stmt|;
comment|/* Maintain consistency.  Perhaps we should just complain if they      say -fwritable-strings?  */
if|if
condition|(
name|flag_writable_strings
condition|)
name|flag_const_strings
operator|=
literal|0
expr_stmt|;
comment|/* Add GC roots for all of our global variables.  */
name|ggc_add_tree_root
argument_list|(
name|c_global_trees
argument_list|,
sizeof|sizeof
name|c_global_trees
operator|/
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
name|cp_global_trees
argument_list|,
sizeof|sizeof
name|cp_global_trees
operator|/
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|integer_three_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|integer_two_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|signed_size_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|size_one_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|size_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|global_binding_level
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|global_binding_level
argument_list|,
name|mark_binding_level
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|scope_chain
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|scope_chain
argument_list|,
operator|&
name|mark_saved_scope
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|static_ctors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|static_dtors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|lastiddecl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|last_function_parms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|error_mark_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|global_namespace
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|global_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|anonymous_namespace_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|got_object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|got_scope
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|current_lang_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|static_aggregates
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|free_bindings
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an initializer for a function naming variable from    NAME. NAME may be NULL, in which case we generate a special    ERROR_MARK node which should be replaced later. */
end_comment

begin_function
name|tree
name|cp_fname_init
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|domain
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
name|size_t
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|domain
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|length
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
comment|/* We don't know the value until instantiation time. Make        something which will be digested now, but replaced later. */
name|init
operator|=
name|build
argument_list|(
name|ERROR_MARK
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the    decl, NAME is the initialization string and TYPE_DEP indicates whether    NAME depended on the type of the function. We make use of that to detect    __PRETTY_FUNCTION__ inside a template fn. This is being done    lazily at the point of first use, so we musn't push the decl now.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_make_fname_decl
parameter_list|(
name|id
parameter_list|,
name|type_dep
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|type_dep
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
operator|(
name|type_dep
operator|&&
name|processing_template_decl
condition|?
name|NULL
else|:
name|fname_as_string
argument_list|(
name|type_dep
argument_list|)
operator|)
decl_stmt|;
name|tree
name|init
init|=
name|cp_fname_init
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|id
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
decl_stmt|;
comment|/* As we don't push the decl here, we must set the context. */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_PRETTY_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
name|type_dep
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Entry point for the benefit of c_common_nodes_and_builtins.     Make a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.     CLASS and CODE tell later passes how to compile calls to this function.    See tree.h for possible values.     If LIBNAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  */
end_comment

begin_function
name|tree
name|builtin_function
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|,
name|class
parameter_list|,
name|libname
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|code
decl_stmt|;
name|enum
name|built_in_class
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|libname
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_library_fn_1
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|ERROR_MARK
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|=
name|class
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|code
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|392
argument_list|)
expr_stmt|;
comment|/* All builtins that don't begin with an `_' should go in the `std'      namespace.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|std_node
expr_stmt|;
block|}
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,      we cannot change DECL_ASSEMBLER_NAME until we have installed this      function in the namespace.  */
if|if
condition|(
name|libname
condition|)
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|libname
argument_list|)
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Warn if a function in the namespace for users      is used without an occasion to consider it declared.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
name|DECL_ANTICIPATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Possibly apply some default attributes to this built-in function.  */
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Generate a FUNCTION_DECL with the typical flags for a runtime library    function.  Not called directly.  */
end_comment

begin_function
specifier|static
name|tree
name|build_library_fn_1
parameter_list|(
name|name
parameter_list|,
name|operator_code
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|enum
name|tree_code
name|operator_code
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|fn
argument_list|,
name|operator_code
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|fn
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Returns the _DECL for a library function with C linkage.    We assume that such functions never throw; if this is incorrect,    callers should unset TREE_NOTHROW.  */
end_comment

begin_function
name|tree
name|build_library_fn
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
return|return
name|build_library_fn_1
argument_list|(
name|name
argument_list|,
name|ERROR_MARK
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the _DECL for a library function with C++ linkage.  */
end_comment

begin_function
specifier|static
name|tree
name|build_cp_library_fn
parameter_list|(
name|name
parameter_list|,
name|operator_code
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|enum
name|tree_code
name|operator_code
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|build_library_fn_1
argument_list|(
name|name
argument_list|,
name|operator_code
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
name|TYPE_NOTHROW_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|fn
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
name|set_mangled_name_for_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Like build_library_fn, but takes a C string instead of an    IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_library_fn_ptr
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
return|return
name|build_library_fn
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like build_cp_library_fn, but takes a C string instead of an    IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_cp_library_fn_ptr
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
return|return
name|build_cp_library_fn
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|ERROR_MARK
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like build_library_fn, but also pushes the function so that we will    be able to find it via IDENTIFIER_GLOBAL_VALUE.  */
end_comment

begin_function
name|tree
name|push_library_fn
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|build_library_fn
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Like build_cp_library_fn, but also pushes the function so that it    will be found by normal lookup.  */
end_comment

begin_function
specifier|static
name|tree
name|push_cp_library_fn
parameter_list|(
name|operator_code
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|operator_code
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|build_cp_library_fn
argument_list|(
name|ansi_opname
argument_list|(
name|operator_code
argument_list|)
argument_list|,
name|operator_code
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|pushdecl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Like push_library_fn, but takes a TREE_LIST of parm types rather than    a FUNCTION_TYPE.  */
end_comment

begin_function
name|tree
name|push_void_library_fn
parameter_list|(
name|name
parameter_list|,
name|parmtypes
parameter_list|)
name|tree
name|name
decl_stmt|,
name|parmtypes
decl_stmt|;
block|{
name|tree
name|type
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parmtypes
argument_list|)
decl_stmt|;
return|return
name|push_library_fn
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like push_library_fn, but also note that this function throws    and does not return.  Used for __throw_foo and the like.  */
end_comment

begin_function
name|tree
name|push_throw_library_fn
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|push_library_fn
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Apply default attributes to a function, if a system function with default    attributes.  */
end_comment

begin_function
name|void
name|insert_default_attributes
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|c_common_insert_default_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When we call finish_struct for an anonymous union, we create    default copy constructors and such.  But, an anonymous union    shouldn't have such things; this function undoes the damage to the    anonymous union type T.     (The reason that we create the synthesized methods is that we don't    distinguish `union { int i; }' from `typedef union { int i; } U'.    The first is an anonymous union; the second is just an ordinary    union type.)  */
end_comment

begin_function
name|void
name|fixup_anonymous_aggr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
modifier|*
name|q
decl_stmt|;
comment|/* Wipe out memory of synthesized methods */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Splice the implicitly generated functions out of the TYPE_METHODS      list.  */
name|q
operator|=
operator|&
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* ISO C++ 9.5.3.  Anonymous unions may not have function members.  */
if|if
condition|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"an anonymous union cannot have function members"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Anonymous aggregates cannot have fields with ctors, dtors or complex      assignment operators (because they cannot have these methods themselves).      For anonymous unions this is already checked because they are not allowed      in any union, otherwise we have to check it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member %#D' with constructor not allowed in anonymous aggregate"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member %#D' with destructor not allowed in anonymous aggregate"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member %#D' with copy assignment operator not allowed in anonymous aggregate"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make sure that a declaration with no declarator is well-formed, i.e.    just defines a tagged type or anonymous union.     Returns the type defined, if any.  */
end_comment

begin_function
name|tree
name|check_tag_decl
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|int
name|found_type
init|=
literal|0
decl_stmt|;
name|int
name|saw_friend
init|=
literal|0
decl_stmt|;
name|int
name|saw_typedef
init|=
literal|0
decl_stmt|;
name|tree
name|ob_modifier
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|value
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|value
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
condition|)
block|{
operator|++
name|found_type
expr_stmt|;
if|if
condition|(
name|found_type
operator|==
literal|2
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"redeclaration of C++ built-in type `%T'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TYPE_P
argument_list|(
name|value
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|value
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|261
argument_list|)
expr_stmt|;
name|t
operator|=
name|value
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
condition|)
name|saw_typedef
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|current_scope
argument_list|()
operator|!=
name|current_class_type
condition|)
name|ob_modifier
operator|=
name|value
expr_stmt|;
else|else
name|saw_friend
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXPLICIT
index|]
condition|)
name|ob_modifier
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|found_type
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple types in one declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|&&
operator|!
name|saw_friend
condition|)
name|pedwarn
argument_list|(
literal|"declaration does not declare anything"
argument_list|)
expr_stmt|;
comment|/* Check for an anonymous union.  */
elseif|else
if|if
condition|(
name|t
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* 7/3 In a simple-declaration, the optional init-declarator-list          can be omitted only when declaring a class (clause 9) or          enumeration (7.2), that is, when the decl-specifier-seq contains          either a class-specifier, an elaborated-type-specifier with          a class-key (9.1), or an enum-specifier.  In these cases and          whenever a class-specifier or enum-specifier is present in the          decl-specifier-seq, the identifiers in these specifiers are among          the names being declared by the declaration (as class-name,          enum-names, or enumerators, depending on the syntax).  In such          cases, and except for the declaration of an unnamed bit-field (9.6),          the decl-specifier-seq shall introduce one or more names into the          program, or shall redeclare a name introduced by a previous          declaration.  [Example:              enum { };            // ill-formed              typedef class { };   // ill-formed          --end example]  */
if|if
condition|(
name|saw_typedef
condition|)
block|{
name|error
argument_list|(
literal|"missing type-name in typedef-declaration"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Anonymous unions are objects, so they can have specifiers.  */
empty_stmt|;
name|SET_ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ prohibits anonymous structs"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ob_modifier
condition|)
block|{
if|if
condition|(
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|||
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
condition|)
name|error
argument_list|(
literal|"`%D' can only be specified for functions"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
condition|)
name|error
argument_list|(
literal|"`%D' can only be specified inside a class"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXPLICIT
index|]
condition|)
name|error
argument_list|(
literal|"`%D' can only be specified for constructors"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%D' can only be specified for objects and functions"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.     C++: may have to grok the declspecs to learn about static,    complain for anonymous unions.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|t
init|=
name|check_tag_decl
argument_list|(
name|declspecs
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|maybe_process_partial_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* This is where the variables in an anonymous union are      declared.  An anonymous union declaration looks like:      union { ... } ;      because there is no declarator after the union, the parser      sends that declaration here.  */
if|if
condition|(
name|t
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|fixup_anonymous_aggr
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|NULL_TREE
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|finish_anon_union
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
name|split_specs_attrs
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
name|type
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|specs
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `cp_finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|,
name|attributes
parameter_list|,
name|prefix_attributes
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|attributes
decl_stmt|,
name|prefix_attributes
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|context
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
if|#
directive|if
literal|0
comment|/* See code below that used this.  */
block|int init_written = initialized;
endif|#
directive|endif
comment|/* This should only be done once on the top most decl.  */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
comment|/* An object declared as __attribute__((deprecated)) suppresses      warnings of uses of other deprecated items.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"deprecated"
argument_list|,
name|attributes
argument_list|)
condition|)
name|deprecated_state
operator|=
name|DEPRECATED_SUPPRESS
expr_stmt|;
name|attributes
operator|=
name|chainon
argument_list|(
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
operator|&
name|attributes
argument_list|)
expr_stmt|;
name|deprecated_state
operator|=
name|DEPRECATED_NORMAL
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|NULL_TREE
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
operator|&&
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|context
operator|!=
name|current_namespace
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* When parsing the initializer, lookup should use the object's 	 namespace. */
name|push_decl_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* We are only interested in class contexts, later. */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `cp_finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* typedef foo = bar  means give foo the same type as bar. 	   We haven't parsed bar yet, so `cp_finish_decl' will fix that up. 	   Any other case of an initialization in a TYPE_DECL is an error.  */
if|if
condition|(
name|pedantic
operator|||
name|list_length
argument_list|(
name|declspecs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"typedef `%D' is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function `%#D' is initialized like a variable"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"declaration of `%#D' has `extern' and is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `cp_finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"inline function `%s' given attribute noinline"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|context
argument_list|)
argument_list|)
condition|)
block|{
name|push_nested_class
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|error
argument_list|(
literal|"`%#D' is not a static member of `%#T'"
argument_list|,
name|decl
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|context
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ does not permit `%T::%D' to be defined as `%T::%D'"
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Static data member are tricky; an in-class initialization 		 still doesn't provide a definition, so the in-class 		 declaration will have DECL_EXTERNAL set, but will have an 		 initialization.  Thus, duplicate_decls won't warn 		 about this situation, and so we check here.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate initialization of %D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|field
argument_list|)
condition|)
name|decl
operator|=
name|field
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|field
init|=
name|check_classfn
argument_list|(
name|context
argument_list|,
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|&&
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|field
argument_list|)
condition|)
name|decl
operator|=
name|field
expr_stmt|;
block|}
comment|/* cp_finish_decl sets DECL_EXTERNAL if DECL_IN_AGGR_P is set.  */
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* [temp.expl.spec] An explicit specialization of a static data 	     member of a template is a definition if the declaration 	     includes an initializer; otherwise, it is a declaration.  	     We check for processing_specialization so this only applies 	     to the new specialization syntax.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|processing_specialization
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"declaration of `%#D' outside of class is not definition"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Enter this declaration into the symbol table.  */
name|tem
operator|=
name|maybe_push_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|tem
operator|=
name|push_template_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_BSS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
comment|/* Tell the back-end to use or not use .common as appropriate.  If we say      -fconserve-space, we want this to save .data space, at the expense of      wrong semantics.  If we say -fno-conserve-space, we want this to      produce errors about redefs; to do this we force variables into the      data segment.  */
name|DECL_COMMON
argument_list|(
name|tem
argument_list|)
operator|=
name|flag_conserve_space
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|start_decl_1
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_function
name|void
name|start_decl_1
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|initialized
init|=
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
name|maybe_push_cleanup_level
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `cp_finish_decl' to ignore the initializer once it is parsed.  */
block|{
comment|/* Don't allow initializations for incomplete types except for 	 arrays which might be completed by the initialization.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* A complete type is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable `%#D' has initializer but incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"elements of array `%#D' have incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* else we already gave an error in start_decl.  */
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|initialized
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|type
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|processing_template_decl
operator|||
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"aggregate `%#D' has incomplete type and cannot be initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Change the type so that assemble_variable will give 	     DECL an rtl we can live with: (mem (const_int 0)).  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
comment|/* If any base type in the hierarchy of TYPE needs a constructor, 	     then we set initialized to 1.  This way any nodes which are 	     created for the purposes of initializing this aggregate 	     will live as long as it does.  This is necessary for global 	     aggregates which do not have their initializers processed until 	     the end of the file.  */
name|initialized
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|initialized
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle initialization of references.    These three arguments are from `cp_finish_decl', and have the    same meaning here that they do there.     Quotes on semantics can be found in ARM 8.4.3.  */
end_comment

begin_function
specifier|static
name|tree
name|grok_reference_init
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%D' declared as reference but not initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|error
argument_list|(
literal|"ISO C++ forbids use of initializer list to initialize reference `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|init
operator|=
name|convert_from_reference
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Note: default conversion is only called in very special cases.  */
name|init
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
comment|/* Convert INIT to the reference type TYPE.  This may involve the      creation of a temporary, whose lifetime must be the same as that      of the reference.  If so, a DECL_STMT for the temporary will be      added just after the DECL_STMT for DECL.  That's why we don't set      DECL_INITIAL for local references (instead assigning to them      explicitly); we need to allow the temporary to be initialized      first.  */
name|tmp
operator|=
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_ONLYCONVERTING
operator||
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_NORMAL
operator||
name|DIRECT_BIND
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"cannot initialize `%T' from `%T'"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|tmp
argument_list|)
condition|)
return|return
name|tmp
return|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|tmp
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fill in DECL_INITIAL with some magical value to prevent expand_decl from    mucking with forces it does not comprehend (i.e. initialization with a    constructor).  If we are at global scope and won't go into COMMON, fill    it in with a dummy CONSTRUCTOR to force the variable into .data;    otherwise we can use error_mark_node.  */
end_comment

begin_function
specifier|static
name|tree
name|obscure_complex_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_no_inline
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|extract_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_BSS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
operator|&&
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* When parsing `int a[] = {1, 2};' we don't know the size of the    array until we finish parsing the initializer.  If that's the    situation we're in, update DECL accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_deduce_size_from_array_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
comment|/* do_default is really a C-ism to deal with tentative definitions. 	 But let's leave it here to ease the eventual merge.  */
name|int
name|do_default
init|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|initializer
init|=
name|init
condition|?
name|init
else|:
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|initializer
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"initializer fails to determine size of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|error
argument_list|(
literal|"array size missing in `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a `static' var's size isn't known, make it extern as 	     well as static, so it does not get allocated.  If it's not 	     `static', then don't mark it extern; finish_incomplete_decl 	     will give it a default size and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|error
argument_list|(
literal|"zero-size array `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set DECL_SIZE, DECL_ALIGN, etc. for DECL (a VAR_DECL), and issue    any appropriate error messages regarding the layout.  */
end_comment

begin_function
specifier|static
name|void
name|layout_var_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|tree ttype = target_type (type);
endif|#
directive|endif
comment|/* If we haven't already layed out this declaration, do so now.      Note that we must not call complete type for an external object      because it's type might involve templates that we are not      supposed to isntantiate yet.  (And it's perfectly legal to say      `extern X x' for some incomplete type `X'.)  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* An automatic variable with an incomplete type: that is an error. 	 Don't talk about array types here, since we took care of that 	 message in grokdeclarator.  */
name|error
argument_list|(
literal|"storage size of `%D' isn't known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Keep this code around in case we later want to control debug info      based on whether a type is "used".  (jason 1999-11-11) */
block|else if (!DECL_EXTERNAL (decl)&& IS_AGGR_TYPE (ttype))
comment|/* Let debugger know it should output info for this type.  */
block|note_debug_info_needed (ttype);    if (TREE_STATIC (decl)&& DECL_CLASS_SCOPE_P (decl))     note_debug_info_needed (DECL_CONTEXT (decl));
endif|#
directive|endif
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"storage size of `%D' isn't constant"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|current_function_decl
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
condition|)
name|push_local_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If a local static variable is declared in an inline function, or if    we have a weak definition, we must endeavor to create only one    instance of the variable at link-time.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_commonize_var
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Static data in a function with comdat linkage also has comdat      linkage.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Don't mess with __FUNCTION__.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|current_function_decl
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
operator|&&
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|current_function_decl
argument_list|)
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* If flag_weak, we don't need to mess with this, as we can just 	 make the function weak, and let it refer to its unique local 	 copy.  This works because we don't allow the function to be 	 inlined.  */
if|if
condition|(
operator|!
name|flag_weak
condition|)
block|{
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* else we lose. We can only do this if we can use common, 	     which we can't if it has been initialized.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  you can work around this by removing the initializer"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Set it up again; we might have set DECL_INITIAL since the last        time.  */
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue an error message if DECL is an uninitialized const variable.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_uninitialized_const_var
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* ``Unless explicitly declared extern, a const object does not have      external linkage and must be initialized. ($8.4; $12.1)'' ARM      7.1.6 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"uninitialized const `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify INIT (the initializer for DECL), and record the    initialization in DECL_INITIAL, if appropriate.  Returns a new    value for INIT.  */
end_comment

begin_function
specifier|static
name|tree
name|check_initializer
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
return|return
name|init
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check the initializer.  */
if|if
condition|(
name|init
condition|)
block|{
comment|/* Things that are going to be initialized need to have complete 	 type.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
comment|/* We will have already complained.  */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object `%D' may not be initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"elements of array `%#D' have incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%D' has incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|148
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|NULL_TREE
argument_list|,
literal|149
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|init
operator|=
name|grok_reference_init
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|init
operator|=
name|obscure_complex_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NON_AGGREGATE_CLASS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%D' must be initialized by constructor, not by `{...}'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
goto|goto
name|dont_use_constructor
goto|;
block|}
block|}
else|else
block|{
name|dont_use_constructor
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|init
operator|=
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
comment|/* We must hide the initializer so that expand_decl 	   won't try to do something it does not understand.  */
name|init
operator|=
name|obscure_complex_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|core_type
init|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|core_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|core_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"structure `%D' with uninitialized const members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|core_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"structure `%D' with uninitialized reference members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|check_for_uninitialized_const_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|init
operator|=
name|obscure_complex_init
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|check_for_uninitialized_const_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* If DECL is not a local variable, give it RTL.  */
end_comment

begin_function
specifier|static
name|void
name|make_rtl_for_nonlocal_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
block|{
name|int
name|toplev
init|=
name|toplevel_bindings_p
argument_list|()
decl_stmt|;
name|int
name|defer_p
decl_stmt|;
comment|/* Handle non-variables up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we see a class member here, it should be a static data      member.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|19990828
argument_list|)
expr_stmt|;
comment|/* An in-class declaration of a static data member should be 	 external; it is only a declaration, and not a definition.  */
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
name|my_friendly_assert
argument_list|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|20000723
argument_list|)
expr_stmt|;
block|}
comment|/* Set the DECL_ASSEMBLER_NAME for the variable.  */
if|if
condition|(
name|asmspec
condition|)
block|{
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The `register' keyword, when used together with an 	 asm-specification, indicates that the variable should be 	 placed in a particular register.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_C_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We don't create any RTL for local variables.  */
if|if
condition|(
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* We defer emission of local statics until the corresponding      DECL_STMT is expanded.  */
name|defer_p
operator|=
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We try to defer namespace-scope static constants so that they are      not emitted into the object file unnecessarily.  */
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|EMPTY_CONSTRUCTOR_P
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|toplev
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Fool with the linkage according to #pragma interface.  */
if|if
condition|(
operator|!
name|interface_unknown
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|interface_only
expr_stmt|;
block|}
name|defer_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we're deferring the variable, we only need to make RTL if      there's an ASMSPEC.  Otherwise, we'll lazily create it later when      we need it.  (There's no way to lazily create RTL for things that      have assembly specs because the information about the specifier      isn't stored in the tree, yet)  */
if|if
condition|(
name|defer_p
operator|&&
name|asmspec
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
comment|/* If we're not deferring, go ahead and assemble the variable.  */
elseif|else
if|if
condition|(
operator|!
name|defer_p
condition|)
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The old ARM scoping rules injected variables declared in the    initialization statement of a for-statement into the surrounding    scope.  We support this usage, in order to be backward-compatible.    DECL is a just-declared VAR_DECL; if necessary inject its    declaration into the surrounding scope.  */
end_comment

begin_function
name|void
name|maybe_inject_for_scope_var
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|current_binding_level
operator|->
name|is_for_scope
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|outer
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
comment|/* Check to see if the same name is already bound at the outer 	 level, either because it was directly declared, or because a 	 dead for-decl got preserved.  In either case, the code would 	 not have been valid under the ARM scope rules, so clear 	 is_for_scope for the current_binding_level.  	 Otherwise, we need to preserve the temp slot for decl to last 	 into the outer binding level.  */
name|tree
name|outer_binding
init|=
name|TREE_CHAIN
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outer_binding
operator|&&
name|BINDING_LEVEL
argument_list|(
name|outer_binding
argument_list|)
operator|==
name|outer
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
condition|)
block|{
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|is_for_scope
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_IN_MEMORY_P
argument_list|(
name|decl
argument_list|)
condition|)
name|preserve_temp_slots
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to initialize DECL (a local variable).  */
end_comment

begin_function
name|void
name|initialize_local_var
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* If the type is bogus, don't bother initializing the variable.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Local statics are handled differently from ordinary automatic      variables.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
operator|!=
name|NULL_TREE
operator|||
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
name|int
name|already_used
decl_stmt|;
comment|/* Compute and store the initial value.  */
name|already_used
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|saved_stmts_are_full_exprs_p
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|building_stmt_tree
argument_list|()
argument_list|,
literal|20000906
argument_list|)
expr_stmt|;
name|saved_stmts_are_full_exprs_p
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|saved_stmts_are_full_exprs_p
expr_stmt|;
block|}
comment|/* Set this to 0 so we can tell whether an aggregate which was 	 initialized was ever used.  Don't do this if it has a 	 destructor, so we don't complain about the 'resource 	 allocation is initialization' idiom.  Now set 	 attribute((unused)) on types so decls of that type will be 	 marked used. (see TREE_USED, above.)  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|already_used
operator|&&
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|already_used
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to destroy DECL (a local variable).  */
end_comment

begin_function
specifier|static
name|void
name|destroy_local_var
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* Only variables get cleaned up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
comment|/* And only things with destructors need cleaning up.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* We don't clean up things that aren't defined in this        translation unit, or that need a static cleanup.  The latter        are handled by finish_file.  */
return|return;
comment|/* Compute the cleanup.  */
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Record the cleanup required for this declaration.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|cleanup
condition|)
name|finish_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its line number and initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.     INIT holds the value of an initializer that should be allowed to escape    the normal rules.     FLAGS is LOOKUP_ONLYCONVERTING if the = init syntax was used, else 0    if the (init) syntax was used.  */
end_comment

begin_function
name|void
name|cp_finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|ttype
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
init|=
name|NULL
decl_stmt|;
name|int
name|was_readonly
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|error
argument_list|(
literal|"assignment (not initialization) in declaration"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If a name was specified, get the string.  */
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"cannot initialize `%D' to namespace `%D'"
argument_list|,
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
operator|&&
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
name|init
operator|)
condition|)
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_namespace
operator|&&
name|init
condition|)
block|{
comment|/* Leave the namespace of the object. */
name|pop_decl_namespace
argument_list|()
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TYPE_HAS_MUTABLE_P
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* Add this declaration to the statement-tree.  */
if|if
condition|(
name|at_function_scope_p
argument_list|()
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|RESULT_DECL
condition|)
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
goto|goto
name|finish_end0
goto|;
block|}
comment|/* Parameters are handled by store_parm_decls, not cp_finish_decl.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
argument_list|,
literal|19990828
argument_list|)
expr_stmt|;
comment|/* Take care of TYPE_DECLs up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|type
condition|)
name|warning
argument_list|(
literal|"shadowing previous type declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If we have installed this as the canonical typedef for this 	 type, and that type has not been defined yet, delay emitting 	 the debug information for it, as we will emit it later.  */
if|if
condition|(
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|decl
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|ttype
operator|=
name|target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Currently, GNU C++ puts constants in text space, making them 	 impossible to initialize.  In the future, one would hope for 	 an operating system which understood the difference between 	 initialization and the running of a program.  */
name|was_readonly
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|asmspec
condition|)
block|{
comment|/* This must override the asm specifier which was placed by 	 grokclassfn.  Lay this out fresh.  */
name|SET_DECL_RTL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
comment|/* Deduce size of array from initialization, if not already known.  */
name|init
operator|=
name|check_initializer
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|maybe_deduce_size_from_array_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Add this declaration to the statement-tree.  This needs to happen      after the call to check_initializer so that the DECL_STMT for a      reference temp is added before the DECL_STMT for the reference itself.  */
if|if
condition|(
name|building_stmt_tree
argument_list|()
operator|&&
name|at_function_scope_p
argument_list|()
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|RESULT_DECL
condition|)
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|layout_var_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|maybe_commonize_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|make_rtl_for_nonlocal_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|strip_array_types
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* This is a local declaration.  */
if|if
condition|(
name|doing_semantic_analysis_p
argument_list|()
condition|)
name|maybe_inject_for_scope_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Initialize the local variable.  But, if we're building a 	     statement-tree, we'll do the initialization when we 	     expand the tree.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|init
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
else|else
block|{
comment|/* If we're not building RTL, then we need to do so 		 now.  */
name|my_friendly_assert
argument_list|(
name|building_stmt_tree
argument_list|()
argument_list|,
literal|20000906
argument_list|)
expr_stmt|;
comment|/* Initialize the variable.  */
name|initialize_local_var
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Clean up the variable.  */
name|destroy_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Cleanups for static variables are handled by `finish_file'.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
operator|!=
name|NULL_TREE
operator|||
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
name|finish_end0
label|:
comment|/* Undo call to `pushclass' that was done in `start_decl' 	 due to initialization of qualified member variable. 	 I.e., Foo::x = 10;  */
block|{
name|tree
name|context
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* We also have a pushclass done that we need to undo here 		   if we're at top level and declare a method.  */
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
comment|/* If size hasn't been set, we're still defining it, 	       and therefore inside the class body; don't pop 	       the binding level..  */
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
name|context
operator|==
name|current_class_type
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
block|}
name|finish_end
label|:
if|if
condition|(
name|was_readonly
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is here for a midend callback from c-common.c */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
block|{
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a declaration for a VAR_DECL as if:       extern "C" TYPE NAME;     had been seen.  Used to create compiler-generated global    variables.  */
end_comment

begin_function
name|tree
name|declare_global_var
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns a pointer to the `atexit' function.  Note that if    FLAG_USE_CXA_ATEXIT is non-zero, then this will actually be the new    `__cxa_atexit' function specified in the IA64 C++ ABI.  */
end_comment

begin_function
specifier|static
name|tree
name|get_atexit_node
parameter_list|()
block|{
name|tree
name|atexit_fndecl
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
name|tree
name|fn_type
decl_stmt|;
name|tree
name|fn_ptr_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|atexit_node
condition|)
return|return
name|atexit_node
return|;
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
block|{
comment|/* The declaration for `__cxa_atexit' is:  	   int __cxa_atexit (void (*)(void *), void *, void *)  	 We build up the argument types and then then function type 	 itself.  */
comment|/* First, build the pointer-to-function type for the first 	 argument.  */
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|fn_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
comment|/* Then, build the rest of the argument types.  */
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn_ptr_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
comment|/* And the final __cxa_atexit type.  */
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|fn_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"__cxa_atexit"
expr_stmt|;
block|}
else|else
block|{
comment|/* The declaration for `atexit' is:             int atexit (void (*)());  	 We build up the argument types and then then function type 	 itself.  */
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|fn_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn_ptr_type
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
comment|/* Build the final atexit type.  */
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"atexit"
expr_stmt|;
block|}
comment|/* Now, build the function declaration.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|atexit_fndecl
operator|=
name|build_library_fn_ptr
argument_list|(
name|name
argument_list|,
name|fn_type
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|atexit_fndecl
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
name|atexit_node
operator|=
name|default_conversion
argument_list|(
name|atexit_fndecl
argument_list|)
expr_stmt|;
return|return
name|atexit_node
return|;
block|}
end_function

begin_comment
comment|/* Returns the __dso_handle VAR_DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|get_dso_handle_node
parameter_list|()
block|{
if|if
condition|(
name|dso_handle_node
condition|)
return|return
name|dso_handle_node
return|;
comment|/* Declare the variable.  */
name|dso_handle_node
operator|=
name|declare_global_var
argument_list|(
name|get_identifier
argument_list|(
literal|"__dso_handle"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
return|return
name|dso_handle_node
return|;
block|}
end_function

begin_comment
comment|/* Begin a new function with internal linkage whose job will be simply    to destroy some particular variable.  */
end_comment

begin_function
specifier|static
name|tree
name|start_cleanup_fn
parameter_list|()
block|{
specifier|static
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|old_interface_unknown
init|=
name|interface_unknown
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
comment|/* No need to mangle this.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
comment|/* Build the parameter-types.  */
name|parmtypes
operator|=
name|void_list_node
expr_stmt|;
comment|/* Functions passed to __cxa_atexit take an additional parameter.      We'll just ignore it.  After we implement the new calling      convention for destructors, we can eliminate the use of      additional cleanup functions entirely in the -fnew-abi case.  */
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* Build the function type itself.  */
name|fntype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* Build the name of the function.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__tcf_%d"
argument_list|,
name|counter
operator|++
argument_list|)
expr_stmt|;
comment|/* Build the function declaration.  */
name|fndecl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
comment|/* It's a function with internal linkage, generated by the      compiler.  */
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make the function `inline' so that it is only emitted if it is      actually needed.  It is unlikely that it will be inlined, since      it is only called via a function pointer, but we avoid unnecessary      emissions this way.  */
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Build the parameter.  */
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
block|{
name|tree
name|parmdecl
decl_stmt|;
name|parmdecl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|parmdecl
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parmdecl
argument_list|)
operator|=
name|ptr_type_node
expr_stmt|;
name|TREE_USED
argument_list|(
name|parmdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|parmdecl
expr_stmt|;
block|}
name|pushdecl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
comment|/*specs=*/
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
name|old_interface_unknown
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
return|return
name|current_function_decl
return|;
block|}
end_function

begin_comment
comment|/* Finish the cleanup function begun by start_cleanup_fn.  */
end_comment

begin_function
specifier|static
name|void
name|end_cleanup_fn
parameter_list|()
block|{
name|expand_body
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to handle the destruction of DECL, an object with    static storage duration.  */
end_comment

begin_function
name|void
name|register_dtor_fn
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|cleanup
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|fcall
decl_stmt|;
name|int
name|saved_flag_access_control
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Call build_cleanup before we enter the anonymous function so that      any access checks will be done relative to the current scope,      rather than the scope of the anonymous function.  */
name|build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Now start the function.  */
name|cleanup
operator|=
name|start_cleanup_fn
argument_list|()
expr_stmt|;
comment|/* Now, recompute the cleanup.  It may contain SAVE_EXPRs that refer      to the original function, rather than the anonymous one.  That      will make the back-end think that nested functions are in use,      which causes confusion.  */
name|saved_flag_access_control
operator|=
name|flag_access_control
expr_stmt|;
name|flag_access_control
operator|=
literal|0
expr_stmt|;
name|fcall
operator|=
name|build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|flag_access_control
operator|=
name|saved_flag_access_control
expr_stmt|;
comment|/* Create the body of the anonymous function.  */
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|fcall
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
name|end_cleanup_fn
argument_list|()
expr_stmt|;
comment|/* Call atexit with the cleanup function.  */
name|mark_addressable
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
block|{
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_dso_handle_node
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|null_pointer_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|get_atexit_node
argument_list|()
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_static_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|decl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|oldstatic
argument_list|)
operator|&&
name|init
operator|!=
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"multiple initializations given for `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* Emit code to perform this initialization but once.  */
name|tree
name|if_stmt
decl_stmt|;
name|tree
name|then_clause
decl_stmt|;
name|tree
name|assignment
decl_stmt|;
name|tree
name|guard
decl_stmt|;
name|tree
name|guard_init
decl_stmt|;
comment|/* Emit code to perform this initialization but once.  This code 	 looks like:             static int guard = 0;            if (!guard) {              // Do initialization. 	     guard = 1; 	     // Register variable for destruction at end of program. 	   }  	 Note that the `temp' variable is only set to 1 *after* the 	 initialization is complete.  This ensures that an exception, 	 thrown during the construction, will cause the variable to 	 reinitialized when we pass through this code again, as per:  	   [stmt.dcl]  	   If the initialization exits by throwing an exception, the 	   initialization is not complete, so it will be tried again 	   the next time control enters the declaration.           In theory, this process should be thread-safe, too; multiple 	 threads should not be able to initialize the variable more 	 than once.  We don't yet attempt to ensure thread-safety.  */
comment|/* Create the guard variable.  */
name|guard
operator|=
name|get_guard
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Begin the conditional initialization.  */
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|get_guard_cond
argument_list|(
name|guard
argument_list|)
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|then_clause
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Do the initialization itself.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
operator|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|)
condition|)
name|assignment
operator|=
name|build_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|init
condition|)
comment|/* The initialization we're doing here is just a bitwise 	   copy.  */
name|assignment
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|assignment
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Once the assignment is complete, set TEMP to 1.  Since the 	 construction of the static object is complete at this point, 	 we want to make sure TEMP is set to 1 even if a temporary 	 constructed during the initialization throws an exception 	 when it is destroyed.  So, we combine the initialization and 	 the assignment to TEMP into a single expression, ensuring 	 that when we call finish_expr_stmt the cleanups will not be 	 run until after TEMP is set to 1.  */
name|guard_init
operator|=
name|set_guard
argument_list|(
name|guard
argument_list|)
expr_stmt|;
if|if
condition|(
name|assignment
condition|)
block|{
name|assignment
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|assignment
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|guard_init
argument_list|)
argument_list|)
expr_stmt|;
name|assignment
operator|=
name|build_compound_expr
argument_list|(
name|assignment
argument_list|)
expr_stmt|;
block|}
else|else
name|assignment
operator|=
name|guard_init
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|assignment
argument_list|)
expr_stmt|;
comment|/* Use atexit to register a function for destroying this static 	 variable.  */
name|register_dtor_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|,
name|then_clause
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
else|else
name|static_aggregates
operator|=
name|tree_cons
argument_list|(
name|init
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the declaration of a catch-parameter.  */
end_comment

begin_function
name|tree
name|start_handler_parms
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|declspecs
condition|)
block|{
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|CATCHPARM
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"invalid catch parameter"
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 0 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|,
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
specifier|register
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* An array of character type can be initialized from a 	 brace-enclosed string constant.  */
if|if
condition|(
name|char_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|initial_value
operator|=
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note MAXINDEX is really the maximum index, one less than the 	 size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|eltsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|/
name|eltsize
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|ssize_int
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
condition|)
name|maxindex
operator|=
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
expr_stmt|;
else|else
name|maxindex
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|maxindex
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|maxindex
operator|=
name|copy_node
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
else|else
name|initial_value
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|tree
name|itype
decl_stmt|;
name|tree
name|domain
decl_stmt|;
name|domain
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|domain
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|domain
expr_stmt|;
if|if
condition|(
name|initial_value
condition|)
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
expr_stmt|;
else|else
name|itype
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|itype
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|itype
argument_list|)
condition|)
name|TYPE_DOMAIN
argument_list|(
name|itype
argument_list|)
operator|=
name|domain
expr_stmt|;
comment|/* The type of the main variant should never be used for arrays 	 of different sizes.  It should only ever be completed with the 	 size of the array.  */
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|TYPE_DOMAIN
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|domain
expr_stmt|;
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return zero if something is declared to be a member of type    CTYPE when in the context of CUR_TYPE.  STRING is the error    message to print in that case.  Otherwise, quietly return 1.  */
end_comment

begin_function
specifier|static
name|int
name|member_function_or_else
parameter_list|(
name|ctype
parameter_list|,
name|cur_type
parameter_list|,
name|flags
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cur_type
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|ctype
operator|&&
name|ctype
operator|!=
name|cur_type
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
name|error
argument_list|(
literal|"destructor for alien class `%T' cannot be a member"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"constructor for alien class `%T' cannot be a member"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `grokdeclarator'.  */
end_comment

begin_comment
comment|/* Generate errors possibly applicable for a given set of specifiers.    This is for ARM $7.1.2.  */
end_comment

begin_function
specifier|static
name|void
name|bad_specifiers
parameter_list|(
name|object
parameter_list|,
name|type
parameter_list|,
name|virtualp
parameter_list|,
name|quals
parameter_list|,
name|inlinep
parameter_list|,
name|friendp
parameter_list|,
name|raises
parameter_list|)
name|tree
name|object
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|quals
decl_stmt|,
name|friendp
decl_stmt|,
name|raises
decl_stmt|,
name|inlinep
decl_stmt|;
block|{
if|if
condition|(
name|virtualp
condition|)
name|error
argument_list|(
literal|"`%D' declared as a `virtual' %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|error
argument_list|(
literal|"`%D' declared as an `inline' %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
name|error
argument_list|(
literal|"`const' and `volatile' function specifiers on `%D' invalid in %s declaration"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|friendp
condition|)
name|cp_error_at
argument_list|(
literal|"`%D' declared as a friend"
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
operator|!
name|TYPE_PTRFN_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_REFFN_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|cp_error_at
argument_list|(
literal|"`%D' declared with an exception specification"
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CTYPE is class type, or null if non-class.    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE    or METHOD_TYPE.    DECLARATOR is the function's name.    VIRTUALP is truthvalue of whether the function is virtual or not.    FLAGS are to be passed through to `grokclassfn'.    QUALS are qualifiers indicating whether the function is `const'    or `volatile'.    RAISES is a list of exceptions that this function can raise.    CHECK is 1 if we must find this method in CTYPE, 0 if we should    not look, and -1 if we should not call `grokclassfn' at all.     Returns `NULL_TREE' if something goes wrong, after issuing    applicable error messages.  */
end_comment

begin_function
specifier|static
name|tree
name|grokfndecl
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|,
name|declarator
parameter_list|,
name|orig_declarator
parameter_list|,
name|virtualp
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|,
name|raises
parameter_list|,
name|check
parameter_list|,
name|friendp
parameter_list|,
name|publicp
parameter_list|,
name|inlinep
parameter_list|,
name|funcdef_flag
parameter_list|,
name|template_count
parameter_list|,
name|in_namespace
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|tree
name|orig_declarator
decl_stmt|;
name|int
name|virtualp
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|check
decl_stmt|,
name|friendp
decl_stmt|,
name|publicp
decl_stmt|,
name|inlinep
decl_stmt|,
name|funcdef_flag
decl_stmt|,
name|template_count
decl_stmt|;
name|tree
name|in_namespace
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|staticp
init|=
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
decl_stmt|;
name|int
name|has_default_arg
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|raises
condition|)
name|type
operator|=
name|build_exception_variant
argument_list|(
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Propagate volatile out from type to decl. */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this decl has namespace scope, set that up.  */
if|if
condition|(
name|in_namespace
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|in_namespace
argument_list|,
name|friendp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ctype
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* `main' and builtins have implicit 'C' linkage.  */
if|if
condition|(
operator|(
name|MAIN_NAME_P
argument_list|(
name|declarator
argument_list|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
name|ctype
operator|==
name|NULL_TREE
comment|/* NULL_TREE means global namespace.  */
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|decl
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
comment|/* Should probably propagate const out from type to decl I bet (mrs).  */
if|if
condition|(
name|staticp
condition|)
block|{
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
if|if
condition|(
name|ctype
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|DECL_MAIN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|error
argument_list|(
literal|"cannot declare `::main' to be a template"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|error
argument_list|(
literal|"cannot declare `::main' to be inline"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|publicp
condition|)
name|error
argument_list|(
literal|"cannot declare `::main' to be static"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|error
argument_list|(
literal|"`main' must return `int'"
argument_list|)
expr_stmt|;
name|inlinep
operator|=
literal|0
expr_stmt|;
name|publicp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Members of anonymous types and local classes have no linkage; make      them internal.  */
comment|/* FIXME what if it gets a name from typedef?  */
if|if
condition|(
name|ctype
operator|&&
operator|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|ctype
argument_list|)
operator|||
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|)
condition|)
name|publicp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|publicp
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the name of a class 	 or enumeration declared in a local scope) shall not be used to 	 declare an entity with linkage.  	 Only check this for public decls for now.  */
name|t
operator|=
name|no_linkage_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_EXTERN_C_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Allow this; it's pretty common in C.  */
empty_stmt|;
else|else
block|{
name|pedwarn
argument_list|(
literal|"non-local function `%#D' uses anonymous type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"\ `%#D' does not refer to the unqualified type, so it is not used for linkage"
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pedwarn
argument_list|(
literal|"non-local function `%#D' uses local type `%T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|publicp
expr_stmt|;
if|if
condition|(
operator|!
name|publicp
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the declaration was declared inline, mark it as such.  */
if|if
condition|(
name|inlinep
condition|)
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We inline functions that are explicitly declared inline, or, when      the user explicitly asks us to, all functions.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|||
name|flag_inline_trees
operator|==
literal|2
condition|)
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%smember function `%D' cannot have `%T' method qualifier"
argument_list|,
operator|(
name|ctype
condition|?
literal|"static "
else|:
literal|"non-"
operator|)
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|decl
argument_list|,
name|friendp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|has_default_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|friendp
operator|&&
name|TREE_CODE
argument_list|(
name|orig_declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
name|funcdef_flag
condition|)
name|error
argument_list|(
literal|"defining explicit specialization `%D' in friend declaration"
argument_list|,
name|orig_declarator
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|fns
init|=
name|TREE_OPERAND
argument_list|(
name|orig_declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|orig_declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
block|{
comment|/* Something like `template<class T> friend void f<T>()'.  */
name|error
argument_list|(
literal|"invalid use of template-id `%D' in declaration of primary template"
argument_list|,
name|orig_declarator
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* A friend declaration of the form friend void f<>().  Record 	     the information in the TEMPLATE_ID_EXPR.  */
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
comment|/* Due to bison parser ickiness, we will have already looked                  up an operator_name or PFUNCNAME within the current class                  (see template_id in parse.y). If the current class contains                  such a name, we'll get a COMPONENT_REF here. Undo that. */
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|current_class_type
argument_list|,
literal|20001120
argument_list|)
expr_stmt|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|LOOKUP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
argument_list|,
literal|20001120
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|fns
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_default_arg
condition|)
block|{
name|error
argument_list|(
literal|"default arguments are not allowed in declaration of friend template specialization `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|error
argument_list|(
literal|"`inline' is not allowed in declaration of friend template specialization `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|}
if|if
condition|(
name|has_default_arg
condition|)
name|add_defarg_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
comment|/* Make the init_value nonzero so pushdecl knows this is not        tentative.  error_mark_node is replaced later with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|TYPE_NOTHROW_P
argument_list|(
name|type
argument_list|)
operator|||
name|nothrow_libfn_p
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Caller will do the rest of this.  */
if|if
condition|(
name|check
operator|<
literal|0
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|declarator
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Function gets the ugly name, field gets the nice one.  This call      may change the type of the function (because of default      parameters)!  */
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|check_explicit_specialization
argument_list|(
name|orig_declarator
argument_list|,
name|decl
argument_list|,
name|template_count
argument_list|,
literal|2
operator|*
operator|(
name|funcdef_flag
operator|!=
literal|0
operator|)
operator|+
literal|4
operator|*
operator|(
name|friendp
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|ctype
argument_list|)
operator|||
name|check_java_method
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|check
condition|)
block|{
name|tree
name|old_decl
decl_stmt|;
name|old_decl
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|&&
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* Because grokfndecl is always supposed to return a 	   FUNCTION_DECL, we pull out the DECL_TEMPLATE_RESULT 	   here.  We depend on our callers to figure out that its 	   really a template that's being returned.  */
name|old_decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Remove the `this' parm added by grokclassfn. 	     XXX Isn't this done in start_function, too?  */
name|revert_static_member_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_decl
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|old_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"definition of implicitly-declared `%D'"
argument_list|,
name|old_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
condition|)
block|{
comment|/* Since we've smashed OLD_DECL to its 	     DECL_TEMPLATE_RESULT, we must do the same to DECL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Attempt to merge the declarations.  This can fail, in 	     the case of some illegal specialization declarations.  */
if|if
condition|(
operator|!
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|old_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"no `%#D' member function declared in class `%T'"
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|old_decl
return|;
block|}
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|grok_ctor_properties
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|||
name|check
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|virtualp
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|grokvardecl
parameter_list|(
name|type
parameter_list|,
name|declarator
parameter_list|,
name|specbits_in
parameter_list|,
name|initialized
parameter_list|,
name|constp
parameter_list|,
name|in_namespace
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|RID_BIT_TYPE
modifier|*
name|specbits_in
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|tree
name|in_namespace
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|RID_BIT_TYPE
name|specbits
decl_stmt|;
name|specbits
operator|=
operator|*
name|specbits_in
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* If you declare a static member so that it 	 can be initialized, the code will reach here.  */
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
block|}
else|else
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|in_namespace
condition|)
name|context
operator|=
name|in_namespace
expr_stmt|;
elseif|else
if|if
condition|(
name|namespace_bindings_p
argument_list|()
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
name|context
operator|=
name|current_namespace
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* For namespace-scope variables, declared in a template, we 	 need the full lang_decl.  The same is true for 	 namespace-scope variables that do not have C++ language 	 linkage.  */
if|if
condition|(
name|context
operator|&&
operator|(
name|processing_template_decl
operator|||
name|current_lang_name
operator|!=
name|lang_name_cplusplus
operator|)
condition|)
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|context
operator|&&
name|current_lang_name
operator|!=
name|lang_name_c
condition|)
comment|/* We can't mangle lazily here because we don't have any 	   way to recover whether or not a variable was `extern 	   "C"' later.  */
name|mangle_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_namespace
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|in_namespace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
comment|/* In class context, static means one per class,      public access, and static storage.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* At top level, either `static' or no s.c. makes a definition      (perhaps tentative), and absence of `static' makes it public.  */
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|RIDBIT_NOTSETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|&&
operator|(
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|constp
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the name of a class 	 or enumeration declared in a local scope) shall not be used to 	 declare an entity with linkage.  	 Only check this for public decls for now.  */
name|tree
name|t
init|=
name|no_linkage_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Ignore for now; `enum { foo } e' is pretty common.  */
empty_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"non-local variable `%#D' uses local type `%T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create and return a canonical pointer to member function type, for    TYPE, which is a POINTER_TYPE to a METHOD_TYPE.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
index|[
literal|4
index|]
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|unqualified_variant
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|type
return|;
comment|/* If a canonical type already exists for this type, use it.  We use      this method instead of type_hash_canon, because it only does a      simple equality check on the list of field members.  */
if|if
condition|(
operator|(
name|t
operator|=
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
comment|/* Make sure that we always have the unqualified pointer-to-member      type first.  */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|unqualified_variant
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Let the front-end know this is a pointer to member function...  */
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ... and not really an aggregate.  */
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|t
argument_list|,
literal|"__ptrmemfunc_type"
argument_list|,
name|fields
argument_list|,
literal|1
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* Zap out the name so that the back-end will give us the debugging      information for this anonymous RECORD_TYPE.  */
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If this is not the unqualified form of this pointer-to-member      type, set the TYPE_MAIN_VARIANT for this type to be the      unqualified type.  Since they are actually RECORD_TYPEs that are      not variants of each other, we must do this manually.  */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|t
operator|=
name|build_qualified_type
argument_list|(
name|t
argument_list|,
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|unqualified_variant
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|unqualified_variant
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|unqualified_variant
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* Cache this pointer-to-member type so that we can find it again      later.  */
name|TYPE_SET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Seems to be wanted.  */
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL defined in-class, whose TYPE is also given.    Check to see that the definition is valid.  Issue appropriate error    messages.  Return 1 if the definition is particularly bad, or 0    otherwise.  */
end_comment

begin_function
name|int
name|check_static_variable_definition
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
comment|/* Motion 10 at San Diego: If a static const integral data member is      initialized with an integral constant expression, the initializer      may appear either in the declaration (within the class), or in      the definition, but not both.  If it appears in the class, the      member is a member constant.  The file-scope definition is always      required.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid in-class initialization of static data member of non-integral type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If we just return the declaration, crashes will sometimes 	 occur.  We therefore return void_type_node, as if this was a 	 friend declaration, to cause callers to completely ignore 	 this declaration.  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"ISO C++ forbids in-class initialization of non-const static member `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids initialization of member constant `%D' of non-integral type `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given the SIZE (i.e., number of elements) in an array, compute an    appropriate index type for the array.  If non-NULL, NAME is the    name of the thing being declared.  */
end_comment

begin_function
name|tree
name|compute_array_index_type
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|size
decl_stmt|;
block|{
name|tree
name|itype
decl_stmt|;
comment|/* If this involves a template parameter, it will be a constant at      instantiation time, but we don't know what the value is yet.      Even if no template parameters are involved, we may an expression      that is not a constant; we don't even simplify `1 + 2' when      processing a template.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* Resolve a qualified reference to an enumerator or static 	 const data member of ours.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_type
condition|)
block|{
name|tree
name|t
init|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|size
operator|=
name|t
expr_stmt|;
block|}
return|return
name|build_index_type
argument_list|(
name|build_min
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
return|;
block|}
comment|/* The size might be the result of a cast. */
name|STRIP_TYPE_NOPS
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* It might be a const variable or enumeration constant.  */
name|size
operator|=
name|decl_constant_value
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* The array bound must be an integer type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"size of array `%D' has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"size of array has non-integer type"
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
comment|/* Normally, the array-bound will be a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Check to see if the array bound overflowed.  Make that an 	 error, no matter how generous we're being.  */
name|int
name|old_flag_pedantic_errors
init|=
name|flag_pedantic_errors
decl_stmt|;
name|int
name|old_pedantic
init|=
name|pedantic
decl_stmt|;
name|pedantic
operator|=
name|flag_pedantic_errors
operator|=
literal|1
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|pedantic
operator|=
name|old_pedantic
expr_stmt|;
name|flag_pedantic_errors
operator|=
name|old_flag_pedantic_errors
expr_stmt|;
comment|/* An array must have a positive number of elements.  */
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|size
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"size of array `%D' is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"size of array is negative"
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
comment|/* Except that an extension we allow zero-sized arrays.  We 	 always allow them in system headers because glibc uses 	 them.  */
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|size
argument_list|)
operator|&&
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids zero-size array `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C++ forbids zero-size array"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* `(int)&fn' is not a valid array bound.  */
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"size of array `%D' is not an integral constant-expression"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"size of array is not an integral constant-expression"
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the index of the largest element in the array.  It is      one less than the number of elements in the array.  */
name|itype
operator|=
name|fold
argument_list|(
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|ssizetype
argument_list|,
name|size
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|ssizetype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for variable-sized arrays.  We allow such things as an      extension, even though they are not allowed in ANSI/ISO C++.  */
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|itype
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids variable-size array `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C++ forbids variable-size array"
argument_list|)
expr_stmt|;
block|}
comment|/* Create a variable-sized array index type.  */
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that there was no overflow when creating to a signed      index type.  (For example, on a 32-bit machine, an array with      size 2^32 - 1 is too big.)  */
elseif|else
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"overflow in array dimension"
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Create and return the appropriate index type.  */
return|return
name|build_index_type
argument_list|(
name|itype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns an ARRAY_TYPE for an array with SIZE elements of the    indicated TYPE.  If non-NULL, NAME is the NAME of the declaration    with this type.  */
end_comment

begin_function
specifier|static
name|tree
name|create_array_type_for_decl
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|size
decl_stmt|;
block|{
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_msg
decl_stmt|;
comment|/* If things have already gone awry, bail now.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|size
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Assume that everything will go OK.  */
name|error_msg
operator|=
name|NULL
expr_stmt|;
comment|/* There are some types which cannot be array elements.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
name|error_msg
operator|=
literal|"array of void"
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|error_msg
operator|=
literal|"array of functions"
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|error_msg
operator|=
literal|"array of references"
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|error_msg
operator|=
literal|"array of data members"
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|error_msg
operator|=
literal|"array of function members"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If something went wrong, issue an error-message and return.  */
if|if
condition|(
name|error_msg
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"declaration of `%D' as %s"
argument_list|,
name|name
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"creating %s"
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [dcl.array]       The constant expressions that specify the bounds of the arrays      can be omitted only for the first member of the sequence.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"declaration of `%D' as multidimensional array must have bounds for all dimensions except the first"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"multidimensional array must have bounds for all dimensions except the first"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Figure out the index type for the array.  */
if|if
condition|(
name|size
condition|)
name|itype
operator|=
name|compute_array_index_type
argument_list|(
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check that it's OK to declare a function with the indicated TYPE.    SFK indicates the kind of special function (if any) that this    function is.  OPTYPE is the type given in a conversion operator    declaration.  Returns the actual return type of the function; that    may be different than TYPE if an error occurs, or for certain    special functions.  */
end_comment

begin_function
specifier|static
name|tree
name|check_special_function_return_type
parameter_list|(
name|sfk
parameter_list|,
name|type
parameter_list|,
name|optype
parameter_list|)
name|special_function_kind
name|sfk
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|optype
decl_stmt|;
block|{
switch|switch
condition|(
name|sfk
condition|)
block|{
case|case
name|sfk_constructor
case|:
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"return type specification for constructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|sfk_destructor
case|:
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"return type specification for destructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|sfk_conversion
case|:
if|if
condition|(
name|type
operator|&&
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|optype
argument_list|)
condition|)
name|error
argument_list|(
literal|"operator `%T' declared to return `%T'"
argument_list|,
name|optype
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
condition|)
name|pedwarn
argument_list|(
literal|"return type specified for `operator %T'"
argument_list|,
name|optype
argument_list|)
expr_stmt|;
name|type
operator|=
name|optype
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      MEMFUNCDEF for a function definition.  Like FUNCDEF but prepares to       handle member functions (which have FIELD context).       Return value may be zero meaning this definition is too screwy to       try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      CATCHPARM for a parameter declaration before a catch clause.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.      BITFIELD for a field with specified width.    INITIALIZED is 1 if the decl has an initializer.     ATTRLIST is a pointer to the list of attributes, which may be NULL    if there are none; *ATTRLIST may be modified if attributes from inside    the declarator should be applied to the declaration.     In the TYPENAME case, DECLARATOR is really an abstract declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.     For C++, if there is any monkey business to do, the function which    calls this one must do it, i.e., prepending instance variables,    renaming overloaded function names, etc.     Note that for this C++, it is an error to define a method within a class    which does not belong to that class.     Except in the case where SCOPE_REFs are implicitly known (such as    methods within a class being redundantly qualified),    declarations which involve SCOPE_REFs are returned as SCOPE_REFs    (class_name::decl_name).  The caller must also deal with this.     If a constructor or destructor is seen, and the context is FIELD,    then the type gains the attribute TREE_HAS_x.  If such a declaration    is erroneous, NULL_TREE is returned.     QUALS is used only for FUNCDEF and MEMFUNCDEF cases.  For a member    function, these are the qualifiers to give to the `this' pointer. We    apply TYPE_QUAL_RESTRICT to the this ptr, not the object.     May return void_type_node if the declarator turned out to be a friend.    See grokfield for details.  */
end_comment

begin_function
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|,
name|attrlist
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
modifier|*
name|attrlist
decl_stmt|;
block|{
name|RID_BIT_TYPE
name|specbits
decl_stmt|;
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|restrictp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|explicitp
decl_stmt|,
name|friendp
decl_stmt|,
name|inlinep
decl_stmt|,
name|staticp
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|int
name|defaulted_int
init|=
literal|0
decl_stmt|;
name|int
name|extern_langp
init|=
literal|0
decl_stmt|;
name|tree
name|typedef_decl
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
name|int
name|bitfield
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
comment|/* See the code below that used this.  */
block|tree decl_attr = NULL_TREE;
endif|#
directive|endif
comment|/* Set this to error_mark_node for FIELD_DECLs we could not handle properly.      All FIELD_DECLs we build here have `init' put into their DECL_INITIAL.  */
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Keep track of what sort of function is being processed      so that we can warn about default return values, or explicit      return values which do not match prescribed defaults.  */
name|special_function_kind
name|sfk
init|=
name|sfk_none
decl_stmt|;
name|tree
name|dname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctype
init|=
name|current_class_type
decl_stmt|;
name|tree
name|ctor_return_type
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|overload_flags
name|flags
init|=
name|NO_SPECIAL
decl_stmt|;
name|tree
name|quals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|raises
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_count
init|=
literal|0
decl_stmt|;
name|tree
name|in_namespace
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|returned_attrs
init|=
name|NULL_TREE
decl_stmt|;
name|RIDBIT_RESET_ALL
argument_list|(
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|MEMFUNCDEF
condition|)
name|funcdef_flag
operator|=
operator|-
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|BITFIELD
condition|)
name|bitfield
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
name|tree
modifier|*
name|next
init|=
operator|&
name|declarator
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next
operator|&&
operator|*
name|next
condition|)
block|{
name|decl
operator|=
operator|*
name|next
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TREE_LIST
case|:
comment|/* For attributes.  */
name|next
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* For C++ destructors!  */
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rename
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|152
argument_list|)
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|sfk
operator|=
name|sfk_destructor
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|name
operator|=
name|constructor_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|153
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"destructors must be member functions"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|NO_SPECIAL
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|current_class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|rename
condition|)
block|{
name|error
argument_list|(
literal|"destructor `%T' must match class name `%T'"
argument_list|,
name|name
argument_list|,
name|rename
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|rename
expr_stmt|;
block|}
name|next
operator|=
operator|&
name|name
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* C++ reference declaration */
comment|/* Fall through. */
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|parmlist_is_exprlist
argument_list|(
name|CALL_DECLARATOR_PARMS
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is actually a variable declaration using 		   constructor syntax.  We need to call start_decl and 		   cp_finish_decl so we can get the variable 		   initialized...  */
name|tree
name|attributes
decl_stmt|;
operator|*
name|next
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|CALL_DECLARATOR_PARMS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrlist
condition|)
block|{
name|attributes
operator|=
operator|*
name|attrlist
expr_stmt|;
block|}
else|else
block|{
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|1
argument_list|,
name|attributes
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_type_access_control
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
comment|/* Look for __unused__ attribute */
if|if
condition|(
name|TREE_USED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid declarator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
operator|)
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
operator|*
name|next
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|flags
operator|!=
name|DTOR_FLAG
operator|&&
name|decl
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|sfk
operator|=
name|sfk_constructor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|fns
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dname
operator|=
name|fns
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|dname
operator|=
name|TREE_OPERAND
argument_list|(
name|dname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|dname
argument_list|)
argument_list|,
literal|19990331
argument_list|)
expr_stmt|;
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through. */
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|dname
operator|=
name|decl
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declarator-id missing; using reserved word `%D'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|dname
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|154
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TYPENAME_FLAG
expr_stmt|;
name|ctor_return_type
operator|=
name|TREE_TYPE
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|sfk
operator|=
name|sfk_conversion
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|dname
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|"<invalid operator>"
expr_stmt|;
block|}
break|break;
comment|/* C++ extension */
case|case
name|SCOPE_REF
case|:
block|{
comment|/* Perform error checking, and decide on a ctype.  */
name|tree
name|cname
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|in_namespace
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Must test TREE_OPERAND (decl, 1), in case user gives 		 us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */
elseif|else
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|ctype
operator|=
name|cname
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|error
argument_list|(
literal|"`%T::%D' is not a valid declarator"
argument_list|,
name|cname
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  perhaps you want `typename %T::%D' to make it a type"
argument_list|,
name|cname
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|cname
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_depth
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|cname
argument_list|,
name|ctype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type `%T' is not derived from type `%T'"
argument_list|,
name|cname
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|ctype
operator|=
name|cname
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
operator|)
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
operator|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|=
operator|*
name|next
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|decl
condition|)
block|{
name|sfk
operator|=
name|sfk_constructor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|||
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|sfk
operator|=
name|sfk_destructor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ERROR_MARK
case|:
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Parse error puts this typespec where 	       a declarator should go.  */
name|error
argument_list|(
literal|"`%T' specified as declarator-id"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
condition|)
name|error
argument_list|(
literal|"  perhaps you want `%T' for a constructor"
argument_list|,
name|current_class_name
argument_list|)
expr_stmt|;
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
comment|/* Avoid giving two errors for this.  */
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|dname
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|declspecs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|dname
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
literal|"`%D' as declarator"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|(
name|dname
operator|&&
name|IDENTIFIER_OPNAME_P
argument_list|(
name|dname
argument_list|)
operator|)
operator|||
name|flags
operator|==
name|TYPENAME_FLAG
operator|)
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
operator|&&
operator|!
operator|(
name|ctype
operator|&&
name|declspecs
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%D' as non-function"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* This heuristic cannot be applied to C++ nodes! Fixed, however,      by not allowing C++ class definitions to specify their parameters      with xdecls (must be spec.d in the parmlist).       Since we now wait to push a class scope until we are sure that      we are in a legitimate method context, we must set oldcname      explicitly (since current_class_name is not yet alive).       We also want to avoid calling this a PARM if it is in a namespace.  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
literal|0
operator|&&
name|toplevel_bindings_p
argument_list|()
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|decl_context
operator|==
name|PARM
condition|?
literal|"parameter"
else|:
literal|"type name"
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT if the type is `int' or `char' and did not      come from a user typedef.       Set LONGLONG if `long' is mentioned twice.       For C++, constructors and destructors have their own fast treatment.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|id
decl_stmt|;
comment|/* Certain parse errors slip through.  For example, 	 `int class;' is not caught by the parser. Try 	 weakly to recover here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|0
return|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
expr_stmt|;
comment|/* If the entire declaration is itself tagged as deprecated then          suppress reports of deprecated items.  */
if|if
condition|(
operator|!
name|adding_implicit_members
operator|&&
name|id
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|deprecated_state
operator|!=
name|DEPRECATED_SUPPRESS
condition|)
name|warn_deprecated_use
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BOOL
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BOOL
index|]
condition|)
name|error
argument_list|(
literal|"`bool' is now a keyword"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"extraneous `%T' ignored"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
name|explicit_int
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
name|explicit_char
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* C++ aggregate types.  */
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"multiple declarations `%T' and `%T'"
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|RID_FIRST_MODIFIER
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|RID_LAST_MODIFIER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
name|i
index|]
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_LONG
operator|&&
name|RIDBIT_SETP
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ does not support `long long'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|longlong
condition|)
name|error
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|TREE_PURPOSE
argument_list|(
name|spec
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* This extern was part of a language linkage.  */
name|extern_langp
operator|=
literal|1
expr_stmt|;
name|RIDBIT_SET
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
comment|/* C++ aggregate types.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"multiple declarations `%T' and `%T'"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See the code below that used this.  */
block|decl_attr = DECL_ATTRIBUTES (id);
endif|#
directive|endif
name|typedef_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|!=
name|error_mark_node
condition|)
comment|/* Can't change CLASS nodes into RECORD nodes here!  */
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
comment|/* No type at all: default to `int', and set DEFAULTED_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
block|{
comment|/* These imply 'int'.  */
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|defaulted_int
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sfk
operator|!=
name|sfk_none
condition|)
name|type
operator|=
name|check_special_function_return_type
argument_list|(
name|sfk
argument_list|,
name|type
argument_list|,
name|ctor_return_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|is_main
decl_stmt|;
name|explicit_int
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We handle `main' specially here, because 'main () { }' is so 	 common.  With no options, it is allowed.  With -Wreturn-type, 	 it is a warning.  It is only an error with -pedantic-errors.  */
name|is_main
operator|=
operator|(
name|funcdef_flag
operator|&&
name|dname
operator|&&
name|MAIN_NAME_P
argument_list|(
name|dname
argument_list|)
operator|&&
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|in_namespace
operator|==
name|NULL_TREE
operator|&&
name|current_namespace
operator|==
name|global_namespace
operator|)
expr_stmt|;
if|if
condition|(
name|in_system_header
operator|||
name|flag_ms_extensions
condition|)
comment|/* Allow it, sigh.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|||
operator|!
name|is_main
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids declaration of `%s' with no type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_return_type
condition|)
name|warning
argument_list|(
literal|"ISO C++ forbids declaration of `%s' with no type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* The implicit typename extension is deprecated and will be 	 removed.  Warn about its use now.  */
name|warning
argument_list|(
literal|"`%T' is implicitly a typename"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_deprecated
argument_list|(
literal|"implicit typename"
argument_list|)
expr_stmt|;
comment|/* Now remove its implicitness, so that we don't warn again.          For instance this might be a typedef, and we do not want to          warn on uses of the typedef itself.  Simply clearing the          TREE_TYPE is insufficient.  */
name|type
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_qualified_type
argument_list|(
name|long_double_type_node
argument_list|,
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"long and short specified together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"long or short specified with floating type for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"signed and unsigned given together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|defaulted_int
operator|&&
operator|!
name|explicit_char
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_COMPLEX
argument_list|,
name|specbits
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"complex invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_COMPLEX
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bitfields as signed by default.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
comment|/* [class.bit]  	 It is implementation-defined whether a plain (neither 	 explicitly signed or unsigned) char, short, int, or long 	 bit-field is signed or unsigned.  	 Naturally, we extend this to long long as well.  Note that 	 this does not include wchar_t.  */
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
comment|/* A typedef for plain `int' without `signed' can be 	     controlled just like plain `int', but a typedef for 	     `signed int' cannot be so controlled.  */
operator|&&
operator|!
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|CHAR_TYPE
operator|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|wchar_type_node
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_COMPLEX
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
comment|/* If we just have "complex", it is equivalent to 	 "complex double", but if any modifiers at all are specified it is 	 the complex form of TYPE.  E.g, "complex short" is 	 "complex short int".  */
if|if
condition|(
name|defaulted_int
operator|&&
operator|!
name|longlong
operator|&&
operator|!
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
name|type
operator|=
name|complex_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|complex_float_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|type
operator|=
name|complex_long_double_type_node
expr_stmt|;
else|else
name|type
operator|=
name|build_complex_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sfk
operator|==
name|sfk_conversion
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_CONST
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_VOLATILE
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_RESTRICT
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"qualifiers are not allowed on declaration of `operator %T'"
argument_list|,
name|ctor_return_type
argument_list|)
expr_stmt|;
comment|/* Set CONSTP if this declaration is `const', whether by      explicit specification or via a typedef.      Likewise for VOLATILEP.  */
name|constp
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_CONST
argument_list|,
name|specbits
argument_list|)
operator|+
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|restrictp
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_RESTRICT
argument_list|,
name|specbits
argument_list|)
operator|+
name|CP_TYPE_RESTRICT_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_VOLATILE
argument_list|,
name|specbits
argument_list|)
operator|+
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|virtualp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_VIRTUAL
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_VIRTUAL
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|explicitp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_EXPLICIT
argument_list|,
name|specbits
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXPLICIT
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|staticp
operator|=
literal|1
operator|+
operator|(
name|decl_context
operator|==
name|FIELD
operator|)
expr_stmt|;
if|if
condition|(
name|virtualp
operator|&&
name|staticp
operator|==
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"member `%D' cannot be declared both virtual and static"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
name|friendp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
comment|/* Warn if two storage classes are given. Default to `auto'.  */
if|if
condition|(
name|RIDBIT_ANY_SET
argument_list|(
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
operator|!
name|extern_langp
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|nclasses
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in parameter declarations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|error
argument_list|(
literal|"typedef declaration invalid in parameter declaration"
argument_list|)
expr_stmt|;
name|nclasses
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nclasses
operator|&&
operator|!
name|friendp
operator|&&
name|extern_langp
condition|)
name|nclasses
operator|++
expr_stmt|;
block|}
comment|/* Give error if `virtual' is used outside of class declaration.  */
if|if
condition|(
name|virtualp
operator|&&
operator|(
name|current_class_name
operator|==
name|NULL_TREE
operator|||
name|decl_context
operator|!=
name|FIELD
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"virtual outside class declaration"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Static anonymous unions are dealt with here.  */
if|if
condition|(
name|staticp
operator|&&
name|decl_context
operator|==
name|TYPENAME
operator|&&
name|TREE_CODE
argument_list|(
name|declspecs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
condition|)
name|decl_context
operator|=
name|FIELD
expr_stmt|;
comment|/* Warn about storage classes that are invalid for certain      kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
operator|)
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
comment|/* C++ allows static class elements  */
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
comment|/* C++ also allows inlines and signed and unsigned elements, 	   but in those cases we don't come in here.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|int
name|op
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|declarator
condition|)
block|{
comment|/* Avoid trying to get an operand off an identifier node.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|tmp
operator|=
name|declarator
expr_stmt|;
else|else
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|IDENTIFIER_OPNAME_P
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|"<invalid operator>"
expr_stmt|;
block|}
block|}
name|error
argument_list|(
literal|"storage class specified for %s `%s'"
argument_list|,
name|op
condition|?
literal|"member operator"
else|:
literal|"field"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
condition|)
name|error
argument_list|(
literal|"storage class specified for parameter `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"storage class specified for typename"
argument_list|)
expr_stmt|;
block|}
name|RIDBIT_RESET
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* It's common practice (and completely valid) to have a const 	     be initialized and declared extern.  */
if|if
condition|(
operator|!
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|funcdef_flag
operator|&&
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"nested function `%s' declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nclasses
operator|>
literal|0
operator|&&
name|friendp
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in friend function declarations"
argument_list|)
expr_stmt|;
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 For C++ it could also be 	 a SCOPE_REF (for class :: ...).  In this case, we have converted 	 sensible names to types, and those are the values we use to 	 qualify the member name. 	 an ADDR_EXPR (for&...), 	 a BIT_NOT_EXPR (for destructors)  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|declarator
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|SCOPE_REF
operator|)
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
case|case
name|TREE_LIST
case|:
block|{
comment|/* We encode a declarator with embedded attributes using 	       a TREE_LIST.  */
name|tree
name|attrs
init|=
name|TREE_PURPOSE
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
decl_stmt|;
name|int
name|attr_flags
decl_stmt|;
name|declarator
operator|=
name|TREE_VALUE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|inner_decl
operator|=
name|declarator
expr_stmt|;
while|while
condition|(
name|inner_decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|inner_decl
operator|=
name|TREE_VALUE
argument_list|(
name|inner_decl
argument_list|)
expr_stmt|;
name|attr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
expr_stmt|;
name|returned_attrs
operator|=
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|chainon
argument_list|(
name|returned_attrs
argument_list|,
name|attrs
argument_list|)
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_REF
case|:
block|{
specifier|register
name|tree
name|size
decl_stmt|;
name|size
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* VC++ spells a zero-sized array with [].  */
if|if
condition|(
name|size
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
operator|!
name|staticp
operator|&&
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
name|size
operator|=
name|integer_zero_node
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_array_type_for_decl
argument_list|(
name|dname
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* VLAs never work as fields. */
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
operator|!
name|processing_template_decl
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of member `%D' is not constant"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
comment|/* Proceed with arbitrary constant size, so that offset 		   computations don't get confused. */
name|type
operator|=
name|create_array_type_for_decl
argument_list|(
name|dname
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|arg_types
decl_stmt|;
name|int
name|funcdecl_p
decl_stmt|;
name|tree
name|inner_parms
init|=
name|CALL_DECLARATOR_PARMS
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Declaring a function type. 	       Make sure we have a valid type for the function to return.  */
comment|/* We now know that the TYPE_QUALS don't apply to the                decl, but to its return type.  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|inner_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|inner_decl
operator|=
name|dname
expr_stmt|;
comment|/* Pick up type qualifiers which should be applied to `this'.  */
name|quals
operator|=
name|CALL_DECLARATOR_QUALS
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
comment|/* Pick up the exception specifications.  */
name|raises
operator|=
name|CALL_DECLARATOR_EXCEPTION_SPEC
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
comment|/* Say it's a definition only for the CALL_EXPR 	       closest to the identifier.  */
name|funcdecl_p
operator|=
name|inner_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
name|funcdecl_p
operator|&&
operator|(
name|friendp
operator|==
literal|0
operator|||
name|dname
operator|==
name|current_class_name
operator|)
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|sfk
operator|==
name|sfk_conversion
condition|)
name|TYPE_HAS_CONVERSION
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|dname
condition|)
block|{
comment|/* We are within a class's scope. If our declarator name 		   is the same as the class name, and we are defining 		   a function, then it is a constructor/destructor, and 		   therefore returns a void type.  */
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
comment|/* ISO C++ 12.4/2.  A destructor may not be 		       declared const or volatile.  A destructor may 		       not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"destructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
block|{
name|error
argument_list|(
literal|"destructors may not be `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|void_type_node
return|;
block|}
block|}
else|else
comment|/* It's a constructor.  */
block|{
if|if
condition|(
name|explicitp
operator|==
literal|1
condition|)
name|explicitp
operator|=
literal|2
expr_stmt|;
comment|/* ISO C++ 12.1.  A constructor may not be 		       declared const or volatile.  A constructor may 		       not be virtual.  A constructor may not be 		       static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"constructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
name|pedwarn
argument_list|(
literal|"constructors cannot be declared virtual"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|quals
condition|)
block|{
name|error
argument_list|(
literal|"constructors may not be `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|{
name|RID_BIT_TYPE
name|tmp_bits
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp_bits
argument_list|,
operator|&
name|specbits
argument_list|,
sizeof|sizeof
argument_list|(
name|RID_BIT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_INLINE
argument_list|,
name|tmp_bits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|tmp_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_ANY_SET
argument_list|(
name|tmp_bits
argument_list|)
condition|)
name|error
argument_list|(
literal|"return value type specifier for constructor ignored"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|void_type_node
return|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sfk
operator|!=
name|sfk_constructor
condition|)
return|return
name|NULL_TREE
return|;
block|}
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|initialized
condition|)
name|error
argument_list|(
literal|"can't initialize friend function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
comment|/* Cannot be both friend and virtual.  */
name|error
argument_list|(
literal|"virtual functions cannot be friends"
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
condition|)
name|error
argument_list|(
literal|"friend declaration not in class definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|funcdef_flag
condition|)
name|error
argument_list|(
literal|"can't define friend function `%s' in a local class definition"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the function type and go to the next 	       inner layer of declarator.  */
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: This is where default args should be fully 	       processed.  */
name|arg_types
operator|=
name|grokparms
argument_list|(
name|inner_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
comment|/* A destructor declared in the body of a class will 		   be represented as a BIT_NOT_EXPR.  But, we just 		   want the underlying IDENTIFIER.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|!=
name|void_list_node
condition|)
block|{
name|error
argument_list|(
literal|"destructors may not have parameters"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
name|last_function_parms
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* ANSI says that `const int foo ();' 	       does not make the function foo const.  */
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|arg_types
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|add_defarg_fn
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
comment|/* Filter out pointers-to-references and references-to-references. 	     We can get these if a TYPE_DECL is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare %s to references"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"references"
else|:
literal|"pointers"
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare pointer to `%#T' member"
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
comment|/* We now know that the TYPE_QUALS don't apply to the decl, 	     but to the target of the pointer.  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|error
argument_list|(
literal|"invalid type: `void&'"
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords (such as 	     const or volatile) that were given inside the `*' or `&'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|restrictp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
name|tree
name|qualifier
init|=
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RESTRICT
index|]
condition|)
name|restrictp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|erred
condition|)
block|{
name|erred
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"invalid type modifier within pointer declarator"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrictp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `restrict'"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
block|{
if|if
condition|(
name|constp
condition|)
name|pedwarn
argument_list|(
literal|"discarding `const' applied to a reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
name|pedwarn
argument_list|(
literal|"discarding `volatile' applied to a reference"
argument_list|)
expr_stmt|;
name|type_quals
operator|&=
operator|~
operator|(
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator|)
expr_stmt|;
block|}
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
block|{
comment|/* We have converted type names to NULL_TREE if the 	       name was bogus, or to a _TYPE node, if not.  	       The variable CTYPE holds the type we will ultimately 	       resolve to.  The code here just needs to build 	       up appropriate member types.  */
name|tree
name|sname
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Destructors can have their visibilities changed as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|sname
operator|=
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
comment|/* This needs to be here, in case we are called 		 multiple times.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/* Namespace member. */
name|pop_decl_namespace
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|friendp
operator|&&
operator|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|<
literal|2
operator|)
condition|)
comment|/* Don't fall out into global scope. Hides real bug? --eichin */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
name|current_class_depth
condition|)
block|{
comment|/* Resolve any TYPENAME_TYPEs from the decl-specifier-seq 		   that refer to ctype.  They couldn't be resolved earlier 		   because we hadn't pushed into the class yet. 		   Example: resolve 'B<T>::type' in 		   'B<typename B<T>::type> B<T>::f () { }'.  */
if|if
condition|(
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|type
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|current_template_args
argument_list|()
decl_stmt|;
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* This pop_nested_class corresponds to the                    push_nested_class used to push into class scope for                    parsing the argument list of a function decl, in                    qualified_id.  */
name|pop_nested_class
argument_list|()
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|=
name|current_class_depth
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* We had a reference to a global decl, or 		   perhaps we were given a non-aggregate typedef, 		   in which case we cleared this out, and should just 		   keep going as though it wasn't there.  */
name|declarator
operator|=
name|sname
expr_stmt|;
continue|continue;
block|}
name|ctype
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|ctype
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* You're supposed to have one `template<...>' 		   for every template class, but you don't need one 		   for a full specialization.  For example:  		     template<class T> struct S{}; 		     template<> struct S<int> { void f(); }; 		     void S<int>::f () {}  		   is correct; there shouldn't be a `template<>' for 		   the definition of `S<int>::f'.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|t
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|template_count
operator|+=
literal|1
expr_stmt|;
name|t
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sname
operator|==
name|NULL_TREE
condition|)
goto|goto
name|done_scoping
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* This is the `standard' use of the scoping operator: 		   basetype :: member .  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
block|{
comment|/* class A { 		         void A::f (); 		       };  		       Is this ill-formed?  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"extra qualification `%T::' on member `%s' ignored"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|friendp
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"cannot declare member function `%T::%s' within `%T'"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Have to move this code elsewhere in this function. 		       this code is used for i.e., typedef int A::M; M *pm;  		       It is?  How? jason 10/2/94 */
if|if
condition|(
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare member `%T::%s' within `%T'"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|declarator
operator|=
name|sname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|done_scoping
label|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
comment|/* In this case, we will deal with it later.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|BIT_NOT_EXPR
case|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|returned_attrs
condition|)
block|{
if|if
condition|(
name|attrlist
condition|)
operator|*
name|attrlist
operator|=
name|chainon
argument_list|(
name|returned_attrs
argument_list|,
operator|*
name|attrlist
argument_list|)
expr_stmt|;
else|else
name|attrlist
operator|=
operator|&
name|returned_attrs
expr_stmt|;
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* Did array size calculations overflow?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If we proceed with the array type as it is, we'll eventually 	 crash in tree_low_cst().  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|explicitp
operator|==
literal|1
operator|||
operator|(
name|explicitp
operator|&&
name|friendp
operator|)
condition|)
block|{
comment|/* [dcl.fct.spec] The explicit specifier shall only be used in          declarations of constructors within a class definition.  */
name|error
argument_list|(
literal|"only declarations of constructors can be `explicit'"
argument_list|)
expr_stmt|;
name|explicitp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_class_name
operator|==
name|NULL_TREE
operator|||
name|decl_context
operator|==
name|PARM
operator|||
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"non-member `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-object member `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|staticp
condition|)
block|{
name|error
argument_list|(
literal|"static `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
condition|)
block|{
name|error
argument_list|(
literal|"const `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"template-id `%D' used as a declarator"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|dname
expr_stmt|;
block|}
else|else
comment|/* Unexpected declarator format.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|&&
name|decl_context
operator|!=
name|TYPENAME
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|declarator
operator|==
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids nested type `%D' with same name as enclosing class"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_function_decl
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
block|}
comment|/* If the user declares "typedef struct {...} foo" then the 	 struct will have an anonymous name.  Fill that name in now. 	 Nothing can refer to it, so nothing needs know about the name 	 change.  */
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|declarator
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_ANONYMOUS_P
argument_list|(
name|type
argument_list|)
operator|&&
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
condition|)
block|{
name|tree
name|oldname
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Replace the anonymous name with the real name everywhere.  */
name|lookup_tag_reverse
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|oldname
condition|)
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is a typedef within a template class, the nested 	     type is a (non-primary) template.  The name for the 	     template needs updating as well.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* FIXME remangle member functions; member functions of a 	     type with external linkage have external linkage.  */
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"typedef name may not be class-qualified"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|cp_error_at
argument_list|(
literal|"invalid type qualifier for non-member function type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"type"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
name|error
argument_list|(
literal|"typedef declaration includes an initializer"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|typedef_type
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|typedef_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Detect where we're using a typedef of function type to declare a      function. last_function_parms will not be set, so we must create      it now.  */
if|if
condition|(
name|type
operator|==
name|typedef_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|args
decl_stmt|;
for|for
control|(
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|decls
expr_stmt|;
name|decls
operator|=
name|decl
expr_stmt|;
block|}
name|last_function_parms
operator|=
name|nreverse
argument_list|(
name|decls
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
comment|/* Special case: "friend class foo" looks like a TYPENAME context.  */
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|error
argument_list|(
literal|"type qualifiers specified for friend class declaration"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|error
argument_list|(
literal|"`inline' specified for friend class declaration"
argument_list|)
expr_stmt|;
name|inlinep
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Until core issue 180 is resolved, allow 'friend typename A::B'. 	     But don't allow implicit typenames except with a class-key.  */
if|if
condition|(
operator|!
name|current_aggr
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|||
name|IMPLICIT_TYPENAME_P
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|pedwarn
argument_list|(
literal|"template parameters cannot be friends"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"\ friend declaration requires class-key, i.e. `friend class %T::%T'"
argument_list|,
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"\ friend declaration requires class-key, i.e. `friend %#T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Only try to do this stuff if we didn't already give up.  */
if|if
condition|(
name|type
operator|!=
name|integer_type_node
condition|)
block|{
comment|/* DR 209. The friendly class does not need to be accessible                  in the scope of the class granting friendship. */
name|skip_type_access_control
argument_list|()
expr_stmt|;
comment|/* A friendly class?  */
if|if
condition|(
name|current_class_type
condition|)
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to make class `%T' a friend of global scope"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|error
argument_list|(
literal|"invalid qualifiers on non-member function type"
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
condition|)
block|{
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
elseif|else
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
name|decl_context
operator|!=
name|CATCHPARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
operator|!
name|bitfield
condition|)
block|{
name|error
argument_list|(
literal|"abstract declarator `%T' used as declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
block|}
comment|/* `void' at top level (not within pointer)      is allowed only in typedefs or type names.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|decl_context
operator|!=
name|PARM
condition|)
block|{
if|if
condition|(
operator|!
name|declarator
condition|)
name|error
argument_list|(
literal|"unnamed variable or field declared void"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|declarator
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"variable or field declared void"
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
condition|)
block|{
if|if
condition|(
name|ctype
operator|||
name|in_namespace
condition|)
name|error
argument_list|(
literal|"cannot use `::' in parameter declaration"
argument_list|)
expr_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	 One declared as a function is really a pointer to a function. 	 One declared as a member is really a pointer to member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"parameter"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Happens when declaring arrays of sizes which 	       are error_mark_node, for example.  */
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_namespace
operator|&&
operator|!
name|friendp
condition|)
block|{
comment|/* Something like struct S { int N::j; };  */
name|error
argument_list|(
literal|"invalid use of `::'"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|int
name|publicp
init|=
literal|0
decl_stmt|;
name|tree
name|function_context
decl_stmt|;
comment|/* We catch the others as conflicts with the builtin 	       typedefs.  */
if|if
condition|(
name|friendp
operator|&&
name|declarator
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
condition|)
block|{
name|error
argument_list|(
literal|"function `%D' cannot be declared friend"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|friendp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"can't make `%D' into a method -- not in a class"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
comment|/* ``A union may [ ... ] not [ have ] virtual functions.'' 		   ARM 9.5 */
if|if
condition|(
name|virtualp
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function `%D' declared virtual inside a union"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|declarator
operator|==
name|ansi_opname
argument_list|(
name|NEW_EXPR
argument_list|)
operator|||
name|declarator
operator|==
name|ansi_opname
argument_list|(
name|VEC_NEW_EXPR
argument_list|)
operator|||
name|declarator
operator|==
name|ansi_opname
argument_list|(
name|DELETE_EXPR
argument_list|)
operator|||
name|declarator
operator|==
name|ansi_opname
argument_list|(
name|VEC_DELETE_EXPR
argument_list|)
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"`%D' cannot be declared virtual, since it is always static"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */
name|function_context
operator|=
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|)
condition|?
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|ctype
argument_list|)
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|publicp
operator|=
operator|(
operator|!
name|friendp
operator|||
operator|!
name|staticp
operator|)
operator|&&
name|function_context
operator|==
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|?
name|declarator
else|:
name|dname
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|friendp
argument_list|,
name|publicp
argument_list|,
name|inlinep
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|decl
return|;
if|#
directive|if
literal|0
comment|/* This clobbers the attrs stored in `decl' from `attrlist'.  */
comment|/* The decl and setting of decl_attr is also turned off.  */
block|decl = build_decl_attribute_variant (decl, decl_attr);
endif|#
directive|endif
comment|/* [class.conv.ctor]  	       A constructor declared without the function-specifier 	       explicit that can be called with a single parameter 	       specifies a conversion from the type of its first 	       parameter to the type of its class.  Such a constructor 	       is called a converting constructor.  */
if|if
condition|(
name|explicitp
operator|==
literal|2
condition|)
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* The constructor can be called with exactly one 		   parameter if there is at least one parameter, and 		   any subsequent parameters have default arguments. 		   Ignore any compiler-added parms.  */
name|tree
name|arg_types
init|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|void_list_node
operator|||
operator|(
name|arg_types
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|!=
name|void_list_node
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|)
condition|)
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* We only get here for friend declarations of 	       members of other classes.  */
comment|/* All method decls are public, so tell grokfndecl to set 	       TREE_PUBLIC, also.  */
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|friendp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|staticp
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|initialized
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|declarator
condition|)
name|error
argument_list|(
literal|"field `%D' has incomplete type"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"name `%T' has incomplete type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If we're instantiating a template, tell them which 	       instantiation made the field's type be incomplete.  */
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
operator|&&
name|declspecs
operator|&&
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|error
argument_list|(
literal|"  in instantiation of template `%T'"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is neither function nor member function; cannot be declared friend"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* Friends are treated specially.  */
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
comment|/* DR 209. The friend does not need to be accessible at this                point. */
name|skip_type_access_control
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
name|warning
argument_list|(
literal|"member functions are implicitly friends of their class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|decl
operator|=
name|check_explicit_specialization
argument_list|(
name|declarator
argument_list|,
name|decl
argument_list|,
name|template_count
argument_list|,
literal|2
operator|*
operator|(
name|funcdef_flag
operator|!=
literal|0
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|t
operator|=
name|do_friend
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|last_function_parms
argument_list|,
operator|*
name|attrlist
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|funcdef_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|funcdef_flag
condition|)
return|return
name|t
return|;
return|return
name|void_type_node
return|;
block|}
comment|/* Structure field.  It may not be a function, except for C++ */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|staticp
condition|)
block|{
comment|/* An attempt is being made to initialize a non-static 		       member.  But, from [class.mem]:  		       4 A member-declarator can contain a 		       constant-initializer only if it declares a static 		       member (_class.static_) of integral or enumeration 		       type, see _class.static.data_.  		       This used to be relatively common practice, but 		       the rest of the compiler does not correctly 		       handle the initialization unless the member is 		       static so we make it static below.  */
name|pedwarn
argument_list|(
literal|"ISO C++ forbids initialization of member `%D'"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"making `%D' static"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
comment|/* We'll check at instantiation time.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|check_static_variable_definition
argument_list|(
name|declarator
argument_list|,
name|type
argument_list|)
condition|)
comment|/* If we just return the declaration, crashes 		     will sometimes occur.  We therefore return 		     void_type_node, as if this was a friend 		     declaration, to cause callers to completely 		     ignore this declaration.  */
return|return
name|void_type_node
return|;
block|}
comment|/* 9.2p13 [class.mem] */
if|if
condition|(
name|declarator
operator|==
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
comment|/* The standard does not allow non-static data members 		   here either, but we agreed at the 10/99 meeting 		   to change that in TC 1 so that they are allowed in 		   classes with no user-defined constructors.  */
operator|&&
name|staticp
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids static data member `%D' with same name as enclosing class"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticp
condition|)
block|{
comment|/* C++ allows static class members.  All other work 		   for this is done by grokfield.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In class context, 'static' means public access.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
name|bitfield
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|DECL_MUTABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"field"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|original_name
decl_stmt|;
name|int
name|publicp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|declarator
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|original_name
operator|=
name|dname
expr_stmt|;
else|else
name|original_name
operator|=
name|declarator
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"storage class `auto' invalid for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"storage class `register' invalid for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"storage class `static' invalid for function `%s' declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"storage class `inline' invalid for function `%s' declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"virtual non-class function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record presence of `static'.  */
name|publicp
operator|=
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|||
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|original_name
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
literal|1
argument_list|,
name|friendp
argument_list|,
name|publicp
argument_list|,
name|inlinep
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|int
name|illegal_static
init|=
literal|0
decl_stmt|;
comment|/* Don't allow a static member function in a class, and forbid 	       declaring main to be static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"cannot declare member function `%D' to have static linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
block|{
comment|/* FIXME need arm citation */
name|error
argument_list|(
literal|"cannot declare static function inside another function"
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|illegal_static
condition|)
block|{
name|staticp
operator|=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|decl
operator|=
name|grokvardecl
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|,
operator|&
name|specbits
argument_list|,
name|initialized
argument_list|,
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|!=
literal|0
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"variable"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|pedwarn
argument_list|(
literal|"`static' may not be used when defining (as opposed to declaring) a static data member"
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"static member `%D' declared `register'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"cannot explicitly declare member `%#D' to have extern linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|my_friendly_assert
argument_list|(
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
argument_list|,
literal|19990927
argument_list|)
expr_stmt|;
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_THIS_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  There's no need to do this        when processing a template; we'll do this for the instantiated        declaration based on the type of DECL.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|c_apply_type_quals_to_decl
argument_list|(
name|type_quals
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell if a parmlist/exprlist looks like an exprlist or a parmlist.    An empty exprlist is a parmlist.  An exprlist which    contains only identifiers at the global level    is a parmlist.  Otherwise, it is an exprlist.  */
end_comment

begin_function
name|int
name|parmlist_is_exprlist
parameter_list|(
name|exprs
parameter_list|)
name|tree
name|exprs
decl_stmt|;
block|{
if|if
condition|(
name|exprs
operator|==
name|NULL_TREE
operator|||
name|TREE_PARMLIST
argument_list|(
name|exprs
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* At the global level, if these are all identifiers, 	 then it is a parmlist.  */
while|while
condition|(
name|exprs
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|exprs
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
name|exprs
operator|=
name|TREE_CHAIN
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of start_function.  Ensure that each of the parameter    types (as listed in PARMS) is complete, as is required for a    function definition.  */
end_comment

begin_function
specifier|static
name|void
name|require_complete_types_for_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
comment|/* grokparms will have already issued an error */
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|complete_type_or_else
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|parms
argument_list|)
condition|)
name|layout_decl
argument_list|(
name|parms
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if T is a local variable.  */
end_comment

begin_function
name|int
name|local_variable_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
comment|/* A VAR_DECL with a context that is a _TYPE is a static data 	  member.  */
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
comment|/* Any other non-local variable must be at namespace scope.  */
operator|&&
operator|!
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|t
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T is an automatic local variable or a label.    (These are the declarations that need to be remapped when the code    containing them is duplicated.)  */
end_comment

begin_function
name|int
name|nonstatic_local_decl_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|local_variable_p
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RESULT_DECL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like local_variable_p, but suitable for use as a tree-walking    function.  */
end_comment

begin_function
specifier|static
name|tree
name|local_variable_p_walkfn
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|local_variable_p
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
condition|?
operator|*
name|tp
else|:
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check that ARG, which is a default-argument expression for a    parameter DECL, is legal.  Returns ARG, or ERROR_MARK_NODE, if    something goes wrong.  DECL may also be a _TYPE node, rather than a    DECL, if there is no DECL available.  */
end_comment

begin_function
name|tree
name|check_default_argument
parameter_list|(
name|decl
parameter_list|,
name|arg
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|decl_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
comment|/* We get a DEFAULT_ARG when looking at an in-class declaration        with a default argument.  Ignore the argument for now; we'll        deal with it after the class is complete.  */
return|return
name|arg
return|;
if|if
condition|(
name|processing_template_decl
operator|||
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* We don't do anything checking until instantiation-time.  Note        that there may be uninstantiated arguments even for an        instantiated function, since default arguments are not        instantiated until they are needed.  */
return|return
name|arg
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|decl_type
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|error_mark_node
operator|||
name|decl_type
operator|==
name|error_mark_node
condition|)
comment|/* Something already went wrong.  There's no need to check        further.  */
return|return
name|error_mark_node
return|;
comment|/* [dcl.fct.default]       A default argument expression is implicitly converted to the      parameter type.  */
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|||
operator|!
name|can_convert_arg
argument_list|(
name|decl_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|error
argument_list|(
literal|"default argument for `%#D' has type `%T'"
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"default argument for parameter of type `%T' has type `%T'"
argument_list|,
name|decl_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [dcl.fct.default]       Local variables shall not be used in default argument      expressions.       The keyword `this' shall not be used in a default argument of a      member function.  */
name|var
operator|=
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|arg
argument_list|,
name|local_variable_p_walkfn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
condition|)
block|{
name|error
argument_list|(
literal|"default argument `%E' uses local variable `%D'"
argument_list|,
name|arg
argument_list|,
name|var
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* All is well.  */
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Decode the list of parameter types for a function type.    Given the list of things declared inside the parens,    return a list of types.     We determine whether ellipsis parms are used by PARMLIST_ELLIPSIS_P    flag. If unset, we append void_list_node. A parmlist declared    as `(void)' is accepted as the empty parmlist.     Also set last_function_parms to the chain of PARM_DECLs.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|first_parm
parameter_list|)
name|tree
name|first_parm
decl_stmt|;
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|ellipsis
init|=
operator|!
name|first_parm
operator|||
name|PARMLIST_ELLIPSIS_P
argument_list|(
name|first_parm
argument_list|)
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|chain
decl_stmt|;
name|int
name|any_error
init|=
literal|0
decl_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|first_parm
operator|||
name|TREE_PARMLIST
argument_list|(
name|first_parm
argument_list|)
argument_list|,
literal|20001115
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|first_parm
init|;
name|parm
operator|!=
name|NULL_TREE
condition|;
name|parm
operator|=
name|chain
control|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* @@ weak defense against parse errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* Give various messages as the need arises.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|error
argument_list|(
literal|"invalid string constant `%E'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid integer constant in parameter list, did you forget to give parameter name?"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parm
operator|==
name|void_list_node
condition|)
break|break;
name|split_specs_attrs
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|specs
argument_list|,
name|PARM
argument_list|,
name|init
operator|!=
name|NULL_TREE
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|attrs
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|void_type_node
argument_list|)
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|result
operator|&&
operator|!
name|chain
operator|&&
operator|!
name|ellipsis
condition|)
comment|/* this is a parmlist of `(void)', which is ok.  */
break|break;
name|incomplete_type_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* It's not a good idea to actually create parameters of 	     type `void'; other parts of the compiler assume that a 	     void type terminates the parameter list.  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Top-level qualifiers on the parameters are 	     ignored for function types.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"parameter `%D' invalidly declared method type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"parameter `%D' invalidly declared offset type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
condition|)
name|any_error
operator|=
literal|1
expr_stmt|;
comment|/* Seems like a good idea. */
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* [dcl.fct]/6, parameter types cannot contain pointers 		 (references) to arrays of unknown bound.  */
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|ptr
init|=
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|t
argument_list|)
condition|)
name|ptr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
break|break;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"parameter `%D' includes %s to array of unknown bound `%T'"
argument_list|,
name|decl
argument_list|,
name|ptr
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|any_error
operator|&&
name|init
condition|)
name|init
operator|=
name|check_default_argument
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|decls
expr_stmt|;
name|decls
operator|=
name|decl
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|init
argument_list|,
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|decls
operator|=
name|nreverse
argument_list|(
name|decls
argument_list|)
expr_stmt|;
name|result
operator|=
name|nreverse
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ellipsis
condition|)
name|result
operator|=
name|chainon
argument_list|(
name|result
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|decls
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* D is a constructor or overloaded `operator='.     Let T be the class in which D is declared. Then, this function    returns:     -1 if D's is an ill-formed constructor or copy assignment operator       whose first parameter is of type `T'.    0  if D is not a copy constructor or copy assignment       operator.    1  if D is a copy constructor or copy assignment operator whose       first parameter is a reference to const qualified T.    2  if D is a copy constructor or copy assignment operator whose       first parameter is a reference to non-const qualified T.     This function can be used as a predicate. Positive values indicate    a copy constructor and non-zero values indicate a copy assignment    operator.  */
end_comment

begin_function
name|int
name|copy_fn_p
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|args
decl_stmt|;
name|tree
name|arg_type
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|d
argument_list|)
argument_list|,
literal|20011208
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
operator|&&
name|is_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|d
argument_list|)
argument_list|)
condition|)
comment|/* Instantiations of template member functions are never copy        functions.  Note that member functions of templated classes are        represented as template functions internally, and we must        accept those as copy functions.  */
return|return
literal|0
return|;
name|args
operator|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
return|return
literal|0
return|;
name|arg_type
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg_type
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|/* Pass by value copy assignment operator.  */
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg_type
argument_list|)
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg_type
argument_list|)
argument_list|)
condition|)
name|result
operator|=
literal|2
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|args
argument_list|)
condition|)
comment|/* There are more non-optional args.  */
return|return
literal|0
return|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Remember any special properties of member function DECL.  */
end_comment

begin_function
name|void
name|grok_special_member_properties
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
comment|/* Not special.  */
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|ctor
init|=
name|copy_fn_p
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctor
operator|>
literal|0
condition|)
block|{
comment|/* [class.copy] 	            	     A non-template constructor for class X is a copy      	     constructor if its first parameter is of type X&, const      	     X&, volatile X& or const volatile X&, and either there      	     are no other parameters or else all other parameters have      	     default arguments.  */
name|TYPE_HAS_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctor
operator|>
literal|1
condition|)
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sufficient_parms_p
argument_list|(
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* [class.copy] 	        	 A non-template assignment operator for class X is a copy      	 assignment operator if its parameter is of type X, X&, const      	 X&, volatile X& or const volatile X&.  */
name|int
name|assop
init|=
name|copy_fn_p
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|assop
condition|)
block|{
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|assop
operator|!=
literal|1
condition|)
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check a constructor DECL has the correct form.  Complains    if the class has a constructor of the form X(X).  */
end_comment

begin_function
name|int
name|grok_ctor_properties
parameter_list|(
name|ctype
parameter_list|,
name|decl
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|int
name|ctor_parm
init|=
name|copy_fn_p
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctor_parm
operator|<
literal|0
condition|)
block|{
comment|/* [class.copy] 	        	 A declaration of a constructor for a class X is ill-formed if      	 its first parameter is of type (optionally cv-qualified) X      	 and either there are no other parameters or else all other      	 parameters have default arguments. 	        	 We *don't* complain about member template instantiations that      	 have this form, though; they can occur as we try to decide      	 what constructor to use during overload resolution.  Since      	 overload resolution will never prefer such a constructor to      	 the non-template copy constructor (which is either explicitly      	 or implicitly defined), there's no need to worry about their      	 existence.  Theoretically, they should never even be      	 instantiated, but that's hard to forestall.  */
name|error
argument_list|(
literal|"invalid constructor; you probably meant `%T (const %T&)'"
argument_list|,
name|ctype
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* An operator with this code is unary, but can also be binary.  */
end_comment

begin_function
specifier|static
name|int
name|ambi_op_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|code
operator|==
name|INDIRECT_REF
operator|||
name|code
operator|==
name|ADDR_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|NEGATE_EXPR
operator|||
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* An operator with this name can only be unary.  */
end_comment

begin_function
specifier|static
name|int
name|unary_op_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|||
name|code
operator|==
name|BIT_NOT_EXPR
operator|||
name|code
operator|==
name|COMPONENT_REF
operator|||
name|code
operator|==
name|TYPE_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a little sanity-checking on how they declared their operator.  */
end_comment

begin_function
name|void
name|grok_op_properties
parameter_list|(
name|decl
parameter_list|,
name|friendp
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|friendp
decl_stmt|;
block|{
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argtype
decl_stmt|;
name|int
name|methodp
init|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|operator_code
decl_stmt|;
name|int
name|arity
decl_stmt|;
comment|/* Count the number of arguments.  */
for|for
control|(
name|argtype
operator|=
name|argtypes
operator|,
name|arity
operator|=
literal|0
init|;
name|argtype
operator|&&
name|argtype
operator|!=
name|void_list_node
condition|;
name|argtype
operator|=
name|TREE_CHAIN
argument_list|(
name|argtype
argument_list|)
control|)
operator|++
name|arity
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|friendp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
name|operator_code
operator|=
name|TYPE_EXPR
expr_stmt|;
else|else
do|do
block|{
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|CODE
parameter_list|,
name|MANGLING
parameter_list|,
name|ARITY
parameter_list|,
name|ASSN_P
parameter_list|)
define|\
value|if (ansi_opname (CODE) == name)				\ 	  {							\ 	    operator_code = (CODE);				\ 	    break;						\ 	  }							\ 	else if (ansi_assopname (CODE) == name)			\ 	  {							\ 	    operator_code = (CODE);				\ 	    DECL_ASSIGNMENT_OPERATOR_P (decl) = 1;		\ 	    break;						\ 	  }
include|#
directive|include
file|"operators.def"
undef|#
directive|undef
name|DEF_OPERATOR
name|abort
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|my_friendly_assert
argument_list|(
name|operator_code
operator|!=
name|LAST_CPLUS_TREE_CODE
argument_list|,
literal|20000526
argument_list|)
expr_stmt|;
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|decl
argument_list|,
name|operator_code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|friendp
condition|)
block|{
switch|switch
condition|(
name|operator_code
condition|)
block|{
case|case
name|CALL_EXPR
case|:
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
case|case
name|MEMBER_REF
case|:
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEW_EXPR
case|:
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DELETE_EXPR
case|:
name|TYPE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|VEC_NEW_EXPR
case|:
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VEC_DELETE_EXPR
case|:
name|TYPE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|operator_code
operator|==
name|NEW_EXPR
operator|||
name|operator_code
operator|==
name|VEC_NEW_EXPR
condition|)
block|{
comment|/* When the compiler encounters the definition of A::operator new, it 	 doesn't look at the class declaration to find out if it's static.  */
if|if
condition|(
name|methodp
condition|)
name|revert_static_member_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_new_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operator_code
operator|==
name|DELETE_EXPR
operator|||
name|operator_code
operator|==
name|VEC_DELETE_EXPR
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|revert_static_member_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_delete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* An operator function must either be a non-static member function 	 or have at least one parameter of a class, a reference to a class, 	 an enumeration, or a reference to an enumeration.  13.4.0.6 */
if|if
condition|(
operator|!
name|methodp
operator|||
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|operator_code
operator|==
name|TYPE_EXPR
operator|||
name|operator_code
operator|==
name|CALL_EXPR
operator|||
name|operator_code
operator|==
name|COMPONENT_REF
operator|||
name|operator_code
operator|==
name|ARRAY_REF
operator|||
name|operator_code
operator|==
name|NOP_EXPR
condition|)
name|error
argument_list|(
literal|"`%D' must be a nonstatic member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|p
init|=
name|argtypes
decl_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%D' must be either a non-static member function or a non-member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* This lets bad template code slip through.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
goto|goto
name|foundaggr
goto|;
block|}
name|error
argument_list|(
literal|"`%D' must have an argument of class or enumerated type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|foundaggr
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|operator_code
operator|==
name|CALL_EXPR
condition|)
return|return;
comment|/* No restrictions on args. */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|friendp
condition|)
block|{
name|int
name|ref
init|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ref
condition|)
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|what
operator|=
literal|"void"
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|current_class_type
condition|)
name|what
operator|=
literal|"the same type"
expr_stmt|;
comment|/* Don't force t to be complete here.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|what
operator|=
literal|"a base class"
expr_stmt|;
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
literal|"conversion to %s%s will never use a type conversion operator"
argument_list|,
name|ref
condition|?
literal|"a reference to "
else|:
literal|""
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operator_code
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* 13.4.0.3 */
name|error
argument_list|(
literal|"ISO C++ prohibits overloading operator ?:"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ambi_op_p
argument_list|(
name|operator_code
argument_list|)
condition|)
block|{
if|if
condition|(
name|arity
operator|==
literal|1
condition|)
comment|/* We pick the one-argument operator codes by default, so 	       we don't have to change anything.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|arity
operator|==
literal|2
condition|)
block|{
comment|/* If we thought this was a unary operator, we now know 		 it to be a binary operator.  */
switch|switch
condition|(
name|operator_code
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
name|operator_code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
name|operator_code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CONVERT_EXPR
case|:
name|operator_code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
name|operator_code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
name|operator_code
operator|=
name|POSTINCREMENT_EXPR
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
name|operator_code
operator|=
name|POSTDECREMENT_EXPR
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|decl
argument_list|,
name|operator_code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|operator_code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|POSTDECREMENT_EXPR
operator|)
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"postfix `%D' must take `int' as its argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"postfix `%D' must take `int' as its second argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"`%D' must take either zero or one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%D' must take either one or two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* More Effective C++ rule 6.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|(
name|operator_code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|operator_code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|PREDECREMENT_EXPR
operator|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|argtypes
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|methodp
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|operator_code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|PREDECREMENT_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ret
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ret
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
name|warning
argument_list|(
literal|"prefix `%D' should return `%T'"
argument_list|,
name|decl
argument_list|,
name|build_reference_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ret
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
name|warning
argument_list|(
literal|"postfix `%D' should return `%T'"
argument_list|,
name|decl
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|unary_op_p
argument_list|(
name|operator_code
argument_list|)
condition|)
block|{
if|if
condition|(
name|arity
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"`%D' must take `void'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* if (binary_op_p (operator_code)) */
block|{
if|if
condition|(
name|arity
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%D' must take exactly two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* More Effective C++ rule 7.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|(
name|operator_code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|operator_code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|operator_code
operator|==
name|COMPOUND_EXPR
operator|)
condition|)
name|warning
argument_list|(
literal|"user-defined `%D' always evaluates both arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Effective C++ rule 23.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|arity
operator|==
literal|2
operator|&&
operator|(
name|operator_code
operator|==
name|PLUS_EXPR
operator|||
name|operator_code
operator|==
name|MINUS_EXPR
operator|||
name|operator_code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|operator_code
operator|==
name|MULT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|warning
argument_list|(
literal|"`%D' should return by value"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* [over.oper]/8 */
for|for
control|(
init|;
name|argtypes
operator|&&
name|argtypes
operator|!=
name|void_list_node
condition|;
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|operator_code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|POSTDECREMENT_EXPR
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`%D' cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"`%D' cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tag_name
parameter_list|(
name|code
parameter_list|)
name|enum
name|tag_types
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|record_type
case|:
return|return
literal|"struct"
return|;
case|case
name|class_type
case|:
return|return
literal|"class"
return|;
case|case
name|union_type
case|:
return|return
literal|"union "
return|;
case|case
name|enum_type
case|:
return|return
literal|"enum"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.     C++: If a class derivation is given, process it here, and report    an error if multiple derivation declarations are not identical.     If this is a definition, come in through xref_tag and only look in    the current frame for the name (since C++ allows new names in any    scope.)  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
name|enum
name|tag_types
name|tag_code
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|int
name|got_type
init|=
literal|0
decl_stmt|;
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If we are called from the parser, code_type_node will sometimes be a      TREE_LIST.  This indicates that the user wrote      "class __attribute__ ((foo)) bar".  Extract the attributes so we can      use them later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|code_type_node
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|attributes
operator|=
name|TREE_PURPOSE
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
name|code_type_node
operator|=
name|TREE_VALUE
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
block|}
name|tag_code
operator|=
operator|(
expr|enum
name|tag_types
operator|)
name|tree_low_cst
argument_list|(
name|code_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag_code
condition|)
block|{
case|case
name|record_type
case|:
case|case
name|class_type
case|:
name|code
operator|=
name|RECORD_TYPE
expr_stmt|;
break|break;
case|case
name|union_type
case|:
name|code
operator|=
name|UNION_TYPE
expr_stmt|;
break|break;
case|case
name|enum_type
case|:
name|code
operator|=
name|ENUMERAL_TYPE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|t
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|got_type
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|t
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Warn about 'friend struct Inherited;' doing the wrong thing.  */
if|if
condition|(
name|t
operator|&&
name|globalize
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
specifier|static
name|int
name|explained
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
name|warning
argument_list|(
literal|"`%s %T' declares a new type at namespace scope"
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
operator|++
condition|)
name|warning
argument_list|(
literal|"  names from dependent base classes are not visible to unqualified name lookup - to refer to the inherited type, say `%s %T::%T'"
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|,
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to remove the class scope binding for the          TYPENAME_TYPE as otherwise poplevel_class gets confused. */
for|for
control|(
name|shadowed
operator|=
name|b
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|code
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|globalize
condition|)
block|{
comment|/* If we know we are defining this tag, only look it up in 	 this scope and don't try to find it as a type.  */
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
condition|)
block|{
comment|/* [dcl.type.elab] If the identifier resolves to a 	     typedef-name or a template type-parameter, the 	     elaborated-type-specifier is ill-formed.  */
if|if
condition|(
name|t
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"using typedef-name `%D' after `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|error
argument_list|(
literal|"using template type parameter `%T' after `%s'"
argument_list|,
name|t
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|t
expr_stmt|;
block|}
else|else
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* Try finding it as a type declaration.  If that wins, 	     use it.  */
name|ref
operator|=
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|!=
name|NULL_TREE
operator|&&
name|processing_template_decl
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|ref
argument_list|)
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
comment|/* Since GLOBALIZE is true, we're declaring a global 	       template, so we want this type.  */
name|ref
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|code
condition|)
name|ref
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|ref
operator|&&
name|current_class_type
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
block|{
comment|/* Since GLOBALIZE is non-zero, we are not looking at a 	     definition of this tag.  Since, in addition, we are currently 	     processing a (member) template declaration of a template 	     class, we must be very careful; consider:  	       template<class X> 	       struct S1  	       template<class U> 	       struct S2 	       { template<class V> 	       friend struct S1; };  	     Here, the S2::S1 declaration should not be confused with the 	     outer declaration.  In particular, the inner version should 	     have a template parameter of level 2, not level 1.  This 	     would be particularly important if the member declaration 	     were instead:  	       template<class V = U> friend struct S1;  	     say, when we should tsubst into `U' when instantiating 	     S2.  On the other hand, when presented with:  	         template<class T> 	         struct S1 { 		   template<class U> 	           struct S2 {}; 		   template<class U> 		   friend struct S2; 		 };                we must find the inner binding eventually.  We 	      accomplish this by making sure that the new type we 	      create to represent this declaration has the right 	      TYPE_CONTEXT.  */
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* If no such tag is yet defined, create a forward-reference node 	 and record it as the "definition". 	 When a real declaration of this type is found, 	 the forward-reference will be altered into a real type.  */
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"use of enum `%#D' without previous declaration"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
comment|/* Give the type a default layout like unsigned int 	     to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Enable us to recognize when a type is created in class context. 	     To do nested classes correctly, this should probably be cleared 	     out when we leave this classes scope.  Currently this in only 	     done in `start_enum'.  */
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|binding_level
modifier|*
name|old_b
init|=
name|class_binding_level
decl_stmt|;
name|ref
operator|=
name|make_aggr_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|ref
argument_list|)
operator|=
name|context
expr_stmt|;
ifdef|#
directive|ifdef
name|NONNESTED_CLASSES
comment|/* Class types don't nest the way enums do.  */
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|old_b
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|globalize
operator|&&
name|processing_template_decl
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ref
argument_list|)
condition|)
name|redeclare_class_template
argument_list|(
name|ref
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
block|}
comment|/* Until the type is defined, tentatively accept whatever      structure tag the user hands us.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|ref
argument_list|)
operator|&&
name|ref
operator|!=
name|current_class_type
comment|/* Have to check this, in case we have contradictory tag info.  */
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tag_code
operator|==
name|class_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|record_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TYPE_ATTRIBUTES
argument_list|(
name|ref
argument_list|)
operator|=
name|attributes
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_function
name|tree
name|xref_tag_from_type
parameter_list|(
name|old
parameter_list|,
name|id
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|old
decl_stmt|,
name|id
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
name|tree
name|code_type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|code_type_node
operator|=
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|old
argument_list|)
condition|?
name|class_type_node
else|:
name|record_type_node
operator|)
expr_stmt|;
else|else
name|code_type_node
operator|=
name|union_type_node
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL_TREE
condition|)
name|id
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|xref_tag
argument_list|(
name|code_type_node
argument_list|,
name|id
argument_list|,
name|globalize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* REF is a type (named NAME), for which we have just seen some    baseclasses.  BINFO is a list of those baseclasses; the    TREE_PURPOSE is an access_* node, and the TREE_VALUE is the type of    the base-class.  CODE_TYPE_NODE indicates whether REF is a class,    struct, or union.  */
end_comment

begin_function
name|void
name|xref_basetypes
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|ref
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|ref
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
comment|/* In the declaration `A : X, Y, ... Z' we mark all the types      (A, X, Y, ..., Z) so we can check for duplicates.  */
name|tree
name|binfos
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|enum
name|tag_types
name|tag_code
decl_stmt|;
comment|/* If we are called from the parser, code_type_node will sometimes be a      TREE_LIST.  This indicates that the user wrote      "class __attribute__ ((foo)) bar".  Extract the attributes so that      tree_low_cst doesn't crash.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|code_type_node
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|code_type_node
operator|=
name|TREE_VALUE
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
name|tag_code
operator|=
operator|(
expr|enum
name|tag_types
operator|)
name|tree_low_cst
argument_list|(
name|code_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_code
operator|==
name|union_type
condition|)
block|{
name|error
argument_list|(
literal|"derived union `%T' invalid"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|list_length
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* First, make sure that any templates in base-classes are      instantiated.  This ensures that if we call ourselves recursively      we do not get confused about which classes are marked and which      are not.  */
for|for
control|(
name|base
operator|=
name|binfo
init|;
name|base
condition|;
name|base
operator|=
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
control|)
name|complete_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|binfos
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
comment|/* The base of a derived struct is public by default.  */
name|int
name|via_public
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_public_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_public_virtual_node
operator|||
operator|(
name|tag_code
operator|!=
name|class_type
operator|&&
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_default_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_default_virtual_node
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|via_protected
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_protected_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_protected_virtual_node
operator|)
decl_stmt|;
name|int
name|via_virtual
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_private_virtual_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_protected_virtual_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_public_virtual_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_default_virtual_node
operator|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
if|if
condition|(
name|basetype
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basetype
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"base type `%T' fails to be a struct or class type"
argument_list|,
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|GNU_xref_hier
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|,
name|via_public
argument_list|,
name|via_virtual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This code replaces similar code in layout_basetypes.          We put the complete_type first for implicit `typename'.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"base class `%T' has incomplete type"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|ref
condition|)
name|error
argument_list|(
literal|"recursive type `%T' undefined"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"duplicate base type `%T' invalid"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|current_lang_depth
argument_list|()
operator|==
literal|0
operator|)
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Note that the BINFO records which describe individual 	     inheritances are *not* shared in the lattice!  They 	     cannot be shared because a given baseclass may be 	     inherited with different `accessibility' by different 	     derived classes.  (Each BINFO record describing an 	     individual inheritance contains flags which say what 	     the `accessibility' of that particular inheritance is.)  */
name|base_binfo
operator|=
name|make_binfo
argument_list|(
name|size_zero_node
argument_list|,
name|basetype
argument_list|,
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|?
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
else|:
name|NULL_TREE
argument_list|,
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|?
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_public
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_protected
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_virtual
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* We need to unshare the binfos now so that lookups during class 	     definition work.  */
name|unshare_base_binfos
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* We are free to modify these bits because they are meaningless 	     at top level, and BASETYPE is a top-level type.  */
if|if
condition|(
name|via_virtual
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Converting to a virtual base class requires looking 		 up the offset of the virtual base.  */
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_DELETE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* If the base-class uses multiple inheritance, so do we.  */
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* Likewise, if converting to a base of the base may require 		 code, then we may need to generate code to convert to a 		 base as well.  */
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|=
name|i
expr_stmt|;
else|else
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If there is more than one non-empty they cannot be at the same 	 address.  */
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Unmark all the types.  */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* Now that we know all the base-classes, set up the list of virtual      bases.  */
name|get_vbase_types
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|enumtype
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
name|NULL_TREE
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"multiple definition of `%#T'"
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous definition here"
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
comment|/* Clear out TYPE_VALUES, and start again.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|b
operator|->
name|tags
argument_list|)
operator|=
literal|1
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of name-value pairs.  */
end_comment

begin_function
name|void
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|)
name|tree
name|enumtype
decl_stmt|;
block|{
name|tree
name|pair
decl_stmt|;
name|tree
name|minnode
decl_stmt|;
name|tree
name|maxnode
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|bool
name|unsignedp
decl_stmt|;
name|int
name|lowprec
decl_stmt|;
name|int
name|highprec
decl_stmt|;
name|int
name|precision
decl_stmt|;
comment|/* We built up the VALUES in reverse order.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* [dcl.enum]       Following the closing brace of an enum-specifier, each      enumerator has the type of its enumeration.  Prior to the      closing brace, the type of each enumerator is the type of      its initializing value.  */
for|for
control|(
name|pair
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
comment|/* For a enum defined in a template, all further processing is      postponed until the template is instantiated.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|add_stmt
argument_list|(
name|build_min
argument_list|(
name|TAG_DEFN
argument_list|,
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Figure out what the minimum and maximum values of the enumerators      are.  */
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
condition|)
block|{
name|minnode
operator|=
name|maxnode
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|value
decl_stmt|;
name|value
operator|=
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|minnode
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
block|}
else|else
name|minnode
operator|=
name|maxnode
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Compute the number of bits require to represent all values of the      enumeration.  We must do this before the type of MINNODE and      MAXNODE are transformed, since min_precision relies on the      TREE_TYPE of the value it is passed.  */
name|unsignedp
operator|=
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|lowprec
operator|=
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|highprec
operator|=
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|precision
operator|=
name|MAX
argument_list|(
name|lowprec
argument_list|,
name|highprec
argument_list|)
expr_stmt|;
comment|/* Set the TREE_TYPE for the values as well.  That's so that when we      call decl_constant_value we get an entity of the right type (but      with the constant value).  In addition, transform the TYPE_VALUES      list to contain the values, rather than the CONST_DECLs for them.  */
for|for
control|(
name|pair
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
comment|/* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE according to `precision'.  */
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|precision
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
else|else
name|fixup_signed_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_short_enums
operator|||
operator|(
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
comment|/* Use the width of the narrowest normal C type which is wide        enough.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|type_for_size
argument_list|(
name|precision
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|namespace_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for an enumeration constant of the    enumeration type ENUMTYPE whose NAME and VALUE (if any) are provided.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|void
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|enumtype
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|enumtype
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|values
decl_stmt|;
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* Validate and default VALUE.  */
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
block|{
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"enumerator value for `%D' not integer constant"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Default based on previous value.  */
if|if
condition|(
name|value
operator|==
name|NULL_TREE
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|prev_value
decl_stmt|;
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
condition|)
block|{
comment|/* The next value is the previous value ... */
name|prev_value
operator|=
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... plus one.  */
name|value
operator|=
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|prev_value
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|prev_value
argument_list|)
condition|)
name|error
argument_list|(
literal|"overflow in enumeration values at `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* To fix MAX_VAL enum consts. (bkoz)  */
block|TREE_TYPE (value) = integer_type_node;
endif|#
directive|endif
block|}
comment|/* We always have to copy here; not all INTEGER_CSTs are unshared.      Even in other cases, we will later (in finish_enum) be setting      the type of VALUE.  But, we don't need to make a copy if this      VALUE is one of the enumeration constants for this same      enumeration type.  */
for|for
control|(
name|values
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
operator|==
name|value
condition|)
break|break;
comment|/* If we didn't break out of the loop, then we do need a copy.  */
if|if
condition|(
operator|!
name|values
operator|&&
name|value
condition|)
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* C++ associates enums with global, function, or class declarations.  */
name|context
operator|=
name|current_scope
argument_list|()
expr_stmt|;
comment|/* Build the actual enumeration constant.  Note that the enumeration     constants have the type of their initializers until the     enumeration is complete:        [ dcl.enum ]        Following the closing brace of an enum-specifier, each enumer-       ator has the type of its enumeration.  Prior to the closing       brace, the type of each enumerator is the type of its       initializing value.      In finish_enum we will reset the type.  Of course, if we're     processing a template, there may be no value.   */
name|type
operator|=
name|value
condition|?
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|context
operator|==
name|current_class_type
condition|)
comment|/* This enum declaration is local to the class.  We need the full        lang_decl so that we can record DECL_CLASS_CONTEXT, for example.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
comment|/* It's a global enum, or it's local to a function.  (Note local to       a function could mean local to a class method.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|context
operator|==
name|current_class_type
condition|)
comment|/* In something like `struct S { enum E { i = 7 }; };' we put `i'       on the TYPE_FIELDS list for `S'.  (That's so that you can say       things like `S::i' later.)  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Add this enumeration constant to the list for this type.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We're defining DECL.  Make sure that it's type is OK.  */
end_comment

begin_function
specifier|static
name|void
name|check_function_type
parameter_list|(
name|decl
parameter_list|,
name|current_function_parms
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|current_function_parms
decl_stmt|;
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|return_type
init|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
decl_stmt|;
comment|/* In a function definition, arg types must be complete.  */
name|require_complete_types_for_parms
argument_list|(
name|current_function_parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|return_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"return type `%#T' is incomplete"
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make it return void instead, but don't change the 	 type of the DECL_RESULT, in case we have a named return value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|void_type_node
argument_list|,
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     FLAGS is a bitwise or of SF_PRE_PARSED (indicating that the    DECLARATOR is really the DECL for the function we are about to    process and that DECLSPECS should be ignored), SF_INCLASS_INLINE    indicating that the function is an inline defined in-class.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.     For C++, we must first check whether that datum makes any sense.    For example, "class A local_a(1,2);" means that variable local_a    is an aggregate of type A, which should have a constructor    applied to it with the argument list [1, 2].  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|attrs
parameter_list|,
name|flags
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|,
name|attrs
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|decl1
decl_stmt|;
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|restype
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
name|int
name|doing_friend
init|=
literal|0
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|bl
decl_stmt|;
name|tree
name|current_function_parms
decl_stmt|;
comment|/* Sanity check.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|void_list_node
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
argument_list|,
literal|160
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|161
argument_list|)
expr_stmt|;
comment|/* This should only be done once on the top most decl.  */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SF_PRE_PARSED
condition|)
block|{
name|decl1
operator|=
name|declarator
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* ISO C++ 11.4/5.  A friend function defined in a class is in 	 the (lexical) scope of the class in which it is defined.  */
if|if
condition|(
operator|!
name|ctype
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|ctype
operator|=
name|DECL_FRIEND_CONTEXT
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* CTYPE could be null here if we're dealing with a template; 	     for example, `inline friend float foo()' inside a template 	     will have no CTYPE set.  */
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|doing_friend
operator|=
literal|1
expr_stmt|;
block|}
name|last_function_parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition, 	 cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl1
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|restype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"semicolon missing after declaration of `%#T'"
argument_list|,
name|restype
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
comment|/* If this doesn't return integer_type, complain.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_return_type
condition|)
name|pedwarn
argument_list|(
literal|"return type for `main' changed to `int'"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|default_function_type
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|attrs
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"inline function `%s' given attribute noinline"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
condition|)
comment|/* This is a constructor, we must ensure that any default args        introduced by this definition are propagated to the clones        now. The clones are used directly in overload resolution.  */
name|adjust_clone_args
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Sometimes we don't notice that a function is a static member, and      build a METHOD_TYPE for it.  Fix that up now.  */
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|revert_static_member_fn
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Warn if function was previously implicitly declared      (but not if we warned then).  */
if|if
condition|(
operator|!
name|warn_implicit
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_warning_at
argument_list|(
literal|"`%D' implicitly declared before its definition"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up current_class_type, and enter the scope of the class, if      appropriate.  */
if|if
condition|(
name|ctype
condition|)
name|push_nested_class
argument_list|(
name|ctype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now that we have entered the scope of the class, we must restore      the bindings for any template parameters surrounding DECL1, if it      is an inline member template.  (Order is important; consider the      case where a template parameter has the same name as a field of      the class.)  It is not until after this point that      PROCESSING_TEMPLATE_DECL is guaranteed to be set up correctly.  */
if|if
condition|(
name|flags
operator|&
name|SF_INCLASS_INLINE
condition|)
name|maybe_begin_member_template_processing
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Effective C++ rule 15.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"`operator=' should return a reference to `*this'"
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We must call push_template_decl after current_class_type is set      up.  (If we are processing inline definitions after exiting a      class scope, current_class_type will be NULL_TREE until set above      by push_nested_class.)  */
if|if
condition|(
name|processing_template_decl
condition|)
name|decl1
operator|=
name|push_template_decl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* We are now in the scope of the function being defined.  */
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
comment|/* Make sure the parameter and return types are reasonable.  When      you declare a function, these types can be incomplete, but they      must be complete when you define the function.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|check_function_type
argument_list|(
name|decl1
argument_list|,
name|current_function_parms
argument_list|)
expr_stmt|;
comment|/* Build the return declaration for the function.  */
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|restype
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Just use `void'.  Nobody will ever look at this anyhow.  */
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Initialize RTL machinery.  We cannot do this until      CURRENT_FUNCTION_DECL and DECL_RESULT are set up.  We do this      even when processing a template; this is how we get      CFUN set up, and our per-function variables initialized.      FIXME factor out the non-RTL stuff.  */
name|bl
operator|=
name|current_binding_level
expr_stmt|;
name|init_function_start
argument_list|(
name|decl1
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|bl
expr_stmt|;
comment|/* Even though we're inside a function body, we still don't want to      call expand_expr to calculate the size of a variable-sized array.      We haven't necessarily assigned RTL to all variables yet, so it's      not safe to try to expand expressions involving them.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|1
expr_stmt|;
comment|/* Start the statement-tree, start the tree now.  */
name|begin_stmt_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let the user know we're compiling this function.  */
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SF_PRE_PARSED
operator|)
condition|)
block|{
comment|/* A specialization is not used to guide overload resolution.  */
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|decl1
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We need to set the DECL_CONTEXT. */
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And make sure we have enough default args.  */
name|check_default_args
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
comment|/* Reset these in case the call to pushdecl changed them.  */
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
name|cfun
operator|->
name|decl
operator|=
name|decl1
expr_stmt|;
comment|/* If we are (erroneously) defining a function that we have already      defined before, wipe out what we knew before.  */
if|if
condition|(
operator|!
name|DECL_PENDING_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|decl1
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|&&
operator|!
name|doing_friend
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
comment|/* We know that this was set up by `grokclassfn'.  We do not 	 wait until `store_parm_decls', since evil parse errors may 	 never get us to that point.  Here we keep the consistency 	 between `current_class_type' and `current_class_ptr'.  */
name|tree
name|t
init|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|162
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|,
literal|19990811
argument_list|)
expr_stmt|;
name|cp_function_chain
operator|->
name|x_current_class_ref
operator|=
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp_function_chain
operator|->
name|x_current_class_ptr
operator|=
name|t
expr_stmt|;
comment|/* Constructors and destructors need to know whether they're "in 	 charge" of initializing virtual base classes.  */
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|current_in_charge_parm
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|vtt_parm_identifier
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_vtt_parm
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|tree
name|ctx
init|=
name|decl_function_context
argument_list|(
name|decl1
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL_TREE
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|ctx
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|ctx
argument_list|)
condition|)
comment|/* This is a function in a local class in an extern inline 	   function.  */
name|comdat_linkage
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
comment|/* If this function belongs to an interface, it is public.      If it belongs to someone else's interface, it is also external.      This only affects inlines and template instantiations.  */
elseif|else
if|if
condition|(
name|interface_unknown
operator|==
literal|0
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|||
name|flag_alt_external_templates
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|||
name|processing_template_decl
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
operator|(
name|interface_only
operator|||
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|decl1
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* For WIN32 we also want to put these in linkonce sections.  */
name|maybe_make_one_only
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|interface_unknown
operator|&&
name|interface_only
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|||
name|flag_alt_external_templates
operator|)
condition|)
block|{
comment|/* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma 	 interface, we will have interface_only set but not 	 interface_known.  In that case, we don't want to use the normal 	 heuristics because someone will supply a #pragma implementation 	 elsewhere, and deducing it here would produce a conflict.  */
name|comdat_linkage
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a definition, not a reference. 	 So clear DECL_EXTERNAL.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
comment|/* Don't try to defer nested functions for now.  */
operator|&&
operator|!
name|decl_function_context
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl1
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|restype
argument_list|)
condition|)
name|restype
operator|=
name|type_promotes_to
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|=
name|CP_TYPE_CONST_P
argument_list|(
name|restype
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|=
name|CP_TYPE_VOLATILE_P
argument_list|(
name|restype
argument_list|)
expr_stmt|;
block|}
operator|++
name|function_depth
expr_stmt|;
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|dtor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|dtor_label
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
block|}
name|start_fname_decls
argument_list|()
expr_stmt|;
name|store_parm_decls
argument_list|(
name|current_function_parms
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     Also install to binding contour return value identifier, if any.  */
end_comment

begin_function
specifier|static
name|void
name|store_parm_decls
parameter_list|(
name|current_function_parms
parameter_list|)
name|tree
name|current_function_parms
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|current_function_parms
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
name|tree
name|next
decl_stmt|;
comment|/* Must clear this because it might contain TYPE_DECLs declared 	     at class level.  */
name|storedecls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If we're doing semantic analysis, then we'll call pushdecl 	     for each of these.  We must do them in reverse order so that 	     they end in the correct forward order.  */
name|specparms
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter `%D' declared void"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we find an enum constant or a type tag, 		 put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order and record in the 	 function.  This is all and only the PARM_DECLs that were 	 pushed into scope by the loop above.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|storetags
argument_list|(
name|gettags
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now store the final chain of decls for the arguments      as the decl-chain of the current lexical scope.      Put the enumerators in as well, at the front so that      DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the starting of the exception specifications, if we have any.  */
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|processing_template_decl
operator|&&
name|flag_enforce_eh_specs
operator|&&
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|current_eh_spec_block
operator|=
name|begin_eh_spec_block
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have finished doing semantic analysis on DECL, but have not yet    generated RTL for its body.  Save away our current state, so that    when we want to generate RTL later we know what to do.  */
end_comment

begin_function
specifier|static
name|void
name|save_function_data
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|cp_language_function
modifier|*
name|f
decl_stmt|;
comment|/* Save the language-specific per-function data so that we can      get it back when we really expand this function.  */
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_PENDING_INLINE_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|19990908
argument_list|)
expr_stmt|;
comment|/* Make a copy.  */
name|f
operator|=
operator|(
operator|(
expr|struct
name|cp_language_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cp_language_function
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|cp_function_chain
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cp_language_function
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|decl
argument_list|)
operator|=
name|f
expr_stmt|;
comment|/* Clear out the bits we don't need.  */
name|f
operator|->
name|base
operator|.
name|x_stmt_tree
operator|.
name|x_last_stmt
operator|=
name|NULL_TREE
expr_stmt|;
name|f
operator|->
name|base
operator|.
name|x_stmt_tree
operator|.
name|x_last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
name|f
operator|->
name|x_named_label_uses
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|bindings
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_local_names
operator|=
name|NULL
expr_stmt|;
comment|/* When we get back here again, we will be expanding.  */
name|f
operator|->
name|x_expanding_p
operator|=
literal|1
expr_stmt|;
comment|/* If we've already decided that we cannot inline this function, we      must remember that fact when we actually go to expand the      function.  */
if|if
condition|(
name|current_function_cannot_inline
condition|)
block|{
name|f
operator|->
name|cannot_inline
operator|=
name|current_function_cannot_inline
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a note to mark the beginning of the main body of the constructor.    This is used to set up the data structures for the cleanup regions for    fully-constructed bases and members.  */
end_comment

begin_function
specifier|static
name|void
name|begin_constructor_body
parameter_list|()
block|{
name|tree
name|ctor_stmt
init|=
name|build_stmt
argument_list|(
name|CTOR_STMT
argument_list|)
decl_stmt|;
name|CTOR_BEGIN_P
argument_list|(
name|ctor_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|ctor_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a note to mark the end of the main body of the constructor.  This is    used to end the cleanup regions for fully-constructed bases and    members.  */
end_comment

begin_function
specifier|static
name|void
name|finish_constructor_body
parameter_list|()
block|{
comment|/* Mark the end of the cleanups for a partially constructed object.       ??? These should really be handled automatically by closing the block,      as with the destructor cleanups; the only difference is that these are      only run if an exception is thrown.  */
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|CTOR_STMT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do all the processing for the beginning of a destructor; set up the    vtable pointers and cleanups for bases and members.  */
end_comment

begin_function
specifier|static
name|void
name|begin_destructor_body
parameter_list|()
block|{
name|tree
name|if_stmt
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
comment|/* If the dtor is empty, and we know there is not any possible      way we could use any vtable entries, before they are possibly      set by a base class dtor, we don't have to setup the vtables,      as we know that any base class dtor will set up any vtables      it needs.  We avoid MI, because one base class dtor can do a      virtual dispatch to an overridden function that would need to      have a non-related vtable set up, we cannot avoid setting up      vtables in that case.  We could change this to see if there      is just one vtable.       ??? In the destructor for a class, the vtables are set      appropriately for that class.  There will be no non-related      vtables.  jason 2001-12-11.  */
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
comment|/* If it is not safe to avoid setting up the vtables, then      someone will change the condition to be boolean_true_node.        (Actually, for now, we do not have code to set the condition      appropriately, so we just assume that we always need to      initialize the vtables.)  */
name|finish_if_stmt_cond
argument_list|(
name|boolean_true_node
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|current_vcalls_possible_p
operator|=
operator|&
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Make all virtual function table pointers in non-virtual base      classes point to CURRENT_CLASS_TYPE's virtual function      tables.  */
name|initialize_vtbl_ptrs
argument_list|(
name|current_class_ptr
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|()
expr_stmt|;
comment|/* And insert cleanups for our bases and members so that they      will be properly destroyed if we throw.  */
name|push_base_cleanups
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of every destructor we generate code to delete the object if    necessary.  Do that now.  */
end_comment

begin_function
specifier|static
name|void
name|finish_destructor_body
parameter_list|()
block|{
name|tree
name|exprstmt
decl_stmt|;
comment|/* In a virtual destructor, we must call delete.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|tree
name|if_stmt
decl_stmt|;
name|tree
name|virtual_size
init|=
name|c_sizeof
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
comment|/* [class.dtor]        At the point of definition of a virtual destructor (including       an implicit definition), non-placement operator delete shall       be looked up in the scope of the destructor's class and if       found shall be accessible and unambiguous.  */
name|exprstmt
operator|=
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|current_class_ptr
argument_list|,
name|virtual_size
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_SPECULATIVELY
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do the necessary processing for the beginning of a function body, which    in this case includes member-initializers, but not the catch clauses of    a function-try-block.  Currently, this means opening a binding level    for the member-initializers (in a ctor) and member cleanups (in a dtor).    In other functions, this isn't necessary, but it doesn't hurt.  */
end_comment

begin_function
name|tree
name|begin_function_body
parameter_list|()
block|{
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Do nothing now.  */
empty_stmt|;
else|else
comment|/* Always keep the BLOCK node associated with the outermost pair of        curly braces of a function.  These are needed for correct        operation of dwarfout.c.  */
name|keep_next_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_compound_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|COMPOUND_STMT_BODY_BLOCK
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Do nothing now.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|begin_constructor_body
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|begin_destructor_body
argument_list|()
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* Do the processing for the end of a function body.  Currently, this means    closing out the cleanups for fully-constructed bases and members, and in    the case of the destructor, deleting the object if desired.  Again, this    is only meaningful for [cd]tors, since they are the only functions where    there is a significant distinction between the main body and any    function catch clauses.  Handling, say, main() return semantics here    would be wrong, as flowing off the end of a function catch clause for    main() would also need to return 0.  */
end_comment

begin_function
name|void
name|finish_function_body
parameter_list|(
name|compstmt
parameter_list|)
name|tree
name|compstmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Do nothing now.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
comment|/* Any return from a destructor will end up here.  Put it before the        cleanups so that an explicit return doesn't duplicate them.  */
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_STMT
argument_list|,
name|dtor_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the block; in a destructor, run the member cleanups.  */
name|finish_compound_stmt
argument_list|(
literal|0
argument_list|,
name|compstmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Do nothing now.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_constructor_body
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_destructor_body
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     FLAGS is a bitwise or of the following values:      2 - INCLASS_INLINE        We just finished processing the body of an in-class inline        function definition.  (This processing will have taken place        after the class definition is complete.)  */
end_comment

begin_function
name|tree
name|finish_function
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
decl_stmt|,
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|inclass_inline
init|=
operator|(
name|flags
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|nested
decl_stmt|;
comment|/* When we get some parse errors, we can end up without a      current_function_decl, so cope.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
name|nested
operator|=
name|function_depth
operator|>
literal|1
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;       This caused&foo to be of type ptr-to-const-function       which then got a warning when stored in a ptr-to-function variable.  */
name|my_friendly_assert
argument_list|(
name|building_stmt_tree
argument_list|()
argument_list|,
literal|20000911
argument_list|)
expr_stmt|;
name|finish_fname_decls
argument_list|()
expr_stmt|;
comment|/* For a cloned function, we've already got all the code we need;      there's no need to add any extra bits.  */
if|if
condition|(
operator|!
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Make it so that `main' always returns 0 by default.  */
ifdef|#
directive|ifdef
name|VMS_TARGET
name|finish_return_stmt
argument_list|(
name|integer_one_node
argument_list|)
expr_stmt|;
else|#
directive|else
name|finish_return_stmt
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Finish dealing with exception specifiers.  */
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|processing_template_decl
operator|&&
name|flag_enforce_eh_specs
operator|&&
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|finish_eh_spec_block
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_eh_spec_block
argument_list|)
expr_stmt|;
block|}
comment|/* If we're saving up tree structure, tie off the function now.  */
name|finish_stmt_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This must come after expand_function_end because cleanups might      have declarations (from inline functions) that need to go into      this function's blocks.  */
comment|/* If the current binding level isn't the outermost binding level      for this function, either there is a bug, or we have experienced      syntax errors and the statement tree is malformed.  */
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|!=
literal|1
condition|)
block|{
comment|/* Make sure we have already experienced errors.  */
if|if
condition|(
name|errorcount
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Throw away the broken statement tree and extra binding          levels.  */
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_stmt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
else|else
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set up the named return value optimization, if we can.  Here, we      eliminate the copy from the nrv into the RESULT_DECL and any cleanup      for the nrv.  genrtl_start_function and declare_return_variable      handle making the nrv and RESULT_DECL share space.  */
if|if
condition|(
name|current_function_return_value
condition|)
block|{
name|tree
name|r
init|=
name|current_function_return_value
decl_stmt|;
comment|/* This is only worth doing for fns that return in memory--and 	 simpler, since we don't have to worry about promoted modes.  */
if|if
condition|(
name|r
operator|!=
name|error_mark_node
operator|&&
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|nullify_returns_r
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Clear it so genrtl_start_function and declare_return_variable 	   know we're not optimizing.  */
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Remember that we were in class scope.  */
if|if
condition|(
name|current_class_name
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point      to the FUNCTION_DECL node itself.  */
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Save away current state, if appropriate.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|save_function_data
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* If this function calls `setjmp' it cannot be inlined.  When      `longjmp' is called it is not guaranteed to restore the value of      local variables that have been modified since the call to      `setjmp'.  So, if were to inline this function into some caller      `c', then when we `longjmp', we might not restore all variables      in `c'.  (It might seem, at first blush, that there's no way for      this function to modify local variables in `c', but their      addresses may have been stored somewhere accessible to this      function.)  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|calls_setjmp_p
argument_list|(
name|fndecl
argument_list|)
condition|)
name|DECL_UNINLINABLE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Clear out memory we no longer need.  */
name|free_after_parsing
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
comment|/* Since we never call rest_of_compilation, we never clear      CFUN.  Do so explicitly.  */
name|free_after_compilation
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|cfun
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a in-class inline definition, we may have to pop the      bindings for the template parameters that we added in      maybe_begin_member_template_processing when start_function was      called.  */
if|if
condition|(
name|inclass_inline
condition|)
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
comment|/* Leave the scope of the class.  */
if|if
condition|(
name|ctype
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
operator|--
name|function_depth
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
operator|!
name|nested
condition|)
comment|/* Let the error reporting routines know that we're outside a        function.  For a nested function, this value is used in        pop_cp_function_context and then reset via pop_function_context.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the return type and the name of the function,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns a FUNCTION_DECL on success.     If the DECLARATOR is not suitable for a function (it defines a datum    instead), we return 0, which tells yyparse to report a parse error.     May return void_type_node indicating that this method is actually    a friend.  See grokfield for more details.     Came here with a `.pushlevel' .     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `grokfield'.  */
end_comment

begin_function
name|tree
name|start_method
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|attrlist
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|attrlist
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
operator|&
name|attrlist
argument_list|)
decl_stmt|;
comment|/* Something too ugly to handle.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|attrlist
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|fndecl
argument_list|,
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pass friends other than inline friend functions back.  */
if|if
condition|(
name|fndecl
operator|==
name|void_type_node
condition|)
return|return
name|fndecl
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* Not a function, tell parser to report parse error.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|error
argument_list|(
literal|"`%D' is already defined in class `%T'"
argument_list|,
name|fndecl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|void_type_node
return|;
block|}
name|check_template_shadow
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_default_inline
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We process method specializations in finish_struct_1.  */
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fndecl
argument_list|)
condition|)
name|fndecl
operator|=
name|push_template_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|grok_special_member_properties
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
name|cp_finish_decl
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a place for the parms */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Go through the motions of finishing a function definition.    We don't compile this method until after the whole class has    been processed.     FINISH_METHOD must return something that looks as though it    came from GROKFIELD (since we are defining a method, after all).     This is called after parsing the body of the function definition.    STMTS is the chain of statements that makes up the function body.     DECL is the ..._DECL that `start_method' provided.  */
end_comment

begin_function
name|tree
name|finish_method
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|decl
decl_stmt|;
name|tree
name|old_initial
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|decl
return|;
name|old_initial
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the level for the parms (from start_method).      This is like poplevel, but it causes nothing to be      saved.  Saving information here confuses symbol-table      output routines.  Besides, this information will      be correctly output when this method is actually      compiled.  */
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|!=
name|FUNCTION_DECL
argument_list|,
literal|163
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|GNU_xref_end_scope
argument_list|(
operator|(
name|size_t
operator|)
name|current_binding_level
argument_list|,
operator|(
name|size_t
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|old_initial
expr_stmt|;
comment|/* We used to check if the context of FNDECL was different from      current_class_type as another way to get inside here.  This didn't work      for String.cc in libg++.  */
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a new struct TYPE is defined.    If this structure or union completes the type of any previous    variable declaration, lay it out and output its rtl.  */
end_comment

begin_function
name|void
name|hack_incomplete_structures
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
modifier|*
name|list
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
comment|/* Don't do this for class templates.  */
return|return;
if|if
condition|(
name|namespace_bindings_p
argument_list|()
condition|)
block|{
name|level
operator|=
literal|0
expr_stmt|;
name|list
operator|=
operator|&
name|namespace_scope_incomplete
expr_stmt|;
block|}
else|else
block|{
name|level
operator|=
name|innermost_nonclass_level
argument_list|()
expr_stmt|;
name|list
operator|=
operator|&
name|level
operator|->
name|incomplete
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|decl
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|type
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
operator|)
condition|)
block|{
name|int
name|toplevel
init|=
name|toplevel_bindings_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
block|{
name|tree
name|cleanup
decl_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
else|else
name|list
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* Keep looking through artificial binding levels generated 	 for local variables.  */
if|if
condition|(
name|level
operator|&&
name|level
operator|->
name|keep
operator|==
literal|2
condition|)
block|{
name|level
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
name|list
operator|=
operator|&
name|level
operator|->
name|incomplete
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_function

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup    here.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
decl_stmt|;
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|rval
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize for space over speed here.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|||
name|flag_expensive_optimizations
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
name|rval
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_vbase_delete
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When a stmt has been parsed, this function is called.  */
end_comment

begin_function
name|void
name|finish_stmt
parameter_list|()
block|{
comment|/* Always assume this statement was not an expression statement.  If      it actually was an expression statement, its our callers      responsibility to fix this up.  */
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL was originally constructed as a non-static member function,    but turned out to be static.  Update it accordingly.  */
end_comment

begin_function
name|void
name|revert_static_member_fn
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|function
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|error
argument_list|(
literal|"static member function `%#D' declared with type qualifiers"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_qualified_type
argument_list|(
name|tmp
argument_list|,
name|cp_type_quals
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_exception_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the variables used during compilation of a C++    function.  */
end_comment

begin_function
specifier|static
name|void
name|push_cp_function_context
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|cp_language_function
modifier|*
name|p
init|=
operator|(
operator|(
expr|struct
name|cp_language_function
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cp_language_function
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|f
operator|->
name|language
operator|=
operator|(
expr|struct
name|language_function
operator|*
operator|)
name|p
expr_stmt|;
comment|/* It takes an explicit call to expand_body to generate RTL for a      function.  */
name|expanding_p
operator|=
literal|0
expr_stmt|;
comment|/* Whenever we start a new function, we destroy temporaries in the      usual way.  */
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the language-specific parts of F, now that we've finished    compiling the function.  */
end_comment

begin_function
specifier|static
name|void
name|pop_cp_function_context
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|language
condition|)
block|{
name|struct
name|cp_language_function
modifier|*
name|cp
init|=
operator|(
expr|struct
name|cp_language_function
operator|*
operator|)
name|f
operator|->
name|language
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|x_local_names
condition|)
name|VARRAY_FREE
argument_list|(
name|cp
operator|->
name|x_local_names
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|language
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|language
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark P for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_lang_function
parameter_list|(
name|p
parameter_list|)
name|struct
name|cp_language_function
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|mark_c_language_function
argument_list|(
operator|&
name|p
operator|->
name|base
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|p
operator|->
name|x_dtor_label
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|p
operator|->
name|x_current_class_ptr
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|p
operator|->
name|x_current_class_ref
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|p
operator|->
name|x_eh_spec_block
argument_list|)
expr_stmt|;
name|ggc_mark_tree_varray
argument_list|(
name|p
operator|->
name|x_local_names
argument_list|)
expr_stmt|;
name|mark_named_label_lists
argument_list|(
operator|&
name|p
operator|->
name|x_named_labels
argument_list|,
operator|&
name|p
operator|->
name|x_named_label_uses
argument_list|)
expr_stmt|;
name|mark_binding_level
argument_list|(
operator|&
name|p
operator|->
name|bindings
argument_list|)
expr_stmt|;
name|mark_pending_inlines
argument_list|(
operator|&
name|p
operator|->
name|unparsed_inlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the language-specific data in F for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_cp_function_context
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|mark_lang_function
argument_list|(
operator|(
expr|struct
name|cp_language_function
operator|*
operator|)
name|f
operator|->
name|language
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_mark_tree
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|struct
name|lang_identifier
modifier|*
name|li
init|=
operator|(
expr|struct
name|lang_identifier
operator|*
operator|)
name|t
decl_stmt|;
name|struct
name|lang_id2
modifier|*
name|li2
init|=
name|li
operator|->
name|x
decl_stmt|;
name|ggc_mark_tree
argument_list|(
name|li
operator|->
name|namespace_bindings
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|li
operator|->
name|bindings
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|li
operator|->
name|class_value
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|li
operator|->
name|class_template_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|li2
condition|)
block|{
name|ggc_mark_tree
argument_list|(
name|li2
operator|->
name|label_value
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|li2
operator|->
name|implicit_decl
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|li2
operator|->
name|error_locus
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CPLUS_BINDING
condition|)
block|{
if|if
condition|(
name|BINDING_HAS_LEVEL_P
argument_list|(
name|t
argument_list|)
condition|)
name|mark_binding_level
argument_list|(
operator|&
name|BINDING_LEVEL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ggc_mark_tree
argument_list|(
name|BINDING_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|BINDING_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|OVERLOAD
condition|)
name|ggc_mark_tree
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
name|ggc_mark_tree
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'d'
condition|)
block|{
name|struct
name|lang_decl
modifier|*
name|ld
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|ld
condition|)
block|{
name|ggc_mark
argument_list|(
name|ld
argument_list|)
expr_stmt|;
name|c_mark_lang_decl
argument_list|(
operator|&
name|ld
operator|->
name|decl_flags
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_GLOBAL_CTOR_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_GLOBAL_DTOR_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_THUNK_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_DISCRIMINATOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|ggc_mark_tree
argument_list|(
name|ld
operator|->
name|decl_flags
operator|.
name|u2
operator|.
name|access
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|t
argument_list|)
condition|)
name|ggc_mark_tree
argument_list|(
name|ld
operator|->
name|decl_flags
operator|.
name|u2
operator|.
name|vcall_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|ggc_mark_tree
argument_list|(
name|ld
operator|->
name|decl_flags
operator|.
name|u
operator|.
name|template_info
argument_list|)
expr_stmt|;
else|else
name|mark_binding_level
argument_list|(
operator|&
name|NAMESPACE_LEVEL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|ggc_mark_tree
argument_list|(
name|ld
operator|->
name|befriending_classes
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|ld
operator|->
name|context
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|ld
operator|->
name|cloned_function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ggc_mark_tree
argument_list|(
name|ld
operator|->
name|u
operator|.
name|sorted_fields
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_PENDING_INLINE_P
argument_list|(
name|t
argument_list|)
condition|)
name|mark_lang_function
argument_list|(
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|struct
name|lang_type
modifier|*
name|lt
init|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|lt
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
block|{
name|ggc_mark
argument_list|(
name|lt
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|primary_base
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|vfields
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|vbases
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|tags
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|size
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|pure_virtuals
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|friend_classes
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|rtti
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|methods
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|template_info
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|lt
operator|->
name|befriending_classes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
condition|)
comment|/* In the case of pointer-to-member function types, the 	   TYPE_LANG_SPECIFIC is really just a tree.  */
name|ggc_mark_tree
argument_list|(
operator|(
name|tree
operator|)
name|lt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since    the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */
end_comment

begin_function
name|tree
name|identifier_global_value
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build the void_list_node (void_type_node having been created).  */
end_comment

begin_function
name|tree
name|build_void_list_node
parameter_list|()
block|{
name|tree
name|t
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
name|TREE_PARMLIST
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_missing_noreturn_ok_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* A missing noreturn is ok for the `main' function.  */
return|return
name|DECL_MAIN_P
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

end_unit

