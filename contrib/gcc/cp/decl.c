begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 92-98, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"../hash.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|tree
name|builtin_return_address_fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|static_ctors
decl_stmt|,
name|static_dtors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|static_labelno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|current_namespace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|global_namespace
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern void (*print_error_function
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*valid_lang_attribute
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Obstack used for remembering local class declarations (like    enums and static (const) members.  */
end_comment

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_decl_stmt
name|struct
name|obstack
name|decl_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_level
modifier|*
name|decl_stack
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_UNSIGNED
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_UNSIGNED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BOOL_TYPE_SIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SLOW_BYTE_ACCESS
end_ifdef

begin_define
define|#
directive|define
name|BOOL_TYPE_SIZE
value|((SLOW_BYTE_ACCESS) ? (POINTER_SIZE) : (CHAR_TYPE_SIZE))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BOOL_TYPE_SIZE
value|CHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|grokparms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_nested_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|redeclaration_error_message
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_level
modifier|*
name|push_decl_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_binding_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|binding_level
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_binding_level
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|suspend_binding_level
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resume_binding_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|declare_namespace_level
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|signal_catch
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|storedecls
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|require_complete_types_for_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_overloaded_decl_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ambi_op_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unary_op_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|store_bindings
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_tag_reverse
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|obscure_complex_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_build_cleanup_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_name_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_extern_redeclared_static
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grok_reference_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|grokfndecl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
expr|enum
name|overload_flags
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|grokvardecl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|RID_BIT_TYPE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_tag
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_identifier_type_value_with_scope
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_builtin_type
name|PROTO
argument_list|(
operator|(
expr|enum
name|rid
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_unknown_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|member_function_or_else
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bad_specifiers
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_print_error_function
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_process_template_type_declaration
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_for_uninitialized_const_var
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|typename_hash
name|PROTO
argument_list|(
operator|(
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|typename_compare
name|PROTO
argument_list|(
operator|(
name|hash_table_key
operator|,
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_binding
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_binding
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_binding
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|local_variable_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|find_binding
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|select_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unqualified_namespace_lookup
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_flags
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|qualify_lookup
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|record_builtin_java_type
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tag_name
name|PROTO
argument_list|(
operator|(
expr|enum
name|tag_types
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_class_binding_level
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|innermost_nonclass_level
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_dtor
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_ctor
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|poplevel_class
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_about_implicit_typename_lookup
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|walk_namespaces_r
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|walk_namespaces_fn
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|walk_globals_r
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|indent
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A node which has tree code ERROR_MARK, and whose type is itself.    All erroneous expressions are replaced with this node.  All functions    that accept nodes as arguments should avoid generating error messages    if this node is one of the arguments, since it is undesirable to get    multiple error messages from one error in the input.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Erroneous argument lists can use this *IFF* they do not modify it.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTEGER_TYPE and REAL_TYPE nodes for the standard data types */
end_comment

begin_decl_stmt
name|tree
name|short_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|short_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ptrdiff_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|wchar_decl_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_long_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intDI_type_node
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
end_if

begin_decl_stmt
name|tree
name|intTI_type_node
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|tree
name|unsigned_intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intDI_type_node
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
end_if

begin_decl_stmt
name|tree
name|unsigned_intTI_type_node
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|tree
name|java_byte_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|java_short_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|java_int_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|java_long_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|java_float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|java_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|java_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|java_boolean_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A VOID_TYPE node, and the same, packaged in a TREE_LIST.  */
end_comment

begin_decl_stmt
name|tree
name|void_type_node
decl_stmt|,
name|void_list_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|void_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `void *' and `const void *'.  */
end_comment

begin_decl_stmt
name|tree
name|ptr_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|const_ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `char *' and `const char *'.  */
end_comment

begin_decl_stmt
name|tree
name|string_type_node
decl_stmt|,
name|const_string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `char[256]' or something like it.    Used when an array of char is needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|char_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `int[256]' or something like it.    Used when an array of int needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|int_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `wchar_t[256]' or something like it.    Used when a wide string literal is created.  */
end_comment

begin_decl_stmt
name|tree
name|wchar_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bool data type, and constants */
end_comment

begin_decl_stmt
name|tree
name|boolean_type_node
decl_stmt|,
name|boolean_true_node
decl_stmt|,
name|boolean_false_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `int ()' -- used for implicit declaration of functions.  */
end_comment

begin_decl_stmt
name|tree
name|default_function_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function types `double (double)' and `double (double, double)', etc.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|double_ftype_double
decl_stmt|,
name|double_ftype_double_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|int_ftype_int
decl_stmt|,
name|long_ftype_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|float_ftype_float
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ldouble_ftype_ldouble
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `int (const void *, const void *, size_t)' */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|int_ftype_cptr_cptr_sizet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ extensions */
end_comment

begin_decl_stmt
name|tree
name|vtable_entry_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|delta_type_node
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Old rtti stuff.  */
end_comment

begin_endif
unit|tree __baselist_desc_type_node; tree __i_desc_type_node, __m_desc_type_node; tree __t_desc_array_type, __i_desc_array_type, __m_desc_array_type;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|tree
name|__t_desc_type_node
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|tree __tp_desc_type_node;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|tree
name|__access_mode_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|__bltn_desc_type_node
decl_stmt|,
name|__user_desc_type_node
decl_stmt|,
name|__class_desc_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|__ptr_desc_type_node
decl_stmt|,
name|__attr_desc_type_node
decl_stmt|,
name|__func_desc_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|__ptmf_desc_type_node
decl_stmt|,
name|__ptmd_desc_type_node
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not needed yet?  May be needed one day?  */
end_comment

begin_endif
unit|tree __bltn_desc_array_type, __user_desc_array_type, __class_desc_array_type; tree __ptr_desc_array_type, __attr_dec_array_type, __func_desc_array_type; tree __ptmf_desc_array_type, __ptmd_desc_array_type;
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the identifier __vlist. */
end_comment

begin_decl_stmt
name|tree
name|vlist_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the type _Vlist = vtable_entry_type**. */
end_comment

begin_decl_stmt
name|tree
name|vlist_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A null pointer of type _Vlist. */
end_comment

begin_decl_stmt
name|tree
name|vlist_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates that there is a type value in some namespace, although    that is not necessarily in scope at the moment. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|global_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|class_star_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|class_type_node
decl_stmt|,
name|record_type_node
decl_stmt|,
name|union_type_node
decl_stmt|,
name|enum_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unknown_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|opaque_type_node
decl_stmt|,
name|signature_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|sigtable_entry_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type `vtable_entry_type[]' */
end_comment

begin_decl_stmt
name|tree
name|vtbl_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|vtbl_ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* namespace std */
end_comment

begin_decl_stmt
name|tree
name|std_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|in_std
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expect only namespace names now. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|only_namespace_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a destructor, the point at which all derived class destroying    has been done, just before any base class destroying will be done.  */
end_comment

begin_decl_stmt
name|tree
name|dtor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a destructor, the last insn emitted after the start of the    function and the parms.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_dtor_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a constructor, the last insn emitted after the start of the    function and the parms, the exception specification and any    function-try-block.  The constructor initializers are emitted after    this insn.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_parm_cleanup_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a constructor, the point at which we are ready to return    the pointer to the initialized object.  */
end_comment

begin_decl_stmt
name|tree
name|ctor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A FUNCTION_DECL which can call `abort'.  Not necessarily the    one that the user will declare, but sufficient to be called    by routines that want to abort the program.  */
end_comment

begin_decl_stmt
name|tree
name|abort_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A FUNCTION_DECL for the default `::operator delete'.  */
end_comment

begin_decl_stmt
name|tree
name|global_delete_fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|cleanup_label
decl_stmt|,
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If original DECL_RESULT of current function was a register,    but due to being an addressable named return value, would up    on the stack, this variable holds the named return value's    original location.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|original_result_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sequence of insns which represents base initialization.  */
end_comment

begin_decl_stmt
name|tree
name|base_init_expr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++: Keep these around to reduce calls to `get_identifier'.    Identifiers for `this' in member functions and the auto-delete    parameter for destructors.  */
end_comment

begin_decl_stmt
name|tree
name|this_identifier
decl_stmt|,
name|in_charge_identifier
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ctor_identifier
decl_stmt|,
name|dtor_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in pointer to member functions, in vtables, and in sigtables.  */
end_comment

begin_decl_stmt
name|tree
name|pfn_identifier
decl_stmt|,
name|index_identifier
decl_stmt|,
name|delta_identifier
decl_stmt|,
name|delta2_identifier
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|pfn_or_delta2_identifier
decl_stmt|,
name|tag_identifier
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|vt_off_identifier
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|named_label_list
block|{
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|names_in_scope
decl_stmt|;
name|tree
name|label_decl
decl_stmt|;
name|char
modifier|*
name|filename_o_goto
decl_stmt|;
name|int
name|lineno_o_goto
decl_stmt|;
name|struct
name|named_label_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of named label uses.    The TREE_PURPOSE field is the list of variables defined    in the label's scope defined at the point of use.    The TREE_VALUE field is the LABEL_DECL used.    The TREE_TYPE field holds `current_binding_level' at the    point of the label's use.     BWAHAHAAHAHahhahahahaah.  No, no, no, said the little chicken.     Look at the pretty struct named_label_list. See the pretty struct    with the pretty named fields that describe what they do. See the    pretty lack of gratuitous casts. Notice the code got a lot cleaner.     Used only for jumps to as-yet undefined labels, since    jumps to defined labels can have their validity checked    by stmt.c.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|named_label_list
modifier|*
name|named_label_uses
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of objects which have constructors or destructors    which reside in the global scope.  The decl is stored in    the TREE_VALUE slot and the initializer is stored    in the TREE_PURPOSE slot.  */
end_comment

begin_decl_stmt
name|tree
name|static_aggregates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- end of C++ */
end_comment

begin_comment
comment|/* Two expressions that are constants with value zero.    The first is of type `int', the second of type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|integer_zero_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|null_pointer_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value for __null (NULL), namely, a zero of an integer type with    the same number of bits as a pointer.  */
end_comment

begin_decl_stmt
name|tree
name|null_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for the integer constants 1, 2, and 3.  */
end_comment

begin_decl_stmt
name|tree
name|integer_one_node
decl_stmt|,
name|integer_two_node
decl_stmt|,
name|integer_three_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that there was overflow computing enum_next_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enum_overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain or parameter decls here.  */
end_comment

begin_decl_stmt
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves here a chain of structure    and enum types declared in the parmlist.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts here the list of parameter names or chain of decls.    `store_parm_decls' finds it here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|shadowed_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, and whenever    a label (case or named) is defined.  Set to value of expression    returned from function when that value can be transformed into    a named return value.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_return_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize any builtin functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.    -ansi sets this.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_no_nonansi_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means enable obscure ANSI features and disable GNU extensions    that might cause ANSI-compliant code to be miscompiled.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_ansi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)    objects.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_huge_objects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to conserve space in the .o files.  We do this    by putting uninitialized data and runtime initialized data into    .common instead of .data at the expense of not flagging multiple    definitions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_conserve_space
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to the base and current top of the language name stack.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* C and C++ flags are in decl2.c.  */
end_comment

begin_comment
comment|/* Set to 0 at beginning of a constructor, set to 1    if that function does an allocation before referencing its    instance variable.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_function_assigns_this
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_function_just_assigned_this
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function.  Set non-zero when    store_parm_decls is called.  Don't call store_parm_decls    if this flag is non-zero!  */
end_comment

begin_decl_stmt
name|int
name|current_function_parms_stored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag used when debugging spew.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|spew_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a copy of the class_shadowed list of the previous class binding    contour when at global scope.  It's used to reset IDENTIFIER_CLASS_VALUEs    when entering another class scope (i.e. a cache miss).  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|previous_class_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A expression of value 0 with the same precision as a sizetype    node, but signed.  */
end_comment

begin_decl_stmt
name|tree
name|signed_size_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the anonymous namespace, throughout this translation    unit.  */
end_comment

begin_decl_stmt
name|tree
name|anonymous_namespace_name
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|stack_level
modifier|*
name|push_decl_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|stack_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure    which records the names defined in that contour.    Contours include:     0) the global one     1) one for each function definition,        where internal declarations of the parameters appear.     2) one for each compound statement,        to record its declarations.     The current meaning of a name can be found by searching the levels    from the current one out to the global one.     Off to the side, may be the class_binding_level.  This exists only    to catch class-local declarations.  It is otherwise nonexistent.     Also there may be binding levels that catch cleanups that must be    run when exceptions occur.  Thus, to see whether a name is bound in    the current scope, it is not enough to look in the    CURRENT_BINDING_LEVEL.  You should use lookup_name_current_level    instead.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,        and typedef types.  These are in the reverse of the order        supplied.  There may be OVERLOADs on this list, too, but they        are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions, for looking up        tag names.        It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,        or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,        or ENUMERAL_TYPE node.         C++: the TREE_VALUE nodes can be simple types for        component_bindings.  */
name|tree
name|tags
decl_stmt|;
comment|/* A list of USING_DECL nodes. */
name|tree
name|usings
decl_stmt|;
comment|/* A list of used namespaces. PURPOSE is the namespace,        VALUE the common ancestor with this binding_level's namespace. */
name|tree
name|using_directives
decl_stmt|;
comment|/* If this binding level is the binding level for a class, then        class_shadowed is a TREE_LIST.  The TREE_PURPOSE of each node        is the name of an entity bound in the class; the TREE_VALUE is        the IDENTIFIER_CLASS_VALUE before we entered the class.  Thus,        when leaving class scope, we can restore the        IDENTIFIER_CLASS_VALUE by walking this list.  The TREE_TYPE is        the DECL bound by this name in the class.  */
name|tree
name|class_shadowed
decl_stmt|;
comment|/* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and        is used for all binding levels.  */
name|tree
name|type_shadowed
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of BLOCK nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The BLOCK node for this level, if one has been preallocated.        If 0, the BLOCK is allocated (if needed) when the level is popped.  */
name|tree
name|this_block
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* List of decls in `names' that have incomplete        structure or union types.  */
name|tree
name|incomplete
decl_stmt|;
comment|/* List of VAR_DECLS saved from a previous for statement.        These would be dead in ANSI-conforming code, but might        be referenced in ARM-era code.  These are stored in a        TREE_LIST; the TREE_VALUE is the actual declaration.  */
name|tree
name|dead_vars_from_for
decl_stmt|;
comment|/* 1 for the level that holds the parameters of a function.        2 for the level that holds a class declaration.        3 for levels that hold parameter declarations.  */
name|unsigned
name|parm_flag
range|:
literal|4
decl_stmt|;
comment|/* 1 means make a BLOCK for this level regardless of all else.        2 for temporary binding contours created by the compiler.  */
name|unsigned
name|keep
range|:
literal|3
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|unsigned
name|tag_transparent
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level can safely have additional        cleanup-needing variables added to it.  */
name|unsigned
name|more_cleanups_ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|have_cleanups
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level is for storing the decls for template        parameters and generic decls; these decls will be discarded and        replaced with a TEMPLATE_DECL.  */
name|unsigned
name|pseudo_global
range|:
literal|1
decl_stmt|;
comment|/* This is set for a namespace binding level.  */
name|unsigned
name|namespace_p
range|:
literal|1
decl_stmt|;
comment|/* True if this level is that of a for-statement where we need to        worry about ambiguous (ARM or ANSI) scope rules.  */
name|unsigned
name|is_for_scope
range|:
literal|1
decl_stmt|;
comment|/* Two bits left for this word.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
comment|/* Binding depth at which this level began.  */
name|unsigned
name|binding_depth
decl_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|((struct binding_level *) NULL)
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|current_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The binding level of the current class, if any.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|class_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
name|clear_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|binding_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_class_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|indent
parameter_list|()
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|binding_depth
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pushdecl_with_scope
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_binding_level
parameter_list|(
name|newlevel
parameter_list|,
name|tag_transparent
parameter_list|,
name|keep
parameter_list|)
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
name|int
name|tag_transparent
decl_stmt|,
name|keep
decl_stmt|;
block|{
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
operator|*
name|newlevel
operator|=
name|clear_binding_level
expr_stmt|;
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|tag_transparent
operator|=
name|tag_transparent
expr_stmt|;
name|newlevel
operator|->
name|more_cleanups_ok
operator|=
literal|1
expr_stmt|;
name|newlevel
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|newlevel
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"push %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|newlevel
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
end_function

begin_comment
comment|/* Find the innermost enclosing class scope, and reset    CLASS_BINDING_LEVEL appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|find_class_binding_level
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|level
operator|&&
name|level
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|level
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|level
operator|&&
name|level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|class_binding_level
operator|=
name|level
expr_stmt|;
else|else
name|class_binding_level
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_binding_level
parameter_list|()
block|{
if|if
condition|(
name|global_binding_level
condition|)
block|{
comment|/* Cannot pop a level, if there are none left to pop.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|my_friendly_abort
argument_list|(
literal|123
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|binding_depth
operator|--
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pop  %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|current_binding_level
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_class_level
operator|!=
operator|(
name|current_binding_level
operator|==
name|class_binding_level
operator|)
condition|)
block|{
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX is_class_level != (current_binding_level == class_binding_level)\n"
argument_list|)
expr_stmt|;
block|}
name|is_class_level
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
if|#
directive|if
literal|0
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|if (level->binding_depth != binding_depth)       abort ();
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|free_binding_level
operator|=
name|level
expr_stmt|;
name|find_class_binding_level
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|suspend_binding_level
parameter_list|()
block|{
if|if
condition|(
name|class_binding_level
condition|)
name|current_binding_level
operator|=
name|class_binding_level
expr_stmt|;
if|if
condition|(
name|global_binding_level
condition|)
block|{
comment|/* Cannot suspend a level, if there are none left to suspend.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|my_friendly_abort
argument_list|(
literal|123
argument_list|)
expr_stmt|;
block|}
comment|/* Suspend the current level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|binding_depth
operator|--
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"suspend  %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|current_binding_level
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_class_level
operator|!=
operator|(
name|current_binding_level
operator|==
name|class_binding_level
operator|)
condition|)
block|{
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX is_class_level != (current_binding_level == class_binding_level)\n"
argument_list|)
expr_stmt|;
block|}
name|is_class_level
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|find_class_binding_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_binding_level
parameter_list|(
name|b
parameter_list|)
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
comment|/* Resuming binding levels is meant only for namespaces,      and those cannot nest into classes. */
name|my_friendly_assert
argument_list|(
operator|!
name|class_binding_level
argument_list|,
literal|386
argument_list|)
expr_stmt|;
comment|/* Also, resuming a non-directly nested namespace is a no-no.  */
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|level_chain
operator|==
name|current_binding_level
argument_list|,
literal|386
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|b
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"resume %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|b
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new `struct binding_level'.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|()
block|{
comment|/* NOSTRICT */
return|return
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost binding level that is not for a class scope.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|innermost_nonclass_level
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in a toplevel binding level.  This    means either the global binding level or a namespace in a toplevel    binding level.  Since there are no non-toplevel namespace levels,    this really means any namespace or pseudo-global level.  We also    include a class whose context is toplevel.  */
end_comment

begin_function
name|int
name|toplevel_bindings_p
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|namespace_p
operator|||
name|b
operator|->
name|pseudo_global
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if this is a namespace scope, or if we are defining a class    which is itself at namespace scope, or whose enclosing class is    such a class, etc.  */
end_comment

begin_function
name|int
name|namespace_bindings_p
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|namespace_p
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|()
block|{
name|keep_next_level_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|int
name|kept_level_p
parameter_list|()
block|{
return|return
operator|(
name|current_binding_level
operator|->
name|blocks
operator|!=
name|NULL_TREE
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
name|NULL_TREE
operator|||
operator|(
name|current_binding_level
operator|->
name|tags
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|current_binding_level
operator|->
name|tag_transparent
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of parameters.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|declare_pseudo_global_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|pseudo_global
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_namespace_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|namespace_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pseudo_global_level_p
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|pseudo_global
return|;
block|}
end_function

begin_function
name|void
name|set_class_shadows
parameter_list|(
name|shadows
parameter_list|)
name|tree
name|shadows
decl_stmt|;
block|{
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|shadows
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
comment|/* If this is the top level of a function,      just make sure that NAMED_LABELS is 0.      They should have been set to 0 at the end of the previous function.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|my_friendly_assert
argument_list|(
name|named_labels
operator|==
name|NULL_TREE
argument_list|,
literal|134
argument_list|)
expr_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
if|if
condition|(
literal|0
condition|)
else|#
directive|else
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
if|if
condition|(
name|free_binding_level
condition|)
endif|#
directive|endif
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
block|}
name|push_binding_level
argument_list|(
name|newlevel
argument_list|,
name|tag_transparent
argument_list|,
name|keep_next_level_flag
argument_list|)
expr_stmt|;
name|GNU_xref_start_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|newlevel
argument_list|)
expr_stmt|;
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_level_for_for
parameter_list|()
block|{
name|current_binding_level
operator|->
name|is_for_scope
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pushlevel_temporary
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
name|pushlevel
argument_list|(
name|tag_transparent
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|keep
operator|=
literal|2
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
comment|/* Note we don't call push_momentary() here.  Otherwise, it would cause      cleanups to be allocated on the momentary obstack, and they will be      overwritten by the next statement.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a binding between a name and an entity at a block scope,    this is the `struct binding_level' for the block.  */
end_comment

begin_define
define|#
directive|define
name|BINDING_LEVEL
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(((struct tree_binding*)NODE)->scope.level)
end_define

begin_comment
comment|/* These are currently unused, but permanent, CPLUS_BINDING nodes.    They are kept here because they are allocated from the permanent    obstack and cannot be easily freed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|free_binding_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make DECL the innermost binding for ID.  The LEVEL is the binding    level at which this declaration is being bound.  */
end_comment

begin_function
specifier|static
name|void
name|push_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|,
name|level
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
block|{
name|tree
name|binding
decl_stmt|;
if|if
condition|(
operator|!
name|free_binding_nodes
condition|)
block|{
comment|/* There are no free nodes, so we must build one here.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|binding
operator|=
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* There are nodes on the free list.  Grab the first one.  */
name|binding
operator|=
name|free_binding_nodes
expr_stmt|;
comment|/* And update the free list.  */
name|free_binding_nodes
operator|=
name|TREE_CHAIN
argument_list|(
name|free_binding_nodes
argument_list|)
expr_stmt|;
block|}
comment|/* Now, fill in the binding information.  */
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BINDING_LEVEL
argument_list|(
name|binding
argument_list|)
operator|=
name|level
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOCAL_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
operator|(
name|level
operator|!=
name|class_binding_level
operator|)
expr_stmt|;
comment|/* And put it on the front of the list of bindings for ID.  */
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|binding
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ID is already bound in the current scope.  But, DECL is an    additional binding for ID in the same scope.  This is the `struct    stat' hack whereby a non-typedef class-name or enum-name can be    bound at the same level as some other kind of entity.  It's the    responsibility of the caller to check that inserting this name is    legal here.  Returns nonzero if the new binding was successful.  */
end_comment

begin_function
specifier|static
name|int
name|add_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binding
init|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The new name is the type name.  */
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
condition|)
comment|/* This situation arises when push_class_level_binding moves an        inherited type-binding out of the way to make room for a new        value binding.  */
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The old binding was a type name.  It was placed in 	 BINDING_VALUE because it was thought, at the point it was 	 declared, to be the only entity with such a name.  Move the 	 type name into the type slot; it is now hidden by the new 	 binding.  */
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|decl
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with previous declaration `%#D'"
argument_list|,
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Bind DECL to ID in the current_binding_level.    If PUSH_USING is set in FLAGS, we know that DECL doesn't really belong    to this binding level, that it got here through a using-declaration.  */
end_comment

begin_function
name|void
name|push_local_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Skip over any local classes.  This makes sense if we call      push_local_binding with a friend decl of a local class.  */
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|lookup_name_current_level
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|/* Supplement the existing binding.  */
if|if
condition|(
operator|!
name|add_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
condition|)
comment|/* It didn't work.  Something else must be bound at this 	   level.  Do not add DECL to the list of things to pop 	   later.  */
return|return;
block|}
else|else
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
condition|)
comment|/* We must put the OVERLOAD into a TREE_LIST since the        TREE_CHAIN of an OVERLOAD is already used.  Similarly for        decls that got here through a using-declaration.  */
name|decl
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* And put DECL on the list of things declared by the current      binding level.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind DECL to ID in the class_binding_level.  Returns nonzero if the    binding was successful.  */
end_comment

begin_function
name|int
name|push_class_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|result
init|=
literal|1
decl_stmt|;
name|tree
name|binding
init|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|context
decl_stmt|;
comment|/* Note that we declared this value so that we can issue an error if      this an illegal redeclaration of a name already used for some      other purpose.  */
name|note_name_declared_in_class
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|BINDING_LEVEL
argument_list|(
name|binding
argument_list|)
operator|==
name|class_binding_level
condition|)
comment|/* Supplement the existing binding.  */
name|result
operator|=
name|add_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
comment|/* Update the IDENTIFIER_CLASS_VALUE for this ID to be the      class-level declaration.  Note that we do not use DECL here      because of the possibility of the `struct stat' hack; if DECL is      a class-name or enum-name we might prefer a field-name, or some      such.  */
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a binding from a base class, mark it as such.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* Any implicit typename must be from a base-class.  The 	 context for an implicit typename declaration is always 	 the derived class in which the lookup was done, so the checks 	 based on the context of DECL below will not trigger.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IMPLICIT_TYPENAME_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|context
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|current_class_type
argument_list|,
name|context
argument_list|)
condition|)
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
condition|)
comment|/* We only encounter a TREE_LIST when push_class_decls detects an        ambiguity.  Such an ambiguity can be overridden by a definition        in this class.  */
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Remove the binding for DECL which should be the innermost binding    for ID.  */
end_comment

begin_function
specifier|static
name|void
name|pop_binding
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binding
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL_TREE
condition|)
comment|/* It's easiest to write the loops that call this function without        checking whether or not the entities involved have names.  We        get here for such an entity.  */
return|return;
comment|/* Get the innermost binding for ID.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* The name should be bound.  */
name|my_friendly_assert
argument_list|(
name|binding
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The DECL will be either the ordinary binding or the type      binding for this identifier.  Remove that binding.  */
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
condition|)
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|==
name|decl
condition|)
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|&&
operator|!
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
condition|)
block|{
comment|/* We're completely done with the innermost binding for this 	 identifier.  Unhook it from the list of bindings.  */
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
expr_stmt|;
comment|/* And place it on the free list.  */
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|free_binding_nodes
expr_stmt|;
name|free_binding_nodes
operator|=
name|binding
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP == 1, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|int
name|tmp
init|=
name|functionbody
decl_stmt|;
name|int
name|real_functionbody
init|=
name|current_binding_level
operator|->
name|keep
operator|==
literal|2
condition|?
operator|(
operator|(
name|functionbody
operator|=
literal|0
operator|)
expr|,
name|tmp
operator|)
else|:
name|functionbody
decl_stmt|;
name|tree
name|tags
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|tags
else|:
literal|0
decl_stmt|;
name|tree
name|subblocks
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|blocks
else|:
literal|0
decl_stmt|;
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|block_previously_created
decl_stmt|;
name|int
name|leaving_for_scope
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
return|return
name|poplevel_class
argument_list|()
return|;
name|my_friendly_assert
argument_list|(
operator|!
name|current_binding_level
operator|->
name|class_shadowed
argument_list|,
literal|19990414
argument_list|)
expr_stmt|;
comment|/* We used to use KEEP == 2 to indicate that the new block should go      at the beginning of the list of blocks at this binding level,      rather than the end.  This hack is no longer used.  */
name|my_friendly_assert
argument_list|(
name|keep
operator|==
literal|0
operator|||
name|keep
operator|==
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|keep
operator|==
literal|1
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* Output any nested inline functions within this block      if they weren't already output.  */
for|for
control|(
name|decl
operator|=
name|decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
condition|)
block|{
comment|/* If this decl was copied from a file-scope decl 	   on account of a block-scope extern decl, 	   propagate TREE_ADDRESSABLE to the file-scope decl.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|push_function_context
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
name|NULL_TREE
expr_stmt|;
name|block_previously_created
operator|=
operator|(
name|current_binding_level
operator|->
name|this_block
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|block_previously_created
condition|)
name|block
operator|=
name|current_binding_level
operator|->
name|this_block
expr_stmt|;
elseif|else
if|if
condition|(
name|keep
operator|==
literal|1
operator|||
name|functionbody
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|block_previously_created
condition|)
block|{
if|if
condition|(
name|decls
operator|||
name|tags
operator|||
name|subblocks
condition|)
block|{
if|if
condition|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|||
name|BLOCK_TYPE_TAGS
argument_list|(
name|block
argument_list|)
condition|)
name|warning
argument_list|(
literal|"internal compiler error: debugging info corrupted"
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_TYPE_TAGS
argument_list|(
name|block
argument_list|)
operator|=
name|tags
expr_stmt|;
comment|/* We can have previous subblocks and new subblocks when 		 doing fixup_gotos with complex cleanups.  We chain the new 		 subblocks onto the end of any pre-existing subblocks.  */
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|chainon
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
block|}
comment|/* If we created the block earlier on, and we are just 	     diddling it now, then it already should have a proper 	     BLOCK_END_NOTE value associated with it.  */
block|}
else|else
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_TYPE_TAGS
argument_list|(
name|block
argument_list|)
operator|=
name|tags
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
comment|/* Otherwise, for a new block, install a new BLOCK_END_NOTE 	     value.  */
name|remember_end_note
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In each subblock, record that this is its superior.  */
if|if
condition|(
name|keep
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* We still support the old for-scope rules, whereby the variables      in a for-init statement were in scope after the for-statement      ended.  We only use the new rules in flag_new_for_scope is      nonzero.  */
name|leaving_for_scope
operator|=
name|current_binding_level
operator|->
name|is_for_scope
operator|&&
name|flag_new_for_scope
operator|==
literal|1
expr_stmt|;
comment|/* Remove declarations for all the DECLs in this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|leaving_for_scope
operator|&&
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|outer_binding
init|=
name|TREE_CHAIN
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ns_binding
decl_stmt|;
if|if
condition|(
operator|!
name|outer_binding
condition|)
name|ns_binding
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_binding
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|outer_binding
operator|&&
operator|(
name|BINDING_LEVEL
argument_list|(
name|outer_binding
argument_list|)
operator|==
name|current_binding_level
operator|->
name|level_chain
operator|)
condition|)
comment|/* We have something like: 	        	         int i; 	         for (int i; ;); 		  	       and we are leaving the `for' scope.  There's no reason to 	       keep the binding of the inner `i' in this case.  */
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|outer_binding
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|||
operator|(
name|ns_binding
operator|&&
name|TREE_CODE
argument_list|(
name|ns_binding
argument_list|)
operator|==
name|TYPE_DECL
operator|)
condition|)
comment|/* Here, we have something like:  		 typedef int I;  		 void f () { 		   for (int I; ;); 		 }  	       We must pop the for-scope binding so we know what's a 	       type and what isn't.  */
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Mark this VAR_DECL as dead so that we can tell we left it 		 there only for backward compatibility.  */
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Keep track of what should of have happenned when we 		 popped the binding.  */
if|if
condition|(
name|outer_binding
operator|&&
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
condition|)
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|link
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
expr_stmt|;
comment|/* Add it to the list of dead variables in the next 		 outermost binding to that we can remove these when we 		 leave that binding.  */
name|current_binding_level
operator|->
name|level_chain
operator|->
name|dead_vars_from_for
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|link
argument_list|,
name|current_binding_level
operator|->
name|level_chain
operator|->
name|dead_vars_from_for
argument_list|)
expr_stmt|;
comment|/* Although we don't pop the CPLUS_BINDING, we do clear 		 its BINDING_LEVEL since the level is going away now.  */
name|BINDING_LEVEL
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Remove the binding.  */
name|decl
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove declarations for any `for' variables from inner scopes      that we kept around.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|dead_vars_from_for
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the IDENTIFIER_TYPE_VALUEs.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|type_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs      list if a `using' declaration put them there.  The debugging      back-ends won't understand OVERLOAD, so we remove them here.      Because the BLOCK_VARS are (temporarily) shared with      CURRENT_BINDING_LEVEL->NAMES we must do this fixup after we have      popped all the bindings.  */
if|if
condition|(
name|block
condition|)
block|{
name|tree
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
operator|*
name|d
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
condition|)
operator|*
name|d
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the level being exited is the top level of a function,      check over all the labels.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* If this is the top level block of a function,          the vars are the function's parameters.          Don't leave them in the BLOCK because they are          found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the definitions of all label names, 	 since their scopes end here.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|label
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"label `%D' used but not defined"
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
literal|1
argument_list|,
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"label `%D' defined but not used"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Put the labels into the "variables" of the              top-level block, so debugger can see them.  */
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Any uses of undefined labels now operate under constraints      of next binding contour.  */
block|{
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
name|level_chain
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|level_chain
condition|)
block|{
name|struct
name|named_label_list
modifier|*
name|labels
decl_stmt|;
for|for
control|(
name|labels
operator|=
name|named_label_uses
init|;
name|labels
condition|;
name|labels
operator|=
name|labels
operator|->
name|next
control|)
if|if
condition|(
name|labels
operator|->
name|binding_level
operator|==
name|current_binding_level
condition|)
block|{
name|labels
operator|->
name|binding_level
operator|=
name|level_chain
expr_stmt|;
name|labels
operator|->
name|names_in_scope
operator|=
name|level_chain
operator|->
name|names
expr_stmt|;
block|}
block|}
block|}
name|tmp
operator|=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
name|pop_binding_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|functionbody
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
block|{
if|if
condition|(
operator|!
name|block_previously_created
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
comment|/* Take care of compiler's internal binding structures.  */
if|if
condition|(
name|tmp
operator|==
literal|2
condition|)
block|{
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|keep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Each and every BLOCK node created here in `poplevel' is important 	 (e.g. for proper debugging information) so if we created one 	 earlier, mark it as "used".  */
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
name|keep
argument_list|,
name|reverse
argument_list|,
name|real_functionbody
argument_list|)
expr_stmt|;
block|}
comment|/* Each and every BLOCK node created here in `poplevel' is important      (e.g. for proper debugging information) so if we created one      earlier, mark it as "used".  */
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Delete the node BLOCK from the current binding level.    This is used for the block inside a stmt expr ({...})    so that the block can be reinserted where appropriate.  */
end_comment

begin_function
name|void
name|delete_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|blocks
operator|==
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|blocks
init|;
name|t
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|block
condition|)
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Clear TREE_USED which is always set by poplevel.      The flag is set again if insert_block is called.  */
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the    current binding level.  This is used when a BIND_EXPR is expanded,    to handle the BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope    (the one we are currently in).  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|this_block
operator|=
name|block
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a pushlevel for class declarations.  */
end_comment

begin_function
name|void
name|pushlevel_class
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
if|if
condition|(
literal|0
condition|)
else|#
directive|else
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
if|if
condition|(
name|free_binding_level
condition|)
endif|#
directive|endif
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|push_binding_level
argument_list|(
name|newlevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl_stack
operator|=
name|push_decl_level
argument_list|(
name|decl_stack
argument_list|,
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|class_binding_level
operator|->
name|parm_flag
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ...and a poplevel for class declarations.  */
end_comment

begin_function
specifier|static
name|tree
name|poplevel_class
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|class_binding_level
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|level
operator|!=
literal|0
argument_list|,
literal|354
argument_list|)
expr_stmt|;
name|decl_stack
operator|=
name|pop_stack_level
argument_list|(
name|decl_stack
argument_list|)
expr_stmt|;
comment|/* If we're leaving a toplevel class, don't bother to do the setting      of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot      shouldn't even be used when current_class_type isn't set, and second,      if we don't touch it here, we're able to use the cache effect if the      next time we're entering a class scope, it is the same class.  */
if|if
condition|(
name|current_class_depth
operator|!=
literal|1
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Clear out our IDENTIFIER_CLASS_VALUEs.  */
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Find the next enclosing class, and recreate 	 IDENTIFIER_CLASS_VALUEs appropriate for that class.  */
name|b
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
while|while
condition|(
name|b
operator|&&
name|b
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
condition|)
for|for
control|(
name|shadowed
operator|=
name|b
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|&&
name|BINDING_LEVEL
argument_list|(
name|t
argument_list|)
operator|!=
name|b
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Remember to save what IDENTIFIER's were bound in this scope so we        can recover from cache misses.  */
block|{
name|previous_class_type
operator|=
name|current_class_type
expr_stmt|;
name|previous_class_values
operator|=
name|class_binding_level
operator|->
name|class_shadowed
expr_stmt|;
block|}
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|type_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the bindings for all of the class-level declarations.  */
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|pop_binding
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|class_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|class_binding_level
operator|->
name|level_chain
argument_list|,
name|class_binding_level
operator|->
name|parm_flag
argument_list|,
name|class_binding_level
operator|->
name|keep
argument_list|)
expr_stmt|;
comment|/* Now, pop out of the binding level which we created up in the      `pushlevel_class' routine.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|pop_binding_level
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE    for any names in enclosing classes.  */
end_comment

begin_function
name|void
name|clear_identifier_class_values
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|class_binding_level
condition|)
return|return;
for|for
control|(
name|t
operator|=
name|class_binding_level
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T is a virtual function table.  */
end_comment

begin_function
name|int
name|vtable_decl_p
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T is a TYPE_DECL for a type with virtual    functions.  */
end_comment

begin_function
name|int
name|vtype_decl_p
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_VSIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T is a signature table.  */
end_comment

begin_function
name|int
name|sigtable_decl_p
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|IS_SIGNATURE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Walk all the namespaces contained NAMESPACE, including NAMESPACE    itself, calling F for each.  The DATA is passed to F as well.  */
end_comment

begin_function
specifier|static
name|int
name|walk_namespaces_r
parameter_list|(
name|namespace
parameter_list|,
name|f
parameter_list|,
name|data
parameter_list|)
name|tree
name|namespace
decl_stmt|;
name|walk_namespaces_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|current
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|result
operator||=
call|(
modifier|*
name|f
call|)
argument_list|(
name|namespace
argument_list|,
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|NAMESPACE_LEVEL
argument_list|(
name|namespace
argument_list|)
operator|->
name|names
init|;
name|current
condition|;
name|current
operator|=
name|TREE_CHAIN
argument_list|(
name|current
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|||
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|current
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|current
argument_list|)
condition|)
block|{
comment|/* Hmm. std. */
name|my_friendly_assert
argument_list|(
name|current
operator|==
name|std_node
argument_list|,
literal|393
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We found a namespace.  */
name|result
operator||=
name|walk_namespaces_r
argument_list|(
name|current
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Walk all the namespaces, calling F for each.  The DATA is passed to    F as well.  */
end_comment

begin_function
name|int
name|walk_namespaces
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|)
name|walk_namespaces_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
return|return
name|walk_namespaces_r
argument_list|(
name|global_namespace
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|walk_globals_data
block|{
name|walk_globals_pred
name|p
decl_stmt|;
name|walk_globals_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Walk the global declarations in NAMESPACE.  Whenever one is found    for which P returns non-zero, call F with its address.  If any call    to F returns a non-zero value, return a non-zero value.  */
end_comment

begin_function
specifier|static
name|int
name|walk_globals_r
parameter_list|(
name|namespace
parameter_list|,
name|data
parameter_list|)
name|tree
name|namespace
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|walk_globals_data
modifier|*
name|wgd
init|=
operator|(
expr|struct
name|walk_globals_data
operator|*
operator|)
name|data
decl_stmt|;
name|walk_globals_pred
name|p
init|=
name|wgd
operator|->
name|p
decl_stmt|;
name|walk_globals_fn
name|f
init|=
name|wgd
operator|->
name|f
decl_stmt|;
name|void
modifier|*
name|d
init|=
name|wgd
operator|->
name|data
decl_stmt|;
name|tree
modifier|*
name|t
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|t
operator|=
operator|&
name|NAMESPACE_LEVEL
argument_list|(
name|namespace
argument_list|)
operator|->
name|names
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|tree
name|glbl
init|=
operator|*
name|t
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|p
call|)
argument_list|(
name|glbl
argument_list|,
name|d
argument_list|)
condition|)
name|result
operator||=
call|(
modifier|*
name|f
call|)
argument_list|(
name|t
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* If F changed *T, then *T still points at the next item to 	 examine.  */
if|if
condition|(
operator|*
name|t
operator|==
name|glbl
condition|)
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Walk the global declarations.  Whenever one is found for which P    returns non-zero, call F with its address.  If any call to F    returns a non-zero value, return a non-zero value.  */
end_comment

begin_function
name|int
name|walk_globals
parameter_list|(
name|p
parameter_list|,
name|f
parameter_list|,
name|data
parameter_list|)
name|walk_globals_pred
name|p
decl_stmt|;
name|walk_globals_fn
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|walk_globals_data
name|wgd
decl_stmt|;
name|wgd
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|wgd
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|wgd
operator|.
name|data
operator|=
name|data
expr_stmt|;
return|return
name|walk_namespaces
argument_list|(
name|walk_globals_r
argument_list|,
operator|&
name|wgd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call wrapup_globals_declarations for the globals in NAMESPACE.  If    DATA is non-NULL, this is the last time we will call    wrapup_global_declarations for this NAMESPACE.  */
end_comment

begin_function
name|int
name|wrapup_globals_for_namespace
parameter_list|(
name|namespace
parameter_list|,
name|data
parameter_list|)
name|tree
name|namespace
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|globals
init|=
name|NAMESPACE_LEVEL
argument_list|(
name|namespace
argument_list|)
operator|->
name|names
decl_stmt|;
name|int
name|len
init|=
name|list_length
argument_list|(
name|globals
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|vec
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|last_time
init|=
operator|(
name|data
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|last_time
operator|&&
name|namespace
operator|==
name|global_namespace
condition|)
comment|/* Let compile_file handle the global namespace.  */
return|return
literal|0
return|;
comment|/* Process the decls in reverse order--earliest first.      Put them into VEC from back to front, then take out from front.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|decl
operator|=
name|globals
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|vec
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|last_time
condition|)
block|{
name|check_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Temporarily mark vtables as external.  That prevents      wrapup_global_declarations from writing them out; we must process      them ourselves in finish_vtable_vardecl.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vtable_decl_p
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Write out any globals that need to be output.  */
name|result
operator|=
name|wrapup_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Undo the hack to DECL_EXTERNAL above.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vtable_decl_p
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
operator|&&
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_print_functions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_print_builtins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_binding_level
parameter_list|(
name|lvl
parameter_list|)
name|struct
name|binding_level
modifier|*
name|lvl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" blocks="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lvl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" n_incomplete=%d parm_flag=%d keep=%d"
argument_list|,
name|list_length
argument_list|(
name|lvl
operator|->
name|incomplete
argument_list|)
argument_list|,
name|lvl
operator|->
name|parm_flag
argument_list|,
name|lvl
operator|->
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|tag_transparent
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tag-transparent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|more_cleanups_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" more-cleanups-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|have_cleanups
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" have-cleanups"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|names
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" names:\t"
argument_list|)
expr_stmt|;
comment|/* We can probably fit 3 names to a line?  */
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|no_print_functions
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|no_print_builtins
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"<built-in>"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Function decls tend to have longer names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|len
operator|=
literal|3
expr_stmt|;
else|else
name|len
operator|=
literal|2
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
break|break;
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|tags
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tags:\t"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|tags
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<unnamed-typedef"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<typedef"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|class_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" class-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|type_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_other_binding_stack
parameter_list|(
name|stack
parameter_list|)
name|struct
name|binding_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|stack
init|;
name|level
operator|!=
name|global_binding_level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"binding level "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|void
operator|*
operator|)
name|level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_binding_stack
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|void
operator|*
operator|)
name|current_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nclass_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|void
operator|*
operator|)
name|class_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nglobal_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|void
operator|*
operator|)
name|global_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
for|for
control|(
name|b
operator|=
name|class_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
if|if
condition|(
name|b
operator|==
name|current_binding_level
condition|)
break|break;
if|if
condition|(
name|b
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
block|}
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|print_other_binding_stack
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"global:\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|global_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Namespace binding access routines: The namespace_bindings field of    the identifier is polymorphic, with three possible values:    NULL_TREE, a list of CPLUS_BINDINGS, or any other tree_node    indicating the BINDING_VALUE of global_namespace. */
end_comment

begin_comment
comment|/* Check whether the a binding for the name to scope is known.    Assumes that the bindings of the name are already a list    of bindings. Returns the binding found, or NULL_TREE. */
end_comment

begin_function
specifier|static
name|tree
name|find_binding
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|iter
decl_stmt|,
name|prev
init|=
name|NULL_TREE
decl_stmt|;
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|iter
argument_list|)
operator|==
name|CPLUS_BINDING
argument_list|,
literal|374
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINDING_SCOPE
argument_list|(
name|iter
argument_list|)
operator|==
name|scope
condition|)
block|{
comment|/* Move binding found to the fron of the list, so              subsequent lookups will find it faster. */
if|if
condition|(
name|prev
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|iter
expr_stmt|;
block|}
return|return
name|iter
return|;
block|}
name|prev
operator|=
name|iter
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Always returns a binding for name in scope. If the    namespace_bindings is not a list, convert it to one first.    If no binding is found, make a new one. */
end_comment

begin_function
name|tree
name|binding_for_name
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|b
init|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|&&
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CPLUS_BINDING
condition|)
block|{
comment|/* Get rid of optimization for global scope. */
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|global_namespace
argument_list|)
argument_list|)
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|&&
operator|(
name|result
operator|=
name|find_binding
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
operator|)
condition|)
return|return
name|result
return|;
comment|/* Not found, make a new permanent one. */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|result
operator|=
name|make_node
argument_list|(
name|CPLUS_BINDING
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|result
argument_list|)
operator|=
name|b
expr_stmt|;
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|result
expr_stmt|;
name|BINDING_SCOPE
argument_list|(
name|result
argument_list|)
operator|=
name|scope
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the binding value for name in scope, considering that    namespace_binding may or may not be a list of CPLUS_BINDINGS. */
end_comment

begin_function
name|tree
name|namespace_binding
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|b
init|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CPLUS_BINDING
condition|)
return|return
operator|(
name|scope
operator|==
name|global_namespace
operator|)
condition|?
name|b
else|:
name|NULL_TREE
return|;
name|name
operator|=
name|find_binding
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
return|return
name|name
return|;
return|return
name|BINDING_VALUE
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the binding value for name in scope. If modifying the binding    of global_namespace is attempted, try to optimize it. */
end_comment

begin_function
name|void
name|set_namespace_binding
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|,
name|val
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|tree
name|val
decl_stmt|;
block|{
name|tree
name|b
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|global_namespace
condition|)
block|{
name|b
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CPLUS_BINDING
condition|)
block|{
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|val
expr_stmt|;
return|return;
block|}
block|}
name|b
operator|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|b
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we    select a name that is unique to this compilation unit.  */
end_comment

begin_function
name|void
name|push_namespace
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|d
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|need_new
init|=
literal|1
decl_stmt|;
name|int
name|implicit_use
init|=
literal|0
decl_stmt|;
name|int
name|global
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|global_namespace
condition|)
block|{
comment|/* This must be ::. */
name|my_friendly_assert
argument_list|(
name|name
operator|==
name|get_identifier
argument_list|(
literal|"::"
argument_list|)
argument_list|,
literal|377
argument_list|)
expr_stmt|;
name|global
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|name
condition|)
block|{
comment|/* The name of anonymous namespace is unique for the translation          unit.  */
if|if
condition|(
operator|!
name|anonymous_namespace_name
condition|)
name|anonymous_namespace_name
operator|=
name|get_file_function_name
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
name|name
operator|=
name|anonymous_namespace_name
expr_stmt|;
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
comment|/* Reopening anonymous namespace.  */
name|need_new
operator|=
literal|0
expr_stmt|;
name|implicit_use
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_namespace
operator|==
name|global_namespace
operator|&&
name|name
operator|==
name|DECL_NAME
argument_list|(
name|std_node
argument_list|)
condition|)
block|{
name|in_std
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Check whether this is an extended namespace definition. */
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|need_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"namespace alias `%D' not allowed here, assuming `%D'"
argument_list|,
name|d
argument_list|,
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need_new
condition|)
block|{
comment|/* Make a new namespace, binding the name to it. */
name|d
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* The global namespace is not pushed, and the global binding 	 level is set elsewhere.  */
if|if
condition|(
operator|!
name|global
condition|)
block|{
name|d
operator|=
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_namespace_level
argument_list|()
expr_stmt|;
name|NAMESPACE_LEVEL
argument_list|(
name|d
argument_list|)
operator|=
name|current_binding_level
expr_stmt|;
block|}
block|}
else|else
name|resume_binding_level
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|implicit_use
condition|)
name|do_using_directive
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Enter the name space. */
name|current_namespace
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop from the scope of the current namespace.  */
end_comment

begin_function
name|void
name|pop_namespace
parameter_list|()
block|{
if|if
condition|(
name|current_namespace
operator|==
name|global_namespace
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|in_std
operator|>
literal|0
argument_list|,
literal|980421
argument_list|)
expr_stmt|;
name|in_std
operator|--
expr_stmt|;
return|return;
block|}
name|current_namespace
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* The binding level is not popped, as it might be re-opened later.  */
name|suspend_binding_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines for reverting temporarily to top-level for instantiation    of templates and such.  We actually need to clear out the class- and    local-value slots of all identifiers, so that only the global values    are at all visible.  Simply setting current_binding_level to the global    scope isn't enough, because more binding levels may be pushed.  */
end_comment

begin_struct
struct|struct
name|saved_scope
block|{
name|struct
name|binding_level
modifier|*
name|old_binding_level
decl_stmt|;
name|tree
name|old_bindings
decl_stmt|;
name|tree
name|old_namespace
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|prev
decl_stmt|;
name|tree
name|class_name
decl_stmt|,
name|class_type
decl_stmt|;
name|tree
name|access_specifier
decl_stmt|;
name|tree
name|function_decl
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|class_bindings
decl_stmt|;
name|tree
modifier|*
name|lang_base
decl_stmt|,
modifier|*
name|lang_stack
decl_stmt|,
name|lang_name
decl_stmt|;
name|int
name|lang_stacksize
decl_stmt|;
name|int
name|minimal_parse_mode
decl_stmt|;
name|tree
name|last_function_parms
decl_stmt|;
name|tree
name|template_parms
decl_stmt|;
name|HOST_WIDE_INT
name|processing_template_decl
decl_stmt|;
name|tree
name|previous_class_type
decl_stmt|,
name|previous_class_values
decl_stmt|;
name|int
name|processing_specialization
decl_stmt|;
name|int
name|processing_explicit_instantiation
decl_stmt|;
name|char
modifier|*
name|class_cache_firstobj
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|saved_scope
modifier|*
name|current_saved_scope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A chain of the binding vecs created by store_bindings.  We create a    whole bunch of these during compilation, on permanent_obstack, so we    can't just throw them away.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|free_binding_vecs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|store_bindings
parameter_list|(
name|names
parameter_list|,
name|old_bindings
parameter_list|)
name|tree
name|names
decl_stmt|,
name|old_bindings
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binding
decl_stmt|,
name|t1
decl_stmt|,
name|id
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|id
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
comment|/* Note that we may have an IDENTIFIER_CLASS_VALUE even when 	     we have no IDENTIFIER_BINDING if we have left the class 	     scope, but cached the class-level declarations.  */
operator|||
operator|!
operator|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|||
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|t1
operator|=
name|old_bindings
init|;
name|t1
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
operator|==
name|id
condition|)
goto|goto
name|skip_it
goto|;
if|if
condition|(
name|free_binding_vecs
condition|)
block|{
name|binding
operator|=
name|free_binding_vecs
expr_stmt|;
name|free_binding_vecs
operator|=
name|TREE_CHAIN
argument_list|(
name|free_binding_vecs
argument_list|)
expr_stmt|;
block|}
else|else
name|binding
operator|=
name|make_tree_vec
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|135
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|0
argument_list|)
operator|=
name|id
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|1
argument_list|)
operator|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|2
argument_list|)
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|3
argument_list|)
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|old_bindings
expr_stmt|;
name|old_bindings
operator|=
name|binding
expr_stmt|;
name|skip_it
label|:
empty_stmt|;
block|}
return|return
name|old_bindings
return|;
block|}
end_function

begin_function
name|void
name|maybe_push_to_top_level
parameter_list|(
name|pseudo
parameter_list|)
name|int
name|pseudo
decl_stmt|;
block|{
specifier|extern
name|int
name|current_lang_stacksize
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|s
init|=
operator|(
expr|struct
name|saved_scope
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_scope
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|tree
name|old_bindings
init|=
name|NULL_TREE
decl_stmt|;
name|push_cp_function_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous_class_type
condition|)
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|previous_class_values
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Have to include global_binding_level, because class-level decls      aren't listed anywhere useful.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Template IDs are inserted into the global level. If they were 	 inserted into namespace level, finish_file wouldn't find them 	 when doing pending instantiations. Therefore, don't stop at 	 namespace level, but continue until :: .  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
operator|||
operator|(
name|pseudo
operator|&&
name|b
operator|->
name|pseudo_global
operator|)
condition|)
break|break;
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|b
operator|->
name|names
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* We also need to check class_shadowed to save class-level type 	 bindings, since pushclass doesn't fill in b->names.  */
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|b
operator|->
name|class_shadowed
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Unwind type-value slots back to top level.  */
for|for
control|(
name|t
operator|=
name|b
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|old_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
name|s
operator|->
name|old_namespace
operator|=
name|current_namespace
expr_stmt|;
name|s
operator|->
name|class_name
operator|=
name|current_class_name
expr_stmt|;
name|s
operator|->
name|class_type
operator|=
name|current_class_type
expr_stmt|;
name|s
operator|->
name|access_specifier
operator|=
name|current_access_specifier
expr_stmt|;
name|s
operator|->
name|function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|s
operator|->
name|class_bindings
operator|=
name|class_binding_level
expr_stmt|;
name|s
operator|->
name|lang_stack
operator|=
name|current_lang_stack
expr_stmt|;
name|s
operator|->
name|lang_base
operator|=
name|current_lang_base
expr_stmt|;
name|s
operator|->
name|lang_stacksize
operator|=
name|current_lang_stacksize
expr_stmt|;
name|s
operator|->
name|lang_name
operator|=
name|current_lang_name
expr_stmt|;
name|s
operator|->
name|minimal_parse_mode
operator|=
name|minimal_parse_mode
expr_stmt|;
name|s
operator|->
name|last_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|s
operator|->
name|template_parms
operator|=
name|current_template_parms
expr_stmt|;
name|s
operator|->
name|processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
name|s
operator|->
name|previous_class_type
operator|=
name|previous_class_type
expr_stmt|;
name|s
operator|->
name|previous_class_values
operator|=
name|previous_class_values
expr_stmt|;
name|s
operator|->
name|class_cache_firstobj
operator|=
name|class_cache_firstobj
expr_stmt|;
name|s
operator|->
name|processing_specialization
operator|=
name|processing_specialization
expr_stmt|;
name|s
operator|->
name|processing_explicit_instantiation
operator|=
name|processing_explicit_instantiation
expr_stmt|;
name|current_class_name
operator|=
name|current_class_type
operator|=
name|NULL_TREE
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
name|current_lang_stacksize
operator|=
literal|10
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_lang_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|shadowed_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|minimal_parse_mode
operator|=
literal|0
expr_stmt|;
name|previous_class_type
operator|=
name|previous_class_values
operator|=
name|NULL_TREE
expr_stmt|;
name|class_cache_firstobj
operator|=
literal|0
expr_stmt|;
name|processing_specialization
operator|=
literal|0
expr_stmt|;
name|processing_explicit_instantiation
operator|=
literal|0
expr_stmt|;
name|current_template_parms
operator|=
name|NULL_TREE
expr_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|current_namespace
operator|=
name|global_namespace
expr_stmt|;
name|s
operator|->
name|prev
operator|=
name|current_saved_scope
expr_stmt|;
name|s
operator|->
name|old_bindings
operator|=
name|old_bindings
expr_stmt|;
name|current_saved_scope
operator|=
name|s
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_to_top_level
parameter_list|()
block|{
name|maybe_push_to_top_level
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_from_top_level
parameter_list|()
block|{
specifier|extern
name|int
name|current_lang_stacksize
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|s
init|=
name|current_saved_scope
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Clear out class-level bindings cache.  */
if|if
condition|(
name|previous_class_type
condition|)
name|invalidate_class_lookup_cache
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|current_binding_level
operator|=
name|s
operator|->
name|old_binding_level
expr_stmt|;
name|current_saved_scope
operator|=
name|s
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|->
name|old_bindings
init|;
name|t
condition|;
control|)
block|{
name|tree
name|save
init|=
name|t
decl_stmt|;
name|tree
name|id
init|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|save
argument_list|)
operator|=
name|free_binding_vecs
expr_stmt|;
name|free_binding_vecs
operator|=
name|save
expr_stmt|;
block|}
name|current_namespace
operator|=
name|s
operator|->
name|old_namespace
expr_stmt|;
name|current_class_name
operator|=
name|s
operator|->
name|class_name
expr_stmt|;
name|current_class_type
operator|=
name|s
operator|->
name|class_type
expr_stmt|;
name|current_access_specifier
operator|=
name|s
operator|->
name|access_specifier
expr_stmt|;
name|current_function_decl
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
name|class_binding_level
operator|=
name|s
operator|->
name|class_bindings
expr_stmt|;
name|free
argument_list|(
name|current_lang_base
argument_list|)
expr_stmt|;
name|current_lang_base
operator|=
name|s
operator|->
name|lang_base
expr_stmt|;
name|current_lang_stack
operator|=
name|s
operator|->
name|lang_stack
expr_stmt|;
name|current_lang_name
operator|=
name|s
operator|->
name|lang_name
expr_stmt|;
name|current_lang_stacksize
operator|=
name|s
operator|->
name|lang_stacksize
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
name|minimal_parse_mode
operator|=
name|s
operator|->
name|minimal_parse_mode
expr_stmt|;
name|last_function_parms
operator|=
name|s
operator|->
name|last_function_parms
expr_stmt|;
name|current_template_parms
operator|=
name|s
operator|->
name|template_parms
expr_stmt|;
name|processing_template_decl
operator|=
name|s
operator|->
name|processing_template_decl
expr_stmt|;
name|previous_class_type
operator|=
name|s
operator|->
name|previous_class_type
expr_stmt|;
name|previous_class_values
operator|=
name|s
operator|->
name|previous_class_values
expr_stmt|;
name|processing_specialization
operator|=
name|s
operator|->
name|processing_specialization
expr_stmt|;
name|processing_explicit_instantiation
operator|=
name|s
operator|->
name|processing_explicit_instantiation
expr_stmt|;
name|class_cache_firstobj
operator|=
name|s
operator|->
name|class_cache_firstobj
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pop_cp_function_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition of struct, union or enum tag "name".    into binding_level "b".   "type" should be the type node,     We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be a NULL_TREE.     C++ gratuitously puts all these tags in the name space.  */
end_comment

begin_comment
comment|/* When setting the IDENTIFIER_TYPE_VALUE field of an identifier ID,    record the shadowed value for this binding contour.  TYPE is    the type that ID maps to.  */
end_comment

begin_function
specifier|static
name|void
name|set_identifier_type_value_with_scope
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|,
name|b
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|b
operator|->
name|namespace_p
condition|)
block|{
comment|/* Shadow the marker, not the real thing, so that the marker 	 gets restored later. */
name|tree
name|old_type_value
init|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|b
operator|->
name|type_shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_type_value
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|binding
init|=
name|binding_for_name
argument_list|(
name|id
argument_list|,
name|current_namespace
argument_list|)
decl_stmt|;
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Store marker instead of real type. */
name|type
operator|=
name|global_type_node
expr_stmt|;
block|}
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As set_identifier_type_value_with_scope, but using current_binding_level.  */
end_comment

begin_function
name|void
name|set_identifier_type_value
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|set_identifier_type_value_with_scope
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type associated with id. */
end_comment

begin_function
name|tree
name|identifier_type_value
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
comment|/* There is no type with that name, anywhere. */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* This is not the type marker, but the real thing. */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|!=
name|global_type_node
condition|)
return|return
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
return|;
comment|/* Have to search for it. It must be on the global level, now.      Ask lookup_name not to return non-types. */
name|id
operator|=
name|lookup_name_real
argument_list|(
name|id
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Pop off extraneous binding levels left over due to syntax errors.     We don't pop past namespaces, as they might be valid.  */
end_comment

begin_function
name|void
name|pop_everything
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX entering pop_everything ()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
else|else
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX leaving pop_everything ()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The type TYPE is being declared.  If it is a class template, or a    specialization of a class template, do any processing required and    perform error-checking.  If IS_FRIEND is non-zero, this TYPE is    being declared a friend.  B is the binding level at which this TYPE    should be bound.     Returns the TYPE_DECL for TYPE, which may have been altered by this    processing.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_process_template_type_declaration
parameter_list|(
name|type
parameter_list|,
name|globalize
parameter_list|,
name|b
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|globalize
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_parmlist
condition|)
comment|/* You can't declare a new template type in a template parameter        list.  But, you can declare a non-template type:                  template<class A*> struct S;                is a forward-declaration of `A'.  */
empty_stmt|;
else|else
block|{
name|maybe_check_template_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* If !GLOBALIZE then we are looking at a definition. 	     It may not be a primary template.  (For example, in: 		   	       template<class T> 	       struct S1 { class S2 {}; } 		   	     we have to push_template_decl for S2.)  */
operator|(
name|processing_template_decl
operator|&&
operator|!
name|globalize
operator|)
comment|/* If we are declaring a friend template class, we will 	     have GLOBALIZE set, since something like:  	       template<class T> 	       struct S1 { 		 template<class U> 		 friend class S2;  	       };  	     declares S2 to be at global scope.  */
operator|||
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
block|{
comment|/* This may change after the call to 	     push_template_decl_real, but we want the original value.  */
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
comment|/* If the current binding level is the binding level for the 	     template parameters (see the comment in 	     begin_template_parm_list) and the enclosing level is a class 	     scope, and we're not looking at a friend, push the 	     declaration of the member class into the class scope.  In the 	     friend case, push_template_decl will already have put the 	     friend into global scope, if appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
name|globalize
operator|&&
name|b
operator|->
name|pseudo_global
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|finish_member_declaration
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put this tag on the list of tags for the class, since 		 that won't happen below because B is not the class 		 binding level, but is instead the pseudo-global level.  */
name|b
operator|->
name|level_chain
operator|->
name|tags
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|level_chain
operator|->
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|level_chain
operator|->
name|tags
expr_stmt|;
block|}
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Push a tag name NAME for struct/class/union/enum type TYPE.    Normally put it into the inner-most non-tag-transparent scope,    but if GLOBALIZE is true, put it in the inner-most non-class scope.    The latter is needed for implicit declarations.  */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
operator|||
operator|(
name|globalize
operator|&&
name|b
operator|->
name|parm_flag
operator|==
literal|2
operator|)
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
name|b
operator|->
name|tags
operator|=
name|perm_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tags
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Do C++ gratuitous typedefing.  */
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|type
condition|)
block|{
specifier|register
name|tree
name|d
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|newdecl
init|=
literal|0
decl_stmt|,
name|in_class
init|=
literal|0
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|c_decl
init|=
name|NULL_TREE
decl_stmt|;
name|context
operator|=
name|type
condition|?
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|globalize
condition|)
name|context
operator|=
name|cs
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|cs
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
comment|/* When declaring a friend class of a local class, we want 		   to inject the newly named class into the scope 		   containing the local class, not the namespace scope.  */
name|context
operator|=
name|hack_decl_function_context
argument_list|(
name|get_type_decl
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
condition|)
name|c_decl
operator|=
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
name|context
else|:
name|TYPE_MAIN_DECL
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|current_namespace
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|->
name|pseudo_global
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|parm_flag
operator|==
literal|2
operator|)
operator|||
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|in_class
operator|=
literal|1
expr_stmt|;
else|else
name|d
operator|=
name|lookup_nested_type
argument_list|(
name|type
argument_list|,
name|c_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL_TREE
condition|)
block|{
name|newdecl
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_class
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|d
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|d
operator|=
name|maybe_process_template_type_declaration
argument_list|(
name|type
argument_list|,
name|globalize
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|newdecl
operator|&&
operator|!
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
comment|/* Put this TYPE_DECL on the TYPE_FIELDS list for the 		   class.  But if it's a member template class, we 		   want the TEMPLATE_DECL, not the TYPE_DECL, so this 		   is done later.  */
name|finish_member_declaration
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdecl
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|tags
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Use the canonical TYPE_DECL for this node.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE 	 will be the tagged type we just added to the current 	 binding level.  This fake NULL-named TYPE_DECL node helps 	 dwarfout.c to know when it needs to output a 	 representation of a tagged type, and it also gives us a 	 convenient place to record the "scope start" address for 	 the tagged type.  */
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Counter used to create anonymous type names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|anon_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an IDENTIFIER which can be used as a name for    anonymous structs and unions.  */
end_comment

begin_function
name|tree
name|make_anon_name
parameter_list|()
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_AGGRNAME_FORMAT
argument_list|,
name|anon_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the TREE_PURPOSE slot of tags which have anonymous typenames.    This keeps dbxout from getting confused.  */
end_comment

begin_function
name|void
name|clear_anon_tags
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
specifier|register
name|tree
name|tags
decl_stmt|;
specifier|static
name|int
name|last_cnt
init|=
literal|0
decl_stmt|;
comment|/* Fast out if no new anon names were declared.  */
if|if
condition|(
name|last_cnt
operator|==
name|anon_cnt
condition|)
return|return;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|tags
operator|=
name|b
operator|->
name|tags
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
comment|/* A NULL purpose means we have already processed all tags 	 from here to the end of the list.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
name|last_cnt
operator|=
name|anon_cnt
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of duplicate_decls: return truthvalue of whether    or not types of these decls match.     For C++, we must compare the parameter list so that `int' can match    `int&' in a parameter position, but `int&' is not confused with    `const int&'.  */
end_comment

begin_function
name|int
name|decls_match
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|int
name|types_match
decl_stmt|;
if|if
condition|(
name|newdecl
operator|==
name|olddecl
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* If the two DECLs are not even the same kind of thing, we're not        interested in their types.  */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|f1
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_REAL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_REAL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|lang_c
operator|)
condition|)
return|return
literal|0
return|;
comment|/* When we parse a static member function definition, 	 we put together a FUNCTION_DECL which thinks its type 	 is METHOD_TYPE.  Change that to FUNCTION_TYPE, and 	 proceed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|olddecl
argument_list|)
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|newdecl
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|olddecl
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
comment|/* Here we must take care of the case where new default 	 parameters are specified.  Also, warn if an old 	 declaration becomes ambiguous because default 	 parameters may cause the two to be ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|cp_compiler_error
argument_list|(
literal|"`%D' redeclared as member function"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|cp_compiler_error
argument_list|(
literal|"`%D' redeclared as non-member function"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strict_prototypes_lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|p2
operator|==
name|NULL_TREE
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|void_list_node
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strict_prototypes_lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|p1
operator|==
name|NULL_TREE
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
name|types_match
operator|=
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
name|types_match
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|types_match
operator|=
literal|1
expr_stmt|;
else|else
name|types_match
operator|=
name|decls_match
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
else|else
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|COMPARE_REDECLARATION
argument_list|)
expr_stmt|;
block|}
return|return
name|types_match
return|;
block|}
end_function

begin_comment
comment|/* If NEWDECL is `static' and an `extern' was seen previously,    warn about it.  (OLDDECL may be NULL_TREE; NAME contains    information about previous usage as an `extern'.)     Note that this does not apply to the C++ case of declaring    a variable `extern const' and then later `const'.     Don't complain about built-in functions, since they are beyond    the user's control.  */
end_comment

begin_function
specifier|static
name|void
name|warn_extern_redeclared_static
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|explicit_extern_static_warning
init|=
literal|"`%D' was declared `extern' and later `static'"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|implicit_extern_static_warning
init|=
literal|"`%D' was declared implicitly `extern' and later `static'"
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
name|DECL_THIS_STATIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* It's okay to redeclare an ANSI built-in function as static, 	 or to declare a non-ANSI built-in function as anything.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|olddecl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|?
name|implicit_extern_static_warning
else|:
name|explicit_extern_static_warning
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
operator|!=
name|NULL_TREE
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"previous declaration of `%D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL has the same name as an old    one OLDDECL in the same binding contour.  Prints an error message    if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|int
name|olddecl_friend
init|=
literal|0
decl_stmt|,
name|types_match
init|=
literal|0
decl_stmt|;
name|int
name|new_defines_function
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|newdecl
operator|==
name|olddecl
condition|)
return|return
literal|1
return|;
name|types_match
operator|=
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If either the type of the new decl or the type of the old decl is an      error_mark_node, then that implies that we have already issued an      error (earlier) for some bogus type specification, and in that case,      it is rather pointless to harass the user with yet more error message      about the same declaration, so just pretend the types match here.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
literal|1
expr_stmt|;
comment|/* Check for redeclaration and other discrepancies. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
comment|/* If you declare a built-in or predefined function name as static, 	 the old definition is overridden, but optionally warn this was a 	 bad choice of name.  Ditto for overloads.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|warn_shadow
condition|)
name|cp_warning
argument_list|(
literal|"shadowing %s function `%#D'"
argument_list|,
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|?
literal|"built-in"
else|:
literal|"library"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* If the built-in is not ansi, then programs can override 		 it even globally without an error.  */
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"library function `%#D' redeclared as non-function `%#D'"
argument_list|,
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"conflicts with built-in declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|cp_warning
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"conflicts with built-in declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We do nothing special here, because C++ does such nasty 	     things with TYPE_DECLs.  Instead, just let the TYPE_DECL 	     get shadowed, and know that if we need to find a TYPE_DECL 	     for a given name, we can look in the IDENTIFIER_TYPE_VALUE 	     slot of the identifier.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|cp_error
argument_list|(
literal|"`%#D' redeclared as different kind of symbol"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration of `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one => 	 tell caller to replace the old one.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
if|if
condition|(
name|DECL_REAL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_REAL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* These are certainly not duplicate declarations; they're 	   from different scopes.  */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* The name of a class template may not be declared to refer to 	     any other template, class, function, object, namespace, value, 	     or type in the same scope.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of template `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with previous declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"new declaration `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"ambiguates old declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|lang_c
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of C function `%#D' conflicts with"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration `%#D' here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"new declaration `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"ambiguates old declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* Already complained about this, so don't do so again.  */
elseif|else
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|cp_error
argument_list|(
literal|"conflicting types for `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration as `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_TI_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
comment|/* It's OK to have a template specialization and a non-template        with the same type, or to have specializations of two        different templates with the same type.  Note that if one is a        specialization, and the other is an instantiation of the same        template, that we do not exit at this point.  That situation        can occur if we instantiate a template class, and then        specialize one of its methods.  This situation is legal, but        the declarations must be merged in the usual way.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|||
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
comment|/* One of the declarations is a template instantiation, and the        other is not a template at all.  That's OK.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* Redeclaration of namespace alias, ignore it. */
return|return
literal|1
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|cp_error
argument_list|(
name|errmsg
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_error_at
argument_list|(
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|namespace_bindings_p
argument_list|()
operator|)
condition|?
literal|"`%#D' previously defined here"
else|:
literal|"`%#D' previously declared here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Prototype decl follows defn w/o prototype.  */
name|cp_warning_at
argument_list|(
literal|"prototype for `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"follows non-prototype definition here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* extern "C" int foo (); 	     int foo () { bar (); } 	     is OK.  */
if|if
condition|(
name|current_lang_stack
operator|==
name|current_lang_base
condition|)
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"previous declaration of `%#D' with %L linkage"
argument_list|,
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"conflicts with new declaration with %L linkage"
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|t1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t1
operator|&&
name|t1
operator|!=
name|void_list_node
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
literal|1
operator|==
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"default argument given for parameter %d of `%#D'"
argument_list|,
name|i
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"after previous specification in `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"default argument given for parameter %d of `%#D'"
argument_list|,
name|i
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"after previous specification in `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_THIS_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_THIS_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|warn_inline
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`%#D' was used before it was declared inline"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"previous non-inline declaration here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If new decl is `static' and an `extern' was seen previously,      warn about it.  */
name|warn_extern_redeclared_static
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* We have committed to returning 1 at this point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Now that functions must hold information normally held 	 by field decls, there is extra work to do so that 	 declaration information does not get destroyed during 	 definition.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_VINDEX
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|==
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
condition|)
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|new_defines_function
operator|=
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
comment|/* Optionally warn about more than one declaration for the same          name, but don't warn about a function declaration followed by a          definition.  */
if|if
condition|(
name|warn_redundant_decls
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|new_defines_function
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
operator|)
comment|/* Don't warn about extern decl followed by definition. */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
comment|/* Don't warn about friends, let add_friend take care of it. */
operator|&&
operator|!
name|DECL_FRIEND_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"redundant redeclaration of `%D' in same scope"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"previous declaration of `%D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deal with C++: must preserve virtual function table size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|register
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|newtype
operator|!=
name|error_mark_node
operator|&&
name|oldtype
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|newtype
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|oldtype
argument_list|)
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|newtype
argument_list|)
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|newtype
argument_list|)
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.  */
name|DECL_MACHINE_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
operator|=
name|merge_machine_decl_attributes
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|duplicate_decls
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"invalid redeclaration of %D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Automatically handles default parameters.  */
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
decl_stmt|;
comment|/* Make sure we put the new type in the same obstack as the old one.  */
if|if
condition|(
name|oldtype
condition|)
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Merge the data types specified in the two decls.  */
name|newtype
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Do this after calling `common_type' so that default 	 parameters don't confuse us.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pedantic
operator|||
operator|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|flag_exceptions
operator|&&
operator|!
name|compexcepttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"declaration of `%D' throws different exceptions"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"previous declaration here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
operator|(
name|processing_template_decl
operator|&&
name|uses_template_parms
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|!
operator|(
name|processing_template_decl
operator|&&
name|uses_template_parms
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_SAVED_TREE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the section attribute.          We want to issue an error if the sections conflict but that must be 	 done later in decl_attributes since we are called before attributes 	 are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Keep the old rtl since we can safely use it, unless it's the 	 call to abort() used for abstract virtuals.  */
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_RTL
argument_list|(
name|abort_fndecl
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
comment|/* Clean out any memory we had of the old declaration.  */
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|olddecl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
name|TREE_VALUE
argument_list|(
name|oldstatic
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
name|DECL_WEAK
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_WEAK
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_ONE_ONLY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INTERFACE_KNOWN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_COMDAT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't really know how much of the language-specific 	 values we should copy from old to new.  */
name|DECL_IN_AGGR_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_IN_AGGR_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ACCESS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ACCESS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NONCONVERTING_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_NONCONVERTING_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|olddecl_friend
operator|=
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Only functions have DECL_BEFRIENDING_CLASSES.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|newdecl
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If newdecl is not a specialization, then it is not a 	     template-related function at all.  And that means that we 	     shoud have exited above, returning 0.  */
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|newdecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* From [temp.expl.spec]: 	        	       If a template, a member template or the member of a class 	       template is explicitly specialized then that 	       specialization shall be declared before the first use of 	       that specialization that would cause an implicit 	       instantiation to take place, in every translation unit in 	       which such a use occurs.  */
name|cp_error
argument_list|(
literal|"explicit specialization of %D after first use"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
name|DECL_THIS_INLINE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If either decl says `inline', this fn is inline, unless its          definition was passed already.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|types_match
operator|||
name|new_defines_function
condition|)
block|{
comment|/* These need to be copied so that the names are available.  */
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_defines_function
condition|)
comment|/* If defining a function declared with other language 	   linkage, use the previously declared language linkage.  */
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If redeclaring a builtin function, and not a definition, 	     it stays built in.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If we're keeping the built-in definition, keep the rtl, 		 regardless of declaration matches.  */
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_FRAME_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FRAME_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
comment|/* Previously saved insns go together with 	       the function's previous definition.  */
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't clear out the arguments if we're redefining a function.  */
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_MAIN_VARIANT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|NAMESPACE_LEVEL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|NAMESPACE_LEVEL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Now preserve various other info from the definition.  */
name|TREE_ADDRESSABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_COMMON
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|function_size
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|ol
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|nl
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|function_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
name|function_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Can we safely free the storage used by newdecl?  */
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((x + obstack_alignment_mask (&permanent_obstack)) \& ~ obstack_alignment_mask (&permanent_obstack))
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If newdecl is a template instantiation, it is possible that 	     the following sequence of events has occurred:  	     o A friend function was declared in a class template.  The 	     class template was instantiated.    	     o The instantiation of the friend declaration was  	     recorded on the instantiation list, and is newdecl.    	     o Later, however, instantiate_class_template called pushdecl 	     on the newdecl to perform name injection.  But, pushdecl in 	     turn called duplicate_decls when it discovered that another 	     declaration of a global function with the same name already 	     existed.   	     o Here, in duplicate_decls, we decided to clobber newdecl.  	     If we're going to do that, we'd better make sure that 	     olddecl, and not newdecl, is on the list of 	     instantiations so that if we try to do the instantiation 	     again we won't get the clobbered declaration.  */
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|decls
init|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|decls
condition|;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
operator|==
name|newdecl
condition|)
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
operator|=
name|olddecl
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
name|ROUND
argument_list|(
name|function_size
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|nl
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
name|ROUND
argument_list|(
name|function_size
argument_list|)
operator|+
name|ROUND
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
operator|==
name|obstack_next_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
name|ROUND
argument_list|(
name|function_size
argument_list|)
operator|==
name|obstack_next_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
operator|)
condition|)
block|{
name|DECL_MAIN_VARIANT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|olddecl
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|ol
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LANG_DECL_PERMANENT
argument_list|(
name|ol
argument_list|)
operator|&&
name|ol
operator|!=
name|nl
condition|)
block|{
if|if
condition|(
name|DECL_MAIN_VARIANT
argument_list|(
name|olddecl
argument_list|)
operator|==
name|olddecl
condition|)
block|{
comment|/* Save these lang_decls that would otherwise be lost.  */
specifier|extern
name|tree
name|free_lang_decl_chain
decl_stmt|;
name|tree
name|free_lang_decl
init|=
operator|(
name|tree
operator|)
name|ol
decl_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|==
name|ol
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|free_lang_decl
argument_list|)
operator|=
name|free_lang_decl_chain
expr_stmt|;
name|free_lang_decl_chain
operator|=
name|free_lang_decl
expr_stmt|;
block|}
else|else
block|{
comment|/* Storage leak.  */
empty_stmt|;
block|}
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
if|if
condition|(
name|olddecl_friend
condition|)
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* NEWDECL contains the merged attribute lists.      Update OLDDECL to be the same.  */
name|DECL_MACHINE_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_MACHINE_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|need_new_binding
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Template parameters have no context; they are not X::T even        when declared within a class or namespace.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
comment|/* A local declaration for a function doesn't constitute              nesting.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|)
comment|/* Don't change DECL_CONTEXT of virtual methods.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
block|}
comment|/* Type are looked up using the DECL_NAME, as that is what the rest of the      compiler wants to use.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Not needed...see below.  */
block|char *file;       int line;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Namespace-scoped variables are not found in the current level. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|)
name|t
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
comment|/* error_mark_node is 0 for a while during initialization!  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"`%#D' used prior to declaration"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is turned off until I have time to do it right (bpk).  */
comment|/* With the code below that uses it...  */
block|file = DECL_SOURCE_FILE (t); 	  line = DECL_SOURCE_LINE (t);
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
comment|/* Check for duplicate params.  */
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|x
argument_list|)
operator|==
name|lang_c
operator|)
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Don't do anything just yet. */
empty_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|wchar_decl_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"redeclaration of wchar_t as `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Throw away the redeclaration.  */
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is turned off until I have time to do it right (bpk).  */
comment|/* Also warn if they did a prototype with `static' on it, but 		 then later left the `static' off.  */
block|if (! TREE_PUBLIC (name)&& TREE_PUBLIC (x)) 		{ 		  if (DECL_LANG_SPECIFIC (t)&& DECL_FRIEND_P (t)) 		    return t;  		  if (extra_warnings) 		    { 		      cp_warning ("`static' missing from declaration of `%D'", 				  t); 		      warning_with_file_and_line (file, line, 						  "previous declaration of `%s'", 						  decl_as_string (t, 0)); 		    }
comment|/* Now fix things so it'll do what they expect.  */
block|if (current_function_decl) 		    TREE_PUBLIC (current_function_decl) = 0; 		}
comment|/* Due to interference in memory reclamation (X may be 		 obstack-deallocated at this point), we must guard against 		 one really special case.  [jason: This should be handled 		 by start_function]  */
block|if (current_function_decl == x) 		current_function_decl = t;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|check_default_args
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* A redeclaration of main, but not a duplicate of the 		 previous one.   		 [basic.start.main]  	         This function shall not be overloaded.  */
name|cp_error_at
argument_list|(
literal|"invalid redeclaration of `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"as `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* We don't try to push this declaration since that 		 causes a crash.  */
return|return
name|x
return|;
block|}
block|}
name|check_template_shadow
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a function conjured up by the backend, massage it 	 so it looks friendly.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|retrofit_lang_decl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|DECL_LANGUAGE
argument_list|(
name|x
argument_list|)
operator|=
name|lang_c
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|x
operator|||
name|DECL_LANGUAGE
argument_list|(
name|x
argument_list|)
operator|==
name|lang_c
condition|)
return|return
name|t
return|;
if|if
condition|(
operator|!
name|namespace_bindings_p
argument_list|()
condition|)
comment|/* We do not need to create a binding for this name; 	       push_overloaded_decl will have already done so if 	       necessary.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_GLOBAL
argument_list|)
return|;
comment|/* If declaring a type as a typedef, copy the type (unless we're 	 at line 0), and install this TYPE_DECL as the new type's typedef 	 name.  See the extensive comment in ../c-decl.c (pushdecl). */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|x
comment|/* We don't want to copy the type when all we're 		      doing is making a TYPE_DECL for the purposes of 		      inlining.  */
operator|&&
operator|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|type
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
block|}
comment|/* Multiple external decls of the same identifier ought to match.  	 We get warnings about inline functions where they are defined. 	 We get warnings about other functions from push_overloaded_decl. 	  	 Avoid duplicate warnings where they are used.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
condition|)
name|decl
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
comment|/* If different sort of thing, we already gave an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"type mismatch with previous external decl"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"previous external decl of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|namespace_bindings_p
argument_list|()
condition|)
block|{
comment|/* Install a global value.  */
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|my_friendly_assert
argument_list|(
operator|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|x
operator|)
argument_list|,
literal|378
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
condition|)
name|cp_warning
argument_list|(
literal|"`%D' was previously implicitly declared to return `int'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If new decl is `static' and an `extern' was seen previously, 	     warn about it.  */
if|if
condition|(
name|x
operator|!=
name|NULL_TREE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
name|warn_extern_redeclared_static
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_new_binding
condition|)
block|{
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Because push_local_binding will hook X on to the 		 current_binding_level's name list, we don't want to 		 do that again below.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a TYPE_DECL, push it into the type value slot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
comment|/* Clear out any TYPE_DECL shadowed by a namespace so that 	     we won't think this is a type.  The C struct hack doesn't 	     go through namespaces.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
name|decls_match
argument_list|(
name|x
argument_list|,
name|oldglobal
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
name|cp_warning
argument_list|(
literal|"extern declaration of `%#D' doesn't match"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"global declaration `%#D'"
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|oldglobal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Inline decls shadow nothing.  */
empty_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
comment|/* Don't complain if it's from an enclosing function.  */
operator|&&
name|DECL_CONTEXT
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* Go to where the parms should be and see if we 		 find them there.  */
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
if|if
condition|(
name|cleanup_label
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
comment|/* ARM $8.3 */
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|1
condition|)
name|cp_error
argument_list|(
literal|"declaration of `%#D' shadows a parameter"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
name|current_binding_level
operator|->
name|is_for_scope
operator|&&
operator|!
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|oldlocal
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"variable `%s' shadows local"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  this is the shadowed declaration"
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|warnstring
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a parameter"
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|current_class_ptr
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|name
argument_list|)
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a member of `this'"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows previous local"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldglobal
operator|!=
name|NULL_TREE
condition|)
comment|/* XXX shadow warnings in outer-more namespaces */
name|warnstring
operator|=
literal|"declaration of `%s' shadows global declaration"
expr_stmt|;
if|if
condition|(
name|warnstring
condition|)
name|warning
argument_list|(
name|warnstring
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|check_default_args
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Keep count of variables in this level with incomplete type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ARRAY_TYPE
argument_list|)
operator|)
comment|/* RTTI TD entries are created while defining the type_info.  */
operator|||
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|current_binding_level
operator|->
name|incomplete
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|current_binding_level
operator|->
name|incomplete
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_new_binding
condition|)
block|{
comment|/* Put decls on list in reverse order. 	 We will reverse them later if necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|x
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|124
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the    caller to set DECL_CONTEXT properly.  */
end_comment

begin_function
specifier|static
name|tree
name|pushdecl_with_scope
parameter_list|(
name|x
parameter_list|,
name|level
parameter_list|)
name|tree
name|x
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|function_decl
init|=
name|current_function_decl
decl_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|b
operator|=
name|class_binding_level
expr_stmt|;
name|class_binding_level
operator|=
name|level
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|level
expr_stmt|;
name|x
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|function_decl
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the current namespace,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_namespace_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|pushdecl_with_scope
argument_list|(
name|x
argument_list|,
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, the type_shadowed stack may screw us.  Munge it so it does      what we want.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|newval
decl_stmt|;
name|tree
modifier|*
name|ptr
init|=
operator|(
name|tree
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
init|;
name|b
operator|!=
name|global_binding_level
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|shadowed
init|=
name|b
operator|->
name|type_shadowed
decl_stmt|;
for|for
control|(
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|name
condition|)
block|{
name|ptr
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
comment|/* Can't break out of the loop here because sometimes 		   a binding level will have duplicate bindings for 		   PT names.  It's gross, but I haven't time to fix it.  */
block|}
block|}
name|newval
operator|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|tree
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* @@ This shouldn't be needed.  My test case "zstring.cc" trips              up here if this is changed to an assertion.  --KR  */
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|=
name|newval
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|cur_namespace
init|=
name|current_namespace
decl_stmt|;
name|current_namespace
operator|=
name|global_namespace
expr_stmt|;
name|x
operator|=
name|pushdecl_namespace_level
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_namespace
operator|=
name|cur_namespace
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Make the declaration of X appear in CLASS scope.  */
end_comment

begin_function
name|void
name|pushdecl_class_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* Don't use DECL_ASSEMBLER_NAME here!  Everything that looks in class      scope looks for the pre-mangled name.  */
specifier|register
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|x
operator|=
name|OVL_CURRENT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ANON_UNION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
name|pushdecl_class_level
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This function is used to push the mangled decls for nested types into    the appropriate scope.  Previously pushdecl_top_level was used, but that    is incorrect for members of local classes.  */
end_comment

begin_if
unit|void pushdecl_nonclass_level (x)      tree x; {   struct binding_level *b = current_binding_level;    my_friendly_assert (b->parm_flag != 2, 180);
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Get out of template binding levels */
end_comment

begin_endif
unit|while (b->pseudo_global)     b = b->level_chain;
endif|#
directive|endif
end_endif

begin_endif
unit|pushdecl_with_scope (x, b); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make the declaration(s) of X appear in CLASS scope    under the name NAME.  */
end_comment

begin_function
name|void
name|push_class_level_binding
parameter_list|(
name|name
parameter_list|,
name|x
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|binding
decl_stmt|;
comment|/* The class_binding_level will be NULL if x is a template       parameter name in a member template.  */
if|if
condition|(
operator|!
name|class_binding_level
condition|)
return|return;
comment|/* Make sure that this new member does not have the same name      as a template parameter.  */
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|check_template_shadow
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this declaration shadows a declaration from an enclosing      class, then we will need to restore IDENTIFIER_CLASS_VALUE when      we leave this class.  Record the shadowed declaration here.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|)
operator|||
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|)
condition|)
block|{
name|tree
name|shadow
decl_stmt|;
name|tree
name|old_decl
decl_stmt|;
comment|/* If the old binding was from a base class, and was for a tag 	 name, slide it over to make room for the new binding.  The 	 old binding is still visible if explicitly qualified with a 	 class-key.  */
if|if
condition|(
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|&&
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|old_decl
operator|=
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|old_decl
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
comment|/* There was already a binding for X containing fewer 	 functions than are named in X.  Find the previous 	 declaration of X on the class-shadowed list, and update it.  */
for|for
control|(
name|shadow
operator|=
name|class_binding_level
operator|->
name|class_shadowed
init|;
name|shadow
condition|;
name|shadow
operator|=
name|TREE_CHAIN
argument_list|(
name|shadow
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadow
argument_list|)
operator|==
name|name
operator|&&
name|TREE_TYPE
argument_list|(
name|shadow
argument_list|)
operator|==
name|old_decl
condition|)
block|{
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|x
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|shadow
argument_list|)
operator|=
name|x
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we didn't replace an existing binding, put the binding on the      stack of bindings for the identifier, and update      IDENTIFIER_CLASS_VALUE.  */
if|if
condition|(
name|push_class_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|push_cache_obstack
argument_list|()
expr_stmt|;
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Record the value we are binding NAME to so that we can know 	 what to pop later.  */
name|TREE_TYPE
argument_list|(
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert another USING_DECL into the current binding level,    returning this declaration. If this is a redeclaration,    do nothing and return NULL_TREE.  */
end_comment

begin_function
name|tree
name|push_using_decl
parameter_list|(
name|scope
parameter_list|,
name|name
parameter_list|)
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|383
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|384
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|usings
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|scope
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|name
condition|)
break|break;
if|if
condition|(
name|decl
condition|)
return|return
name|NULL_TREE
return|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|USING_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|scope
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_binding_level
operator|->
name|usings
expr_stmt|;
name|current_binding_level
operator|->
name|usings
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Add namespace to using_directives. Return NULL_TREE if nothing was    changed (i.e. there was already a directive), or the fresh    TREE_LIST otherwise.  */
end_comment

begin_function
name|tree
name|push_using_directive
parameter_list|(
name|used
parameter_list|)
name|tree
name|used
decl_stmt|;
block|{
name|tree
name|ud
init|=
name|current_binding_level
operator|->
name|using_directives
decl_stmt|;
name|tree
name|iter
decl_stmt|,
name|ancestor
decl_stmt|;
comment|/* Check if we already have this. */
if|if
condition|(
name|purpose_member
argument_list|(
name|used
argument_list|,
name|ud
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Recursively add all namespaces used. */
for|for
control|(
name|iter
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|used
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
name|push_using_directive
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|ancestor
operator|=
name|namespace_ancestor
argument_list|(
name|current_decl_namespace
argument_list|()
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ud
operator|=
name|current_binding_level
operator|->
name|using_directives
expr_stmt|;
name|ud
operator|=
name|perm_tree_cons
argument_list|(
name|used
argument_list|,
name|ancestor
argument_list|,
name|ud
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|using_directives
operator|=
name|ud
expr_stmt|;
return|return
name|ud
return|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL for a non-member function, which may have    other definitions already in place.  We get around this by making    the value of the identifier point to a list of all the things that    want to be referenced by that name.  It is then up to the users of    that name to decide what to do with that list.     DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its DECL_RESULT    slot.  It is dealt with the same way.     FLAGS is a bitwise-or of the following values:      PUSH_LOCAL: Bind DECL in the current scope, rather than at                  namespace scope.      PUSH_USING: DECL is being pushed as the result of a using                  declaration.      The value returned may be a previous declaration if we guessed wrong    about what language DECL should belong to (C or C++).  Otherwise,    it's always DECL (and never something that's not a _DECL).  */
end_comment

begin_function
name|tree
name|push_overloaded_decl
parameter_list|(
name|decl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|old
decl_stmt|;
name|tree
name|new_binding
decl_stmt|;
name|int
name|doing_global
init|=
operator|(
name|namespace_bindings_p
argument_list|()
operator|||
operator|!
operator|(
name|flags
operator|&
name|PUSH_LOCAL
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|doing_global
condition|)
block|{
name|old
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|old
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|old
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|old
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
condition|)
return|return
name|old
return|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
else|else
name|old
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|warn_shadow
operator|&&
operator|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|old
argument_list|)
operator|)
condition|)
name|cp_warning
argument_list|(
literal|"`%#D' hides constructor for `%#T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|old
init|;
name|tmp
condition|;
name|tmp
operator|=
name|OVL_NEXT
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|OVL_USED
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"`%#D' conflicts with previous using declaration `%#D'"
argument_list|,
name|decl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
block|}
else|else
block|{
name|cp_error_at
argument_list|(
literal|"previous non-function declaration `%#D'"
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"conflicts with function declaration `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
if|if
condition|(
name|old
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|ovl_cons
argument_list|(
name|old
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PUSH_USING
condition|)
name|OVL_USED
argument_list|(
name|new_binding
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* NAME is not ambiguous.  */
name|new_binding
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|set_namespace_binding
argument_list|(
name|name
argument_list|,
name|current_namespace
argument_list|,
name|new_binding
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We only create an OVERLOAD if there was a previous binding at 	 this level, or if decl is a template. In the former case, we 	 need to remove the old binding and replace it with the new 	 binding.  We must also run through the NAMES on the binding 	 level where the name was bound to update the chain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_binding
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|old
condition|)
block|{
name|tree
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|BINDING_LEVEL
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
operator|->
name|names
init|;
operator|*
name|d
condition|;
name|d
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
control|)
if|if
condition|(
operator|*
name|d
operator|==
name|old
operator|||
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|old
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* Just replace the old binding with the new.  */
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|=
name|new_binding
expr_stmt|;
else|else
comment|/* Build a TREE_LIST to wrap the OVERLOAD.  */
operator|*
name|d
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|new_binding
argument_list|)
expr_stmt|;
comment|/* And update the CPLUS_BINDING node.  */
name|BINDING_VALUE
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
operator|=
name|new_binding
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* We should always find a previous binding in this case.  */
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Install the new binding.  */
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|new_binding
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
comment|/* Save the decl permanently so we can warn if definition follows.      In ANSI C, warn_implicit is usually false, so the saves little space.      But in C++, it's usually true, hence the extra code.  */
if|if
condition|(
name|temp
operator|&&
operator|(
operator|!
name|warn_implicit
operator|||
name|toplevel_bindings_p
argument_list|()
operator|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ANSI standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_implicit
comment|/* Only one warning per identifier.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"implicit declaration of function `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Because C++ can put things into name space for free, 	 constructs like "typedef struct foo { ... } foo" 	 would look like an erroneous redeclaration.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|"redefinition of `%#D'"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If this is a pure function, its olddecl will actually be 	 the original initialization to `0' (which we force to call 	 abort()).  Don't complain about redefinition in this case.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If both functions come from different namespaces, this is not 	 a redeclaration - this is a conflict with a used function. */
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"`%D' conflicts with used function"
return|;
comment|/* We'll complain about linkage mismatches in          warn_extern_redeclared_static.  */
comment|/* Defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|"`%#D' not declared in class"
return|;
else|else
return|return
literal|"redefinition of `%#D'"
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|"redefinition of `%#D'"
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject two definitions.  */
return|return
literal|"redefinition of `%#D'"
return|;
block|}
else|else
block|{
comment|/* Objects declared with block scope:  */
comment|/* Reject two definitions, and reject a definition 	 together with an external reference.  */
if|if
condition|(
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|"redeclaration of `%#D'"
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier ID as a label.    Create one if none exists so far for the current function.    This function is called for both label definitions and label references.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"label `%s' referenced outside of any function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|named_label_uses
operator|==
name|NULL
operator|||
name|named_label_uses
operator|->
name|names_in_scope
operator|!=
name|current_binding_level
operator|->
name|names
operator|||
name|named_label_uses
operator|->
name|label_decl
operator|!=
name|decl
operator|)
condition|)
block|{
name|struct
name|named_label_list
modifier|*
name|new_ent
decl_stmt|;
name|new_ent
operator|=
operator|(
expr|struct
name|named_label_list
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|named_label_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_ent
operator|->
name|label_decl
operator|=
name|decl
expr_stmt|;
name|new_ent
operator|->
name|names_in_scope
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|new_ent
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|new_ent
operator|->
name|lineno_o_goto
operator|=
name|lineno
expr_stmt|;
name|new_ent
operator|->
name|filename_o_goto
operator|=
name|input_filename
expr_stmt|;
name|new_ent
operator|->
name|next
operator|=
name|named_label_uses
expr_stmt|;
name|named_label_uses
operator|=
name|new_ent
expr_stmt|;
block|}
comment|/* Use a label already defined or ref'd with this name.  */
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* But not if it is inherited and wasn't declared to be inheritable.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
operator|&&
operator|!
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|shadow_label
argument_list|(
name|id
argument_list|)
return|;
return|return
name|decl
return|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Make sure every label has an rtx.  */
name|label_rtx
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* A label not explicitly declared must be local to where it's ref'd.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Say where one reference is to the label,      for the sake of the error if it is not defined.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|named_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|named_labels
argument_list|)
expr_stmt|;
name|named_label_uses
operator|->
name|label_decl
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Make a label named NAME in the current function,    shadowing silently any that may be inherited from containing functions    or containing scopes.     Note that valid use, if the label being shadowed    comes from another scope in the same function,    requires calling declare_nonlocal_label right away.  */
end_comment

begin_function
name|tree
name|shadow_label
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup_label
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|minimal_parse_mode
condition|)
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|add_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
name|decl
operator|=
name|lookup_label
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
comment|/* If label with this name is known from an outer context, shadow it.  */
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lookup_label
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|get_identifier
argument_list|(
literal|"wchar_t"
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"label named wchar_t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"duplicate label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|struct
name|named_label_list
modifier|*
name|uses
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|identified
init|=
literal|0
decl_stmt|;
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Say where in the source.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|uses
operator|=
name|named_label_uses
expr_stmt|;
while|while
condition|(
name|uses
operator|!=
name|NULL
condition|)
if|if
condition|(
name|uses
operator|->
name|label_decl
operator|==
name|decl
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|b
condition|)
block|{
name|tree
name|new_decls
init|=
name|b
operator|->
name|names
decl_stmt|;
name|tree
name|old_decls
init|=
operator|(
name|b
operator|==
name|uses
operator|->
name|binding_level
operator|)
condition|?
name|uses
operator|->
name|names_in_scope
else|:
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|new_decls
operator|!=
name|old_decls
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_decls
argument_list|)
operator|==
name|VAR_DECL
comment|/* Don't complain about crossing initialization 			   of internal entities.  They can't be accessed, 			   and they should be cleaned up 			   by the time we get to the label.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|new_decls
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|pod_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decls
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* This is really only important if we're crossing 			   an initialization.  The POD stuff is just 			   pedantry; why should it matter if the class 			   contains a field of pointer to member type?  */
name|int
name|problem
init|=
operator|(
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|||
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decls
argument_list|)
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|identified
condition|)
block|{
if|if
condition|(
name|problem
condition|)
block|{
name|cp_error
argument_list|(
literal|"jump to label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|uses
operator|->
name|filename_o_goto
argument_list|,
name|uses
operator|->
name|lineno_o_goto
argument_list|,
literal|"  from here"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_pedwarn
argument_list|(
literal|"jump to label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|pedwarn_with_file_and_line
argument_list|(
name|uses
operator|->
name|filename_o_goto
argument_list|,
name|uses
operator|->
name|lineno_o_goto
argument_list|,
literal|"  from here"
argument_list|)
expr_stmt|;
block|}
name|identified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|problem
condition|)
name|cp_error_at
argument_list|(
literal|"  crosses initialization of `%#D'"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn_at
argument_list|(
literal|"  enters scope of non-POD `%#D'"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
block|}
name|new_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|new_decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
name|uses
operator|->
name|binding_level
condition|)
break|break;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|uses
operator|->
name|next
expr_stmt|;
else|else
name|named_label_uses
operator|=
name|uses
operator|->
name|next
expr_stmt|;
name|uses
operator|=
name|uses
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|uses
expr_stmt|;
name|uses
operator|=
name|uses
operator|->
name|next
expr_stmt|;
block|}
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|cp_switch
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
name|struct
name|cp_switch
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cp_switch
modifier|*
name|switch_stack
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_switch
parameter_list|()
block|{
name|struct
name|cp_switch
modifier|*
name|p
init|=
operator|(
expr|struct
name|cp_switch
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cp_switch
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|level
operator|=
name|current_binding_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|switch_stack
expr_stmt|;
name|switch_stack
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_switch
parameter_list|()
block|{
name|switch_stack
operator|=
name|switch_stack
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same, but for CASE labels.  If DECL is NULL_TREE, it's the default.  */
end_comment

begin_comment
comment|/* XXX Note decl is never actually used. (bpk) */
end_comment

begin_function
name|void
name|define_case_label
parameter_list|()
block|{
name|tree
name|cleanup
init|=
name|last_cleanup_this_contour
argument_list|()
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|int
name|identified
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cleanup
condition|)
block|{
specifier|static
name|int
name|explained
init|=
literal|0
decl_stmt|;
name|cp_warning_at
argument_list|(
literal|"destructor needed for `%#D'"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"where case label appears here"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|warning
argument_list|(
literal|"(enclose actions of previous case statements requiring"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"destructors in their own binding contours.)"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|b
operator|&&
name|b
operator|!=
name|switch_stack
operator|->
name|level
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|new_decls
init|=
name|b
operator|->
name|names
decl_stmt|;
for|for
control|(
init|;
name|new_decls
condition|;
name|new_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|new_decls
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_decls
argument_list|)
operator|==
name|VAR_DECL
comment|/* Don't complain about crossing initialization 		 of internal entities.  They can't be accessed, 		 and they should be cleaned up 		 by the time we get to the label.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|new_decls
argument_list|)
operator|&&
operator|(
operator|(
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decls
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|identified
condition|)
name|error
argument_list|(
literal|"jump to case label"
argument_list|)
expr_stmt|;
name|identified
operator|=
literal|1
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  crosses initialization of `%#D'"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    FORM says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, and it's not a template, an error is    reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|form
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|form
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
comment|/* Non-zero if, we should look past a pseudo-global level, even if      THISLEVEL_ONLY.  */
name|int
name|allow_pseudo_global
init|=
literal|1
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
comment|/* There's no need for error checking here, because 	       anon names are unique throughout the compilation.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|level
operator|->
name|namespace_p
condition|)
comment|/* Do namespace lookup. */
for|for
control|(
name|tail
operator|=
name|current_namespace
init|;
literal|1
condition|;
name|tail
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|tree
name|old
init|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|tail
argument_list|)
decl_stmt|;
comment|/* If we just skipped past a pseudo global level, even 	       though THISLEVEL_ONLY, and we find a template class 	       declaration, then we use the _TYPE node for the 	       template.  See the example below.  */
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|allow_pseudo_global
operator|&&
name|old
operator|&&
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
name|old
operator|=
name|TREE_TYPE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
name|BINDING_TYPE
argument_list|(
name|old
argument_list|)
expr_stmt|;
comment|/* If it has an original type, it is a typedef, and we 	       should not return it.  */
if|if
condition|(
name|old
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
name|old
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|form
operator|&&
operator|!
operator|(
name|form
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%#D' redeclared as %C"
argument_list|,
name|old
argument_list|,
name|form
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|old
condition|)
return|return
name|old
return|;
if|if
condition|(
name|thislevel_only
operator|||
name|tail
operator|==
name|global_namespace
condition|)
return|return
name|NULL_TREE
return|;
block|}
else|else
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Should tighten this up; it'll probably permit 		   UNION_TYPE and a struct template, for example.  */
if|if
condition|(
name|code
operator|!=
name|form
operator|&&
operator|!
operator|(
name|form
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|code
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|cp_error
argument_list|(
literal|"`%#D' redeclared as %C"
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|level
operator|->
name|tag_transparent
condition|)
block|{
if|if
condition|(
name|level
operator|->
name|pseudo_global
operator|&&
name|allow_pseudo_global
condition|)
block|{
comment|/* We must deal with cases like this: 		  	           template<class T> struct S; 		   template<class T> struct S {}; 		    		 When looking up `S', for the second declaration, we 		 would like to find the first declaration.  But, we 		 are in the pseudo-global level created for the 		 template parameters, rather than the (surrounding) 		 namespace level.  Thus, we keep going one more level, 		 even though THISLEVEL_ONLY is non-zero.  */
name|allow_pseudo_global
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|current_class_type
operator|&&
name|level
operator|->
name|level_chain
operator|->
name|namespace_p
condition|)
block|{
comment|/* Try looking in this class's tags before heading into 	     global binding level.  */
name|tree
name|context
init|=
name|current_class_type
decl_stmt|;
while|while
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|these_tags
decl_stmt|;
case|case
literal|'t'
case|:
name|these_tags
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
while|while
condition|(
name|these_tags
condition|)
block|{
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_tags
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
name|these_tags
operator|=
name|TREE_CHAIN
argument_list|(
name|these_tags
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|these_tags
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|these_tags
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_tags
argument_list|)
argument_list|)
operator|!=
name|form
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%#D' redeclared as %C in class scope"
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
name|these_tags
operator|=
name|TREE_CHAIN
argument_list|(
name|these_tags
argument_list|)
expr_stmt|;
block|}
comment|/* If this type is not yet complete, then don't 		       look at its context.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|no_context
goto|;
comment|/* Go to next enclosing type, if any.  */
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
continue|continue;
name|no_context
label|:
break|break;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void set_current_level_tags_transparency (tags_transparent)      int tags_transparent; {   current_binding_level->tag_transparent = tags_transparent; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  However, the value can never be 0    in the cases in which this is used.     C++: If NAME is non-zero, this is the new name to install.  This is    done when replacing anonymous tags with real tag names.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lookup TYPE in CONTEXT (a chain of nested types or a FUNCTION_DECL).    Return the type value, or NULL_TREE if not found.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_nested_type
parameter_list|(
name|type
parameter_list|,
name|context
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|context
decl_stmt|;
block|{
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
while|while
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|tree
name|match
init|=
name|value_member
argument_list|(
name|type
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|match
argument_list|)
return|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* When we have a nested class whose member functions have 	       local types (e.g., a set of enums), we'll arrive here 	       with the DECL_CONTEXT as the actual RECORD_TYPE node for 	       the enclosing class.  Instead, we want to make sure we 	       come back in here with the TYPE_DECL, not the RECORD_TYPE.  */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|context
operator|=
name|TREE_CHAIN
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|lookup_name
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the NAMESPACE.  */
end_comment

begin_function
name|tree
name|lookup_namespace_name
parameter_list|(
name|namespace
parameter_list|,
name|name
parameter_list|)
name|tree
name|namespace
decl_stmt|,
name|name
decl_stmt|;
block|{
name|struct
name|tree_binding
name|_b
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|370
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
comment|/* This happens for A::B<int> when B is a namespace. */
return|return
name|name
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This happens for A::B where B is a template, and there are no 	 template arguments.  */
name|cp_error
argument_list|(
literal|"invalid use of `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|373
argument_list|)
expr_stmt|;
name|val
operator|=
name|binding_init
argument_list|(
operator|&
name|_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|namespace
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|val
operator|=
name|BINDING_VALUE
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* If we have a single function from a using decl, pull it out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|OVL_FUNCTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|cp_error
argument_list|(
literal|"`%D' undeclared in namespace `%D'"
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|typename_hash
parameter_list|(
name|k
parameter_list|)
name|hash_table_key
name|k
decl_stmt|;
block|{
name|unsigned
name|long
name|hash
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|k
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|)
operator|^
operator|(
operator|(
name|unsigned
name|long
operator|)
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */
end_comment

begin_function
specifier|static
name|boolean
name|typename_compare
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|)
name|hash_table_key
name|k1
decl_stmt|;
name|hash_table_key
name|k2
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
name|tree
name|d1
decl_stmt|;
name|tree
name|d2
decl_stmt|;
name|t1
operator|=
operator|(
name|tree
operator|)
name|k1
expr_stmt|;
name|t2
operator|=
operator|(
name|tree
operator|)
name|k2
expr_stmt|;
name|d1
operator|=
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
expr_stmt|;
return|return
operator|(
name|DECL_NAME
argument_list|(
name|d1
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|d2
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|==
operator|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is    the type of `T', NAME is the IDENTIFIER_NODE for `t'.  If BASE_TYPE    is non-NULL, this type is being created by the implicit typename    extension, and BASE_TYPE is a type named `t' in some base class of    `T' which depends on template parameters.       Returns the new TYPENAME_TYPE.  */
end_comment

begin_function
name|tree
name|build_typename_type
parameter_list|(
name|context
parameter_list|,
name|name
parameter_list|,
name|fullname
parameter_list|,
name|base_type
parameter_list|)
name|tree
name|context
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|fullname
decl_stmt|;
name|tree
name|base_type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|d
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|e
decl_stmt|;
specifier|static
name|struct
name|hash_table
name|ht
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ht
operator|.
name|table
operator|&&
operator|!
name|hash_table_init
argument_list|(
operator|&
name|ht
argument_list|,
operator|&
name|hash_newfunc
argument_list|,
operator|&
name|typename_hash
argument_list|,
operator|&
name|typename_compare
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
comment|/* The FULLNAME needs to exist for the life of the hash table, i.e.,      for the entire compilation.  */
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|fullname
argument_list|)
condition|)
name|fullname
operator|=
name|copy_to_permanent
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
comment|/* Build the TYPENAME_TYPE.  */
name|t
operator|=
name|make_lang_type
argument_list|(
name|TYPENAME_TYPE
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
operator|=
name|fullname
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|base_type
expr_stmt|;
comment|/* Build the corresponding TYPE_DECL.  */
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* See if we already have this type.  */
name|e
operator|=
name|hash_lookup
argument_list|(
operator|&
name|ht
argument_list|,
name|t
argument_list|,
comment|/*create=*/
name|false
argument_list|,
comment|/*copy=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
comment|/* This will free not only TREE_TYPE, but the lang-specific data 	 and the TYPE_DECL as well.  */
name|obstack_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|e
operator|->
name|key
expr_stmt|;
block|}
else|else
comment|/* Insert the type into the table.  */
name|hash_lookup
argument_list|(
operator|&
name|ht
argument_list|,
name|t
argument_list|,
comment|/*create=*/
name|true
argument_list|,
comment|/*copy=*/
literal|0
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|make_typename_type
parameter_list|(
name|context
parameter_list|,
name|name
parameter_list|)
name|tree
name|context
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|fullname
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|name
argument_list|)
operator|||
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|name
argument_list|)
operator|)
operator|)
condition|)
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* Create a TEMPLATE_ID_EXPR for the type.  */
name|name
operator|=
name|build_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|name
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|fullname
argument_list|,
literal|0
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|my_friendly_abort
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
comment|/* We can get here from typename_sub0 in the explicit_template_type 	 expansion.  Just fail.  */
name|cp_error
argument_list|(
literal|"no class template named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|context
argument_list|)
operator|||
name|currently_open_class
argument_list|(
name|context
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fullname
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
name|tmpl
operator|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpl
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"no class template named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|lookup_template_class
argument_list|(
name|tmpl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fullname
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|context
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
name|t
operator|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"no type named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|t
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
comment|/* If the CONTEXT is not a template type, then either the field is      there now or its never going to be.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|context
argument_list|)
operator|&&
operator|!
name|t
condition|)
block|{
name|cp_error
argument_list|(
literal|"no type named `%#T' in `%#T'"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_typename_type
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
name|fullname
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Select the right _DECL from multiple choices. */
end_comment

begin_function
specifier|static
name|tree
name|select_decl
parameter_list|(
name|binding
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binding
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
name|val
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
block|{
comment|/* We are not interested in types. */
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|val
return|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* If we could have a type and      we have nothing or we need a type and have none.  */
if|if
condition|(
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|&&
operator|(
operator|!
name|val
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|)
condition|)
name|val
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't return non-types if we really prefer types. */
elseif|else
if|if
condition|(
name|val
operator|&&
name|LOOKUP_TYPES_ONLY
argument_list|(
name|flags
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Unscoped lookup of a global, iterate over namespaces, considering    using namespace statements. */
end_comment

begin_function
specifier|static
name|tree
name|unqualified_namespace_lookup
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|tree_binding
name|_binding
decl_stmt|;
name|tree
name|b
init|=
name|binding_init
argument_list|(
operator|&
name|_binding
argument_list|)
decl_stmt|;
name|tree
name|initial
init|=
name|current_decl_namespace
argument_list|()
decl_stmt|;
name|tree
name|scope
init|=
name|initial
decl_stmt|;
name|tree
name|siter
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
operator|!
name|val
condition|)
block|{
name|val
operator|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|/* Initialize binding for this context. */
name|BINDING_VALUE
argument_list|(
name|b
argument_list|)
operator|=
name|BINDING_VALUE
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|BINDING_TYPE
argument_list|(
name|b
argument_list|)
operator|=
name|BINDING_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Add all _DECLs seen through local using-directives. */
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
operator|!
name|level
operator|->
name|namespace_p
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|b
argument_list|,
name|level
operator|->
name|using_directives
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|)
condition|)
comment|/* Give up because of error. */
return|return
name|error_mark_node
return|;
comment|/* Add all _DECLs seen through global using-directives. */
comment|/* XXX local and global using lists should work equally. */
name|siter
operator|=
name|initial
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|b
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|siter
argument_list|)
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|)
condition|)
comment|/* Give up because of error. */
return|return
name|error_mark_node
return|;
if|if
condition|(
name|siter
operator|==
name|scope
condition|)
break|break;
name|siter
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|siter
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|select_decl
argument_list|(
name|b
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|global_namespace
condition|)
break|break;
name|scope
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Combine prefer_type and namespaces_only into flags.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_flags
parameter_list|(
name|prefer_type
parameter_list|,
name|namespaces_only
parameter_list|)
name|int
name|prefer_type
decl_stmt|,
name|namespaces_only
decl_stmt|;
block|{
if|if
condition|(
name|namespaces_only
condition|)
return|return
name|LOOKUP_PREFER_NAMESPACES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|1
condition|)
return|return
name|LOOKUP_PREFER_TYPES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|0
condition|)
return|return
name|LOOKUP_PREFER_BOTH
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a lookup that returned VAL, use FLAGS to decide if we want to    ignore it or not.  Subroutine of lookup_name_real.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_lookup
parameter_list|(
name|val
parameter_list|,
name|flags
parameter_list|)
name|tree
name|val
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
return|return
name|val
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_NAMESPACES
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|val
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOOKUP_TEMPLATES_EXPECTED
operator|)
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|)
operator|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|flags
operator|&
operator|(
name|LOOKUP_PREFER_NAMESPACES
operator||
name|LOOKUP_PREFER_TYPES
operator|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Any other BINDING overrides an implicit TYPENAME.  Warn about    that.  */
end_comment

begin_function
specifier|static
name|void
name|warn_about_implicit_typename_lookup
parameter_list|(
name|typename
parameter_list|,
name|binding
parameter_list|)
name|tree
name|typename
decl_stmt|;
name|tree
name|binding
decl_stmt|;
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|typename
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|typename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|binding
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|subtype
argument_list|)
operator|&&
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|subtype
argument_list|)
operator|==
name|binding
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|binding
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|binding
argument_list|)
argument_list|,
name|subtype
argument_list|)
operator|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"lookup of `%D' finds `%#D'"
argument_list|,
name|name
argument_list|,
name|binding
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"  instead of `%D' from dependent base class"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"  (use `typename %T::%D' if that's what you meant)"
argument_list|,
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look up NAME in the current binding level and its superiors in the    namespace of variables, functions and typedefs.  Return a ..._DECL    node of some kind representing its definition if there is only one    such declaration, or return a TREE_LIST with all the overloaded    definitions if there are many, or return 0 if it is undefined.     If PREFER_TYPE is> 0, we prefer TYPE_DECLs or namespaces.    If PREFER_TYPE is> 1, we reject non-type decls (e.g. namespaces).    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)    Otherwise we prefer non-TYPE_DECLs.       If NONCLASS is non-zero, we don't look for the NAME in class scope,    using IDENTIFIER_CLASS_VALUE.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_real
parameter_list|(
name|name
parameter_list|,
name|prefer_type
parameter_list|,
name|nonclass
parameter_list|,
name|namespaces_only
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|prefer_type
decl_stmt|,
name|nonclass
decl_stmt|,
name|namespaces_only
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|yylex
init|=
literal|0
decl_stmt|;
name|tree
name|from_obj
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|val_is_implicit_typename
init|=
literal|0
decl_stmt|;
comment|/* Hack: copy flag set by parser, if set. */
if|if
condition|(
name|only_namespace_names
condition|)
name|namespaces_only
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prefer_type
operator|==
operator|-
literal|2
condition|)
block|{
specifier|extern
name|int
name|looking_for_typename
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|yylex
operator|=
literal|1
expr_stmt|;
name|prefer_type
operator|=
name|looking_for_typename
expr_stmt|;
name|flags
operator|=
name|lookup_flags
argument_list|(
name|prefer_type
argument_list|,
name|namespaces_only
argument_list|)
expr_stmt|;
comment|/* If the next thing is '<', class templates are types. */
if|if
condition|(
name|looking_for_template
condition|)
name|flags
operator||=
name|LOOKUP_TEMPLATES_EXPECTED
expr_stmt|;
comment|/* std:: becomes :: for now.  */
if|if
condition|(
name|got_scope
operator|==
name|std_node
condition|)
name|got_scope
operator|=
name|void_type_node
expr_stmt|;
if|if
condition|(
name|got_scope
condition|)
name|type
operator|=
name|got_scope
expr_stmt|;
elseif|else
if|if
condition|(
name|got_object
operator|!=
name|error_mark_node
condition|)
name|type
operator|=
name|got_object
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|type
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|struct
name|tree_binding
name|b
decl_stmt|;
name|val
operator|=
name|binding_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_COMPLAIN
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|val
operator|=
name|select_decl
argument_list|(
name|val
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
comment|/* Someone else will give an error about this if needed.  */
name|val
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|current_class_type
condition|)
name|val
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|lookup_member
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|prefer_type
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|got_scope
condition|)
goto|goto
name|done
goto|;
elseif|else
if|if
condition|(
name|got_object
operator|&&
name|val
condition|)
name|from_obj
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|lookup_flags
argument_list|(
name|prefer_type
argument_list|,
name|namespaces_only
argument_list|)
expr_stmt|;
comment|/* If we're not parsing, we need to complain. */
name|flags
operator||=
name|LOOKUP_COMPLAIN
expr_stmt|;
block|}
comment|/* First, look in non-namespace scopes.  */
for|for
control|(
name|t
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binding
decl_stmt|;
if|if
condition|(
operator|!
name|LOCAL_BINDING_P
argument_list|(
name|t
argument_list|)
operator|&&
name|nonclass
condition|)
comment|/* We're not looking for class-scoped bindings, so keep going.  */
continue|continue;
comment|/* If this is the kind of thing we're looking for, we're done.  */
if|if
condition|(
name|qualify_lookup
argument_list|(
name|BINDING_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|BINDING_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
name|qualify_lookup
argument_list|(
name|BINDING_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|BINDING_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|binding
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
operator|(
operator|!
name|val
operator|||
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|binding
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IMPLICIT_TYPENAME_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|binding
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|val_is_implicit_typename
operator|&&
operator|!
name|yylex
condition|)
name|warn_about_implicit_typename_lookup
argument_list|(
name|val
argument_list|,
name|binding
argument_list|)
expr_stmt|;
name|val
operator|=
name|binding
expr_stmt|;
name|val_is_implicit_typename
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IMPLICIT_TYPENAME_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|val_is_implicit_typename
condition|)
break|break;
block|}
block|}
comment|/* Now lookup in namespace scopes.  */
if|if
condition|(
operator|!
name|val
operator|||
name|val_is_implicit_typename
condition|)
block|{
name|t
operator|=
name|unqualified_namespace_lookup
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|val_is_implicit_typename
operator|&&
operator|!
name|yylex
condition|)
name|warn_about_implicit_typename_lookup
argument_list|(
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|val
operator|=
name|t
expr_stmt|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|val
condition|)
block|{
comment|/* This should only warn about types used in qualified-ids.  */
if|if
condition|(
name|from_obj
operator|&&
name|from_obj
operator|!=
name|val
condition|)
block|{
if|if
condition|(
name|looking_for_typename
operator|&&
name|TREE_CODE
argument_list|(
name|from_obj
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|from_obj
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"lookup of `%D' in the scope of `%#T' (`%#T')"
argument_list|,
name|name
argument_list|,
name|got_object
argument_list|,
name|TREE_TYPE
argument_list|(
name|from_obj
argument_list|)
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"  does not match lookup in the current scope (`%#T')"
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We don't change val to from_obj if got_object depends on 	     template parms because that breaks implicit typename for 	     destructor calls.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|got_object
argument_list|)
condition|)
name|val
operator|=
name|from_obj
expr_stmt|;
block|}
comment|/* If we have a single function from a using decl, pull it out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|OVL_FUNCTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_obj
condition|)
name|val
operator|=
name|from_obj
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name_nonclass
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_function_nonclass
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
return|return
name|lookup_arg_dependent
argument_list|(
name|name
argument_list|,
name|lookup_name_nonclass
argument_list|(
name|name
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name_namespace_only
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
comment|/* type-or-namespace, nonclass, namespace_only */
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|,
name|prefer_type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|prefer_type
decl_stmt|;
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|prefer_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only in the innermost non-class    binding level.  */
end_comment

begin_function
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|namespace_p
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* extern "C" function() */
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|&&
name|LOCAL_BINDING_P
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|BINDING_LEVEL
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|b
condition|)
return|return
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|b
operator|->
name|keep
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_name_current_level, but for types.  */
end_comment

begin_function
name|tree
name|lookup_type_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|current_binding_level
operator|->
name|namespace_p
argument_list|,
literal|980716
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|global_type_node
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
condition|)
return|return
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|b
operator|->
name|keep
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|begin_only_namespace_names
parameter_list|()
block|{
name|only_namespace_names
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_only_namespace_names
parameter_list|()
block|{
name|only_namespace_names
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Arrange for the user to get a source line number, even when the    compiler is going down in flames, so that she at least has a    chance of working around problems in the compiler.  We used to    call error(), but that let the segmentation fault continue    through; now, it's much more passive by asking them to send the    maintainers mail about the problem.  */
end_comment

begin_function
specifier|static
name|void
name|signal_catch
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIOT
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Unused -- brendan 970107 */
end_comment

begin_comment
comment|/* Array for holding types considered "built-in".  These types    are output in the module in which `main' is defined.  */
end_comment

begin_endif
unit|static tree *builtin_type_tdescs_arr; static int builtin_type_tdescs_len, builtin_type_tdescs_max;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Push the declarations of builtin types into the namespace.    RID_INDEX, if< RID_MAX is the index of the builtin type    in the array RID_POINTERS.  NAME is the name used when looking    up the builtin type.  TYPE is the _TYPE node for the builtin type.  */
end_comment

begin_function
specifier|static
name|void
name|record_builtin_type
parameter_list|(
name|rid_index
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|rid
name|rid_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|rname
init|=
name|NULL_TREE
decl_stmt|,
name|tname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tdecl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
name|rname
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|tname
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TYPE_BUILT_IN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tname
condition|)
block|{
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|tname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|tname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
comment|/* Built-in types live in the global namespace. */
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tname
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rname
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|tname
operator|!=
name|NULL_TREE
condition|)
block|{
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|rname
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|rname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record one of the standard Java types.  * Declare it as having the given NAME.  * If SIZE> 0, it is the size of one of the integral types;  * otherwise it is the negative of the size of one of the other types.  */
end_comment

begin_function
specifier|static
name|tree
name|record_builtin_java_type
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|type
operator|=
name|make_signed_type
argument_list|(
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
operator|-
literal|32
condition|)
block|{
comment|/* "__java_char" or ""__java_boolean". */
name|type
operator|=
name|make_unsigned_type
argument_list|(
operator|-
name|size
argument_list|)
expr_stmt|;
comment|/*if (size == -1)	TREE_SET_CODE (type, BOOLEAN_TYPE);*/
block|}
else|else
block|{
comment|/* "__java_float" or ""__java_double". */
name|type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
operator|-
name|size
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Suppress generate debug symbol entries for these types,      since for normal C++ they are just clutter.      However, push_lang_context undoes this if extern "Java" is seen. */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Push a type into the namespace so that the back-ends ignore it. */
end_comment

begin_function
specifier|static
name|void
name|record_unknown_type
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure the "unknown type" typedecl gets ignored for debug info.  */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push overloaded decl, in global scope, with one argument so it    can be used as a callback from define_function.  */
end_comment

begin_function
specifier|static
name|void
name|push_overloaded_decl_1
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_GLOBAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
name|tree
name|auto_function
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
name|enum
name|built_in_function
name|code
decl_stmt|;
block|{
return|return
name|define_function
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|push_overloaded_decl_1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|build_decl_overload
argument_list|(
name|name
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|init_decl_processing
parameter_list|()
block|{
specifier|register
name|tree
name|endlink
decl_stmt|,
name|int_endlink
decl_stmt|,
name|double_endlink
decl_stmt|,
name|unsigned_endlink
decl_stmt|;
name|tree
name|fields
index|[
literal|20
index|]
decl_stmt|;
comment|/* Data type of memcpy.  */
name|tree
name|memcpy_ftype
decl_stmt|,
name|strlen_ftype
decl_stmt|;
name|int
name|wchar_type_size
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|tree
name|array_domain_type
decl_stmt|;
name|tree
name|vb_off_identifier
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Function type `char *(char *, char *)' and similar ones */
name|tree
name|string_ftype_ptr_ptr
decl_stmt|,
name|int_ftype_string_string
decl_stmt|;
name|tree
name|sizetype_endlink
decl_stmt|;
name|tree
name|ptr_ftype
decl_stmt|,
name|ptr_ftype_unsigned
decl_stmt|,
name|ptr_ftype_sizetype
decl_stmt|;
name|tree
name|void_ftype
decl_stmt|,
name|void_ftype_int
decl_stmt|,
name|void_ftype_ptr
decl_stmt|;
comment|/* Have to make these distinct before we try using them.  */
name|lang_name_cplusplus
operator|=
name|get_identifier
argument_list|(
literal|"C++"
argument_list|)
expr_stmt|;
name|lang_name_c
operator|=
name|get_identifier
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
name|lang_name_java
operator|=
name|get_identifier
argument_list|(
literal|"Java"
argument_list|)
expr_stmt|;
comment|/* Enter the global namespace. */
name|my_friendly_assert
argument_list|(
name|global_namespace
operator|==
name|NULL_TREE
argument_list|,
literal|375
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|current_lang_name
operator|==
name|NULL_TREE
argument_list|,
literal|375
argument_list|)
expr_stmt|;
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
name|push_namespace
argument_list|(
name|get_identifier
argument_list|(
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
name|global_namespace
operator|=
name|current_namespace
expr_stmt|;
name|current_lang_name
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|flag_strict_prototype
operator|==
literal|2
condition|)
name|flag_strict_prototype
operator|=
name|pedantic
expr_stmt|;
if|if
condition|(
operator|!
name|flag_permissive
operator|&&
operator|!
name|pedantic
condition|)
name|flag_pedantic_errors
operator|=
literal|1
expr_stmt|;
name|strict_prototypes_lang_c
operator|=
name|flag_strict_prototype
expr_stmt|;
comment|/* Initially, C.  */
name|current_lang_name
operator|=
name|lang_name_c
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|named_label_uses
operator|=
name|NULL
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
comment|/* Because most segmentation signals can be traced back into user      code, catch them and at least give the user a chance of working      around compiler bugs.  */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
comment|/* We will also catch aborts in the back-end through signal_catch and      give the user a chance to see where the error might be, and to defeat      aborts in the back-end when there have been errors previously in their      code.  */
ifdef|#
directive|ifdef
name|SIGIOT
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_obstack_init
argument_list|(
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
comment|/* Must lay these out before anything else gets laid out.  */
name|error_mark_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|error_mark_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|error_mark_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_list
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Make the binding_level structure for global names.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
comment|/* The global level is the namespace level of ::.  */
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
operator|=
name|global_binding_level
expr_stmt|;
name|declare_namespace_level
argument_list|()
expr_stmt|;
name|this_identifier
operator|=
name|get_identifier
argument_list|(
name|THIS_NAME
argument_list|)
expr_stmt|;
name|in_charge_identifier
operator|=
name|get_identifier
argument_list|(
name|IN_CHARGE_NAME
argument_list|)
expr_stmt|;
name|vlist_identifier
operator|=
name|get_identifier
argument_list|(
name|VLIST_NAME
argument_list|)
expr_stmt|;
name|ctor_identifier
operator|=
name|get_identifier
argument_list|(
name|CTOR_NAME
argument_list|)
expr_stmt|;
name|dtor_identifier
operator|=
name|get_identifier
argument_list|(
name|DTOR_NAME
argument_list|)
expr_stmt|;
name|pfn_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_PFN_NAME
argument_list|)
expr_stmt|;
name|index_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_INDEX_NAME
argument_list|)
expr_stmt|;
name|delta_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA_NAME
argument_list|)
expr_stmt|;
name|delta2_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA2_NAME
argument_list|)
expr_stmt|;
name|pfn_or_delta2_identifier
operator|=
name|get_identifier
argument_list|(
literal|"__pfn_or_delta2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_signatures
condition|)
block|{
name|tag_identifier
operator|=
name|get_identifier
argument_list|(
name|SIGTABLE_TAG_NAME
argument_list|)
expr_stmt|;
name|vb_off_identifier
operator|=
name|get_identifier
argument_list|(
name|SIGTABLE_VB_OFF_NAME
argument_list|)
expr_stmt|;
name|vt_off_identifier
operator|=
name|get_identifier
argument_list|(
name|SIGTABLE_VT_OFF_NAME
argument_list|)
expr_stmt|;
block|}
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_INT
argument_list|,
name|NULL_PTR
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|flag_signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_CHAR
argument_list|,
literal|"char"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* `signed' is the same as `int' */
name|record_builtin_type
argument_list|(
name|RID_SIGNED
argument_list|,
name|NULL_PTR
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_LONG
argument_list|,
literal|"long int"
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long unsigned int"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned long"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long int"
argument_list|,
name|long_long_integer_type_node
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned int"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_SHORT
argument_list|,
literal|"short int"
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"short unsigned int"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned short"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* `unsigned long' is the standard type for sizeof.      Note that stddef.h uses `unsigned long',      and this must agree, even if long and int are the same size.  */
name|set_sizetype
argument_list|(
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ptrdiff_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|PTRDIFF_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"signed char"
argument_list|,
name|signed_char_type_node
argument_list|)
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned char"
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* These are types that type_for_size and type_for_mode use.  */
name|intQI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intHI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intSI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intDI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|intTI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__int128_t"
argument_list|)
argument_list|,
name|intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unsigned_intQI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intHI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intSI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intDI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|unsigned_intTI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__uint128_t"
argument_list|)
argument_list|,
name|unsigned_intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_FLOAT
argument_list|,
name|NULL_PTR
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_short_double
condition|)
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DOUBLE
argument_list|,
name|NULL_PTR
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long double"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|complex_integer_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex int"
argument_list|)
argument_list|,
name|complex_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_integer_type_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_integer_type_node
argument_list|)
expr_stmt|;
name|complex_float_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex float"
argument_list|)
argument_list|,
name|complex_float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_float_type_node
argument_list|)
operator|=
name|float_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_float_type_node
argument_list|)
expr_stmt|;
name|complex_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex double"
argument_list|)
argument_list|,
name|complex_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_double_type_node
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_double_type_node
argument_list|)
expr_stmt|;
name|complex_long_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex long double"
argument_list|)
argument_list|,
name|complex_long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_long_double_type_node
argument_list|)
operator|=
name|long_double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_long_double_type_node
argument_list|)
expr_stmt|;
name|java_byte_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_byte"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|java_short_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_short"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|java_int_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_int"
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|java_long_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_long"
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|java_float_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_float"
argument_list|,
operator|-
literal|32
argument_list|)
expr_stmt|;
name|java_double_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_double"
argument_list|,
operator|-
literal|64
argument_list|)
expr_stmt|;
name|java_char_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_char"
argument_list|,
operator|-
literal|16
argument_list|)
expr_stmt|;
name|java_boolean_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_boolean"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|integer_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_zero_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_one_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_two_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_two_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_three_node
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_three_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|boolean_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|BOOL_TYPE_SIZE
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|boolean_type_node
argument_list|,
name|BOOLEAN_TYPE
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|boolean_type_node
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|boolean_type_node
argument_list|)
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|boolean_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_BOOL
argument_list|,
literal|"bool"
argument_list|,
name|boolean_type_node
argument_list|)
expr_stmt|;
name|boolean_false_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|boolean_false_node
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
name|boolean_true_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|boolean_true_node
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
comment|/* These are needed by stor-layout.c.  */
name|size_zero_node
operator|=
name|size_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size_one_node
operator|=
name|size_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|signed_size_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|signed_size_zero_node
argument_list|)
operator|=
name|make_signed_type
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_VOID
argument_list|,
name|NULL_PTR
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Uses integer_zero_node.  */
name|void_list_node
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|void_list_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|null_pointer_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Used for expressions that do nothing, but are not errors.  */
name|void_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|void_zero_node
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|const_string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|record_builtin_type (RID_MAX, NULL_PTR, string_type_node);
endif|#
directive|endif
comment|/* Make a type to be the domain of a few array types      whose domains don't really matter.      200 is small enough that it always fits in size_t      and large enough that it can hold most function names for the      initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|array_domain_type
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
literal|200
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a type for arrays of characters.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* This is just some anonymous class type.  Nobody should ever      need to look inside this envelope.  */
name|class_star_type_node
operator|=
name|build_pointer_type
argument_list|(
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|const_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|record_builtin_type (RID_MAX, NULL_PTR, ptr_type_node);
endif|#
directive|endif
name|endlink
operator|=
name|void_list_node
expr_stmt|;
name|int_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|double_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|unsigned_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|ptr_ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ptr_ftype_unsigned
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|unsigned_endlink
argument_list|)
expr_stmt|;
name|sizetype_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
comment|/* We realloc here because sizetype could be int or unsigned.  S'ok.  */
name|ptr_ftype_sizetype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|sizetype_endlink
argument_list|)
expr_stmt|;
name|void_ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|void_ftype_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|int_endlink
argument_list|)
expr_stmt|;
name|void_ftype_ptr
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr
operator|=
name|build_exception_variant
argument_list|(
name|void_ftype_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|float_ftype_float
operator|=
name|build_function_type
argument_list|(
name|float_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|float_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|double_ftype_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
expr_stmt|;
name|ldouble_ftype_ldouble
operator|=
name|build_function_type
argument_list|(
name|long_double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_double_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|double_ftype_double_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
expr_stmt|;
name|long_ftype_long
operator|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_cptr_cptr_sizet
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|string_ftype_ptr_ptr
comment|/* strcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_string_string
comment|/* strcmp prototype */
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strlen_ftype
comment|/* strlen prototype */
operator|=
name|build_function_type
argument_list|(
name|sizetype
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy_ftype
comment|/* memcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|sizetype_endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_huge_objects
condition|)
name|delta_type_node
operator|=
name|long_integer_type_node
expr_stmt|;
else|else
name|delta_type_node
operator|=
name|short_integer_type_node
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_constant_p"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_CONSTANT_P
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_return_address_fndecl
operator|=
name|builtin_function
argument_list|(
literal|"__builtin_return_address"
argument_list|,
name|ptr_ftype_unsigned
argument_list|,
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_frame_address"
argument_list|,
name|ptr_ftype_unsigned
argument_list|,
name|BUILT_IN_FRAME_ADDRESS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_alloca"
argument_list|,
name|ptr_ftype_sizetype
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
literal|"alloca"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Define alloca, ffs as builtins.      Declare _exit just to mark it as volatile.  */
if|if
condition|(
operator|!
name|flag_no_builtin
operator|&&
operator|!
name|flag_no_nonansi_builtin
condition|)
block|{
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"alloca"
argument_list|,
name|ptr_ftype_sizetype
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"_exit"
argument_list|,
name|void_ftype_int
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|builtin_function
argument_list|(
literal|"__builtin_abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabsf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabsl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_saveregs"
argument_list|,
name|ptr_ftype
argument_list|,
name|BUILT_IN_SAVEREGS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_classify_type"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_CLASSIFY_TYPE
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_next_arg"
argument_list|,
name|ptr_ftype
argument_list|,
name|BUILT_IN_NEXT_ARG
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_args_info"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ARGS_INFO
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_setjmp"
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_SETJMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_longjmp"
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_LONGJMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Untyped call and return.  */
name|builtin_function
argument_list|(
literal|"__builtin_apply_args"
argument_list|,
name|ptr_ftype
argument_list|,
name|BUILT_IN_APPLY_ARGS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_ftype_sizetype
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_apply"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|temp
argument_list|)
argument_list|,
name|BUILT_IN_APPLY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_return"
argument_list|,
name|void_ftype_ptr
argument_list|,
name|BUILT_IN_RETURN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Currently under experimentation.  */
name|builtin_function
argument_list|(
literal|"__builtin_memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
literal|"memcpy"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
literal|"memcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
literal|"strcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
literal|"strcpy"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strlen"
argument_list|,
name|strlen_ftype
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
literal|"strlen"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sqrtf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
literal|"sqrtf"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fsqrt"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sqrtl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
literal|"sqrtl"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sinf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_SIN
argument_list|,
literal|"sinf"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
literal|"sin"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sinl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_SIN
argument_list|,
literal|"sinl"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cosf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_COS
argument_list|,
literal|"cosf"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
literal|"cos"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cosl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_COS
argument_list|,
literal|"cosl"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_no_builtin
condition|)
block|{
name|builtin_function
argument_list|(
literal|"abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"fabsf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"fabsl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strlen"
argument_list|,
name|strlen_ftype
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sqrtf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sqrt"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sqrtl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sinf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_SIN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sinl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_SIN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"cosf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_COS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"cosl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_COS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Declare these functions volatile 	 to avoid spurious "control drops through" warnings.  */
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"abort"
argument_list|,
name|void_ftype
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Well, these are actually ANSI, but we can't set DECL_BUILT_IN on          them...  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"exit"
argument_list|,
name|void_ftype_int
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Support for these has not been written in either expand_builtin      or build_function_call.  */
block|builtin_function ("__builtin_div", default_ftype, BUILT_IN_DIV, NULL_PTR);   builtin_function ("__builtin_ldiv", default_ftype, BUILT_IN_LDIV, NULL_PTR);   builtin_function ("__builtin_ffloor", double_ftype_double, BUILT_IN_FFLOOR, 		    NULL_PTR);   builtin_function ("__builtin_fceil", double_ftype_double, BUILT_IN_FCEIL, 		    NULL_PTR);   builtin_function ("__builtin_fmod", double_ftype_double_double, 		    BUILT_IN_FMOD, NULL_PTR);   builtin_function ("__builtin_frem", double_ftype_double_double, 		    BUILT_IN_FREM, NULL_PTR);   builtin_function ("__builtin_memset", ptr_ftype_ptr_int_int, 		    BUILT_IN_MEMSET, NULL_PTR);   builtin_function ("__builtin_getexp", double_ftype_double, BUILT_IN_GETEXP, 		    NULL_PTR);   builtin_function ("__builtin_getman", double_ftype_double, BUILT_IN_GETMAN, 		    NULL_PTR);
endif|#
directive|endif
comment|/* C++ extensions */
name|unknown_type_node
operator|=
name|make_node
argument_list|(
name|UNKNOWN_TYPE
argument_list|)
expr_stmt|;
name|record_unknown_type
argument_list|(
name|unknown_type_node
argument_list|,
literal|"unknown type"
argument_list|)
expr_stmt|;
comment|/* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */
name|TREE_TYPE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_node
argument_list|)
operator|=
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same      result.  */
name|TYPE_POINTER_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* This is for handling opaque types in signatures.  */
name|opaque_type_node
operator|=
name|copy_node
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|opaque_type_node
argument_list|)
operator|=
name|opaque_type_node
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|0
argument_list|,
name|opaque_type_node
argument_list|)
expr_stmt|;
comment|/* This is special for C++ so functions can be overloaded.  */
name|wchar_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|WCHAR_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_type_size
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|signed_wchar_type_node
operator|=
name|make_signed_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|unsigned_wchar_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|wchar_type_node
operator|=
name|TREE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|?
name|unsigned_wchar_type_node
else|:
name|signed_wchar_type_node
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_WCHAR
argument_list|,
literal|"__wchar_t"
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
comment|/* Artificial declaration of wchar_t -- can be bashed */
name|wchar_decl_node
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"wchar_t"
argument_list|)
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|wchar_decl_node
argument_list|)
expr_stmt|;
comment|/* This is for wide string constants.  */
name|wchar_array_type_node
operator|=
name|build_array_type
argument_list|(
name|wchar_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
comment|/* Make sure we get a unique function type, so we can give 	 its pointer type a name.  (This wins for gdb.) */
name|tree
name|vfunc_type
init|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_pointer_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vtable_entry_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|index_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_identifier
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
comment|/* Make this part of an invisible union.  */
name|fields
index|[
literal|3
index|]
operator|=
name|copy_node
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|delta_type_node
expr_stmt|;
name|DECL_NAME
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|delta2_identifier
expr_stmt|;
name|DECL_MODE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|delta_type_node
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|delta_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
operator|=
name|fields
index|[
literal|3
index|]
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_qualified_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_qualified_type
argument_list|(
name|vtbl_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL_PTR
argument_list|,
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL_PTR
argument_list|,
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
comment|/* We need vlists only when using thunks; otherwise leave them 	 as NULL_TREE. That way, it doesn't get into the way of the 	 mangling.  */
name|vlist_type_node
operator|=
name|build_pointer_type
argument_list|(
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|vlist_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vlist_zero_node
argument_list|)
operator|=
name|vlist_type_node
expr_stmt|;
block|}
comment|/* Simplify life by making a "sigtable_entry_type".  Give its      fields names so that the debugger can use them.  */
if|if
condition|(
name|flag_handle_signatures
condition|)
block|{
name|sigtable_entry_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|tag_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|vb_off_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|index_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|4
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_identifier
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* Set the alignment to the max of the alignment of ptr_type_node and 	 delta_type_node.  Double alignment wastes a word on the Sparc.  */
name|finish_builtin_type
argument_list|(
name|sigtable_entry_type
argument_list|,
name|SIGTABLE_PTR_TYPE
argument_list|,
name|fields
argument_list|,
literal|4
argument_list|,
operator|(
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|delta_type_node
argument_list|)
operator|)
condition|?
name|ptr_type_node
else|:
name|delta_type_node
argument_list|)
expr_stmt|;
comment|/* Make this part of an invisible union.  */
name|fields
index|[
literal|5
index|]
operator|=
name|copy_node
argument_list|(
name|fields
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fields
index|[
literal|5
index|]
argument_list|)
operator|=
name|delta_type_node
expr_stmt|;
name|DECL_NAME
argument_list|(
name|fields
index|[
literal|5
index|]
argument_list|)
operator|=
name|vt_off_identifier
expr_stmt|;
name|DECL_MODE
argument_list|(
name|fields
index|[
literal|5
index|]
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|delta_type_node
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|fields
index|[
literal|5
index|]
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|delta_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|fields
index|[
literal|5
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
literal|4
index|]
argument_list|)
operator|=
name|fields
index|[
literal|5
index|]
expr_stmt|;
name|sigtable_entry_type
operator|=
name|build_qualified_type
argument_list|(
name|sigtable_entry_type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|SIGTABLE_PTR_TYPE
argument_list|,
name|sigtable_entry_type
argument_list|)
expr_stmt|;
block|}
name|std_node
operator|=
name|build_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|flag_honor_std
condition|?
literal|"fake std"
else|:
literal|"std"
argument_list|)
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|std_node
argument_list|)
expr_stmt|;
name|global_type_node
operator|=
name|make_node
argument_list|(
name|LANG_TYPE
argument_list|)
expr_stmt|;
name|record_unknown_type
argument_list|(
name|global_type_node
argument_list|,
literal|"global type"
argument_list|)
expr_stmt|;
comment|/* Now, C++.  */
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
block|{
name|tree
name|bad_alloc_type_node
decl_stmt|,
name|newtype
decl_stmt|,
name|deltype
decl_stmt|;
if|if
condition|(
name|flag_honor_std
condition|)
name|push_namespace
argument_list|(
name|get_identifier
argument_list|(
literal|"std"
argument_list|)
argument_list|)
expr_stmt|;
name|bad_alloc_type_node
operator|=
name|xref_tag
argument_list|(
name|class_type_node
argument_list|,
name|get_identifier
argument_list|(
literal|"bad_alloc"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_honor_std
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
name|newtype
operator|=
name|build_exception_variant
argument_list|(
name|ptr_ftype_sizetype
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|bad_alloc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|deltype
operator|=
name|build_exception_variant
argument_list|(
name|void_ftype_ptr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|,
name|newtype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
argument_list|,
name|newtype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|global_delete_fndecl
operator|=
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|,
name|deltype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
argument_list|,
name|deltype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
block|}
name|abort_fndecl
operator|=
name|define_function
argument_list|(
literal|"__pure_virtual"
argument_list|,
name|void_ftype
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform other language dependent initializations.  */
name|init_class_processing
argument_list|()
expr_stmt|;
name|init_init_processing
argument_list|()
expr_stmt|;
name|init_search_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_rtti
condition|)
name|init_rtti_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_exceptions
condition|)
name|init_exception_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_no_inline
condition|)
block|{
name|flag_inline_functions
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|supports_one_only
argument_list|()
condition|)
name|flag_weak
operator|=
literal|0
expr_stmt|;
comment|/* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|declare_function_name
argument_list|()
expr_stmt|;
comment|/* Prepare to check format strings against argument lists.  */
name|init_function_format_info
argument_list|()
expr_stmt|;
comment|/* Show we use EH for cleanups.  */
name|using_eh_for_cleanups
argument_list|()
expr_stmt|;
name|print_error_function
operator|=
name|lang_print_error_function
expr_stmt|;
name|lang_get_alias_set
operator|=
operator|&
name|c_get_alias_set
expr_stmt|;
name|valid_lang_attribute
operator|=
name|cp_valid_lang_attribute
expr_stmt|;
comment|/* Maintain consistency.  Perhaps we should just complain if they      say -fwritable-strings?  */
if|if
condition|(
name|flag_writable_strings
condition|)
name|flag_const_strings
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to print any language-specific context for an error message.  */
end_comment

begin_function
specifier|static
name|void
name|lang_print_error_function
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|default_print_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|maybe_print_template_context
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  */
end_comment

begin_function_decl
name|tree
name|define_function
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|function_code
parameter_list|,
name|pfn
parameter_list|,
name|library_name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|built_in_function
name|function_code
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*pfn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|library_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|decl
init|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|392
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,      we cannot change DECL_ASSEMBLER_NAME until we have installed this      function in the namespace.  */
if|if
condition|(
name|pfn
condition|)
call|(
modifier|*
name|pfn
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|library_name
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_code
operator|!=
name|NOT_BUILT_IN
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|function_code
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* When we call finish_struct for an anonymous union, we create    default copy constructors and such.  But, an anonymous union    shouldn't have such things; this function undoes the damage to the    anonymous union type T.     (The reason that we create the synthesized methods is that we don't    distinguish `union { int i; }' from `typedef union { int i; } U'.    The first is an anonymous union; the second is just an ordinary    union type.)  */
end_comment

begin_function
name|void
name|fixup_anonymous_union
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
modifier|*
name|q
decl_stmt|;
comment|/* Wipe out memory of synthesized methods */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Splice the implicitly generated functions out of the TYPE_METHODS      list.  */
name|q
operator|=
operator|&
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have      function members.  */
if|if
condition|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"an anonymous union cannot have function members"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure that a declaration with no declarator is well-formed, i.e.    just defines a tagged type or anonymous union.     Returns the type defined, if any.  */
end_comment

begin_function
name|tree
name|check_tag_decl
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|int
name|found_type
init|=
literal|0
decl_stmt|;
name|tree
name|ob_modifier
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
operator|++
name|found_type
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|value
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|261
argument_list|)
expr_stmt|;
name|t
operator|=
name|value
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|current_scope
argument_list|()
operator|!=
name|current_class_type
condition|)
name|ob_modifier
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXPLICIT
index|]
condition|)
name|ob_modifier
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|found_type
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple types in one declaration"
argument_list|)
expr_stmt|;
comment|/* Inside a class, we might be in a friend or access declaration.      Until we have a good way of detecting the latter, don't warn.  */
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|&&
operator|!
name|current_class_type
condition|)
name|pedwarn
argument_list|(
literal|"declaration does not declare anything"
argument_list|)
expr_stmt|;
comment|/* Check for an anonymous union.  We're careful      accessing TYPE_IDENTIFIER because some built-in types, like      pointer-to-member types, do not have TYPE_NAME.  */
elseif|else
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Anonymous unions are objects, so they can have specifiers.  */
empty_stmt|;
name|SET_ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ob_modifier
condition|)
block|{
if|if
condition|(
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|||
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
condition|)
name|cp_error
argument_list|(
literal|"`%D' can only be specified for functions"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
condition|)
name|cp_error
argument_list|(
literal|"`%D' can only be specified inside a class"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ob_modifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXPLICIT
index|]
condition|)
name|cp_error
argument_list|(
literal|"`%D' can only be specified for constructors"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' can only be specified for objects and functions"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.     C++: may have to grok the declspecs to learn about static,    complain for anonymous unions.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|t
init|=
name|check_tag_decl
argument_list|(
name|declspecs
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|maybe_process_partial_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* This is where the variables in an anonymous union are      declared.  An anonymous union declaration looks like:      union { ... } ;      because there is no declarator after the union, the parser      sends that declaration here.  */
if|if
condition|(
name|t
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|fixup_anonymous_union
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|NULL_TREE
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|finish_anon_union
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `cp_finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_comment
comment|/* Set this to zero to debug not using the temporary obstack    to parse initializers.  */
end_comment

begin_decl_stmt
name|int
name|debug_temp_inits
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|,
name|attributes
parameter_list|,
name|prefix_attributes
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|attributes
decl_stmt|,
name|prefix_attributes
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|context
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
name|tree
name|attrlist
decl_stmt|;
if|#
directive|if
literal|0
comment|/* See code below that used this.  */
block|int init_written = initialized;
endif|#
directive|endif
comment|/* This should only be done once on the top most decl.  */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|attributes
operator|||
name|prefix_attributes
condition|)
name|attrlist
operator|=
name|build_scratch_list
argument_list|(
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
else|else
name|attrlist
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
name|attrlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|NULL_TREE
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't lose if destructors must be executed at file-level.  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|decl
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|itype
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|itype
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|itype
operator|=
name|build_index_type
argument_list|(
name|copy_to_permanent
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
operator|&&
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|context
operator|!=
name|current_namespace
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* When parsing the initializer, lookup should use the object's 	 namespace. */
name|push_decl_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* We are only interested in class contexts, later. */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `cp_finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* typedef foo = bar  means give foo the same type as bar. 	   We haven't parsed bar yet, so `cp_finish_decl' will fix that up. 	   Any other case of an initialization in a TYPE_DECL is an error.  */
if|if
condition|(
name|pedantic
operator|||
name|list_length
argument_list|(
name|declspecs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|cp_error
argument_list|(
literal|"typedef `%D' is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|cp_error
argument_list|(
literal|"function `%#D' is initialized like a variable"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"variable-sized object `%D' may not be initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"elements of array `%#D' have incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"declaration of `%#D' has `extern' and is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `cp_finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SET_DEFAULT_DECL_ATTRIBUTES
name|SET_DEFAULT_DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|cplus_decl_attributes
argument_list|(
name|decl
argument_list|,
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|context
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|push_nested_class
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|cp_error
argument_list|(
literal|"`%#D' is not a static member of `%#T'"
argument_list|,
name|decl
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|context
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ does not permit `%T::%D' to be defined as `%T::%D'"
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Static data member are tricky; an in-class initialization 		 still doesn't provide a definition, so the in-class 		 declaration will have DECL_EXTERNAL set, but will have an 		 initialization.  Thus, duplicate_decls won't warn 		 about this situation, and so we check here.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"duplicate initialization of %D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|field
argument_list|)
condition|)
name|decl
operator|=
name|field
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|field
init|=
name|check_classfn
argument_list|(
name|context
argument_list|,
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|&&
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|field
argument_list|)
condition|)
name|decl
operator|=
name|field
expr_stmt|;
block|}
comment|/* cp_finish_decl sets DECL_EXTERNAL if DECL_IN_AGGR_P is set.  */
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* [temp.expl.spec] An explicit specialization of a static data 	     member of a template is a definition if the declaration 	     includes an initializer; otherwise, it is a declaration.  	     We check for processing_specialization so this only applies 	     to the new specialization syntax.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|processing_specialization
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"declaration of `%#D' outside of class is not definition"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Add this decl to the current binding level, but not if it      comes from another scope, e.g. a static member variable.      TEM may equal DECL or it may be a previous decl of the same name.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
comment|/* Definitions of namespace members outside their namespace are 	  possible. */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|namespace_bindings_p
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|LANG_TYPE
comment|/* The declaration of template specializations does not affect 	 the functions available for overload resolution, so we do not 	 call pushdecl.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|tem
operator|=
name|decl
expr_stmt|;
else|else
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
operator|!
name|current_function_decl
condition|)
name|tem
operator|=
name|push_template_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|minimal_parse_mode
condition|)
name|DECL_VINDEX
argument_list|(
name|tem
argument_list|)
operator|=
name|build_min_nt
argument_list|(
name|DECL_STMT
argument_list|,
name|copy_to_permanent
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|copy_to_permanent
argument_list|(
name|declspecs
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_BSS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
comment|/* Tell the back-end to use or not use .common as appropriate.  If we say      -fconserve-space, we want this to save .data space, at the expense of      wrong semantics.  If we say -fno-conserve-space, we want this to      produce errors about redefs; to do this we force variables into the      data segment.  */
name|DECL_COMMON
argument_list|(
name|tem
argument_list|)
operator|=
name|flag_conserve_space
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|start_decl_1
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Corresponding pop_obstacks is done in `cp_finish_decl'.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We have no way of knowing whether the initializer will need to be      evaluated at run-time or not until we've parsed it, so let's just put      it in the permanent obstack.  (jason) */
block|if (init_written&& ! (TREE_CODE (tem) == PARM_DECL 	    || (TREE_READONLY (tem)&& (TREE_CODE (tem) == VAR_DECL 		    || TREE_CODE (tem) == FIELD_DECL))))     {
comment|/* When parsing and digesting the initializer, 	 use temporary storage.  Do this even if we will ignore the value.  */
block|if (toplevel_bindings_p ()&& debug_temp_inits) 	{ 	  if (processing_template_decl 	      || TYPE_NEEDS_CONSTRUCTING (type) 	      || TREE_CODE (type) == REFERENCE_TYPE)
comment|/* In this case, the initializer must lay down in permanent 	       storage, since it will be saved until `finish_file' is run.   */
block|; 	  else 	    temporary_allocation (); 	}     }
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_function
name|void
name|start_decl_1
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|initialized
init|=
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* If this type of object needs a cleanup, and control may      jump past it, make a new binding level so that it is cleaned      up only when it is initialized first.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|==
literal|0
condition|)
name|pushlevel_temporary
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `cp_finish_decl' to ignore the initializer once it is parsed.  */
block|{
comment|/* Don't allow initializations for incomplete types except for 	 arrays which might be completed by the initialization.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* A complete type is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"variable `%#D' has initializer but incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"elements of array `%#D' have incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* else we already gave an error in start_decl.  */
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|initialized
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|processing_template_decl
operator|||
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"aggregate `%#D' has incomplete type and cannot be initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Change the type so that assemble_variable will give 	     DECL an rtl we can live with: (mem (const_int 0)).  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
comment|/* If any base type in the hierarchy of TYPE needs a constructor, 	     then we set initialized to 1.  This way any nodes which are 	     created for the purposes of initializing this aggregate 	     will live as long as it does.  This is necessary for global 	     aggregates which do not have their initializers processed until 	     the end of the file.  */
name|initialized
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* We don't do this yet for GNU C++.  */
comment|/* For a local variable, define the RTL now.  */
block|if (! toplevel_bindings_p ()
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
block|&& DECL_RTL (tem) == NULL_RTX)     {       if (TYPE_SIZE (TREE_TYPE (tem)) != NULL_TREE) 	expand_decl (tem);       else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE&& DECL_INITIAL (tem) != NULL_TREE) 	expand_decl (tem);     }
endif|#
directive|endif
if|if
condition|(
operator|!
name|initialized
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle initialization of references.    These three arguments are from `cp_finish_decl', and have the    same meaning here that they do there.     Quotes on semantics can be found in ARM 8.4.3.  */
end_comment

begin_function
specifier|static
name|void
name|grok_reference_init
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' declared as reference but not initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|cp_error
argument_list|(
literal|"ANSI C++ forbids use of initializer list to initialize reference `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|init
operator|=
name|convert_from_reference
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Note: default conversion is only called in very special cases.  */
name|init
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_NORMAL
operator||
name|DIRECT_BIND
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
goto|goto
name|fail
goto|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|init
operator|=
name|tmp
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"cannot initialize `%T' from `%T'"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* ?? Can this be optimized in some cases to      hand back the DECL_INITIAL slot??  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
name|init
operator|=
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return;
name|fail
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Fill in DECL_INITIAL with some magical value to prevent expand_decl from    mucking with forces it does not comprehend (i.e. initialization with a    constructor).  If we are at global scope and won't go into COMMON, fill    it in with a dummy CONSTRUCTOR to force the variable into .data;    otherwise we can use error_mark_node.  */
end_comment

begin_function
specifier|static
name|tree
name|obscure_complex_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_no_inline
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|extract_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_BSS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ASM_OUTPUT_ALIGNED_BSS
argument_list|)
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
operator|&&
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Issue an error message if DECL is an uninitialized const variable.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_uninitialized_const_var
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* ``Unless explicitly declared extern, a const object does not have      external linkage and must be initialized. ($8.4; $12.1)'' ARM      7.1.6 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"uninitialized const `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its line number and initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.     Call `pop_obstacks' iff NEED_POP is nonzero.     For C++, `cp_finish_decl' must be fairly evasive:  it must keep initializers    for aggregates that have constructors alive on the permanent obstack,    so that the global initializing functions can be written at the end.     INIT0 holds the value of an initializer that should be allowed to escape    the normal rules.     FLAGS is LOOKUP_ONLYCONVERTING is the = init syntax was used, else 0    if the (init) syntax was used.     For functions that take default parameters, DECL points to its    "maximal" instantiation.  `cp_finish_decl' must then also declared its    subsequently lower and lower forms of instantiation, checking for    ambiguity as it goes.  This can be sped up later.  */
end_comment

begin_function
name|void
name|cp_finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|,
name|need_pop
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
name|int
name|need_pop
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|cleanup
init|=
name|NULL_TREE
decl_stmt|,
name|ttype
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|was_incomplete
decl_stmt|;
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
name|NULL
decl_stmt|;
name|int
name|was_readonly
init|=
literal|0
decl_stmt|;
name|int
name|already_used
init|=
literal|0
decl_stmt|;
name|tree
name|core_type
decl_stmt|;
comment|/* If this is 0, then we did not change obstacks.  */
if|if
condition|(
operator|!
name|decl
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|error
argument_list|(
literal|"assignment (not initialization) in declaration"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If a name was specified, get the string.  */
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"Cannot initialize `%D' to namespace `%D'"
argument_list|,
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
operator|&&
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
name|init
operator|)
condition|)
name|DECL_DEFINED_IN_CLASS_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_namespace
operator|&&
name|init
condition|)
block|{
comment|/* Leave the namespace of the object. */
name|pop_decl_namespace
argument_list|()
expr_stmt|;
block|}
comment|/* If the type of the thing we are declaring either has      a constructor, or has a virtual function table pointer,      AND its initialization was accepted by `start_decl',      then we stayed on the permanent obstack through the      declaration, otherwise, changed obstacks as GCC would.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_HAS_MUTABLE_P
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|minimal_parse_mode
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|stmt
init|=
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* If the decl is declaring a member of a local class (in a 	     template function), the DECL_VINDEX will either be NULL, 	     or it will be an actual virtual function index, not a 	     DECL_STMT.  */
if|if
condition|(
name|stmt
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|DECL_STMT
condition|)
block|{
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|finish_end0
goto|;
block|}
comment|/* Take care of TYPE_DECLs up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|type
condition|)
name|cp_warning
argument_list|(
literal|"shadowing previous type declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If we have installed this as the canonical typedef for this 	 type, and that type has not been defined yet, delay emitting 	 the debug information for it, as we will emit it later.  */
if|if
condition|(
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|decl
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|ttype
operator|=
name|target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Currently, GNU C++ puts constants in text space, making them 	 impossible to initialize.  In the future, one would hope for 	 an operating system which understood the difference between 	 initialization and the running of a program.  */
name|was_readonly
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|init
operator|!=
name|error_mark_node
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|init
argument_list|)
argument_list|,
literal|147
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* This must override the asm specifier which was placed 	     by grokclassfn.  Lay this out fresh.  */
name|DECL_RTL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
elseif|else
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplevel_bindings_p
argument_list|()
operator|||
name|pseudo_global_level_p
argument_list|()
argument_list|)
expr_stmt|;
name|grok_reference_init
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|core_type
operator|=
name|type
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|core_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|core_type
operator|=
name|TREE_TYPE
argument_list|(
name|core_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|148
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
comment|/* This will keep us from needing to worry about our obstacks.  */
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|NULL_TREE
argument_list|,
literal|149
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NON_AGGREGATE_CLASS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' must be initialized by constructor, not by `{...}'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
goto|goto
name|dont_use_constructor
goto|;
block|}
block|}
else|else
block|{
name|dont_use_constructor
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|init
operator|=
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
comment|/* We must hide the initializer so that expand_decl 	   won't try to do something it does not understand.  */
name|init
operator|=
name|obscure_complex_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|core_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|core_type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"structure `%D' with uninitialized const members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|core_type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"structure `%D' with uninitialized reference members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|check_for_uninitialized_const_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|init
operator|=
name|obscure_complex_init
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|check_for_uninitialized_const_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For top-level declaration, the initial value was read in      the temporary obstack.  MAXINDEX, rtl, etc. to be made below      must go in the permanent obstack; but don't discard the      temporary data yet.  */
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|tree
name|initializer
init|=
name|init
condition|?
name|init
else|:
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|initializer
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|cp_error
argument_list|(
literal|"initializer fails to determine size of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|cp_error
argument_list|(
literal|"array size missing in `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a `static' var's size isn't known, make it extern as 	     well as static, so it does not get allocated.  If it's not 	     `static', then don't mark it extern; finish_incomplete_decl 	     will give it a default size and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"zero-size array `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* A static variable with an incomplete type: 	     that is an error if it is initialized. 	     Otherwise, let it through, but if it is not `extern' 	     then it may cause an error message later.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_error
argument_list|(
literal|"storage size of `%D' isn't known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* An automatic variable with an incomplete type: that is an error. 	     Don't talk about array types here, since we took care of that 	     message in grokdeclarator.  */
name|cp_error
argument_list|(
literal|"storage size of `%D' isn't known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|note_debug_info_needed
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"storage size of `%D' isn't constant"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
comment|/* Cleanups for static variables are handled by `finish_file'.  */
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* PARM_DECLs get cleanups, too.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
name|was_incomplete
operator|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
comment|/* ??? FIXME: What about nested classes?  */
name|int
name|toplev
init|=
name|toplevel_bindings_p
argument_list|()
operator|||
name|pseudo_global_level_p
argument_list|()
decl_stmt|;
name|int
name|was_temp
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|allocation_temporary_p
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Static data in a function with comdat linkage also has comdat          linkage.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Don't mess with __FUNCTION__.  */
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|current_function_decl
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
operator|&&
operator|(
name|DECL_THIS_INLINE
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|current_function_decl
argument_list|)
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Rather than try to get this right with inlining, we suppress 	     inlining of such functions.  */
name|current_function_cannot_inline
operator|=
literal|"function with static variable cannot be inline"
expr_stmt|;
comment|/* If flag_weak, we don't need to mess with this, as we can just 	     make the function weak, and let it refer to its unique local 	     copy.  This works because we don't allow the function to be 	     inlined.  */
if|if
condition|(
operator|!
name|flag_weak
condition|)
block|{
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* else we lose. We can only do this if we can use common,                  which we can't if it has been initialized.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_static_name
argument_list|(
name|current_function_decl
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  you can work around this by removing the initializer"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Set it up again; we might have set DECL_INITIAL since the 	   last time.  */
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|EMPTY_CONSTRUCTOR_P
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplev
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
comment|/* If this variable is really a constant, then fill its DECL_RTL 		 slot with something which won't take up storage. 		 If something later should take its address, we can always give 		 it legitimate RTL at that time.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toplev
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If this is a static const, change its apparent linkage 	         if it belongs to a #pragma interface.  */
if|if
condition|(
operator|!
name|interface_unknown
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|interface_only
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
ifdef|#
directive|ifdef
name|DEFAULT_STATIC_DEFS
comment|/* If this code is dead, then users must 		     explicitly declare static member variables 		     outside the class def'n as well.  */
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Just a constant field.  Should not need any rtl.  */
goto|goto
name|finish_end0
goto|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|core_type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|core_type
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|core_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|core_type
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|core_type
argument_list|)
condition|)
name|signature_error
argument_list|(
name|decl
argument_list|,
name|core_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|signature_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Cleanups for static variables are handled by `finish_file'.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
operator|!=
name|NULL_TREE
operator|||
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|toplev
condition|)
block|{
comment|/* This is a declared decl which must live until the 	     end of the binding contour.  It may need a cleanup.  */
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
block|{
comment|/* Do this here, because we did not expand this decl's 		 rtl in start_decl.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_RTX
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cleanup
condition|)
block|{
comment|/* XXX: Why don't we use decl here?  */
comment|/* Ans: Because it was already expanded? */
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Cleanup used up here.  */
name|cleanup
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_binding_level
operator|->
name|is_for_scope
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|outer
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
comment|/* Check to see if the same name is already bound at 		 the outer level, either because it was directly declared, 		 or because a dead for-decl got preserved.  In either case, 		 the code would not have been valid under the ARM 		 scope rules, so clear is_for_scope for the 		 current_binding_level.  		 Otherwise, we need to preserve the temp slot for decl 		 to last into the outer binding level.  */
name|tree
name|outer_binding
init|=
name|TREE_CHAIN
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outer_binding
operator|&&
name|BINDING_LEVEL
argument_list|(
name|outer_binding
argument_list|)
operator|==
name|outer
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
condition|)
block|{
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|BINDING_VALUE
argument_list|(
name|outer_binding
argument_list|)
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|is_for_scope
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_IN_MEMORY_P
argument_list|(
name|decl
argument_list|)
condition|)
name|preserve_temp_slots
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Compute and store the initial value.  */
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|already_used
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* Set this to 0 so we can tell whether an aggregate which 		 was initialized was ever used.  Don't do this if it has a 		 destructor, so we don't complain about the 'resource 		 allocation is initialization' idiom.  */
comment|/* Now set attribute((unused)) on types so decls of 		 that type will be marked used. (see TREE_USED, above.)  		 This avoids the warning problems this particular code 		 tried to work around. */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|already_used
operator|&&
name|cleanup
operator|==
name|NULL_TREE
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|already_used
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Cleanup any temporaries needed for the initial value.  */
name|expand_end_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Store the cleanup, if there was one.  */
if|if
condition|(
name|cleanup
condition|)
block|{
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|finish_end0
label|:
comment|/* Undo call to `pushclass' that was done in `start_decl' 	 due to initialization of qualified member variable. 	 I.e., Foo::x = 10;  */
block|{
name|tree
name|context
init|=
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* We also have a pushclass done that we need to undo here 		   if we're at top level and declare a method.  */
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
comment|/* If size hasn't been set, we're still defining it, 	       and therefore inside the class body; don't pop 	       the binding level..  */
operator|&&
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|context
operator|==
name|current_class_type
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
block|}
name|finish_end
label|:
comment|/* If requested, warn about definitions of large data objects.  */
if|if
condition|(
name|warn_larger_than
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|decl_size
init|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_size
operator|&&
name|TREE_CODE
argument_list|(
name|decl_size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|units
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|decl_size
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|units
operator|>
name|larger_than_size
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"size of `%s' is %u bytes"
argument_list|,
name|units
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_pop
condition|)
block|{
comment|/* Resume permanent allocation, if not within a function.  */
comment|/* The corresponding push_obstacks_nochange is in start_decl, 	 start_method, groktypename, and in grokfield.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|was_readonly
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is here for a midend callback from c-common.c */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
block|{
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_static_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|decl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|oldstatic
argument_list|)
operator|&&
name|init
operator|!=
name|NULL_TREE
condition|)
name|cp_error
argument_list|(
literal|"multiple initializations given for `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* Emit code to perform this initialization but once.  */
name|tree
name|temp
decl_stmt|;
comment|/* Remember this information until end of file.  */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
comment|/* Emit code to perform this initialization but once.  This code 	 looks like:             static int temp = 0;            if (!temp) {              // Do initialization. 	     temp = 1; 	     // Register variable for destruction at end of program. 	   }  	 Note that the `temp' variable is only set to 1 *after* the 	 initialization is complete.  This ensures that an exception, 	 thrown during the construction, will cause the variable to 	 reinitialized when we pass through this code again, as per: 	  	   [stmt.dcl]  	   If the initialization exits by throwing an exception, the 	   initialization is not complete, so it will be tried again 	   the next time control enters the declaration.           In theory, this process should be thread-safe, too; multiple 	 threads should not be able to initialize the variable more 	 than once.  We don't yet attempt to ensure thread-safety.  */
name|temp
operator|=
name|get_temp_name
argument_list|(
name|integer_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|temp
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Begin the conditional initialization.  */
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|temp
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_start_target_temps
argument_list|()
expr_stmt|;
comment|/* Do the initialization itself.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
operator|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|)
condition|)
block|{
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set TEMP to 1.  */
name|expand_assignment
argument_list|(
name|temp
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cleanup any temporaries needed for the initial value.  If 	 destroying one of the temporaries causes an exception to be 	 thrown, then the object itself has still been fully 	 constructed.  */
name|expand_end_target_temps
argument_list|()
expr_stmt|;
comment|/* Use atexit to register a function for destroying this static 	 variable.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|cleanup
decl_stmt|,
name|fcall
decl_stmt|;
specifier|static
name|tree
name|Atexit
init|=
literal|0
decl_stmt|;
name|int
name|saved_flag_access_control
decl_stmt|;
if|if
condition|(
name|Atexit
operator|==
literal|0
condition|)
block|{
name|tree
name|atexit_fndecl
decl_stmt|,
name|PFV
decl_stmt|,
name|pfvlist
decl_stmt|;
comment|/* Remember this information until end of file.  */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|PFV
operator|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|pfvlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|PFV
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|atexit_fndecl
operator|=
name|builtin_function
argument_list|(
literal|"atexit"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|pfvlist
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|atexit_fndecl
argument_list|)
expr_stmt|;
name|Atexit
operator|=
name|default_conversion
argument_list|(
name|atexit_fndecl
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Call build_cleanup before we enter the anonymous function 	     so that any access checks will be done relative to the 	     current scope, rather than the scope of the anonymous 	     function.  */
name|build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Now start the function.  */
name|cleanup
operator|=
name|start_anon_func
argument_list|()
expr_stmt|;
comment|/* Now, recompute the cleanup.  It may contain SAVE_EXPRs 	     that refer to the original function, rather than the 	     anonymous one.  That will make the back-end think that 	     nested functions are in use, which causes confusion.  */
name|saved_flag_access_control
operator|=
name|flag_access_control
expr_stmt|;
name|flag_access_control
operator|=
literal|0
expr_stmt|;
name|fcall
operator|=
name|build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|flag_access_control
operator|=
name|saved_flag_access_control
expr_stmt|;
comment|/* Finish off the function.  */
name|expand_expr_stmt
argument_list|(
name|fcall
argument_list|)
expr_stmt|;
name|end_anon_func
argument_list|()
expr_stmt|;
comment|/* Call atexit with the cleanup function.  */
name|mark_addressable
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcall
operator|=
name|build_function_call
argument_list|(
name|Atexit
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|fcall
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
comment|/* Resume old (possibly temporary) allocation.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This code takes into account memory allocation policy of 	 `start_decl'.  Namely, if TYPE_NEEDS_CONSTRUCTING does not 	 hold for this object, then we must make permanent the storage 	 currently in the temporary obstack.  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|preserve_initializer
argument_list|()
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 0 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|,
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
specifier|register
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
comment|/* Allocate on the same obstack as TYPE.  */
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|eltsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|/
name|eltsize
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
condition|)
name|maxindex
operator|=
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
expr_stmt|;
else|else
name|maxindex
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|maxindex
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
block|}
name|maxindex
operator|=
name|copy_node
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
else|else
name|initial_value
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|tree
name|itype
decl_stmt|;
name|tree
name|domain
decl_stmt|;
name|domain
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|domain
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|domain
expr_stmt|;
if|if
condition|(
name|initial_value
condition|)
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
expr_stmt|;
else|else
name|itype
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|itype
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|itype
argument_list|)
condition|)
name|TYPE_DOMAIN
argument_list|(
name|itype
argument_list|)
operator|=
name|domain
expr_stmt|;
comment|/* The type of the main variant should never be used for arrays 	 of different sizes.  It should only ever be completed with the 	 size of the array.  */
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|TYPE_DOMAIN
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|domain
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return zero if something is declared to be a member of type    CTYPE when in the context of CUR_TYPE.  STRING is the error    message to print in that case.  Otherwise, quietly return 1.  */
end_comment

begin_function
specifier|static
name|int
name|member_function_or_else
parameter_list|(
name|ctype
parameter_list|,
name|cur_type
parameter_list|,
name|string
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cur_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|ctype
operator|&&
name|ctype
operator|!=
name|cur_type
condition|)
block|{
name|error
argument_list|(
name|string
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `grokdeclarator'.  */
end_comment

begin_comment
comment|/* Generate errors possibly applicable for a given set of specifiers.    This is for ARM $7.1.2.  */
end_comment

begin_function
specifier|static
name|void
name|bad_specifiers
parameter_list|(
name|object
parameter_list|,
name|type
parameter_list|,
name|virtualp
parameter_list|,
name|quals
parameter_list|,
name|inlinep
parameter_list|,
name|friendp
parameter_list|,
name|raises
parameter_list|)
name|tree
name|object
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|quals
decl_stmt|,
name|friendp
decl_stmt|,
name|raises
decl_stmt|,
name|inlinep
decl_stmt|;
block|{
if|if
condition|(
name|virtualp
condition|)
name|cp_error
argument_list|(
literal|"`%D' declared as a `virtual' %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|cp_error
argument_list|(
literal|"`%D' declared as an `inline' %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
name|cp_error
argument_list|(
literal|"`const' and `volatile' function specifiers on `%D' invalid in %s declaration"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|friendp
condition|)
name|cp_error_at
argument_list|(
literal|"invalid friend declaration"
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|cp_error_at
argument_list|(
literal|"invalid exception specifications"
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CTYPE is class type, or null if non-class.    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE    or METHOD_TYPE.    DECLARATOR is the function's name.    VIRTUALP is truthvalue of whether the function is virtual or not.    FLAGS are to be passed through to `grokclassfn'.    QUALS are qualifiers indicating whether the function is `const'    or `volatile'.    RAISES is a list of exceptions that this function can raise.    CHECK is 1 if we must find this method in CTYPE, 0 if we should    not look, and -1 if we should not call `grokclassfn' at all.       Returns `NULL_TREE' if something goes wrong, after issuing    applicable error messages.  */
end_comment

begin_function
specifier|static
name|tree
name|grokfndecl
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|,
name|declarator
parameter_list|,
name|orig_declarator
parameter_list|,
name|virtualp
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|,
name|raises
parameter_list|,
name|check
parameter_list|,
name|friendp
parameter_list|,
name|publicp
parameter_list|,
name|inlinep
parameter_list|,
name|funcdef_flag
parameter_list|,
name|template_count
parameter_list|,
name|in_namespace
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|tree
name|orig_declarator
decl_stmt|;
name|int
name|virtualp
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|check
decl_stmt|,
name|friendp
decl_stmt|,
name|publicp
decl_stmt|,
name|inlinep
decl_stmt|,
name|funcdef_flag
decl_stmt|,
name|template_count
decl_stmt|;
name|tree
name|in_namespace
decl_stmt|;
block|{
name|tree
name|cname
decl_stmt|,
name|decl
decl_stmt|;
name|int
name|staticp
init|=
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
decl_stmt|;
name|int
name|has_default_arg
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|ctype
condition|)
name|cname
operator|=
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TYPE_IDENTIFIER
argument_list|(
name|ctype
argument_list|)
else|:
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
else|else
name|cname
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|type
operator|=
name|build_exception_variant
argument_list|(
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Propagate volatile out from type to decl. */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this decl has namespace scope, set that up.  */
if|if
condition|(
name|in_namespace
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|in_namespace
argument_list|,
name|friendp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|publicp
operator|&&
operator|!
name|ctype
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* `main' and builtins have implicit 'C' linkage.  */
if|if
condition|(
operator|(
name|MAIN_NAME_P
argument_list|(
name|declarator
argument_list|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
name|ctype
operator|==
name|NULL_TREE
comment|/* NULL_TREE means global namespace.  */
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|=
name|lang_c
expr_stmt|;
comment|/* Should probably propagate const out from type to decl I bet (mrs).  */
if|if
condition|(
name|staticp
condition|)
block|{
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
if|if
condition|(
name|ctype
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|DECL_MAIN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|error
argument_list|(
literal|"cannot declare `main' to be a template"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|error
argument_list|(
literal|"cannot declare `main' to be inline"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|publicp
condition|)
name|error
argument_list|(
literal|"cannot declare `main' to be static"
argument_list|)
expr_stmt|;
name|inlinep
operator|=
literal|0
expr_stmt|;
name|publicp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Members of anonymous types and local classes have no linkage; make      them internal.  */
if|if
condition|(
name|ctype
operator|&&
operator|(
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|||
name|hack_decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|)
condition|)
name|publicp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|publicp
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the name of a class 	 or enumeration declared in a local scope) shall not be used to 	 declare an entity with linkage.  	 Only check this for public decls for now.  */
name|t
operator|=
name|no_linkage_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
comment|/* Allow this; it's pretty common in C.  */
empty_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"non-local function `%#D' uses anonymous type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_pedwarn
argument_list|(
literal|"non-local function `%#D' uses local type `%T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|publicp
expr_stmt|;
if|if
condition|(
operator|!
name|publicp
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inlinep
condition|)
name|DECL_THIS_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"%smember function `%D' cannot have `%T' method qualifier"
argument_list|,
operator|(
name|ctype
condition|?
literal|"static "
else|:
literal|"non-"
operator|)
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|decl
argument_list|,
name|virtualp
argument_list|,
name|check
operator|<
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|hack_decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|has_default_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|friendp
operator|&&
name|TREE_CODE
argument_list|(
name|orig_declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
name|funcdef_flag
condition|)
name|cp_error
argument_list|(
literal|"defining explicit specialization `%D' in friend declaration"
argument_list|,
name|orig_declarator
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
block|{
comment|/* Something like `template<class T> friend void f<T>()'.  */
name|cp_error
argument_list|(
literal|"template-id `%D' in declaration of primary template"
argument_list|,
name|orig_declarator
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* A friend declaration of the form friend void f<>().  Record 	     the information in the TEMPLATE_ID_EXPR.  */
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|orig_declarator
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|orig_declarator
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_default_arg
condition|)
block|{
name|cp_error
argument_list|(
literal|"default arguments are not allowed in declaration of friend template specialization `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|cp_error
argument_list|(
literal|"`inline' is not allowed in declaration of friend template specialization `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|}
if|if
condition|(
name|has_default_arg
condition|)
name|add_defarg_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Plain overloading: will not be grok'd by grokclassfn.  */
if|if
condition|(
operator|!
name|ctype
operator|&&
operator|!
name|processing_template_decl
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|!=
name|lang_c
operator|&&
operator|(
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|||
name|name_mangling_version
operator|<
literal|1
operator|)
condition|)
name|set_mangled_name_for_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
comment|/* Make the init_value nonzero so pushdecl knows this is not        tentative.  error_mark_node is replaced later with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Caller will do the rest of this.  */
if|if
condition|(
name|check
operator|<
literal|0
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|check
operator|&&
name|funcdef_flag
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|cname
argument_list|)
operator|==
name|declarator
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Just handle constructors here.  We could do this 	 inside the following if stmt, but I think 	 that the code is more legible by breaking this 	 case out.  See comments below for what each of 	 the following calls is supposed to do.  */
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|check_explicit_specialization
argument_list|(
name|orig_declarator
argument_list|,
name|decl
argument_list|,
name|template_count
argument_list|,
literal|2
operator|*
operator|(
name|funcdef_flag
operator|!=
literal|0
operator|)
operator|+
literal|4
operator|*
operator|(
name|friendp
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|maybe_vlist_ctor_wrapper
argument_list|(
name|decl
argument_list|,
name|funcdef_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|ctype
argument_list|)
operator|||
name|check_java_method
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|check
condition|)
block|{
name|tmp
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|tmp
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|tmp
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"definition of implicitly-declared `%D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
condition|)
return|return
name|tmp
return|;
block|}
if|if
condition|(
operator|!
name|grok_ctor_properties
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Function gets the ugly name, field gets the nice one. 	 This call may change the type of the function (because 	 of default parameters)!  */
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|check_explicit_specialization
argument_list|(
name|orig_declarator
argument_list|,
name|decl
argument_list|,
name|template_count
argument_list|,
literal|2
operator|*
operator|(
name|funcdef_flag
operator|!=
literal|0
operator|)
operator|+
literal|4
operator|*
operator|(
name|friendp
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|ctype
argument_list|)
operator|||
name|check_java_method
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|check
condition|)
block|{
name|tmp
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|tmp
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Remove the `this' parm added by grokclassfn. 	         XXX Isn't this done in start_function, too?  */
name|revert_static_member_fn
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|tmp
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"definition of implicitly-declared `%D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* Attempt to merge the declarations.  This can fail, in 		 the case of some illegal specialization declarations.  */
if|if
condition|(
operator|!
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"no `%#D' member function declared in class `%T'"
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|||
name|check
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|virtualp
condition|)
block|{
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|grokvardecl
parameter_list|(
name|type
parameter_list|,
name|declarator
parameter_list|,
name|specbits_in
parameter_list|,
name|initialized
parameter_list|,
name|constp
parameter_list|,
name|in_namespace
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|RID_BIT_TYPE
modifier|*
name|specbits_in
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|tree
name|in_namespace
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|RID_BIT_TYPE
name|specbits
decl_stmt|;
name|specbits
operator|=
operator|*
name|specbits_in
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* If you declare a static member so that it 	 can be initialized, the code will reach here.  */
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_static_name
argument_list|(
name|basetype
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|in_namespace
condition|)
name|context
operator|=
name|in_namespace
expr_stmt|;
elseif|else
if|if
condition|(
name|namespace_bindings_p
argument_list|()
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
name|context
operator|=
name|current_namespace
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|context
operator|&&
name|current_lang_name
operator|!=
name|lang_name_c
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_static_name
argument_list|(
name|context
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_namespace
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|in_namespace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
comment|/* In class context, static means one per class,      public access, and static storage.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* At top level, either `static' or no s.c. makes a definition      (perhaps tentative), and absence of `static' makes it public.  */
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|RIDBIT_NOTSETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|&&
operator|(
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|constp
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the name of a class 	 or enumeration declared in a local scope) shall not be used to 	 declare an entity with linkage.  	 Only check this for public decls for now.  */
name|tree
name|t
init|=
name|no_linkage_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
comment|/* Ignore for now; `enum { foo } e' is pretty common.  */
empty_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"non-local variable `%#D' uses local type `%T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create and return a canonical pointer to member function type, for    TYPE, which is a POINTER_TYPE to a METHOD_TYPE.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
index|[
literal|4
index|]
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|u
decl_stmt|;
comment|/* If a canonical type already exists for this type, use it.  We use      this method instead of type_hash_canon, because it only does a      simple equality check on the list of field members.  */
if|if
condition|(
operator|(
name|t
operator|=
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|make_lang_type
argument_list|(
name|UNION_TYPE
argument_list|)
expr_stmt|;
name|SET_IS_AGGR_TYPE
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta2_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|u
argument_list|,
literal|"__ptrmemfunc_type"
argument_list|,
name|fields
argument_list|,
literal|1
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|u
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|t
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Let the front-end know this is a pointer to member function...  */
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ... and not really an aggregate.  */
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|index_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_or_delta2_identifier
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|t
argument_list|,
literal|"__ptrmemfunc_type"
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Zap out the name so that the back-end will give us the debugging      information for this anonymous RECORD_TYPE.  */
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_SET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Seems to be wanted.  */
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL defined in-class, whose TYPE is also given.    Check to see that the definition is valid.  Issue appropriate error    messages.  Return 1 if the definition is particularly bad, or 0    otherwise.  */
end_comment

begin_function
name|int
name|check_static_variable_definition
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
comment|/* Motion 10 at San Diego: If a static const integral data member is      initialized with an integral constant expression, the initializer      may appear either in the declaration (within the class), or in      the definition, but not both.  If it appears in the class, the      member is a member constant.  The file-scope definition is always      required.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"in-class initialization of static data member of non-integral type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If we just return the declaration, crashes will sometimes 	 occur.  We therefore return void_type_node, as if this was a 	 friend declaration, to cause callers to completely ignore 	 this declaration.  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"ANSI C++ forbids in-class initialization of non-const static member `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids initialization of member constant `%D' of non-integral type `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      MEMFUNCDEF for a function definition.  Like FUNCDEF but prepares to       handle member functions (which have FIELD context).       Return value may be zero meaning this definition is too screwy to       try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      CATCHPARM for a parameter declaration before a catch clause.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.      BITFIELD for a field with specified width.    INITIALIZED is 1 if the decl has an initializer.     ATTRLIST is a TREE_LIST node with prefix attributes in TREE_VALUE and    normal attributes in TREE_PURPOSE, or NULL_TREE.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.     For C++, if there is any monkey business to do, the function which    calls this one must do it, i.e., prepending instance variables,    renaming overloaded function names, etc.     Note that for this C++, it is an error to define a method within a class    which does not belong to that class.     Except in the case where SCOPE_REFs are implicitly known (such as    methods within a class being redundantly qualified),    declarations which involve SCOPE_REFs are returned as SCOPE_REFs    (class_name::decl_name).  The caller must also deal with this.     If a constructor or destructor is seen, and the context is FIELD,    then the type gains the attribute TREE_HAS_x.  If such a declaration    is erroneous, NULL_TREE is returned.     QUALS is used only for FUNCDEF and MEMFUNCDEF cases.  For a member    function, these are the qualifiers to give to the `this' pointer.     May return void_type_node if the declarator turned out to be a friend.    See grokfield for details.  */
end_comment

begin_enum
enum|enum
name|return_types
block|{
name|return_normal
block|,
name|return_ctor
block|,
name|return_dtor
block|,
name|return_conversion
block|}
enum|;
end_enum

begin_function
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|,
name|attrlist
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|attrlist
decl_stmt|;
block|{
name|RID_BIT_TYPE
name|specbits
decl_stmt|;
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|restrictp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|explicitp
decl_stmt|,
name|friendp
decl_stmt|,
name|inlinep
decl_stmt|,
name|staticp
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|int
name|defaulted_int
init|=
literal|0
decl_stmt|;
name|int
name|opaque_typedef
init|=
literal|0
decl_stmt|;
name|tree
name|typedef_decl
init|=
name|NULL_TREE
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
name|int
name|bitfield
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
comment|/* See the code below that used this.  */
block|tree decl_machine_attr = NULL_TREE;
endif|#
directive|endif
comment|/* Set this to error_mark_node for FIELD_DECLs we could not handle properly.      All FIELD_DECLs we build here have `init' put into their DECL_INITIAL.  */
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Keep track of what sort of function is being processed      so that we can warn about default return values, or explicit      return values which do not match prescribed defaults.  */
name|enum
name|return_types
name|return_type
init|=
name|return_normal
decl_stmt|;
name|tree
name|dname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctype
init|=
name|current_class_type
decl_stmt|;
name|tree
name|ctor_return_type
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|overload_flags
name|flags
init|=
name|NO_SPECIAL
decl_stmt|;
name|tree
name|quals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|raises
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_count
init|=
literal|0
decl_stmt|;
name|tree
name|in_namespace
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|inner_attrs
decl_stmt|;
name|int
name|ignore_attrs
decl_stmt|;
name|RIDBIT_RESET_ALL
argument_list|(
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|MEMFUNCDEF
condition|)
name|funcdef_flag
operator|=
operator|-
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|BITFIELD
condition|)
name|bitfield
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
name|tree
modifier|*
name|next
init|=
operator|&
name|declarator
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next
operator|&&
operator|*
name|next
condition|)
block|{
name|decl
operator|=
operator|*
name|next
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TREE_LIST
case|:
comment|/* For attributes.  */
name|next
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* For C++ destructors!  */
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rename
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|152
argument_list|)
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|return_type
operator|=
name|return_dtor
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|name
operator|=
name|constructor_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|153
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"destructors must be member functions"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|NO_SPECIAL
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|current_class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|rename
condition|)
block|{
name|cp_error
argument_list|(
literal|"destructor `%T' must match class name `%T'"
argument_list|,
name|name
argument_list|,
name|rename
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|rename
expr_stmt|;
block|}
name|next
operator|=
operator|&
name|name
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* C++ reference declaration */
comment|/* Fall through. */
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|parmlist_is_exprlist
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is actually a variable declaration using 		   constructor syntax.  We need to call start_decl and 		   cp_finish_decl so we can get the variable 		   initialized...  */
name|tree
name|attributes
decl_stmt|,
name|prefix_attributes
decl_stmt|;
operator|*
name|next
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrlist
condition|)
block|{
name|attributes
operator|=
name|TREE_PURPOSE
argument_list|(
name|attrlist
argument_list|)
expr_stmt|;
name|prefix_attributes
operator|=
name|TREE_VALUE
argument_list|(
name|attrlist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
name|prefix_attributes
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|1
argument_list|,
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
comment|/* Look for __unused__ attribute */
if|if
condition|(
name|TREE_USED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"invalid declarator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
operator|)
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
operator|*
name|next
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|flags
operator|!=
name|DTOR_FLAG
operator|&&
name|decl
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|fns
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dname
operator|=
name|fns
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|dname
operator|=
name|TREE_OPERAND
argument_list|(
name|dname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|dname
argument_list|)
argument_list|,
literal|19990331
argument_list|)
expr_stmt|;
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through. */
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|dname
operator|=
name|decl
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_rid
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"declarator-id missing; using reserved word `%D'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IDENTIFIER_OPNAME_P
argument_list|(
name|dname
argument_list|)
comment|/* GNU/Linux headers use '__op'.  Arrgh.  */
operator|||
operator|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|dname
argument_list|)
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|dname
argument_list|)
operator|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|154
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TYPENAME_FLAG
expr_stmt|;
name|ctor_return_type
operator|=
name|TREE_TYPE
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|return_type
operator|=
name|return_conversion
expr_stmt|;
block|}
name|name
operator|=
name|operator_name_string
argument_list|(
name|dname
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* C++ extension */
case|case
name|SCOPE_REF
case|:
block|{
comment|/* Perform error checking, and decide on a ctype.  */
name|tree
name|cname
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|in_namespace
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Must test TREE_OPERAND (decl, 1), in case user gives 		 us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */
elseif|else
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|ctype
operator|=
name|cname
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T::%D' is not a valid declarator"
argument_list|,
name|cname
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  perhaps you want `typename %T::%D' to make it a type"
argument_list|,
name|cname
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|cname
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_depth
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|cname
argument_list|,
name|ctype
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' is not derived from type `%T'"
argument_list|,
name|cname
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|ctype
operator|=
name|cname
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
operator|)
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
operator|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|=
operator|*
name|next
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|decl
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|||
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|return_type
operator|=
name|return_dtor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ERROR_MARK
case|:
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Parse error puts this typespec where 	       a declarator should go.  */
name|cp_error
argument_list|(
literal|"`%T' specified as declarator-id"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
condition|)
name|cp_error
argument_list|(
literal|"  perhaps you want `%T' for a constructor"
argument_list|,
name|current_class_name
argument_list|)
expr_stmt|;
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
comment|/* Avoid giving two errors for this.  */
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|dname
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|declspecs
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|dname
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|cp_compiler_error
argument_list|(
literal|"`%D' as declarator"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* We used to do a 155 abort here.  */
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|(
name|dname
operator|&&
name|IDENTIFIER_OPNAME_P
argument_list|(
name|dname
argument_list|)
operator|)
operator|||
name|flags
operator|==
name|TYPENAME_FLAG
operator|)
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
operator|&&
operator|!
operator|(
name|ctype
operator|&&
name|declspecs
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as non-function"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* This heuristic cannot be applied to C++ nodes! Fixed, however,      by not allowing C++ class definitions to specify their parameters      with xdecls (must be spec.d in the parmlist).       Since we now wait to push a class scope until we are sure that      we are in a legitimate method context, we must set oldcname      explicitly (since current_class_name is not yet alive).       We also want to avoid calling this a PARM if it is in a namespace.  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
operator|!
name|namespace_bindings_p
argument_list|()
operator|&&
operator|!
name|pseudo_global_level_p
argument_list|()
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
literal|0
operator|&&
name|toplevel_bindings_p
argument_list|()
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT if the type is `int' or `char' and did not      come from a user typedef.       Set LONGLONG if `long' is mentioned twice.       For C++, constructors and destructors have their own fast treatment.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|id
decl_stmt|;
comment|/* Certain parse errors slip through.  For example, 	 `int class;' is not caught by the parser. Try 	 weakly to recover here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|0
return|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BOOL
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BOOL
index|]
condition|)
name|error
argument_list|(
literal|"`bool' is now a keyword"
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"extraneous `%T' ignored"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
name|explicit_int
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
name|explicit_char
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* C++ aggregate types.  */
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|cp_error
argument_list|(
literal|"multiple declarations `%T' and `%T'"
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|RID_FIRST_MODIFIER
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|RID_LAST_MODIFIER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
name|i
index|]
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_LONG
operator|&&
name|RIDBIT_SETP
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ does not support `long long'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|longlong
condition|)
name|error
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|RIDBIT_SET
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
comment|/* C++ aggregate types.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|cp_error
argument_list|(
literal|"multiple declarations `%T' and `%T'"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See the code below that used this.  */
block|decl_machine_attr = DECL_MACHINE_ATTRIBUTES (id);
endif|#
directive|endif
name|typedef_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|!=
name|error_mark_node
condition|)
comment|/* Can't change CLASS nodes into RECORD nodes here!  */
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
comment|/* No type at all: default to `int', and set DEFAULTED_INT      because it was not a user-defined typedef.      Except when we have a `typedef' inside a signature, in      which case the type defaults to `unknown type' and is      instantiated when assigning to a signature pointer or ref.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
block|{
comment|/* These imply 'int'.  */
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|defaulted_int
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
name|explicit_int
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_conversion
condition|)
name|type
operator|=
name|ctor_return_type
expr_stmt|;
elseif|else
if|if
condition|(
name|current_class_type
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|&&
operator|(
name|decl_context
operator|==
name|FIELD
operator|||
name|decl_context
operator|==
name|NORMAL
operator|)
condition|)
block|{
name|explicit_int
operator|=
literal|0
expr_stmt|;
name|opaque_typedef
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|copy_node
argument_list|(
name|opaque_type_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We handle `main' specially here, because 'main () { }' is so 	     common.  With no options, it is allowed.  With -Wreturn-type, 	     it is a warning.  It is only an error with -pedantic-errors.  */
name|int
name|is_main
init|=
operator|(
name|funcdef_flag
operator|&&
name|MAIN_NAME_P
argument_list|(
name|dname
argument_list|)
operator|&&
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|in_namespace
operator|==
name|NULL_TREE
operator|&&
name|current_namespace
operator|==
name|global_namespace
operator|)
decl_stmt|;
if|if
condition|(
name|in_system_header
condition|)
comment|/* Allow it, sigh.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|||
operator|!
name|is_main
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids declaration `%D' with no type"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_return_type
condition|)
name|cp_warning
argument_list|(
literal|"ANSI C++ forbids declaration `%D' with no type"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
block|{
name|error
argument_list|(
literal|"return type specification for destructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
block|{
name|error
argument_list|(
literal|"return type specification for constructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_conversion
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|ctor_return_type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"operator `%T' declared to return `%T'"
argument_list|,
name|ctor_return_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"return type specified for `operator %T'"
argument_list|,
name|ctor_return_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctor_return_type
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_qualified_type
argument_list|(
name|long_double_type_node
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"long and short specified together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"long or short specified with floating type for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"signed and unsigned given together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|defaulted_int
operator|&&
operator|!
name|explicit_char
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_COMPLEX
argument_list|,
name|specbits
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"complex invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_COMPLEX
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bitfields as signed by default.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|(
name|explicit_int
operator|||
name|defaulted_int
operator|||
name|explicit_char
comment|/* A typedef for plain `int' without `signed' 		 can be controlled just like plain `int'.  */
operator|||
operator|!
operator|(
name|typedef_decl
operator|!=
name|NULL_TREE
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_COMPLEX
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
comment|/* If we just have "complex", it is equivalent to 	 "complex double", but if any modifiers at all are specified it is 	 the complex form of TYPE.  E.g, "complex short" is 	 "complex short int".  */
if|if
condition|(
name|defaulted_int
operator|&&
operator|!
name|longlong
operator|&&
operator|!
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
name|type
operator|=
name|complex_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|complex_float_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|type
operator|=
name|complex_long_double_type_node
expr_stmt|;
else|else
name|type
operator|=
name|build_complex_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|return_type
operator|==
name|return_conversion
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_CONST
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_VOLATILE
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_RESTRICT
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
name|cp_error
argument_list|(
literal|"qualifiers are not allowed on declaration of `operator %T'"
argument_list|,
name|ctor_return_type
argument_list|)
expr_stmt|;
comment|/* Set CONSTP if this declaration is `const', whether by      explicit specification or via a typedef.      Likewise for VOLATILEP.  */
name|constp
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_CONST
argument_list|,
name|specbits
argument_list|)
operator|+
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|restrictp
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_RESTRICT
argument_list|,
name|specbits
argument_list|)
operator|+
name|CP_TYPE_RESTRICT_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_VOLATILE
argument_list|,
name|specbits
argument_list|)
operator|+
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|virtualp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_VIRTUAL
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_VIRTUAL
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|explicitp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_EXPLICIT
argument_list|,
name|specbits
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXPLICIT
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|staticp
operator|=
literal|1
operator|+
operator|(
name|decl_context
operator|==
name|FIELD
operator|)
expr_stmt|;
if|if
condition|(
name|virtualp
operator|&&
name|staticp
operator|==
literal|2
condition|)
block|{
name|cp_error
argument_list|(
literal|"member `%D' cannot be declared both virtual and static"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
name|friendp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
comment|/* $7.1.2, Function specifiers */
if|if
condition|(
name|friendp
operator|&&
name|explicitp
condition|)
name|error
argument_list|(
literal|"only declarations of constructors can be `explicit'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|error
argument_list|(
literal|"non-member `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
operator|||
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
name|error
argument_list|(
literal|"non-object member `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Warn if two storage classes are given. Default to `auto'.  */
if|if
condition|(
name|RIDBIT_ANY_SET
argument_list|(
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|nclasses
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in parameter declarations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|error
argument_list|(
literal|"typedef declaration invalid in parameter declaration"
argument_list|)
expr_stmt|;
name|nclasses
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
block|}
comment|/* Give error if `virtual' is used outside of class declaration.  */
if|if
condition|(
name|virtualp
operator|&&
operator|(
name|current_class_name
operator|==
name|NULL_TREE
operator|||
name|decl_context
operator|!=
name|FIELD
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"virtual outside class declaration"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current_class_name
operator|==
name|NULL_TREE
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"only members can be declared mutable"
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
comment|/* Static anonymous unions are dealt with here.  */
if|if
condition|(
name|staticp
operator|&&
name|decl_context
operator|==
name|TYPENAME
operator|&&
name|TREE_CODE
argument_list|(
name|declspecs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
condition|)
name|decl_context
operator|=
name|FIELD
expr_stmt|;
comment|/* Give error if `const,' `volatile,' `inline,' `friend,' or `virtual'      is used in a signature member function declaration.  */
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|error
argument_list|(
literal|"type qualifiers specified for signature member function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|error
argument_list|(
literal|"`inline' specified for signature member function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Later, we'll make signature member functions inline.  */
name|inlinep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"`friend' declaration in signature definition"
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"`virtual' specified for signature member function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Later, we'll make signature member functions virtual.  */
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Warn about storage classes that are invalid for certain      kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
operator|)
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
comment|/* C++ allows static class elements  */
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
comment|/* C++ also allows inlines and signed and unsigned elements,  	   but in those cases we don't come in here.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|int
name|op
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|declarator
condition|)
block|{
comment|/* Avoid trying to get an operand off an identifier node.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|tmp
operator|=
name|declarator
expr_stmt|;
else|else
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|IDENTIFIER_OPNAME_P
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"storage class specified for %s `%s'"
argument_list|,
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|?
operator|(
name|op
condition|?
literal|"signature member operator"
else|:
literal|"signature member function"
operator|)
else|:
operator|(
name|op
condition|?
literal|"member operator"
else|:
literal|"field"
operator|)
argument_list|,
name|op
condition|?
name|operator_name_string
argument_list|(
name|tmp
argument_list|)
else|:
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
operator|(
operator|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
operator|)
condition|?
literal|"storage class specified for parameter `%s'"
else|:
literal|"storage class specified for typename"
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* It's common practice (and completely valid) to have a const 	     be initialized and declared extern.  */
if|if
condition|(
operator|!
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|funcdef_flag
operator|&&
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"nested function `%s' declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nclasses
operator|>
literal|0
operator|&&
name|friendp
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in friend function declarations"
argument_list|)
expr_stmt|;
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
name|inner_attrs
operator|=
name|NULL_TREE
expr_stmt|;
name|ignore_attrs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 For C++ it could also be 	 a SCOPE_REF (for class :: ...).  In this case, we have converted 	 sensible names to types, and those are the values we use to 	 qualify the member name. 	 an ADDR_EXPR (for&...), 	 a BIT_NOT_EXPR (for destructors)  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|declarator
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|SCOPE_REF
operator|)
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|ctype
operator|=
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* See the comment for the TREE_LIST case, below.  */
if|if
condition|(
name|ignore_attrs
condition|)
name|ignore_attrs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|inner_attrs
condition|)
block|{
name|decl_attributes
argument_list|(
name|type
argument_list|,
name|inner_attrs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|inner_attrs
operator|=
name|NULL_TREE
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
case|case
name|TREE_LIST
case|:
block|{
comment|/* We encode a declarator with embedded attributes using 	       a TREE_LIST.  The attributes apply to the declarator 	       directly inside them, so we have to skip an iteration 	       before applying them to the type.  If the declarator just 	       inside is the declarator-id, we apply the attrs to the 	       decl itself.  */
name|inner_attrs
operator|=
name|TREE_PURPOSE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|ignore_attrs
operator|=
literal|1
expr_stmt|;
name|declarator
operator|=
name|TREE_VALUE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_REF
case|:
block|{
specifier|register
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* The index is a signed object `sizetype' bits wide.  */
name|tree
name|index_type
init|=
name|signed_type
argument_list|(
name|sizetype
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of voids"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of functions"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* ARM $8.4.3: Since you can't have a pointer to a reference, 	       you can't have arrays of references.  If we allowed them, 	       then we'd be saying x[i] is valid for an array x, but 	       then you'd have to ask: what does `*(x + i)' mean?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
name|cp_error
argument_list|(
literal|"cannot make arrays of references"
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of references"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of data members"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of function members"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* [dcl.array]  		   the constant expressions that specify the bounds of 		   the arrays can be omitted only for the first member 		   of the sequence.  */
name|cp_error
argument_list|(
literal|"declaration of `%D' as multidimensional array"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"must have bounds for all dimensions except the first"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* VC++ spells a zero-sized array with [].  */
if|if
condition|(
name|size
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
operator|!
name|staticp
operator|&&
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
name|size
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
comment|/* Must suspend_momentary here because the index 		   type may need to live until the end of the function. 		   For example, it is used in the declaration of a 		   variable which requires destructing at the end of 		   the function; then build_vec_delete will need this 		   value.  */
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
comment|/* Might be a cast. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|size
operator|=
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this involves a template parameter, it will be a 		   constant at instantiation time, but we don't know 		   what the value is yet.  Even if no template 		   parameters are involved, we may an expression that 		   is not a constant; we don't even simplify `1 + 2' 		   when processing a template.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* Resolve a qualified reference to an enumerator or 		       static const data member of ours.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_type
condition|)
block|{
name|tree
name|t
init|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|size
operator|=
name|t
expr_stmt|;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|build_min
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|dont_grok_size
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"size of array `%D' has non-integer type"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
name|decl_constant_value
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids zero-size array `%D'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|int
name|old_flag_pedantic_errors
init|=
name|flag_pedantic_errors
decl_stmt|;
name|int
name|old_pedantic
init|=
name|pedantic
decl_stmt|;
name|pedantic
operator|=
name|flag_pedantic_errors
operator|=
literal|1
expr_stmt|;
comment|/* Always give overflow errors on array subscripts.  */
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|pedantic
operator|=
name|old_pedantic
expr_stmt|;
name|flag_pedantic_errors
operator|=
name|old_flag_pedantic_errors
expr_stmt|;
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|size
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"size of array `%D' is negative"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|dname
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids variable-size array `%D'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids variable-size array"
argument_list|)
expr_stmt|;
block|}
block|}
name|itype
operator|=
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|index_type
argument_list|,
name|size
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|index_type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|itype
argument_list|)
condition|)
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"overflow in array dimension"
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we're a parm, we need to have a permanent type so                    mangling checks for re-use will work right.  If both the                    element and index types are permanent, the array type                    will be, too.  */
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|allocation_temporary_p
argument_list|()
operator|&&
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|dont_grok_size
label|:
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|arg_types
decl_stmt|;
name|int
name|funcdecl_p
decl_stmt|;
name|tree
name|inner_parms
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Declaring a function type. 	       Make sure we have a valid type for the function to return.  */
comment|/* We now know that the TYPE_QUALS don't apply to the                decl, but to its return type.  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|inner_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|inner_decl
operator|=
name|dname
expr_stmt|;
comment|/* Pick up type qualifiers which should be applied to `this'.  */
name|quals
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Pick up the exception specifications.  */
name|raises
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
comment|/* Say it's a definition only for the CALL_EXPR 	       closest to the identifier.  */
name|funcdecl_p
operator|=
name|inner_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
name|funcdecl_p
operator|&&
operator|(
name|friendp
operator|==
literal|0
operator|||
name|dname
operator|==
name|current_class_name
operator|)
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|return_type
operator|==
name|return_conversion
condition|)
name|TYPE_HAS_CONVERSION
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|dname
condition|)
block|{
comment|/* We are within a class's scope. If our declarator name 		   is the same as the class name, and we are defining 		   a function, then it is a constructor/destructor, and 		   therefore returns a void type.  */
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 12.4.1.  A destructor may 		       not be declared const or volatile.  A destructor 		       may not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"destructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
block|{
name|cp_error
argument_list|(
literal|"destructors may not be `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"destructor for alien class `%s' cannot be a member"
argument_list|)
condition|)
return|return
name|void_type_node
return|;
block|}
block|}
else|else
comment|/* It's a constructor.  */
block|{
if|if
condition|(
name|explicitp
operator|==
literal|1
condition|)
name|explicitp
operator|=
literal|2
expr_stmt|;
comment|/* ANSI C++ June 5 1992 WP 12.1.2.  A constructor may 		       not be declared const or volatile.  A constructor may 		       not be virtual.  A constructor may not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"constructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
name|pedwarn
argument_list|(
literal|"constructors cannot be declared virtual"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|quals
condition|)
block|{
name|cp_error
argument_list|(
literal|"constructors may not be `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|{
name|RID_BIT_TYPE
name|tmp_bits
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|specbits
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|RID_BIT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_INLINE
argument_list|,
name|tmp_bits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|tmp_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_ANY_SET
argument_list|(
name|tmp_bits
argument_list|)
condition|)
name|error
argument_list|(
literal|"return value type specifier for constructor ignored"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_pointer_type
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"constructor not allowed in signature"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"constructor for alien class `%s' cannot be member"
argument_list|)
condition|)
return|return
name|void_type_node
return|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|return_type
operator|!=
name|return_ctor
condition|)
return|return
name|NULL_TREE
return|;
block|}
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|initialized
condition|)
name|error
argument_list|(
literal|"can't initialize friend function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
comment|/* Cannot be both friend and virtual.  */
name|error
argument_list|(
literal|"virtual functions cannot be friends"
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
condition|)
name|error
argument_list|(
literal|"friend declaration not in class definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|funcdef_flag
condition|)
name|cp_error
argument_list|(
literal|"can't define friend function `%s' in a local class definition"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the function type and go to the next 	       inner layer of declarator.  */
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: This is where default args should be fully 	       processed.  */
name|arg_types
operator|=
name|grokparms
argument_list|(
name|inner_parms
argument_list|,
name|funcdecl_p
condition|?
name|funcdef_flag
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
comment|/* A destructor declared in the body of a class will 		   be represented as a BIT_NOT_EXPR.  But, we just 		   want the underlying IDENTIFIER.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_prototype
operator|==
literal|0
operator|&&
name|arg_types
operator|==
name|NULL_TREE
condition|)
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
elseif|else
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
name|arg_types
operator|!=
name|void_list_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"destructors may not have parameters"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
name|last_function_parms
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* ANSI says that `const int foo ();' 	       does not make the function foo const.  */
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|arg_types
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|add_defarg_fn
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
comment|/* Filter out pointers-to-references and references-to-references. 	     We can get these if a TYPE_DECL is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare %s to references"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"references"
else|:
literal|"pointers"
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot declare pointer to `%#T' member"
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
comment|/* We now know that the TYPE_QUALS don't apply to the decl, 	     but to the target of the pointer.  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"empty signature `%T' used in signature reference declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|type = build_signature_reference_type (type);
else|#
directive|else
name|sorry
argument_list|(
literal|"signature reference"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"empty signature `%T' used in signature pointer declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_signature_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|error
argument_list|(
literal|"invalid type: `void&'"
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords (such as 	     const or volatile) that were given inside the `*' or `&'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|restrictp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
name|tree
name|qualifier
init|=
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|qualifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RESTRICT
index|]
condition|)
name|restrictp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|erred
condition|)
block|{
name|erred
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"invalid type modifier within pointer declarator"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrictp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `restrict'"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
block|{
if|if
condition|(
name|constp
condition|)
name|pedwarn
argument_list|(
literal|"discarding `const' applied to a reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
name|pedwarn
argument_list|(
literal|"discarding `volatile' applied to a reference"
argument_list|)
expr_stmt|;
name|type_quals
operator|&=
operator|~
operator|(
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator|)
expr_stmt|;
block|}
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
block|{
comment|/* We have converted type names to NULL_TREE if the 	       name was bogus, or to a _TYPE node, if not.  	       The variable CTYPE holds the type we will ultimately 	       resolve to.  The code here just needs to build 	       up appropriate member types.  */
name|tree
name|sname
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Destructors can have their visibilities changed as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|sname
operator|=
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
comment|/* This needs to be here, in case we are called 		 multiple times.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/* Namespace member. */
name|pop_decl_namespace
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|friendp
operator|&&
operator|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|<
literal|2
operator|)
condition|)
comment|/* Don't fall out into global scope. Hides real bug? --eichin */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
name|current_class_depth
condition|)
block|{
comment|/* Resolve any TYPENAME_TYPEs from the decl-specifier-seq 		   that refer to ctype.  They couldn't be resolved earlier 		   because we hadn't pushed into the class yet. 		   Example: resolve 'B<T>::type' in 		   'B<typename B<T>::type> B<T>::f () { }'.  */
if|if
condition|(
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|type
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|current_template_args
argument_list|()
decl_stmt|;
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* This pop_nested_class corresponds to the                    push_nested_class used to push into class scope for                    parsing the argument list of a function decl, in                    qualified_id.  */
name|pop_nested_class
argument_list|()
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|=
name|current_class_depth
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* We had a reference to a global decl, or 		   perhaps we were given a non-aggregate typedef, 		   in which case we cleared this out, and should just 		   keep going as though it wasn't there.  */
name|declarator
operator|=
name|sname
expr_stmt|;
continue|continue;
block|}
name|ctype
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|ctype
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
name|template_count
operator|+=
literal|1
expr_stmt|;
name|t
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|sname
operator|==
name|NULL_TREE
condition|)
goto|goto
name|done_scoping
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* This is the `standard' use of the scoping operator: 		   basetype :: member .  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
block|{
comment|/* class A { 		         void A::f (); 		       };  		       Is this ill-formed?  */
if|if
condition|(
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"extra qualification `%T::' on member `%s' ignored"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|friendp
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"cannot declare member function `%T::%s' within `%T'"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Have to move this code elsewhere in this function. 		       this code is used for i.e., typedef int A::M; M *pm;  		       It is?  How? jason 10/2/94 */
if|if
condition|(
name|current_class_type
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot declare member `%T::%s' within `%T'"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"structure `%T' not yet defined"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|declarator
operator|=
name|sname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|my_friendly_abort
argument_list|(
literal|17
argument_list|)
expr_stmt|;
else|else
block|{
name|done_scoping
label|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
comment|/* In this case, we will deal with it later.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|BIT_NOT_EXPR
case|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|158
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See the comment for the TREE_LIST case, above.  */
if|if
condition|(
name|inner_attrs
condition|)
block|{
if|if
condition|(
operator|!
name|ignore_attrs
condition|)
name|decl_attributes
argument_list|(
name|type
argument_list|,
name|inner_attrs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attrlist
condition|)
name|TREE_VALUE
argument_list|(
name|attrlist
argument_list|)
operator|=
name|chainon
argument_list|(
name|inner_attrs
argument_list|,
name|TREE_VALUE
argument_list|(
name|attrlist
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|attrlist
operator|=
name|build_decl_list
argument_list|(
name|NULL_TREE
argument_list|,
name|inner_attrs
argument_list|)
expr_stmt|;
block|}
comment|/* Now TYPE has the actual type.  */
if|if
condition|(
name|explicitp
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"only constructors can be declared `explicit'"
argument_list|)
expr_stmt|;
name|explicitp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
condition|)
block|{
name|error
argument_list|(
literal|"const `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|staticp
condition|)
block|{
name|error
argument_list|(
literal|"static `%s' cannot be declared `mutable'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|cp_error
argument_list|(
literal|"template-id `%D' used as a declarator"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|dname
expr_stmt|;
block|}
else|else
comment|/* Unexpected declarator format.  */
name|my_friendly_abort
argument_list|(
literal|990210
argument_list|)
expr_stmt|;
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|&&
name|decl_context
operator|!=
name|TYPENAME
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|declarator
operator|==
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids nested type `%D' with same name as enclosing class"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|opaque_typedef
condition|)
name|SIGNATURE_HAS_OPAQUE_TYPEDECLS
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure this typedef lives as long as its type, 	     since it might be used as a template parameter. */
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* If the user declares "struct {...} foo" then `foo' will have 	 an anonymous name.  Fill that name in now.  Nothing can 	 refer to it, so nothing needs know about the name change. 	 The TYPE_NAME field was filled in by build_struct_xref.  */
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|oldname
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* FIXME: This is bogus; we should not be doing this for 	            cv-qualified types.  */
comment|/* Replace the anonymous name with the real name everywhere.  */
name|lookup_tag_reverse
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|oldname
condition|)
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is a typedef within a template class, the nested 	     type is a (non-primary) template.  The name for the 	     template needs updating as well.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* XXX Temporarily set the scope.  	     When returning, start_decl expects it as NULL_TREE, 	     and will then then set it using pushdecl. */
name|my_friendly_assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|980404
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
else|else
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* FIXME remangle member functions; member functions of a 	     type with external linkage have external linkage.  */
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"typedef name may not be class-qualified"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|cp_error_at
argument_list|(
literal|"invalid type qualifier for non-method type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"non-object member `%s' cannot be declared mutable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"type"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
name|error
argument_list|(
literal|"typedef declaration includes an initializer"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|==
name|typedef_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"type qualifiers specified for signature type"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
comment|/* Special case: "friend class foo" looks like a TYPENAME context.  */
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|cp_error
argument_list|(
literal|"type qualifiers specified for friend class declaration"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|cp_error
argument_list|(
literal|"`inline' specified for friend class declaration"
argument_list|)
expr_stmt|;
name|inlinep
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Only try to do this stuff if we didn't already give up.  */
if|if
condition|(
name|type
operator|!=
name|integer_type_node
condition|)
block|{
comment|/* A friendly class?  */
if|if
condition|(
name|current_class_type
condition|)
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to make class `%s' a friend of global scope"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|,
literal|159
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
elseif|else
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
name|decl_context
operator|!=
name|CATCHPARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
operator|!
name|bitfield
condition|)
block|{
name|cp_error
argument_list|(
literal|"abstract declarator `%T' used as declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
block|}
comment|/* `void' at top level (not within pointer)      is allowed only in typedefs or type names.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|decl_context
operator|!=
name|PARM
condition|)
block|{
if|if
condition|(
operator|!
name|declarator
condition|)
name|error
argument_list|(
literal|"unnamed variable or field declared void"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|declarator
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|356
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"variable or field declared void"
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
condition|)
block|{
if|if
condition|(
name|ctype
operator|||
name|in_namespace
condition|)
name|error
argument_list|(
literal|"cannot use `::' in parameter declaration"
argument_list|)
expr_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	 One declared as a function is really a pointer to a function. 	 One declared as a member is really a pointer to member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|declarator
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"parameter"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|inlinep
condition|)
name|error
argument_list|(
literal|"parameter of signature member function declared `inline'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter of signature member function declared `auto'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter of signature member function declared `register'"
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Happens when declaring arrays of sizes which 	       are error_mark_node, for example.  */
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_namespace
operator|&&
operator|!
name|friendp
condition|)
block|{
comment|/* Something like struct S { int N::j; };  */
name|cp_error
argument_list|(
literal|"invalid use of `::'"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|int
name|publicp
init|=
literal|0
decl_stmt|;
name|tree
name|function_context
decl_stmt|;
comment|/* We catch the others as conflicts with the builtin 	       typedefs.  */
if|if
condition|(
name|friendp
operator|&&
name|declarator
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
condition|)
block|{
name|cp_error
argument_list|(
literal|"function `%D' cannot be declared friend"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|friendp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"can't make `%D' into a method -- not in a class"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
comment|/* ``A union may [ ... ] not [ have ] virtual functions.'' 		   ARM 9.5 */
if|if
condition|(
name|virtualp
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"function `%D' declared virtual inside a union"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|||
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
operator|||
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|||
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' cannot be declared virtual, since it is always static"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */
name|function_context
operator|=
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|)
condition|?
name|hack_decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|ctype
argument_list|)
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|publicp
operator|=
operator|(
operator|!
name|friendp
operator|||
operator|!
name|staticp
operator|)
operator|&&
name|function_context
operator|==
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|?
name|declarator
else|:
name|dname
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|friendp
argument_list|,
name|publicp
argument_list|,
name|inlinep
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|decl
return|;
if|#
directive|if
literal|0
comment|/* This clobbers the attrs stored in `decl' from `attrlist'.  */
comment|/* The decl and setting of decl_machine_attr is also turned off.  */
block|decl = build_decl_attribute_variant (decl, decl_machine_attr);
endif|#
directive|endif
comment|/* [class.conv.ctor]  	       A constructor declared without the function-specifier 	       explicit that can be called with a single parameter 	       specifies a conversion from the type of its first 	       parameter to the type of its class.  Such a constructor 	       is called a converting constructor.  */
if|if
condition|(
name|explicitp
operator|==
literal|2
condition|)
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* The constructor can be called with exactly one 		   parameter if there is at least one parameter, and 		   any subsequent parameters have default arguments. 		   We don't look at the first parameter, which is 		   really just the `this' parameter for the new 		   object.  */
name|tree
name|arg_types
init|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Skip the `in_chrg' argument too, if present.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
comment|/* And the `vlist' argument. */
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|void_list_node
operator|||
operator|(
name|arg_types
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|!=
name|void_list_node
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|)
condition|)
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* We only get here for friend declarations of 	       members of other classes.  */
comment|/* All method decls are public, so tell grokfndecl to set 	       TREE_PUBLIC, also.  */
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|friendp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|staticp
operator|&&
operator|!
name|processing_template_decl
operator|&&
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|initialized
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|declarator
condition|)
name|cp_error
argument_list|(
literal|"field `%D' has incomplete type"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"name `%T' has incomplete type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If we're instantiating a template, tell them which 	       instantiation made the field's type be incomplete.  */
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
operator|&&
name|declspecs
operator|&&
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|cp_error
argument_list|(
literal|"  in instantiation of template `%T'"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is neither function nor method; cannot be declared friend"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* Friends are treated specially.  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
name|warning
argument_list|(
literal|"member functions are implicitly friends of their class"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|decl
operator|=
name|check_explicit_specialization
argument_list|(
name|declarator
argument_list|,
name|decl
argument_list|,
name|template_count
argument_list|,
literal|2
operator|*
operator|(
name|funcdef_flag
operator|!=
literal|0
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|t
operator|=
name|do_friend
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|last_function_parms
argument_list|,
name|attrlist
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|funcdef_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|funcdef_flag
condition|)
return|return
name|t
return|;
return|return
name|void_type_node
return|;
block|}
block|}
comment|/* Structure field.  It may not be a function, except for C++ */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|staticp
condition|)
block|{
comment|/* An attempt is being made to initialize a non-static 		       member.  But, from [class.mem]: 		        		       4 A member-declarator can contain a 		       constant-initializer only if it declares a static 		       member (_class.static_) of integral or enumeration 		       type, see _class.static.data_.    		       This used to be relatively common practice, but 		       the rest of the compiler does not correctly 		       handle the initialization unless the member is 		       static so we make it static below.  */
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids initialization of member `%D'"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"making `%D' static"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
comment|/* We'll check at instantiation time.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|check_static_variable_definition
argument_list|(
name|declarator
argument_list|,
name|type
argument_list|)
condition|)
comment|/* If we just return the declaration, crashes 		     will sometimes occur.  We therefore return 		     void_type_node, as if this was a friend 		     declaration, to cause callers to completely 		     ignore this declaration.  */
return|return
name|void_type_node
return|;
block|}
comment|/* 9.2p13 [class.mem] */
if|if
condition|(
name|declarator
operator|==
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
comment|/* Divergence from the standard:  In extern "C", we 		   allow non-static data members here, because C does 		   and /usr/include/netinet/in.h uses that.  */
operator|&&
operator|(
name|staticp
operator|||
operator|!
name|in_system_header
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids data member `%D' with same name as enclosing class"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticp
condition|)
block|{
comment|/* C++ allows static class members. 		   All other work for this is done by grokfield. 		   This VAR_DCL is built by build_lang_field_decl. 		   All other VAR_DECLs are built by build_decl.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In class context, 'static' means public access.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|DECL_MUTABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"field"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|original_name
decl_stmt|;
name|int
name|publicp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|declarator
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|original_name
operator|=
name|dname
expr_stmt|;
else|else
name|original_name
operator|=
name|declarator
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"storage class `auto' invalid for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"storage class `register' invalid for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"storage class `static' invalid for function `%s' declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"storage class `inline' invalid for function `%s' declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"virtual non-class function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record presence of `static'.  */
name|publicp
operator|=
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|||
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|original_name
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
literal|1
argument_list|,
name|friendp
argument_list|,
name|publicp
argument_list|,
name|inlinep
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|int
name|illegal_static
init|=
literal|0
decl_stmt|;
comment|/* Don't allow a static member function in a class, and forbid 	       declaring main to be static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"cannot declare member function `%D' to have static linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
block|{
comment|/* FIXME need arm citation */
name|error
argument_list|(
literal|"cannot declare static function inside another function"
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|illegal_static
condition|)
block|{
name|staticp
operator|=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|decl
operator|=
name|grokvardecl
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|,
operator|&
name|specbits
argument_list|,
name|initialized
argument_list|,
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|!=
literal|0
argument_list|,
name|in_namespace
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"variable"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"static member `%D' re-declared as static"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"static member `%D' declared `register'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|pedantic
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"cannot explicitly declare member `%#D' to have extern linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' cannot be declared mutable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_THIS_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
comment|/* FIXME: Disallow `restrict' pointer-to-member declarations.  */
name|c_apply_type_quals_to_decl
argument_list|(
name|type_quals
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell if a parmlist/exprlist looks like an exprlist or a parmlist.    An empty exprlist is a parmlist.  An exprlist which    contains only identifiers at the global level    is a parmlist.  Otherwise, it is an exprlist.  */
end_comment

begin_function
name|int
name|parmlist_is_exprlist
parameter_list|(
name|exprs
parameter_list|)
name|tree
name|exprs
decl_stmt|;
block|{
if|if
condition|(
name|exprs
operator|==
name|NULL_TREE
operator|||
name|TREE_PARMLIST
argument_list|(
name|exprs
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* At the global level, if these are all identifiers, 	 then it is a parmlist.  */
while|while
condition|(
name|exprs
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|exprs
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
name|exprs
operator|=
name|TREE_CHAIN
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of start_function.  Ensure that each of the parameter    types (as listed in PARMS) is complete, as is required for a    function definition.  */
end_comment

begin_function
specifier|static
name|void
name|require_complete_types_for_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|layout_decl
argument_list|(
name|parms
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns DECL if DECL is a local variable (or parameter).  Returns    NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|local_variable_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
comment|/* A VAR_DECL with a context that is a _TYPE is a static data 	  member.  */
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
comment|/* Any other non-local variable must be at namespace scope.  */
operator|&&
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check that ARG, which is a default-argument expression for a    parameter DECL, is legal.  Returns ARG, or ERROR_MARK_NODE, if    something goes wrong.  DECL may also be a _TYPE node, rather than a    DECL, if there is no DECL available.  */
end_comment

begin_function
name|tree
name|check_default_argument
parameter_list|(
name|decl
parameter_list|,
name|arg
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|decl_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
comment|/* We get a DEFAULT_ARG when looking at an in-class declaration        with a default argument.  Ignore the argument for now; we'll        deal with it after the class is complete.  */
return|return
name|arg
return|;
if|if
condition|(
name|processing_template_decl
operator|||
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* We don't do anything checking until instantiation-time.  Note        that there may be uninstantiated arguments even for an        instantiated function, since default arguments are not        instantiated until they are needed.  */
return|return
name|arg
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|decl_type
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|error_mark_node
operator|||
name|decl_type
operator|==
name|error_mark_node
condition|)
comment|/* Something already went wrong.  There's no need to check        further.  */
return|return
name|error_mark_node
return|;
comment|/* [dcl.fct.default]            A default argument expression is implicitly converted to the      parameter type.  */
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|||
operator|!
name|can_convert_arg
argument_list|(
name|decl_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|cp_error
argument_list|(
literal|"default argument for `%#D' has type `%T'"
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"default argument for paramter of type `%T' has type `%T'"
argument_list|,
name|decl_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [dcl.fct.default]       Local variables shall not be used in default argument      expressions.        The keyword `this' shall not be used in a default argument of a      member function.  */
name|var
operator|=
name|search_tree
argument_list|(
name|arg
argument_list|,
name|local_variable_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
condition|)
block|{
name|cp_error
argument_list|(
literal|"default argument `%E' uses local variable `%D'"
argument_list|,
name|arg
argument_list|,
name|var
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* All is well.  */
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Decode the list of parameter types for a function type.    Given the list of things declared inside the parens,    return a list of types.     The list we receive can have three kinds of elements:    an IDENTIFIER_NODE for names given without types,    a TREE_LIST node for arguments given as typespecs or names with typespecs,    or void_type_node, to mark the end of an argument list    when additional arguments are not permitted (... was not used).     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.    If FUNCDEF_FLAG is 1, then parameter types must be complete.    If FUNCDEF_FLAG is -1, then parameter types may be incomplete.     If all elements of the input list contain types,    we return a list of the types.    If all elements contain no type (except perhaps a void_type_node    at the end), we return a null list.    If some have types and some do not, it is an error, and we    return a null list.     Also set last_function_parms to either    a list of names (IDENTIFIER_NODEs) or a chain of PARM_DECLs.    A list of names is converted to a chain of PARM_DECLs    by store_parm_decls so that ultimately it is always a chain of decls.     Note that in C++, parameters can take default values.  These default    values are in the TREE_PURPOSE field of the TREE_LIST.  It is    an error to specify default values which are followed by parameters    that have no default values, or an ELLIPSES.  For simplicities sake,    only parameters which are specified with their types can take on    default values.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|first_parm
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|first_parm
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|pedwarn
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|145
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Types were specified.  This is a list of declarators 	 each represented as a TREE_LIST node.  */
specifier|register
name|tree
name|parm
decl_stmt|,
name|chain
decl_stmt|;
name|int
name|any_init
init|=
literal|0
decl_stmt|,
name|any_error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|last_result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|last_decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|first_parm
init|;
name|parm
operator|!=
name|NULL_TREE
condition|;
name|parm
operator|=
name|chain
control|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|list_node
init|=
name|parm
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* @@ weak defense against parse errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* Give various messages as the need arises.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|cp_error
argument_list|(
literal|"invalid string constant `%E'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid integer constant in parameter list, did you forget to give parameter name?"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|PARM
argument_list|,
name|init
operator|!=
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* Top-level qualifiers on the parameters are 		     ignored for function types.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|decl
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Cannot use the decl here because 			   we don't have DECL_CONTEXT set up yet.  */
name|cp_error
argument_list|(
literal|"parameter `%D' invalidly declared method type"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared method type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parameter `%D' invalidly declared offset type"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared offset type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
comment|/* Seems like a good idea. */
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|signature_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
comment|/* Seems like a good idea. */
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|type
decl_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|cp_error
argument_list|(
literal|"parameter type `%T' includes %s to array of unknown bound"
argument_list|,
name|type
argument_list|,
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|void_list_node
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|&&
operator|(
name|chain
operator|!=
name|void_list_node
operator|||
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"`void' in parameter list must be entire list"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Since there is a prototype, args are passed in their own types.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|any_error
operator|&&
name|init
condition|)
block|{
name|any_init
operator|++
expr_stmt|;
name|init
operator|=
name|check_default_argument
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decls
operator|==
name|NULL_TREE
condition|)
block|{
name|decls
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decls
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_function_decl
operator|&&
name|TREE_PERMANENT
argument_list|(
name|list_node
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|list_node
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list_node
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|list_node
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|list_node
operator|=
name|saveable_tree_cons
argument_list|(
name|init
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|list_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_result
condition|)
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there are no parameters, and the function does not end 	     with `...', then last_decl will be NULL_TREE.  */
if|if
condition|(
name|last_decl
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|last_function_parms
operator|=
name|decls
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Called from the parser to update an element of TYPE_ARG_TYPES for some    FUNCTION_TYPE with the newly parsed version of its default argument, which    was previously digested as text.  See snarf_defarg et al in lex.c.  */
end_comment

begin_function
name|void
name|replace_defarg
parameter_list|(
name|arg
parameter_list|,
name|init
parameter_list|)
name|tree
name|arg
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|!
name|can_convert_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"invalid type `%T' for default argument to `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if D copies its arguments. This is used to test for copy    constructors and copy assignment operators.  */
end_comment

begin_function
name|int
name|copy_args_p
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|t
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|d
argument_list|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
name|DECL_CLASS_CONTEXT
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* These memoizing functions keep track of special properties which    a class may have.  `grok_ctor_properties' notices whether a class    has a constructor of the form X(X&), and also complains    if the class has a constructor of the form X(X).    `grok_op_properties' takes notice of the various forms of    operator= which are defined, as well as what sorts of type conversion    may apply.  Both functions take a FUNCTION_DECL as an argument.  */
end_comment

begin_function
name|int
name|grok_ctor_properties
parameter_list|(
name|ctype
parameter_list|,
name|decl
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|parmtypes
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
comment|/* When a type has virtual baseclasses, a magical first int argument is      added to any ctor so we can tell if the class has been initialized      yet.  This could screw things up in this function, so we deliberately      ignore the leading int if we're in that situation.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|parmtypes
operator|&&
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|integer_type_node
argument_list|,
literal|980529
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|parmtypes
operator|&&
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|vlist_type_node
argument_list|,
literal|980529
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
name|maybe_vlist_ctor_wrapper
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* [class.copy]       A non-template constructor for class X is a copy constructor if      its first parameter is of type X&, const X&, volatile X& or const      volatile X&, and either there are no other parameters or else all      other parameters have default arguments.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|==
name|ctype
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|TYPE_HAS_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* [class.copy]       A declaration of a constructor for a class X is ill-formed if its      first parameter is of type (optionally cv-qualified) X and either      there are no other parameters or else all other parameters have      default arguments.         We *don't* complain about member template instantiations that      have this form, though; they can occur as we try to decide what      constructor to use during overload resolution.  Since overload      resolution will never prefer such a constructor to the      non-template copy constructor (which is either explicitly or      implicitly defined), there's no need to worry about their      existence.  Theoretically, they should never even be      instantiated, but that's hard to forestall.  */
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|ctype
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid constructor; you probably meant `%T (const %T&)'"
argument_list|,
name|ctype
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* An operator with this name can be either unary or binary.  */
end_comment

begin_function
specifier|static
name|int
name|ambi_op_p
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
return|return
operator|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* An operator with this name can only be unary.  */
end_comment

begin_function
specifier|static
name|int
name|unary_op_p
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
return|return
operator|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|||
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a little sanity-checking on how they declared their operator.  */
end_comment

begin_function
name|void
name|grok_op_properties
parameter_list|(
name|decl
parameter_list|,
name|virtualp
parameter_list|,
name|friendp
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|friendp
decl_stmt|;
block|{
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|methodp
init|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|friendp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|friendp
condition|)
block|{
comment|/* [class.copy]  	 A user-declared copy assignment operator X::operator= is a 	 non-static non-template member function of class X with 	 exactly one parameter of type X, X&, const X&, volatile X& or 	 const volatile X&.  */
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|&&
operator|!
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
condition|)
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
condition|)
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
condition|)
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
condition|)
name|TYPE_GETS_NEW
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
name|TYPE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
condition|)
name|TYPE_GETS_NEW
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
name|TYPE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
condition|)
block|{
comment|/* When the compiler encounters the definition of A::operator new, it 	 doesn't look at the class declaration to find out if it's static.  */
if|if
condition|(
name|methodp
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Take care of function decl if we had syntax errors.  */
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_new_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_delete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|friendp
operator|&&
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_list_node
operator|)
condition|)
name|TYPE_VEC_DELETE_TAKES_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* An operator function must either be a non-static member function 	 or have at least one parameter of a class, a reference to a class, 	 an enumeration, or a reference to an enumeration.  13.4.0.6 */
if|if
condition|(
operator|!
name|methodp
operator|||
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
condition|)
name|cp_error
argument_list|(
literal|"`%D' must be a nonstatic member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|p
init|=
name|argtypes
decl_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"`%D' must be either a non-static member function or a non-member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* This lets bad template code slip through.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
goto|goto
name|foundaggr
goto|;
block|}
name|cp_error
argument_list|(
literal|"`%D' must have an argument of class or enumerated type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|foundaggr
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
condition|)
return|return;
comment|/* No restrictions on args. */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"void is not a valid type conversion operator"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|friendp
condition|)
block|{
name|int
name|ref
init|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ref
condition|)
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|current_class_type
condition|)
name|what
operator|=
literal|"the same type"
expr_stmt|;
comment|/* Don't force t to be complete here.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|what
operator|=
literal|"a base class"
expr_stmt|;
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
literal|"conversion to %s%s will never use a type conversion operator"
argument_list|,
name|ref
condition|?
literal|"a reference to "
else|:
literal|""
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtype
decl_stmt|;
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|3
operator|&&
name|methodp
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_assignment_arg_p
argument_list|(
name|parmtype
argument_list|,
name|virtualp
argument_list|)
operator|&&
operator|!
name|friendp
condition|)
block|{
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
condition|)
block|{
comment|/* 13.4.0.3 */
name|pedwarn
argument_list|(
literal|"ANSI C++ prohibits overloading operator ?:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|4
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take exactly three arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ambi_op_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|==
literal|2
condition|)
comment|/* prefix */
empty_stmt|;
elseif|else
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|)
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"postfix `%D' must take `int' as its argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"postfix `%D' must take `int' as its second argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take either zero or one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' must take either one or two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* More Effective C++ rule 6.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|argtypes
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|methodp
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ret
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ret
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"prefix `%D' should return `%T'"
argument_list|,
name|decl
argument_list|,
name|build_reference_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ret
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"postfix `%D' should return `%T'"
argument_list|,
name|decl
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|unary_op_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take `void'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* if (binary_op_p (name)) */
block|{
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|3
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' must take exactly two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* More Effective C++ rule 7.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|(
name|name
operator|==
name|ansi_opname
index|[
name|TRUTH_ANDIF_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
name|TRUTH_ORIF_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
name|COMPOUND_EXPR
index|]
operator|)
condition|)
name|cp_warning
argument_list|(
literal|"user-defined `%D' always evaluates both arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Effective C++ rule 23.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|==
literal|3
operator|&&
operator|(
name|name
operator|==
name|ansi_opname
index|[
name|PLUS_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
name|MINUS_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
name|TRUNC_DIV_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
name|MULT_EXPR
index|]
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|cp_warning
argument_list|(
literal|"`%D' should return by value"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* 13.4.0.8 */
if|if
condition|(
name|argtypes
condition|)
for|for
control|(
init|;
name|argtypes
operator|!=
name|void_list_node
condition|;
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"`%D' cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"`%D' cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tag_name
parameter_list|(
name|code
parameter_list|)
name|enum
name|tag_types
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|record_type
case|:
return|return
literal|"struct"
return|;
case|case
name|class_type
case|:
return|return
literal|"class"
return|;
case|case
name|union_type
case|:
return|return
literal|"union "
return|;
case|case
name|enum_type
case|:
return|return
literal|"enum"
return|;
case|case
name|signature_type
case|:
return|return
literal|"signature"
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|981122
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.     C++: If a class derivation is given, process it here, and report    an error if multiple derivation declarations are not identical.     If this is a definition, come in through xref_tag and only look in    the current frame for the name (since C++ allows new names in any    scope.)  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
name|enum
name|tag_types
name|tag_code
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|temp
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|int
name|got_type
init|=
literal|0
decl_stmt|;
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If we are called from the parser, code_type_node will sometimes be a      TREE_LIST.  This indicates that the user wrote      "class __attribute__ ((foo)) bar".  Extract the attributes so we can      use them later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|code_type_node
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|attributes
operator|=
name|TREE_PURPOSE
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
name|code_type_node
operator|=
name|TREE_VALUE
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
block|}
name|tag_code
operator|=
operator|(
expr|enum
name|tag_types
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag_code
condition|)
block|{
case|case
name|record_type
case|:
case|case
name|class_type
case|:
case|case
name|signature_type
case|:
name|code
operator|=
name|RECORD_TYPE
expr_stmt|;
break|break;
case|case
name|union_type
case|:
name|code
operator|=
name|UNION_TYPE
expr_stmt|;
break|break;
case|case
name|enum_type
case|:
name|code
operator|=
name|ENUMERAL_TYPE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|18
argument_list|)
expr_stmt|;
block|}
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|t
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|got_type
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|t
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|code
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|globalize
condition|)
block|{
comment|/* If we know we are defining this tag, only look it up in 	 this scope and don't try to find it as a type.  */
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
condition|)
block|{
comment|/* [dcl.type.elab] If the identifier resolves to a 	     typedef-name or a template type-parameter, the 	     elaborated-type-specifier is ill-formed.  */
if|if
condition|(
name|t
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"using typedef-name `%D' after `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|cp_error
argument_list|(
literal|"using template type parameter `%T' after `%s'"
argument_list|,
name|t
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|t
expr_stmt|;
block|}
else|else
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* Try finding it as a type declaration.  If that wins, 	     use it.  */
name|ref
operator|=
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|!=
name|NULL_TREE
operator|&&
name|processing_template_decl
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|ref
argument_list|)
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
comment|/* Since GLOBALIZE is true, we're declaring a global 	       template, so we want this type.  */
name|ref
operator|=
name|DECL_RESULT
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|code
condition|)
name|ref
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|ref
operator|&&
name|current_class_type
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
block|{
comment|/* Since GLOBALIZE is non-zero, we are not looking at a 	     definition of this tag.  Since, in addition, we are currently 	     processing a (member) template declaration of a template 	     class, we must be very careful; consider:  	       template<class X> 	       struct S1  	       template<class U> 	       struct S2 	       { template<class V> 	       friend struct S1; };  	     Here, the S2::S1 declaration should not be confused with the 	     outer declaration.  In particular, the inner version should 	     have a template parameter of level 2, not level 1.  This 	     would be particularly important if the member declaration 	     were instead:  	       template<class V = U> friend struct S1;  	     say, when we should tsubst into `U' when instantiating 	     S2.  On the other hand, when presented with:  	         template<class T> 	         struct S1 { 		   template<class U> 	           struct S2 {}; 		   template<class U> 		   friend struct S2; 		 };                we must find the inner binding eventually.  We 	      accomplish this by making sure that the new type we 	      create to represent this declaration has the right 	      TYPE_CONTEXT.  */
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* If no such tag is yet defined, create a forward-reference node 	 and record it as the "definition". 	 When a real declaration of this type is found, 	 the forward-reference will be altered into a real type.  */
comment|/* In C++, since these migrate into the global scope, we must 	 build them on the permanent obstack.  */
name|temp
operator|=
name|allocation_temporary_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"use of enum `%#D' without previous declaration"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
comment|/* Give the type a default layout like unsigned int 	     to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Enable us to recognize when a type is created in class context. 	     To do nested classes correctly, this should probably be cleared 	     out when we leave this classes scope.  Currently this in only 	     done in `start_enum'.  */
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|binding_level
modifier|*
name|old_b
init|=
name|class_binding_level
decl_stmt|;
name|ref
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|ref
argument_list|)
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|tag_code
operator|==
name|signature_type
condition|)
block|{
name|SET_SIGNATURE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* Since a signature type will be turned into the type 		 of signature tables, it's not only an interface.  */
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* A signature doesn't have a vtable.  */
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NONNESTED_CLASSES
comment|/* Class types don't nest the way enums do.  */
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|old_b
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If it no longer looks like a nested type, make sure it's 	 in global scope.            If it is not an IDENTIFIER, this is not a declaration */
if|if
condition|(
name|b
operator|->
name|namespace_p
operator|&&
operator|!
name|class_binding_level
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|,
name|TYPE_NAME
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|globalize
operator|&&
name|processing_template_decl
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ref
argument_list|)
condition|)
name|redeclare_class_template
argument_list|(
name|ref
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
block|}
comment|/* Until the type is defined, tentatively accept whatever      structure tag the user hands us.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ref
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ref
operator|!=
name|current_class_type
comment|/* Have to check this, in case we have contradictory tag info.  */
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tag_code
operator|==
name|class_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|record_type
operator|||
name|tag_code
operator|==
name|signature_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
operator|=
name|attributes
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_function
name|tree
name|xref_tag_from_type
parameter_list|(
name|old
parameter_list|,
name|id
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|old
decl_stmt|,
name|id
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
name|tree
name|code_type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|code_type_node
operator|=
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|old
argument_list|)
condition|?
name|class_type_node
else|:
name|record_type_node
operator|)
expr_stmt|;
else|else
name|code_type_node
operator|=
name|union_type_node
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL_TREE
condition|)
name|id
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|xref_tag
argument_list|(
name|code_type_node
argument_list|,
name|id
argument_list|,
name|globalize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* REF is a type (named NAME), for which we have just seen some    baseclasses.  BINFO is a list of those baseclasses; the    TREE_PURPOSE is an access_* node, and the TREE_VALUE is the type of    the base-class.  CODE_TYPE_NODE indicates whether REF is a class,    struct, or union.  */
end_comment

begin_function
name|void
name|xref_basetypes
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|ref
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|ref
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
comment|/* In the declaration `A : X, Y, ... Z' we mark all the types      (A, X, Y, ..., Z) so we can check for duplicates.  */
name|tree
name|binfos
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|enum
name|tag_types
name|tag_code
init|=
operator|(
expr|enum
name|tag_types
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|code_type_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag_code
operator|==
name|union_type
condition|)
block|{
name|cp_error
argument_list|(
literal|"derived union `%T' invalid"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|list_length
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|ref
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First, make sure that any templates in base-classes are      instantiated.  This ensures that if we call ourselves recursively      we do not get confused about which classes are marked and which      are not.  */
for|for
control|(
name|base
operator|=
name|binfo
init|;
name|base
condition|;
name|base
operator|=
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
control|)
name|complete_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|binfos
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
comment|/* The base of a derived struct is public by default.  */
name|int
name|via_public
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_public_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_public_virtual_node
operator|||
operator|(
name|tag_code
operator|!=
name|class_type
operator|&&
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_default_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_default_virtual_node
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|via_protected
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_protected_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_protected_virtual_node
operator|)
decl_stmt|;
name|int
name|via_virtual
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_private_virtual_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_protected_virtual_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_public_virtual_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
name|access_default_virtual_node
operator|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
if|if
condition|(
name|basetype
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basetype
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"base type `%T' fails to be a struct or class type"
argument_list|,
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|GNU_xref_hier
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|,
name|via_public
argument_list|,
name|via_virtual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This code replaces similar code in layout_basetypes.          We put the complete_type first for implicit `typename'.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
operator|(
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"base class `%T' has incomplete type"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|ref
condition|)
name|cp_error
argument_list|(
literal|"recursive type `%T' undefined"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"duplicate base type `%T' invalid"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|basetype
argument_list|)
operator|&&
name|current_lang_stack
operator|==
name|current_lang_base
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Note that the BINFO records which describe individual 	     inheritances are *not* shared in the lattice!  They 	     cannot be shared because a given baseclass may be 	     inherited with different `accessibility' by different 	     derived classes.  (Each BINFO record describing an 	     individual inheritance contains flags which say what 	     the `accessibility' of that particular inheritance is.)  */
name|base_binfo
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|basetype
argument_list|,
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|?
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
else|:
name|NULL_TREE
argument_list|,
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|?
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_public
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_protected
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_virtual
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* We need to unshare the binfos now so that lookups during class 	     definition work.  */
name|unshare_base_binfos
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* We are free to modify these bits because they are meaningless 	     at top level, and BASETYPE is a top-level type.  */
if|if
condition|(
name|via_virtual
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The PVBASES flag is never set for templates; we know 		 only for instantiations whether the virtual bases are 		 polymorphic. */
if|if
condition|(
name|flag_vtable_thunks
operator|>=
literal|2
operator|&&
operator|!
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|via_virtual
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|TYPE_USES_PVBASES
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|basetype
argument_list|)
condition|)
name|TYPE_USES_PVBASES
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_GETS_NEW
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_NEW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_DELETE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|=
name|i
expr_stmt|;
else|else
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
condition|)
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Unmark all the types.  */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* Now that we know all the base-classes, set up the list of virtual      bases.  */
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
name|get_vbase_types
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|enumtype
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
comment|/* We are wasting space here and putting these on the permanent_obstack so      that typeid(local enum) will work correctly. */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
name|NULL_TREE
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|cp_error
argument_list|(
literal|"multiple definition of `%#T'"
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
else|else
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|b
operator|->
name|tags
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We don't copy this value because build_enumerator needs to do it.  */
name|enum_next_value
operator|=
name|integer_zero_node
expr_stmt|;
name|enum_overflow
operator|=
literal|0
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of name-value pairs.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|)
name|tree
name|enumtype
decl_stmt|;
block|{
specifier|register
name|tree
name|minnode
init|=
name|NULL_TREE
decl_stmt|,
name|maxnode
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
name|tree
name|values
init|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
condition|)
block|{
name|tree
name|pair
decl_stmt|;
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|value
decl_stmt|;
comment|/* The TREE_VALUE is a CONST_DECL for this enumeration 	     constant.  */
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
expr_stmt|;
comment|/* The DECL_INITIAL will be NULL if we are processing a 	     template declaration and this enumeration constant had no 	     explicit initializer.  */
name|value
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* Set the TREE_TYPE for the VALUE as well.  That's so 		 that when we call decl_constant_value we get an 		 entity of the right type (but with the constant 		 value).  Since we shouldn't ever call 		 decl_constant_value on a template type, there's no 		 reason to do that when processing_template_decl. 		 And, if the expression is something like a 		 TEMPLATE_PARM_INDEX or a CAST_EXPR doing so will 		 wreak havoc on the intended type of the expression.    	         Of course, there's also no point in trying to compute 		 minimum or maximum values if we're in a template.  */
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|enumtype
expr_stmt|;
if|if
condition|(
operator|!
name|minnode
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* If this is just a template, leave the CONST_DECL 	       alone.  That way tsubst_copy will find CONST_DECLs for 	       CONST_DECLs, and not INTEGER_CSTs.  */
empty_stmt|;
else|else
comment|/* In the list we're building up, we want the enumeration 	       values, not the CONST_DECLs.  */
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
block|}
else|else
name|maxnode
operator|=
name|minnode
operator|=
name|integer_zero_node
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|nreverse
argument_list|(
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|add_tree
argument_list|(
name|build_min
argument_list|(
name|TAG_DEFN
argument_list|,
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|unsignedp
init|=
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|int
name|lowprec
init|=
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|int
name|highprec
init|=
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|int
name|precision
init|=
name|MAX
argument_list|(
name|lowprec
argument_list|,
name|highprec
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE according to `precision'.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|precision
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
else|else
name|fixup_signed_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_short_enums
operator|||
operator|(
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
comment|/* Use the width of the narrowest normal C type which is wide 	   enough.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|type_for_size
argument_list|(
name|precision
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|tem
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|TYPE_VALUES
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|tem
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|namespace_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* In start_enum we pushed obstacks.  Here, we must pop them.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for an enumeration constant of the    enumeration type TYPE whose NAME and VALUE (if any) are provided.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|result
decl_stmt|;
name|tree
name|context
decl_stmt|;
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* Validate and default VALUE.  */
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"enumerator value for `%D' not integer constant"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Default based on previous value.  */
if|if
condition|(
name|value
operator|==
name|NULL_TREE
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
name|value
operator|=
name|enum_next_value
expr_stmt|;
if|if
condition|(
name|enum_overflow
condition|)
name|cp_error
argument_list|(
literal|"overflow in enumeration values at `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* To fix MAX_VAL enum consts. (bkoz)  */
block|TREE_TYPE (value) = integer_type_node;
endif|#
directive|endif
block|}
comment|/* We always have to copy here; not all INTEGER_CSTs are unshared.     Even in other cases, we will later (in finish_enum) be setting the     type of VALUE.  */
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* C++ associates enums with global, function, or class declarations.  */
name|context
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|context
operator|==
name|current_class_type
condition|)
comment|/* This enum declaration is local to the class.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
comment|/* It's a global enum, or it's local to a function.  (Note local to       a function could mean local to a class method.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|context
operator|==
name|current_class_type
condition|)
comment|/* In something like `struct S { enum E { i = 7 }; };' we put `i'       on the TYPE_FIELDS list for `S'.  (That's so that you can say       things like `S::i' later.)  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
name|PLUS_EXPR
argument_list|)
expr_stmt|;
name|enum_overflow
operator|=
name|tree_int_cst_lt
argument_list|(
name|enum_next_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|function_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     If PRE_PARSED_P is non-zero then DECLARATOR is really the DECL for    the function we are about to process; DECLSPECS are ignored.  For    example, we set PRE_PARSED_P when processing the definition of    inline function that was defined in-class; the definition is    actually processed when the class is complete.  In this case,    PRE_PARSED_P is 2.  We also set PRE_PARSED_P when instanting the    body of a template function, and when constructing thunk functions    and such; in these cases PRE_PARSED_P is 1.        This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.     For C++, we must first check whether that datum makes any sense.    For example, "class A local_a(1,2);" means that variable local_a    is an aggregate of type A, which should have a constructor    applied to it with the argument list [1, 2].     @@ There is currently no way to retrieve the storage    @@ allocated to FUNCTION (or all of its parms) if we return    @@ something we had previously.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|attrs
parameter_list|,
name|pre_parsed_p
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|,
name|attrs
decl_stmt|;
name|int
name|pre_parsed_p
decl_stmt|;
block|{
name|tree
name|decl1
decl_stmt|;
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|restype
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
name|int
name|doing_friend
init|=
literal|0
decl_stmt|;
comment|/* Sanity check.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|void_list_node
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
argument_list|,
literal|160
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|161
argument_list|)
expr_stmt|;
comment|/* Assume, until we see it does.  */
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|named_labels
operator|=
literal|0
expr_stmt|;
name|shadowed_labels
operator|=
literal|0
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|current_function_parms_stored
operator|=
literal|0
expr_stmt|;
name|original_result_rtx
operator|=
name|NULL_RTX
expr_stmt|;
name|base_init_expr
operator|=
name|NULL_TREE
expr_stmt|;
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|ctor_label
operator|=
name|dtor_label
operator|=
name|NULL_TREE
expr_stmt|;
name|static_labelno
operator|=
literal|0
expr_stmt|;
name|clear_temp_name
argument_list|()
expr_stmt|;
comment|/* This should only be done once on the top most decl.  */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pre_parsed_p
condition|)
block|{
name|decl1
operator|=
name|declarator
expr_stmt|;
if|#
directive|if
literal|0
comment|/* What was this testing for, exactly?  */
block|if (! DECL_ARGUMENTS (decl1)&& !DECL_STATIC_FUNCTION_P (decl1)&& !DECL_ARTIFICIAL (decl1)&& DECL_CLASS_SCOPE_P (decl1)&& TYPE_IDENTIFIER (DECL_CONTEXT (decl1))&& IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (DECL_CONTEXT (decl1)))) 	{ 	  tree binding = binding_for_name (DECL_NAME (decl1),  					   current_namespace); 	  cp_error ("redeclaration of `%#D'", decl1); 	  if (IDENTIFIER_CLASS_VALUE (DECL_NAME (decl1))) 	    cp_error_at ("previous declaration here", IDENTIFIER_CLASS_VALUE (DECL_NAME (decl1))); 	  else if (BINDING_VALUE (binding)) 	    cp_error_at ("previous declaration here", BINDING_VALUE (binding)); 	}
endif|#
directive|endif
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* ANSI C++ June 5 1992 WP 11.4.5.  A friend function defined in a 	 class is in the (lexical) scope of the class in which it is 	 defined.  */
if|if
condition|(
operator|!
name|ctype
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|ctype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* CTYPE could be null here if we're dealing with a template; 	     for example, `inline friend float foo()' inside a template 	     will have no CTYPE set.  */
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|doing_friend
operator|=
literal|1
expr_stmt|;
block|}
name|last_function_parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition, 	 cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl1
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|restype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"semicolon missing after declaration of `%#T'"
argument_list|,
name|restype
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
comment|/* If this doesn't return integer_type, complain.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_return_type
condition|)
name|pedwarn
argument_list|(
literal|"return type for `main' changed to `int'"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|default_function_type
expr_stmt|;
block|}
block|}
block|}
comment|/* Warn if function was previously implicitly declared      (but not if we warned then).  */
if|if
condition|(
operator|!
name|warn_implicit
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_warning_at
argument_list|(
literal|"`%D' implicitly declared before its definition"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Set up current_class_type, and enter the scope of the class, if      appropriate.  */
if|if
condition|(
name|ctype
condition|)
name|push_nested_class
argument_list|(
name|ctype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now that we have entered the scope of the class, we must restore      the bindings for any template parameters surrounding DECL1, if it      is an inline member template.  (Order is important; consider the      case where a template parameter has the same name as a field of      the class.)  It is not until after this point that      PROCESSING_TEMPLATE_DECL is guaranteed to be set up correctly.  */
if|if
condition|(
name|pre_parsed_p
operator|==
literal|2
condition|)
name|maybe_begin_member_template_processing
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* We are now in the scope of the function being defined.  */
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* In a function definition, arg types must be complete.  */
name|require_complete_types_for_parms
argument_list|(
name|current_function_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"return-type `%#T' is an incomplete type"
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make it return void instead, but don't change the 	     type of the DECL_RESULT, in case we have a named return value.  */
if|if
condition|(
name|ctype
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|void_type_node
argument_list|,
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|=
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|=
name|CP_TYPE_VOLATILE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl1
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Effective C++ rule 15.  See also c_expand_return.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_warning
argument_list|(
literal|"`operator=' should return a reference to `*this'"
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_DEFAULT_DECL_ATTRIBUTES
name|SET_DEFAULT_DECL_ATTRIBUTES
argument_list|(
name|decl1
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We must call push_template_decl after current_class_type is set      up.  (If we are processing inline definitions after exiting a      class scope, current_class_type will be NULL_TREE until set above      by push_nested_class.)  */
if|if
condition|(
name|processing_template_decl
condition|)
name|decl1
operator|=
name|push_template_decl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|pre_parsed_p
operator|==
literal|0
condition|)
block|{
comment|/* A specialization is not used to guide overload resolution.  */
if|if
condition|(
operator|(
name|flag_guiding_decls
operator|||
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl1
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|decl1
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We need to set the DECL_CONTEXT. */
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And make sure we have enough default args.  */
name|check_default_args
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
name|DECL_MAIN_VARIANT
argument_list|(
name|decl1
argument_list|)
operator|=
name|decl1
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|tree
name|ctx
init|=
name|hack_decl_function_context
argument_list|(
name|decl1
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL_TREE
operator|&&
name|DECL_THIS_INLINE
argument_list|(
name|ctx
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|ctx
argument_list|)
condition|)
comment|/* This is a function in a local class in an extern inline 	   function.  */
name|comdat_linkage
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
comment|/* If this function belongs to an interface, it is public.      If it belongs to someone else's interface, it is also external.      This only affects inlines and template instantiations.  */
elseif|else
if|if
condition|(
name|interface_unknown
operator|==
literal|0
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|||
name|flag_alt_external_templates
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_THIS_INLINE
argument_list|(
name|decl1
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|||
name|processing_template_decl
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
operator|(
name|interface_only
operator|||
operator|(
name|DECL_THIS_INLINE
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|decl1
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* For WIN32 we also want to put these in linkonce sections.  */
name|maybe_make_one_only
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|interface_unknown
operator|&&
name|interface_only
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|||
name|flag_alt_external_templates
operator|)
condition|)
block|{
comment|/* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma 	 interface, we will have interface_only set but not 	 interface_known.  In that case, we don't want to use the normal 	 heuristics because someone will supply a #pragma implementation 	 elsewhere, and deducing it here would produce a conflict.  */
name|comdat_linkage
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a definition, not a reference. 	 So clear DECL_EXTERNAL.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_THIS_INLINE
argument_list|(
name|decl1
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
comment|/* Don't try to defer nested functions for now.  */
operator|&&
operator|!
name|hack_decl_function_context
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_function_parms
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
operator|=
name|current_function_parms
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
comment|/* If we're compiling a friend function, neither of the variables 	 current_class_ptr nor current_class_type will have values.  */
if|if
condition|(
operator|!
name|doing_friend
condition|)
block|{
comment|/* We know that this was set up by `grokclassfn'. 	     We do not wait until `store_parm_decls', since evil 	     parse errors may never get us to that point.  Here 	     we keep the consistency between `current_class_type' 	     and `current_class_ptr'.  */
name|tree
name|t
init|=
name|current_function_parms
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|162
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|hack_decl_function_context
argument_list|(
name|decl1
argument_list|)
condition|)
name|temporary_allocation
argument_list|()
expr_stmt|;
name|i
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* Normally, build_indirect_ref returns 		 current_class_ref whenever current_class_ptr is 		 dereferenced.  This time, however, we want it to 		 *create* current_class_ref, so we temporarily clear 		 current_class_ptr to fool it.  */
name|current_class_ptr
operator|=
name|NULL_TREE
expr_stmt|;
name|current_class_ref
operator|=
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|current_class_ptr
operator|=
name|t
expr_stmt|;
name|resume_momentary
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hack_decl_function_context
argument_list|(
name|decl1
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* We're having a signature pointer here.  */
name|current_class_ref
operator|=
name|current_class_ptr
operator|=
name|t
expr_stmt|;
block|}
block|}
else|else
name|current_class_ptr
operator|=
name|current_class_ref
operator|=
name|NULL_TREE
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
name|GNU_xref_function
argument_list|(
name|decl1
argument_list|,
name|current_function_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|cplus_decl_attributes
argument_list|(
name|decl1
argument_list|,
name|NULL_TREE
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|restype
argument_list|)
condition|)
name|restype
operator|=
name|type_promotes_to
argument_list|(
name|restype
argument_list|)
expr_stmt|;
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|=
name|CP_TYPE_CONST_P
argument_list|(
name|restype
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|=
name|CP_TYPE_VOLATILE_P
argument_list|(
name|restype
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate further tree nodes temporarily during compilation      of this function only.  Tiemann moved up here from bottom of fn.  */
comment|/* If this is a nested function, then we must continue to allocate RTL      on the permanent obstack in case we need to inline it later.  */
if|if
condition|(
operator|!
name|hack_decl_function_context
argument_list|(
name|decl1
argument_list|)
condition|)
name|temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
operator|++
name|minimal_parse_mode
expr_stmt|;
name|last_tree
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_nt
argument_list|(
name|EXPR_STMT
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
operator|++
name|function_depth
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|decl1
argument_list|)
operator|==
name|lang_cplusplus
condition|)
block|{
name|dtor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|dtor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|ctor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called after store_parm_decls for a function-try-block.  We need to update    last_parm_cleanup_insn so that the base initializers for a constructor    are run within this block, not before it.  */
end_comment

begin_function
name|void
name|expand_start_early_try_stmts
parameter_list|()
block|{
name|expand_start_try_stmts
argument_list|()
expr_stmt|;
name|last_parm_cleanup_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     Also install to binding contour return value identifier, if any.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|()
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
name|int
name|parms_have_cleanups
init|=
literal|0
decl_stmt|;
name|tree
name|cleanups
init|=
name|NULL_TREE
decl_stmt|;
comment|/* This is either a chain of PARM_DECLs (when a prototype is used).  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
comment|/* This is a list of types declared among parms in a prototype.  */
name|tree
name|parmtags
init|=
name|current_function_parm_tags
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
comment|/* Initialize RTL machinery.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Create a binding level for the parms.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|specparms
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
specifier|register
name|tree
name|next
decl_stmt|;
comment|/* Must clear this because it might contain TYPE_DECLs declared 	 at class level.  */
name|storedecls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|tree
name|cleanup
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_error
argument_list|(
literal|"parameter `%D' declared void"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Now fill in DECL_REFERENCE_SLOT for any of the parm decls. 		     A parameter is assumed not to have any side effects. 		     If this should change for any reason, then this 		     will have to wrap the bashed reference type in a save_expr. 		      		     Also, if the parameter type is declared to be an X 		     and there is an X(X&) constructor, we cannot lay it 		     into the stack (any more), so we make this parameter 		     look like it is really of reference type.  Functions 		     which pass parameters to this function will know to 		     create a temporary in their frame, and pass a reference 		     to that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|parm
argument_list|,
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|(
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|parm
argument_list|)
operator|,
name|cleanup
operator|)
condition|)
block|{
name|expand_decl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parms_have_cleanups
operator|=
literal|1
expr_stmt|;
comment|/* Keep track of the cleanups.  */
name|cleanups
operator|=
name|tree_cons
argument_list|(
name|parm
argument_list|,
name|cleanup
argument_list|,
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we find an enum constant or a type tag, 		 put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order 	 and record in the function.  This is all and only the 	 PARM_DECLs that were pushed into scope by the loop above.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|storetags
argument_list|(
name|chainon
argument_list|(
name|parmtags
argument_list|,
name|gettags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now store the final chain of decls for the arguments      as the decl-chain of the current lexical scope.      Put the enumerators in as well, at the front so that      DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */
name|declare_function_name
argument_list|()
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
name|parms_have_cleanups
argument_list|)
expr_stmt|;
name|current_function_parms_stored
operator|=
literal|1
expr_stmt|;
comment|/* If this function is `main', emit a call to `__main'      to run global initializers, etc.  */
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|expand_main_function
argument_list|()
expr_stmt|;
comment|/* Now that we have initialized the parms, we can start their      cleanups.  We cannot do this before, since expand_decl_cleanup      should not be called before the parm can be used.  */
if|if
condition|(
name|cleanups
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
for|for
control|(
name|cleanups
operator|=
name|nreverse
argument_list|(
name|cleanups
argument_list|)
init|;
name|cleanups
condition|;
name|cleanups
operator|=
name|TREE_CHAIN
argument_list|(
name|cleanups
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|cleanups
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|cleanups
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|cleanups
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create a binding contour which can be used to catch      cleanup-generated temporaries.  Also, if the return value needs or      has initialization, deal with that now.  */
if|if
condition|(
name|parms_have_cleanups
condition|)
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|flag_exceptions
condition|)
block|{
comment|/* Do the starting of the exception specifications, if we have any.  */
if|if
condition|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|expand_start_eh_spec
argument_list|()
expr_stmt|;
block|}
name|last_parm_cleanup_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_dtor_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind a name and initialization to the return value of    the current function.  */
end_comment

begin_function
name|void
name|store_return_init
parameter_list|(
name|return_id
parameter_list|,
name|init
parameter_list|)
name|tree
name|return_id
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
comment|/* Give this error as many times as there are occurrences,        so that users can use Emacs compilation buffers to find        and fix all such places.  */
name|pedwarn
argument_list|(
literal|"ANSI C++ does not permit named return values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_id
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|return_id
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|return_id
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"return identifier `%D' already in place"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Can't let this happen for constructors.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't redefine default return value for constructors"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have a named return value, put that in our scope as well.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* If this named return value comes in a register, 	 put it in a pseudo-register.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|original_result_rtx
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Let `cp_finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|minimal_parse_mode
condition|)
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|RETURN_INIT
argument_list|,
name|return_id
argument_list|,
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit implicit code for a destructor. This is a subroutine of    finish_function.  */
end_comment

begin_function
specifier|static
name|void
name|finish_dtor
parameter_list|()
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|cond
init|=
name|integer_one_node
decl_stmt|;
name|tree
name|exprstmt
decl_stmt|;
name|tree
name|in_charge_node
init|=
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
name|int
name|ok_to_optimize_dtor
init|=
literal|0
decl_stmt|;
name|int
name|empty_dtor
init|=
name|get_last_insn
argument_list|()
operator|==
name|last_dtor_insn
decl_stmt|;
name|rtx
name|insns
decl_stmt|,
name|last_parm_insn
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
name|cond
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|current_class_ptr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
comment|/* If this destructor is empty, then we don't need to check 	 whether `this' is NULL in some cases.  */
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|ok_to_optimize_dtor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|empty_dtor
condition|)
name|ok_to_optimize_dtor
operator|=
operator|(
name|n_baseclasses
operator|==
literal|0
operator|||
operator|(
name|n_baseclasses
operator|==
literal|1
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TYPE_BINFO_BASETYPE
argument_list|(
name|current_class_type
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* If this has a vlist1 parameter, allocate the corresponding vlist      parameter.  */
if|if
condition|(
name|DECL_DESTRUCTOR_FOR_PVBASE_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* _Vlist __vlist; */
name|tree
name|vlist
decl_stmt|;
name|mark_all_temps_used
argument_list|()
expr_stmt|;
name|vlist
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|vlist_identifier
argument_list|,
name|vlist_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|vlist
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|vlist
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_decl
argument_list|(
name|vlist
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|vlist
argument_list|)
expr_stmt|;
block|}
comment|/* These initializations might go inline.  Protect      the binding level of the parms.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate the code to call destructor on base class.      If this destructor belongs to a class with virtual      functions, then set the virtual function table      pointer to represent the type of our base class.  */
comment|/* This side-effect makes call to `build_delete' generate the      code we have to have at the end of this destructor.      `build_delete' will set the flag again.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* These are two cases where we cannot delegate deletion.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|TYPE_GETS_REG_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|current_class_ref
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
operator||
name|LOOKUP_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|current_class_ref
argument_list|,
name|in_charge_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
operator||
name|LOOKUP_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we did not assign to this, then `this' is non-zero at      the end of a destructor.  As a special optimization, don't      emit test if this is an empty destructor.  If it does nothing,      it does nothing.  If it calls a base destructor, the base      destructor will perform the test.  */
if|if
condition|(
name|exprstmt
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exprstmt
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|exprstmt
argument_list|,
literal|0
argument_list|)
operator|!=
name|integer_zero_node
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
block|{
name|expand_label
argument_list|(
name|dtor_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprstmt
operator|!=
name|void_zero_node
condition|)
comment|/* Don't call `expand_expr_stmt' if we're not going to do 	   anything, since -Wall will give a diagnostic.  */
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
comment|/* Run destructor on all virtual baseclasses.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|vbases
init|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_two_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|vb
init|=
name|get_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_base_dtor_call
argument_list|(
name|current_class_ref
argument_list|,
name|vb
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|virtual_size
operator|=
name|c_sizeof
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* At the end, call delete if that's what's requested.  */
comment|/* FDIS sez: At the point of definition of a virtual destructor      (including an implicit definition), non-placement operator      delete shall be looked up in the scope of the destructor's      class and if found shall be accessible and unambiguous.       This is somewhat unclear, but I take it to mean that if the      class only defines placement deletes we don't do anything here.      So we pass LOOKUP_SPECULATIVELY; delete_sanity will complain      for us if they ever try to delete one of these.  */
if|if
condition|(
name|TYPE_GETS_REG_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|current_class_ptr
argument_list|,
name|virtual_size
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_SPECULATIVELY
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|exprstmt
condition|)
block|{
name|cond
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* End of destructor.  */
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
name|getdecls
argument_list|()
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|getdecls
argument_list|()
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Back to the top of destructor.  */
comment|/* Don't execute destructor code if `this' is NULL.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If we need thunk-style vlists, initialize them if the caller did      not pass them. This requires a new temporary. The generated code      looks like        if (!(__in_charge& 4))          __vlist = __vl.<type> + sizeof(__vl.<type>);        else          __vlist = __vlist1;    */
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|vlist
init|=
name|lookup_name
argument_list|(
name|vlist_identifier
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|vlist1
init|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
name|VLIST1_NAME
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|cond
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|build_int_2
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_vlist
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|vlist
argument_list|,
name|NOP_EXPR
argument_list|,
name|vlist1
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* If the dtor is empty, and we know there is not possible way we      could use any vtable entries, before they are possibly set by      a base class dtor, we don't have to setup the vtables, as we      know that any base class dtoring will set up any vtables it      needs.  We avoid MI, because one base class dtor can do a      virtual dispatch to an overridden function that would need to      have a non-related vtable set up, we cannot avoid setting up      vtables in that case.  We could change this to see if there is      just one vtable.  */
if|if
condition|(
operator|!
name|empty_dtor
operator|||
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Make all virtual function table pointers in non-virtual base 	 classes point to CURRENT_CLASS_TYPE's virtual function 	 tables.  */
name|expand_direct_vtbls_init
argument_list|(
name|binfo
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|current_class_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|expand_indirect_vtbls_init
argument_list|(
name|binfo
argument_list|,
name|current_class_ref
argument_list|,
name|current_class_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|current_class_ptr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
name|NULL_RTX
condition|)
name|last_parm_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
else|else
name|last_parm_insn
operator|=
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
name|emit_insns_after
argument_list|(
name|insns
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit implicit code for a constructor. This is a subroutine of    finish_function. CALL_POPLEVEL is the same variable in    finish_function.  */
end_comment

begin_function
specifier|static
name|void
name|finish_ctor
parameter_list|(
name|call_poplevel
parameter_list|)
name|int
name|call_poplevel
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|cond
init|=
name|NULL_TREE
decl_stmt|,
name|thenclause
init|=
name|NULL_TREE
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|tree
name|decls
decl_stmt|;
comment|/* Allow constructor for a type to get a new instance of the object      using `build_new'.  */
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|current_class_ptr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|thenclause
operator|=
name|build_modify_expr
argument_list|(
name|current_class_ptr
argument_list|,
name|NOP_EXPR
argument_list|,
name|build_new
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_type
argument_list|,
name|void_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
block|{
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|thenclause
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* Emit insns from `emit_base_init' which sets up virtual      function table pointer(s).  */
if|if
condition|(
name|base_init_expr
condition|)
block|{
name|expand_expr_stmt
argument_list|(
name|base_init_expr
argument_list|)
expr_stmt|;
name|base_init_expr
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* This is where the body of the constructor begins.  */
name|emit_insns_after
argument_list|(
name|insns
argument_list|,
name|last_parm_cleanup_insn
argument_list|)
expr_stmt|;
name|end_protect_partials
argument_list|()
expr_stmt|;
comment|/* This is where the body of the constructor ends.  */
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|decls
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* c_expand_return knows to return 'this' from a constructor.  */
name|c_expand_return
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.    LINENO is the current line number.     FLAGS is a bitwise or of the following values:       1 - CALL_POPLEVEL         An extra call to poplevel (and expand_end_bindings) must be        made to take care of the binding contour for the base        initializers.  This is only relevant for constructors.      2 - INCLASS_INLINE        We just finished processing the body of an in-class inline        function definition.  (This processing will have taken place        after the class definition is complete.)     NESTED is nonzero if we were in the middle of compiling another function    when we started on this one.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|lineno
parameter_list|,
name|flags
parameter_list|,
name|nested
parameter_list|)
name|int
name|lineno
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|nested
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
decl_stmt|,
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Label to use if this function is supposed to return a value.  */
name|tree
name|no_return_label
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|call_poplevel
init|=
operator|(
name|flags
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|inclass_inline
init|=
operator|(
name|flags
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|in_template
decl_stmt|;
comment|/* When we get some parse errors, we can end up without a      current_function_decl, so cope.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|function_depth
operator|>
literal|1
condition|)
name|nested
operator|=
literal|1
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;     This caused&foo to be of type ptr-to-const-function     which then got a warning when stored in a ptr-to-function variable.  */
comment|/* This happens on strange parse errors.  */
if|if
condition|(
operator|!
name|current_function_parms_stored
condition|)
block|{
name|call_poplevel
operator|=
literal|0
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|call_poplevel
condition|)
block|{
name|decls
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
comment|/*&& TREE_CODE (fntype) != METHOD_TYPE*/
condition|)
block|{
name|tree
name|ttype
init|=
name|target_type
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|tree
name|parmdecl
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
for|for
control|(
name|parmdecl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parmdecl
condition|;
name|parmdecl
operator|=
name|TREE_CHAIN
argument_list|(
name|parmdecl
argument_list|)
control|)
block|{
name|ttype
operator|=
name|target_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean house because we will need to reorder insns here.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtor_label
condition|)
name|finish_dtor
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
comment|/* Does not need to call emit_base_init, because 	     that is done (if needed) just after assignment to this 	     is seen.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|end_protect_partials
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|decls
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* c_expand_return knows to return 'this' from a constructor.  */
name|c_expand_return
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|return_label
operator|!=
name|NULL_RTX
condition|)
name|no_return_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|base_init_expr
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|DECL_VLIST_CTOR_WRAPPER_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|finish_ctor
argument_list|(
name|call_poplevel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Make it so that `main' always returns 0 by default.  */
ifdef|#
directive|ifdef
name|VMS
name|c_expand_return
argument_list|(
name|integer_one_node
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_expand_return
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|return_label
operator|!=
name|NULL_RTX
operator|&&
name|current_function_return_value
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|no_return_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_exceptions
condition|)
name|expand_exception_blocks
argument_list|()
expr_stmt|;
comment|/* If this function is supposed to return a value, ensure that 	 we do not fall into the cleanups by mistake.  The end of our 	 function will look like this: 	  	 user code (may have return stmt somewhere) 	 goto no_return_label 	 cleanup_label: 	 cleanups 	 goto return_label 	 no_return_label: 	 NOTE_INSN_FUNCTION_END 	 return_label: 	 things for return 	  	 If the user omits a return stmt in the USER CODE section, we 	 will have a control path which reaches NOTE_INSN_FUNCTION_END. 	 Otherwise, we won't.  */
if|if
condition|(
name|no_return_label
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|expand_goto
argument_list|(
name|no_return_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup_label
condition|)
block|{
comment|/* Remove the binding contour which is used 	     to catch cleanup-generated temporaries.  */
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Emit label at beginning of cleanup code for parameters.  */
name|emit_label
argument_list|(
name|cleanup_label
argument_list|)
expr_stmt|;
block|}
comment|/* Get return value into register if that's where it's supposed to be.  */
if|if
condition|(
name|original_result_rtx
condition|)
name|fixup_result_decl
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|original_result_rtx
argument_list|)
expr_stmt|;
comment|/* Finish building code that will trigger warnings if users forget 	 to make their functions return values.  */
if|if
condition|(
name|no_return_label
operator|||
name|cleanup_label
condition|)
name|emit_jump
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_return_label
condition|)
block|{
comment|/* We don't need to call `expand_*_return' here because we 	     don't need any cleanups here--this path of code is only 	     for error checking purposes.  */
name|expand_label
argument_list|(
name|no_return_label
argument_list|)
expr_stmt|;
block|}
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we're processing a template, squirrel away the definition      until we do an instantiation.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
operator|--
name|minimal_parse_mode
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have to save this value here in case 	 maybe_end_member_template_processing decides to pop all the 	 template parameters.  */
name|in_template
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|in_template
operator|=
literal|0
expr_stmt|;
comment|/* This must come after expand_function_end because cleanups might      have declarations (from inline functions) that need to go into      this function's blocks.  */
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|!=
literal|1
condition|)
name|my_friendly_abort
argument_list|(
literal|122
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is a in-class inline definition, we may have to pop the      bindings for the template parameters that we added in      maybe_begin_member_template_processing when start_function was      called.  */
if|if
condition|(
name|inclass_inline
condition|)
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
comment|/* Reset scope for C++: if we were in the scope of a class,      then when we finish this function, we are not longer so.      This cannot be done until we know for sure that no more      class members will ever be referenced in this function      (i.e., calls to destructors).  */
if|if
condition|(
name|current_class_name
condition|)
block|{
name|ctype
operator|=
name|current_class_type
expr_stmt|;
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point      to the FUNCTION_DECL node itself.  */
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
if|if
condition|(
operator|!
name|in_template
condition|)
block|{
name|int
name|saved_flag_keep_inline_functions
init|=
name|flag_keep_inline_functions
decl_stmt|;
comment|/* So we can tell if jump_optimize sets it to 1.  */
name|can_reach_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|hack_decl_function_context
argument_list|(
name|fndecl
argument_list|)
condition|)
comment|/* Trick rest_of_compilation into not deferring output of this 	   function, even if it is inline, since the rtl_obstack for 	   this function is the function_obstack of the enclosing 	   function and will be deallocated when the enclosing 	   function is gone.  See save_tree_status.  */
name|flag_keep_inline_functions
operator|=
literal|1
expr_stmt|;
comment|/* Run the optimizers and output the assembler code for this          function.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Do we really *want* to inline this synthesized method?  */
name|int
name|save_fif
init|=
name|flag_inline_functions
decl_stmt|;
name|flag_inline_functions
operator|=
literal|1
expr_stmt|;
comment|/* Turn off DECL_INLINE for the moment so function_cannot_inline_p 	     will check our size.  */
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|flag_inline_functions
operator|=
name|save_fif
expr_stmt|;
block|}
else|else
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|flag_keep_inline_functions
operator|=
name|saved_flag_keep_inline_functions
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Set DECL_EXTERNAL so that assemble_external will be called as 	     necessary.  We'll clear it again in finish_file.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
condition|)
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_inline_for_output
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
condition|)
name|note_debug_info_needed
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|current_function_returns_null
operator||=
name|can_reach_end
expr_stmt|;
comment|/* Since we don't normally go through c_expand_return for constructors, 	 this normally gets the wrong value. 	 Also, named return values have their return codes emitted after 	 NOTE_INSN_FUNCTION_END, confusing jump.c.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|current_function_returns_null
condition|)
name|cp_warning
argument_list|(
literal|"`noreturn' function `%D' does return"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|warn_return_type
operator|||
name|pedantic
operator|)
operator|&&
name|current_function_returns_null
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
comment|/* If this function returns non-void and control can drop through, 	     complain.  */
name|cp_warning
argument_list|(
literal|"control reaches end of non-void function `%D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* With just -W, complain only if function returns both with 	 and without a value.  */
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
block|}
operator|--
name|function_depth
expr_stmt|;
comment|/* Free all the tree nodes making up this function.  */
comment|/* Switch back to allocating nodes permanently      until we start another function.  */
if|if
condition|(
operator|!
name|nested
condition|)
name|permanent_allocation
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_RTX
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fndecl
argument_list|)
condition|)
name|static_ctors
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fndecl
argument_list|)
condition|)
name|static_dtors
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nested
condition|)
block|{
comment|/* Let the error reporting routines know that we're outside a          function.  For a nested function, this value is used in          pop_cp_function_context and then reset via pop_function_context.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|named_label_uses
operator|=
name|NULL
expr_stmt|;
name|current_class_ptr
operator|=
name|NULL_TREE
expr_stmt|;
name|current_class_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the return type and the name of the function,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns a FUNCTION_DECL on success.     If the DECLARATOR is not suitable for a function (it defines a datum    instead), we return 0, which tells yyparse to report a parse error.     May return void_type_node indicating that this method is actually    a friend.  See grokfield for more details.     Came here with a `.pushlevel' .     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `grokfield'.  */
end_comment

begin_function
name|tree
name|start_method
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|attrlist
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|attrlist
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
name|attrlist
argument_list|)
decl_stmt|;
comment|/* Something too ugly to handle.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Pass friends other than inline friend functions back.  */
if|if
condition|(
name|fndecl
operator|==
name|void_type_node
condition|)
return|return
name|fndecl
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* Not a function, tell parser to report parse error.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|IS_DEFAULT_IMPLEMENTATION
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|cp_error
argument_list|(
literal|"`%D' is already defined in class %s"
argument_list|,
name|fndecl
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|void_type_node
return|;
block|}
name|check_template_shadow
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_THIS_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_default_inline
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We process method specializations in finish_struct_1.  */
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fndecl
argument_list|)
condition|)
name|fndecl
operator|=
name|push_template_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* We read in the parameters on the maybepermanent_obstack,      but we won't be getting back to them until after we      may have clobbered them.  So the call to preserve_data      will keep them safe.  */
name|preserve_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|grok_ctor_properties
argument_list|(
name|current_class_type
argument_list|,
name|fndecl
argument_list|)
condition|)
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|fndecl
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cp_finish_decl
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a place for the parms */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Go through the motions of finishing a function definition.    We don't compile this method until after the whole class has    been processed.     FINISH_METHOD must return something that looks as though it    came from GROKFIELD (since we are defining a method, after all).     This is called after parsing the body of the function definition.    STMTS is the chain of statements that makes up the function body.     DECL is the ..._DECL that `start_method' provided.  */
end_comment

begin_function
name|tree
name|finish_method
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|decl
decl_stmt|;
name|tree
name|old_initial
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|decl
return|;
name|old_initial
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the level for the parms (from start_method).      This is like poplevel, but it causes nothing to be      saved.  Saving information here confuses symbol-table      output routines.  Besides, this information will      be correctly output when this method is actually      compiled.  */
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|!=
name|FUNCTION_DECL
argument_list|,
literal|163
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|old_initial
expr_stmt|;
comment|/* We used to check if the context of FNDECL was different from      current_class_type as another way to get inside here.  This didn't work      for String.cc in libg++.  */
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a new struct TYPE is defined.    If this structure or union completes the type of any previous    variable declaration, lay it out and output its rtl.  */
end_comment

begin_function
name|void
name|hack_incomplete_structures
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|incomplete
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
operator|!
name|type
condition|)
comment|/* Don't do this for class templates.  */
return|return;
for|for
control|(
name|list
operator|=
operator|&
name|current_binding_level
operator|->
name|incomplete
init|;
operator|*
name|list
condition|;
control|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|decl
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|type
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
operator|)
condition|)
block|{
name|int
name|toplevel
init|=
name|toplevel_bindings_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
block|{
name|tree
name|cleanup
decl_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
else|else
name|list
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup here.    See build_delete for information about AUTO_DELETE.     Don't build these on the momentary obstack; they must live    the life of the binding contour.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_build_cleanup_1
parameter_list|(
name|decl
parameter_list|,
name|auto_delete
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|auto_delete
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|temp
init|=
literal|0
decl_stmt|,
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
decl_stmt|;
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|temp
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|rval
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize for space over speed here.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|||
name|flag_expensive_optimizations
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
name|rval
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|,
name|auto_delete
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_vbase_delete
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|resume_momentary
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup    here.  The cleanup does free the storage with a call to delete.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup_and_delete
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|maybe_build_cleanup_1
argument_list|(
name|decl
argument_list|,
name|integer_three_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup    here.  The cleanup does not free the storage with a call a delete.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|maybe_build_cleanup_1
argument_list|(
name|decl
argument_list|,
name|integer_two_node
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C++ expression at the statement level.    This is needed to ferret out nodes which have UNKNOWN_TYPE.    The C++ type checker should get all of these out when    expressions are combined with other, type-providing, expressions,    leaving only orphan expressions, such as:&class::bar;		/ / takes its address, but does nothing with it.  */
end_comment

begin_function
name|void
name|cplus_expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|EXPR_STMT
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Arrange for all temps to disappear.  */
name|expand_start_target_temps
argument_list|()
expr_stmt|;
name|exp
operator|=
name|require_complete_type_in_void
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|cp_warning
argument_list|(
literal|"reference, not call, to function `%D'"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* We should do this eventually, but right now this causes regex.o from      libg++ to miscompile, and tString to core dump.  */
block|exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);
endif|#
directive|endif
comment|/* Strip unused implicit INDIRECT_REFs of references.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we don't do this, we end up down inside expand_expr      trying to do TYPE_MODE on the ERROR_MARK, and really      go outside the bounds of the type.  */
if|if
condition|(
name|exp
operator|!=
name|error_mark_node
condition|)
name|expand_expr_stmt
argument_list|(
name|break_out_cleanups
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up any pending cleanups.  This happens when a function call      returns a cleanup-needing value that nobody uses.  */
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When a stmt has been parsed, this function is called.     Currently, this function only does something within a    constructor's scope: if a stmt has just assigned to this,    and we are in a derived class, we call `emit_base_init'.  */
end_comment

begin_function
name|void
name|finish_stmt
parameter_list|()
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|,
modifier|*
name|loop_stack
decl_stmt|,
modifier|*
name|case_stack
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
operator|||
operator|!
name|current_function_just_assigned_this
condition|)
return|return;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Constructors must wait until we are out of control 	 zones before calling base constructors.  */
if|if
condition|(
name|cond_stack
operator|||
name|loop_stack
operator|||
name|case_stack
condition|)
return|return;
name|expand_expr_stmt
argument_list|(
name|base_init_expr
argument_list|)
expr_stmt|;
name|check_base_init
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
block|}
name|current_function_assigns_this
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change a static member function definition into a FUNCTION_TYPE, instead    of the METHOD_TYPE that we create when it's originally parsed.     WARNING: DO NOT pass&TREE_TYPE (decl) to FN or&TYPE_ARG_TYPES    (TREE_TYPE (decl)) to ARGTYPES, as doing so will corrupt the types of    other decls.  Either pass the addresses of local variables or NULL.  */
end_comment

begin_function
name|void
name|revert_static_member_fn
parameter_list|(
name|decl
parameter_list|,
name|fn
parameter_list|,
name|argtypes
parameter_list|)
name|tree
modifier|*
name|decl
decl_stmt|,
decl|*
name|fn
decl_stmt|,
modifier|*
name|argtypes
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|function
init|=
name|fn
condition|?
operator|*
name|fn
else|:
name|TREE_TYPE
argument_list|(
operator|*
name|decl
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|argtypes
condition|?
operator|*
name|argtypes
else|:
name|TYPE_ARG_TYPES
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|cp_error
argument_list|(
literal|"static member function `%#D' declared with type qualifiers"
argument_list|,
operator|*
name|decl
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_qualified_type
argument_list|(
name|tmp
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_exception_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|decl
argument_list|)
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
operator|*
name|decl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
operator|*
name|decl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
operator|*
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
operator|*
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fn
condition|)
operator|*
name|fn
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|argtypes
condition|)
operator|*
name|argtypes
operator|=
name|args
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|cp_function
block|{
name|int
name|returns_value
decl_stmt|;
name|int
name|returns_null
decl_stmt|;
name|int
name|assigns_this
decl_stmt|;
name|int
name|just_assigned_this
decl_stmt|;
name|int
name|parms_stored
decl_stmt|;
name|int
name|temp_name_counter
decl_stmt|;
name|tree
name|named_labels
decl_stmt|;
name|struct
name|named_label_list
modifier|*
name|named_label_uses
decl_stmt|;
name|tree
name|shadowed_labels
decl_stmt|;
name|tree
name|ctor_label
decl_stmt|;
name|tree
name|dtor_label
decl_stmt|;
name|rtx
name|last_dtor_insn
decl_stmt|;
name|rtx
name|last_parm_cleanup_insn
decl_stmt|;
name|tree
name|base_init_list
decl_stmt|;
name|tree
name|member_init_list
decl_stmt|;
name|tree
name|base_init_expr
decl_stmt|;
name|tree
name|current_class_ptr
decl_stmt|;
name|tree
name|current_class_ref
decl_stmt|;
name|rtx
name|result_rtx
decl_stmt|;
name|struct
name|cp_function
modifier|*
name|next
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|int
name|static_labelno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cp_function
modifier|*
name|cp_function_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|temp_name_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save and reinitialize the variables    used during compilation of a C++ function.  */
end_comment

begin_function
name|void
name|push_cp_function_context
parameter_list|(
name|context
parameter_list|)
name|tree
name|context
decl_stmt|;
block|{
name|struct
name|cp_function
modifier|*
name|p
init|=
operator|(
expr|struct
name|cp_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cp_function
argument_list|)
argument_list|)
decl_stmt|;
name|push_function_context_to
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|cp_function_chain
expr_stmt|;
name|cp_function_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|named_labels
operator|=
name|named_labels
expr_stmt|;
name|p
operator|->
name|named_label_uses
operator|=
name|named_label_uses
expr_stmt|;
name|p
operator|->
name|shadowed_labels
operator|=
name|shadowed_labels
expr_stmt|;
name|p
operator|->
name|returns_value
operator|=
name|current_function_returns_value
expr_stmt|;
name|p
operator|->
name|returns_null
operator|=
name|current_function_returns_null
expr_stmt|;
name|p
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|p
operator|->
name|ctor_label
operator|=
name|ctor_label
expr_stmt|;
name|p
operator|->
name|dtor_label
operator|=
name|dtor_label
expr_stmt|;
name|p
operator|->
name|last_dtor_insn
operator|=
name|last_dtor_insn
expr_stmt|;
name|p
operator|->
name|last_parm_cleanup_insn
operator|=
name|last_parm_cleanup_insn
expr_stmt|;
name|p
operator|->
name|assigns_this
operator|=
name|current_function_assigns_this
expr_stmt|;
name|p
operator|->
name|just_assigned_this
operator|=
name|current_function_just_assigned_this
expr_stmt|;
name|p
operator|->
name|parms_stored
operator|=
name|current_function_parms_stored
expr_stmt|;
name|p
operator|->
name|result_rtx
operator|=
name|original_result_rtx
expr_stmt|;
name|p
operator|->
name|base_init_expr
operator|=
name|base_init_expr
expr_stmt|;
name|p
operator|->
name|temp_name_counter
operator|=
name|temp_name_counter
expr_stmt|;
name|p
operator|->
name|base_init_list
operator|=
name|current_base_init_list
expr_stmt|;
name|p
operator|->
name|member_init_list
operator|=
name|current_member_init_list
expr_stmt|;
name|p
operator|->
name|current_class_ptr
operator|=
name|current_class_ptr
expr_stmt|;
name|p
operator|->
name|current_class_ref
operator|=
name|current_class_ref
expr_stmt|;
name|p
operator|->
name|static_labelno
operator|=
name|static_labelno
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the variables used during compilation of a C++ function.  */
end_comment

begin_function
name|void
name|pop_cp_function_context
parameter_list|(
name|context
parameter_list|)
name|tree
name|context
decl_stmt|;
block|{
name|struct
name|cp_function
modifier|*
name|p
init|=
name|cp_function_chain
decl_stmt|;
name|tree
name|link
decl_stmt|;
comment|/* Bring back all the labels that were shadowed.  */
for|for
control|(
name|link
operator|=
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|pop_function_context_from
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|cp_function_chain
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|named_labels
operator|=
name|p
operator|->
name|named_labels
expr_stmt|;
name|named_label_uses
operator|=
name|p
operator|->
name|named_label_uses
expr_stmt|;
name|shadowed_labels
operator|=
name|p
operator|->
name|shadowed_labels
expr_stmt|;
name|current_function_returns_value
operator|=
name|p
operator|->
name|returns_value
expr_stmt|;
name|current_function_returns_null
operator|=
name|p
operator|->
name|returns_null
expr_stmt|;
name|current_binding_level
operator|=
name|p
operator|->
name|binding_level
expr_stmt|;
name|ctor_label
operator|=
name|p
operator|->
name|ctor_label
expr_stmt|;
name|dtor_label
operator|=
name|p
operator|->
name|dtor_label
expr_stmt|;
name|last_dtor_insn
operator|=
name|p
operator|->
name|last_dtor_insn
expr_stmt|;
name|last_parm_cleanup_insn
operator|=
name|p
operator|->
name|last_parm_cleanup_insn
expr_stmt|;
name|current_function_assigns_this
operator|=
name|p
operator|->
name|assigns_this
expr_stmt|;
name|current_function_just_assigned_this
operator|=
name|p
operator|->
name|just_assigned_this
expr_stmt|;
name|current_function_parms_stored
operator|=
name|p
operator|->
name|parms_stored
expr_stmt|;
name|original_result_rtx
operator|=
name|p
operator|->
name|result_rtx
expr_stmt|;
name|base_init_expr
operator|=
name|p
operator|->
name|base_init_expr
expr_stmt|;
name|temp_name_counter
operator|=
name|p
operator|->
name|temp_name_counter
expr_stmt|;
name|current_base_init_list
operator|=
name|p
operator|->
name|base_init_list
expr_stmt|;
name|current_member_init_list
operator|=
name|p
operator|->
name|member_init_list
expr_stmt|;
name|current_class_ptr
operator|=
name|p
operator|->
name|current_class_ptr
expr_stmt|;
name|current_class_ref
operator|=
name|p
operator|->
name|current_class_ref
expr_stmt|;
name|static_labelno
operator|=
name|p
operator|->
name|static_labelno
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|in_function_p
parameter_list|()
block|{
return|return
name|function_depth
operator|!=
literal|0
return|;
block|}
end_function

end_unit

