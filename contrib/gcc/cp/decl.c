begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C++ compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C++ front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_function_decl
specifier|static
name|tree
name|grokparms
parameter_list|(
name|cp_parameter_declarator
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decl_jump_unsafe
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|require_complete_types_for_parms
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ambi_op_p
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unary_op_p
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_local_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|grok_reference_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|grokvardecl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_unknown_type
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|builtin_function_1
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|built_in_function
name|code
parameter_list|,
name|enum
name|built_in_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_library_fn_1
parameter_list|(
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|member_function_or_else
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|overload_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bad_specifiers
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_for_uninitialized_const_var
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|typename_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|typename_compare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|local_variable_p_walkfn
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|record_builtin_java_type
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|tag_name
parameter_list|(
name|enum
name|tag_types
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_and_check_tag
parameter_list|(
name|enum
name|tag_types
parameter_list|,
name|tree
parameter_list|,
name|tag_scope
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|walk_namespaces_r
parameter_list|(
name|tree
parameter_list|,
name|walk_namespaces_fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_deduce_size_from_array_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_var_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_commonize_var
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|check_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_rtl_for_nonlocal_decl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_function_data
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_function_type
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_constructor_body
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|begin_destructor_body
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_destructor_body
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|create_array_type_for_decl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_atexit_node
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_dso_handle_node
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|start_cleanup_fn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_cleanup_fn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_make_fname_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_predefined_identifiers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|check_special_function_return_type
parameter_list|(
name|special_function_kind
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|push_cp_library_fn
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_cp_library_fn
parameter_list|(
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_parm_decls
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_local_var
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_static_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|next_initializable_field
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The following symbols are subsumed in the cp_global_trees array, and    listed here individually for documentation purposes.     C++ extensions 	tree wchar_decl_node;  	tree vtable_entry_type; 	tree delta_type_node; 	tree __t_desc_type_node;  	tree class_type_node; 	tree unknown_type_node;     Array type `vtable_entry_type[]'  	tree vtbl_type_node; 	tree vtbl_ptr_type_node;     Namespaces,  	tree std_node; 	tree abi_node;     A FUNCTION_DECL which can call `abort'.  Not necessarily the    one that the user will declare, but sufficient to be called    by routines that want to abort the program.  	tree abort_fndecl;     The FUNCTION_DECL for the default `::operator delete'.  	tree global_delete_fndecl;     Used by RTTI 	tree type_info_type_node, tinfo_decl_id, tinfo_decl_type; 	tree tinfo_var_id;  */
end_comment

begin_decl_stmt
name|tree
name|cp_global_trees
index|[
name|CPTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates that there is a type value in some namespace, although    that is not necessarily in scope at the moment.  */
end_comment

begin_decl_stmt
name|tree
name|global_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The node that holds the "name" of the global scope.  */
end_comment

begin_decl_stmt
name|tree
name|global_scope_name
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|local_names
value|cp_function_chain->x_local_names
end_define

begin_comment
comment|/* A list of objects which have constructors or destructors    which reside in the global scope.  The decl is stored in    the TREE_VALUE slot and the initializer is stored    in the TREE_PURPOSE slot.  */
end_comment

begin_decl_stmt
name|tree
name|static_aggregates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- end of C++ */
end_comment

begin_comment
comment|/* A node for the integer constants 2, and 3.  */
end_comment

begin_decl_stmt
name|tree
name|integer_two_node
decl_stmt|,
name|integer_three_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used only for jumps to as-yet undefined labels, since jumps to    defined labels can have their validity checked immediately.  */
end_comment

begin_decl_stmt
name|struct
name|named_label_use_entry
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|named_label_use_entry
modifier|*
name|next
decl_stmt|;
comment|/* The binding level to which this entry is *currently* attached.      This is initially the binding level in which the goto appeared,      but is modified as scopes are closed.  */
name|struct
name|cp_binding_level
modifier|*
name|binding_level
decl_stmt|;
comment|/* The head of the names list that was current when the goto appeared,      or the inner scope popped.  These are the decls that will *not* be      skipped when jumping to the label.  */
name|tree
name|names_in_scope
decl_stmt|;
comment|/* The location of the goto, for error reporting.  */
name|location_t
name|o_goto_locus
decl_stmt|;
comment|/* True if an OpenMP structured block scope has been closed since      the goto appeared.  This means that the branch from the label will      illegally exit an OpenMP scope.  */
name|bool
name|in_omp_scope
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* A list of all LABEL_DECLs in the function that have names.  Here so    we can clear out their names' definitions at the end of the    function, and so we can check the validity of jumps to these labels.  */
end_comment

begin_decl_stmt
name|struct
name|named_label_entry
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The decl itself.  */
name|tree
name|label_decl
decl_stmt|;
comment|/* The binding level to which the label is *currently* attached.      This is initially set to the binding level in which the label      is defined, but is modified as scopes are closed.  */
name|struct
name|cp_binding_level
modifier|*
name|binding_level
decl_stmt|;
comment|/* The head of the names list that was current when the label was      defined, or the inner scope popped.  These are the decls that will      be skipped when jumping to the label.  */
name|tree
name|names_in_scope
decl_stmt|;
comment|/* A tree list of all decls from all binding levels that would be      crossed by a backward branch to the label.  */
name|tree
name|bad_decls
decl_stmt|;
comment|/* A list of uses of the label, before the label is defined.  */
name|struct
name|named_label_use_entry
modifier|*
name|uses
decl_stmt|;
comment|/* The following bits are set after the label is defined, and are      updated as scopes are popped.  They indicate that a backward jump      to the label will illegally enter a scope of the given flavor.  */
name|bool
name|in_try_scope
decl_stmt|;
name|bool
name|in_catch_scope
decl_stmt|;
name|bool
name|in_omp_scope
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|named_labels
value|cp_function_chain->x_named_labels
end_define

begin_escape
end_escape

begin_comment
comment|/* The number of function bodies which we are currently processing.    (Zero if we are at namespace scope, one inside the body of a    function, two inside the body of a function in a local class, etc.)  */
end_comment

begin_decl_stmt
name|int
name|function_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* States indicating how grokdeclarator() should handle declspecs marked    with __attribute__((deprecated)).  An object declared as    __attribute__((deprecated)) suppresses warnings of uses of other    deprecated items.  */
end_comment

begin_enum
enum|enum
name|deprecated_states
block|{
name|DEPRECATED_NORMAL
block|,
name|DEPRECATED_SUPPRESS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|deprecated_states
name|deprecated_state
init|=
name|DEPRECATED_NORMAL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* A TREE_LIST of VAR_DECLs.  The TREE_PURPOSE is a RECORD_TYPE or    UNION_TYPE; the TREE_VALUE is a VAR_DECL with that type.  At the    time the VAR_DECL was declared, the type was incomplete.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|incomplete_vars
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns the kind of template specialization we are currently    processing, given that it's declaration contained N_CLASS_SCOPES    explicit scope qualifications.  */
end_comment

begin_function
name|tmpl_spec_kind
name|current_tmpl_spec_kind
parameter_list|(
name|int
name|n_class_scopes
parameter_list|)
block|{
name|int
name|n_template_parm_scopes
init|=
literal|0
decl_stmt|;
name|int
name|seen_specialization_p
init|=
literal|0
decl_stmt|;
name|int
name|innermost_specialization_p
init|=
literal|0
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Scan through the template parameter scopes.  */
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
comment|/* If we see a specialization scope inside a parameter scope, 	 then something is wrong.  That corresponds to a declaration 	 like:  	    template<class T> template<> ...  	 which is always invalid since [temp.expl.spec] forbids the 	 specialization of a class member template if the enclosing 	 class templates are not explicitly specialized as well.  */
if|if
condition|(
name|b
operator|->
name|explicit_spec_p
condition|)
block|{
if|if
condition|(
name|n_template_parm_scopes
operator|==
literal|0
condition|)
name|innermost_specialization_p
operator|=
literal|1
expr_stmt|;
else|else
name|seen_specialization_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_specialization_p
operator|==
literal|1
condition|)
return|return
name|tsk_invalid_member_spec
return|;
operator|++
name|n_template_parm_scopes
expr_stmt|;
block|}
comment|/* Handle explicit instantiations.  */
if|if
condition|(
name|processing_explicit_instantiation
condition|)
block|{
if|if
condition|(
name|n_template_parm_scopes
operator|!=
literal|0
condition|)
comment|/* We've seen a template parameter list during an explicit 	   instantiation.  For example:  	     template<class T> template void f(int);  	   This is erroneous.  */
return|return
name|tsk_invalid_expl_inst
return|;
else|else
return|return
name|tsk_expl_inst
return|;
block|}
if|if
condition|(
name|n_template_parm_scopes
operator|<
name|n_class_scopes
condition|)
comment|/* We've not seen enough template headers to match all the        specialized classes present.  For example:  	 template<class T> void R<T>::S<T>::f(int);         This is invalid; there needs to be one set of template        parameters for each class.  */
return|return
name|tsk_insufficient_parms
return|;
elseif|else
if|if
condition|(
name|n_template_parm_scopes
operator|==
name|n_class_scopes
condition|)
comment|/* We're processing a non-template declaration (even though it may        be a member of a template class.)  For example:  	 template<class T> void S<T>::f(int);         The `class T' maches the `S<T>', leaving no template headers        corresponding to the `f'.  */
return|return
name|tsk_none
return|;
elseif|else
if|if
condition|(
name|n_template_parm_scopes
operator|>
name|n_class_scopes
operator|+
literal|1
condition|)
comment|/* We've got too many template headers.  For example:  	 template<> template<class T> void f (T);         There need to be more enclosing classes.  */
return|return
name|tsk_excessive_parms
return|;
else|else
comment|/* This must be a template.  It's of the form:  	 template<class T> template<class U> void S<T>::f(U);         This is a specialization if the innermost level was a        specialization; otherwise it's just a definition of the        template.  */
return|return
name|innermost_specialization_p
condition|?
name|tsk_expl_spec
else|:
name|tsk_template
return|;
block|}
end_function

begin_comment
comment|/* Exit the current scope.  */
end_comment

begin_function
name|void
name|finish_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When a label goes out of scope, check to see if that label was used    in a valid manner, and issue any appropriate warnings or errors.  */
end_comment

begin_function
specifier|static
name|void
name|pop_label
parameter_list|(
name|tree
name|label
parameter_list|,
name|tree
name|old_value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|location_t
name|location
decl_stmt|;
name|error
argument_list|(
literal|"label %q+D used but not defined"
argument_list|,
name|label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|location
operator|=
name|input_location
expr_stmt|;
comment|/* FIXME want (input_filename, (line)0) */
else|#
directive|else
name|location
operator|.
name|file
operator|=
name|input_filename
expr_stmt|;
name|location
operator|.
name|line
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|location
argument_list|,
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wunused_label
argument_list|,
literal|"label %q+D defined but not used"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of a function, all labels declared within the function    go out of scope.  BLOCK is the top-level block for the    function.  */
end_comment

begin_function
specifier|static
name|int
name|pop_labels_1
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|named_label_entry
modifier|*
name|ent
init|=
operator|(
expr|struct
name|named_label_entry
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|tree
name|block
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|pop_label
argument_list|(
name|ent
operator|->
name|label_decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Put the labels into the "variables" of the top-level block,      so debugger can see them.  */
name|TREE_CHAIN
argument_list|(
name|ent
operator|->
name|label_decl
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|ent
operator|->
name|label_decl
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|named_labels
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_labels
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
if|if
condition|(
name|named_labels
condition|)
block|{
name|htab_traverse
argument_list|(
name|named_labels
argument_list|,
name|pop_labels_1
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|named_labels
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* At the end of a block with local labels, restore the outer definition.  */
end_comment

begin_function
specifier|static
name|void
name|pop_local_label
parameter_list|(
name|tree
name|label
parameter_list|,
name|tree
name|old_value
parameter_list|)
block|{
name|struct
name|named_label_entry
name|dummy
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|pop_label
argument_list|(
name|label
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
name|dummy
operator|.
name|label_decl
operator|=
name|label
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|named_labels
argument_list|,
operator|&
name|dummy
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|named_labels
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following two routines are used to interface to Objective-C++.    The binding level is purposely treated as an opaque type.  */
end_comment

begin_function
name|void
modifier|*
name|objc_get_current_scope
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_binding_level
return|;
block|}
end_function

begin_comment
comment|/* The following routine is used by the NeXT-style SJLJ exceptions;    variables get marked 'volatile' so as to not be clobbered by    _setjmp()/_longjmp() calls.  All variables in the current scope,    as well as parent scopes up to (but not including) ENCLOSING_BLK    shall be thusly marked.  */
end_comment

begin_function
name|void
name|objc_mark_locals_volatile
parameter_list|(
name|void
modifier|*
name|enclosing_blk
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|scope
decl_stmt|;
for|for
control|(
name|scope
operator|=
name|current_binding_level
init|;
name|scope
operator|&&
name|scope
operator|!=
name|enclosing_blk
condition|;
name|scope
operator|=
name|scope
operator|->
name|level_chain
control|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|scope
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|objc_volatilize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Do not climb up past the current function.  */
if|if
condition|(
name|scope
operator|->
name|kind
operator|==
name|sk_function_parms
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Update data for defined and undefined labels when leaving a scope.  */
end_comment

begin_function
specifier|static
name|int
name|poplevel_named_label_1
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|named_label_entry
modifier|*
name|ent
init|=
operator|(
expr|struct
name|named_label_entry
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|bl
init|=
operator|(
expr|struct
name|cp_binding_level
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|obl
init|=
name|bl
operator|->
name|level_chain
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|binding_level
operator|==
name|bl
condition|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|ent
operator|->
name|names_in_scope
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|decl_jump_unsafe
argument_list|(
name|decl
argument_list|)
condition|)
name|ent
operator|->
name|bad_decls
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|decl
argument_list|,
name|ent
operator|->
name|bad_decls
argument_list|)
expr_stmt|;
name|ent
operator|->
name|binding_level
operator|=
name|obl
expr_stmt|;
name|ent
operator|->
name|names_in_scope
operator|=
name|obl
operator|->
name|names
expr_stmt|;
switch|switch
condition|(
name|bl
operator|->
name|kind
condition|)
block|{
case|case
name|sk_try
case|:
name|ent
operator|->
name|in_try_scope
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|sk_catch
case|:
name|ent
operator|->
name|in_catch_scope
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|sk_omp
case|:
name|ent
operator|->
name|in_omp_scope
operator|=
name|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|uses
condition|)
block|{
name|struct
name|named_label_use_entry
modifier|*
name|use
decl_stmt|;
for|for
control|(
name|use
operator|=
name|ent
operator|->
name|uses
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next
control|)
if|if
condition|(
name|use
operator|->
name|binding_level
operator|==
name|bl
condition|)
block|{
name|use
operator|->
name|binding_level
operator|=
name|obl
expr_stmt|;
name|use
operator|->
name|names_in_scope
operator|=
name|obl
operator|->
name|names
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|kind
operator|==
name|sk_omp
condition|)
name|use
operator|->
name|in_omp_scope
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP == 1, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|int
name|keep
parameter_list|,
name|int
name|reverse
parameter_list|,
name|int
name|functionbody
parameter_list|)
block|{
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|int
name|tmp
init|=
name|functionbody
decl_stmt|;
name|int
name|real_functionbody
decl_stmt|;
name|tree
name|subblocks
decl_stmt|;
name|tree
name|block
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|leaving_for_scope
decl_stmt|;
name|scope_kind
name|kind
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|restart
label|:
name|block
operator|=
name|NULL_TREE
expr_stmt|;
name|gcc_assert
argument_list|(
name|current_binding_level
operator|->
name|kind
operator|!=
name|sk_class
argument_list|)
expr_stmt|;
name|real_functionbody
operator|=
operator|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_cleanup
condition|?
operator|(
operator|(
name|functionbody
operator|=
literal|0
operator|)
operator|,
name|tmp
operator|)
else|:
name|functionbody
operator|)
expr_stmt|;
name|subblocks
operator|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|blocks
else|:
literal|0
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|VEC_length
argument_list|(
name|cp_class_binding
argument_list|,
name|current_binding_level
operator|->
name|class_shadowed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We used to use KEEP == 2 to indicate that the new block should go      at the beginning of the list of blocks at this binding level,      rather than the end.  This hack is no longer used.  */
name|gcc_assert
argument_list|(
name|keep
operator|==
literal|0
operator|||
name|keep
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|keep
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
comment|/* Any uses of undefined labels, and any defined labels, now operate      under constraints of next binding contour.  */
if|if
condition|(
name|cfun
operator|&&
operator|!
name|functionbody
operator|&&
name|named_labels
condition|)
name|htab_traverse
argument_list|(
name|named_labels
argument_list|,
name|poplevel_named_label_1
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|keep
operator|==
literal|1
operator|||
name|functionbody
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
name|NULL_TREE
condition|)
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
if|if
condition|(
name|keep
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* We still support the old for-scope rules, whereby the variables      in a for-init statement were in scope after the for-statement      ended.  We only use the new rules if flag_new_for_scope is      nonzero.  */
name|leaving_for_scope
operator|=
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_for
operator|&&
name|flag_new_for_scope
operator|==
literal|1
expr_stmt|;
comment|/* Before we remove the declarations first check for unused variables.  */
if|if
condition|(
name|warn_unused_variable
operator|&&
operator|!
name|processing_template_decl
condition|)
for|for
control|(
name|decl
operator|=
name|getdecls
argument_list|()
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wunused_variable
argument_list|,
literal|"unused variable %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Remove declarations for all the DECLs in this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|leaving_for_scope
operator|&&
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|cxx_binding
modifier|*
name|ob
decl_stmt|;
name|tree
name|ns_binding
decl_stmt|;
name|ob
operator|=
name|outer_binding
argument_list|(
name|name
argument_list|,
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|,
comment|/*class_p=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ob
condition|)
name|ns_binding
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|ns_binding
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|ob
operator|&&
name|ob
operator|->
name|scope
operator|==
name|current_binding_level
operator|->
name|level_chain
condition|)
comment|/* We have something like:  		 int i; 		 for (int i; ;);  	       and we are leaving the `for' scope.  There's no reason to 	       keep the binding of the inner `i' in this case.  */
name|pop_binding
argument_list|(
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ob
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ob
operator|->
name|value
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|||
operator|(
name|ns_binding
operator|&&
name|TREE_CODE
argument_list|(
name|ns_binding
argument_list|)
operator|==
name|TYPE_DECL
operator|)
condition|)
comment|/* Here, we have something like:  		 typedef int I;  		 void f () { 		   for (int I; ;); 		 }  	       We must pop the for-scope binding so we know what's a 	       type and what isn't.  */
name|pop_binding
argument_list|(
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Mark this VAR_DECL as dead so that we can tell we left it 		 there only for backward compatibility.  */
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Keep track of what should have happened when we 		 popped the binding.  */
if|if
condition|(
name|ob
operator|&&
name|ob
operator|->
name|value
condition|)
block|{
name|SET_DECL_SHADOWED_FOR_VAR
argument_list|(
name|link
argument_list|,
name|ob
operator|->
name|value
argument_list|)
expr_stmt|;
name|DECL_HAS_SHADOWED_FOR_VAR_P
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Add it to the list of dead variables in the next 		 outermost binding to that we can remove these when we 		 leave that binding.  */
name|current_binding_level
operator|->
name|level_chain
operator|->
name|dead_vars_from_for
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|link
argument_list|,
name|current_binding_level
operator|->
name|level_chain
operator|->
name|dead_vars_from_for
argument_list|)
expr_stmt|;
comment|/* Although we don't pop the cxx_binding, we do clear 		 its SCOPE since the scope is going away now.  */
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|->
name|scope
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|name
decl_stmt|;
comment|/* Remove the binding.  */
name|decl
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|OVL_FUNCTION
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|name
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove declarations for any `for' variables from inner scopes      that we kept around.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|dead_vars_from_for
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the IDENTIFIER_TYPE_VALUEs.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|type_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the IDENTIFIER_LABEL_VALUEs for local labels.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|pop_local_label
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs      list if a `using' declaration put them there.  The debugging      back-ends won't understand OVERLOAD, so we remove them here.      Because the BLOCK_VARS are (temporarily) shared with      CURRENT_BINDING_LEVEL->NAMES we must do this fixup after we have      popped all the bindings.  */
if|if
condition|(
name|block
condition|)
block|{
name|tree
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
operator|*
name|d
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
condition|)
operator|*
name|d
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the level being exited is the top level of a function,      check over all the labels.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* Since this is the top level block of a function, the vars are 	 the function's parameters.  Don't leave them in the BLOCK 	 because they are found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pop_labels
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|kind
operator|=
name|current_binding_level
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|sk_cleanup
condition|)
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* If this is a temporary binding created for a cleanup, then we'll 	 have pushed a statement list level.  Pop that, create a new 	 BIND_EXPR for the block, and insert it into the stream.  */
name|stmt
operator|=
name|pop_stmt_list
argument_list|(
name|current_binding_level
operator|->
name|statement_list
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_build_bind_expr
argument_list|(
name|block
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
name|leave_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|functionbody
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
comment|/* Each and every BLOCK node created here in `poplevel' is important      (e.g. for proper debugging information) so if we created one      earlier, mark it as "used".  */
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* All temporary bindings created for cleanups are popped silently.  */
if|if
condition|(
name|kind
operator|==
name|sk_cleanup
condition|)
goto|goto
name|restart
goto|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the    current binding level.  This is used when a BIND_EXPR is expanded,    to handle the BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk all the namespaces contained NAMESPACE, including NAMESPACE    itself, calling F for each.  The DATA is passed to F as well.  */
end_comment

begin_function
specifier|static
name|int
name|walk_namespaces_r
parameter_list|(
name|tree
name|namespace
parameter_list|,
name|walk_namespaces_fn
name|f
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|tree
name|current
init|=
name|NAMESPACE_LEVEL
argument_list|(
name|namespace
argument_list|)
operator|->
name|namespaces
decl_stmt|;
name|result
operator||=
call|(
modifier|*
name|f
call|)
argument_list|(
name|namespace
argument_list|,
name|data
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|current
condition|;
name|current
operator|=
name|TREE_CHAIN
argument_list|(
name|current
argument_list|)
control|)
name|result
operator||=
name|walk_namespaces_r
argument_list|(
name|current
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Walk all the namespaces, calling F for each.  The DATA is passed to    F as well.  */
end_comment

begin_function
name|int
name|walk_namespaces
parameter_list|(
name|walk_namespaces_fn
name|f
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|walk_namespaces_r
argument_list|(
name|global_namespace
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call wrapup_globals_declarations for the globals in NAMESPACE.  If    DATA is non-NULL, this is the last time we will call    wrapup_global_declarations for this NAMESPACE.  */
end_comment

begin_function
name|int
name|wrapup_globals_for_namespace
parameter_list|(
name|tree
name|namespace
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
init|=
name|NAMESPACE_LEVEL
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|statics
operator|=
name|level
operator|->
name|static_decls
expr_stmt|;
name|tree
modifier|*
name|vec
init|=
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|statics
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|statics
argument_list|)
decl_stmt|;
name|int
name|last_time
init|=
operator|(
name|data
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|last_time
condition|)
block|{
name|check_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|emit_debug_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Write out any globals that need to be output.  */
return|return
name|wrapup_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In C++, you don't have to write `struct S' to refer to `S'; you    can just use `S'.  We accomplish this by creating a TYPE_DECL as    if the user had written `typedef struct S S'.  Create and return    the TYPE_DECL for TYPE.  */
end_comment

begin_function
name|tree
name|create_implicit_typedef
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* There are other implicit type declarations, like the one *within*      a class that allows you to write `S::S'.  We must distinguish      amongst these.  */
name|SET_DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Remember a local name for name-mangling purposes.  */
end_comment

begin_function
specifier|static
name|void
name|push_local_name
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|nelts
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|name
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|local_names
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|local_names
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|->
name|decl_flags
operator|.
name|u2sel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_DISCRIMINATOR
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_DISCRIMINATOR
argument_list|(
name|t
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|DECL_DISCRIMINATOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|local_names
argument_list|,
name|i
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|local_names
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of duplicate_decls: return truthvalue of whether    or not types of these decls match.     For C++, we must compare the parameter list so that `int' can match    `int&' in a parameter position, but `int&' is not confused with    `const int&'.  */
end_comment

begin_function
name|int
name|decls_match
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
name|int
name|types_match
decl_stmt|;
if|if
condition|(
name|newdecl
operator|==
name|olddecl
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* If the two DECLs are not even the same kind of thing, we're not        interested in their types.  */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|f1
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
decl_stmt|;
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CP_DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|p2
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
operator|||
operator|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|||
operator|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|void_list_node
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
elseif|else
if|if
condition|(
name|p1
operator|==
name|NULL_TREE
operator|&&
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|types_match
operator|=
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
name|types_match
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|types_match
operator|=
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|types_match
operator|=
name|decls_match
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Need to check scope for variable declaration (VAR_DECL). 	 For typedef (TYPE_DECL), scope is ignored.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|CP_DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CP_DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
comment|/* [dcl.link] 	     Two declarations for an object with C language linkage 	     with the same name (ignoring the namespace that qualify 	     it) that appear in different namespace scopes refer to 	     the same object.  */
operator|&&
operator|!
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
else|else
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|COMPARE_REDECLARATION
argument_list|)
expr_stmt|;
block|}
return|return
name|types_match
return|;
block|}
end_function

begin_comment
comment|/* If NEWDECL is `static' and an `extern' was seen previously,    warn about it.  OLDDECL is the previous declaration.     Note that this does not apply to the C++ case of declaring    a variable `extern const' and then later `const'.     Don't complain about built-in functions, since they are beyond    the user's control.  */
end_comment

begin_function
name|void
name|warn_extern_redeclared_static
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return;
comment|/* Don't get confused by static member functions; that's a different      use of `static'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return;
comment|/* If the old declaration was `static', or the new one isn't, then      then everything is OK.  */
if|if
condition|(
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|DECL_THIS_STATIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return;
comment|/* It's OK to declare a builtin function as `static'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"%qD was declared %<extern%> and later %<static%>"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"previous declaration of %q+D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NEW_DECL is a redeclaration of OLD_DECL; both are functions or    function templates.  If their exception specifications do not    match, issue an a diagnostic.  */
end_comment

begin_function
specifier|static
name|void
name|check_redeclaration_exception_specification
parameter_list|(
name|tree
name|new_decl
parameter_list|,
name|tree
name|old_decl
parameter_list|)
block|{
name|tree
name|new_type
decl_stmt|;
name|tree
name|old_type
decl_stmt|;
name|tree
name|new_exceptions
decl_stmt|;
name|tree
name|old_exceptions
decl_stmt|;
name|new_type
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|new_exceptions
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
name|old_type
operator|=
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|old_exceptions
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|old_type
argument_list|)
expr_stmt|;
comment|/* [except.spec]       If any declaration of a function has an exception-specification,      all declarations, including the definition and an explicit      specialization, of that function shall have an      exception-specification with the same set of type-ids.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|old_decl
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_IS_BUILTIN
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|flag_exceptions
operator|&&
operator|!
name|comp_except_specs
argument_list|(
name|new_exceptions
argument_list|,
name|old_exceptions
argument_list|,
comment|/*exact=*/
name|true
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qF throws different exceptions"
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"from previous declaration %q+F"
argument_list|,
name|old_decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If NEWDECL is a redeclaration of OLDDECL, merge the declarations.    If the redeclaration is invalid, a diagnostic is issued, and the    error_mark_node is returned.  Otherwise, OLDDECL is returned.     If NEWDECL is not a redeclaration of OLDDECL, NULL_TREE is    returned.     NEWDECL_IS_FRIEND is true if NEWDECL was declared as a friend.  */
end_comment

begin_function
name|tree
name|duplicate_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|,
name|bool
name|newdecl_is_friend
parameter_list|)
block|{
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|int
name|olddecl_friend
init|=
literal|0
decl_stmt|,
name|types_match
init|=
literal|0
decl_stmt|,
name|hidden_friend
init|=
literal|0
decl_stmt|;
name|int
name|new_defines_function
init|=
literal|0
decl_stmt|;
name|tree
name|new_template
decl_stmt|;
if|if
condition|(
name|newdecl
operator|==
name|olddecl
condition|)
return|return
name|olddecl
return|;
name|types_match
operator|=
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If either the type of the new decl or the type of the old decl is an      error_mark_node, then that implies that we have already issued an      error (earlier) for some bogus type specification, and in that case,      it is rather pointless to harass the user with yet more error message      about the same declaration, so just pretend the types match here.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
comment|/* Already warned elsewhere.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
comment|/* Already warned.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"function %q+D redeclared as inline"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"previous declaration of %q+D "
literal|"with attribute noinline"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"function %q+D redeclared with "
literal|"attribute noinline"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"previous declaration of %q+D was inline"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for redeclaration and other discrepancies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* Avoid warnings redeclaring built-ins which have not been 	     explicitly declared.  */
if|if
condition|(
name|DECL_ANTICIPATED
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If you declare a built-in or predefined function name as static, 	     the old definition is overridden, but optionally warn this was a 	     bad choice of name.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"shadowing %s function %q#D"
argument_list|,
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|?
literal|"built-in"
else|:
literal|"library"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
name|NULL_TREE
return|;
block|}
comment|/* If the built-in is not ansi, then programs can override 	     it even globally without an error.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"library function %q#D redeclared as non-function %q#D"
argument_list|,
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"declaration of %q#D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with built-in declaration %q#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* Avoid warnings redeclaring built-ins which have not been 	     explicitly declared.  */
if|if
condition|(
name|DECL_ANTICIPATED
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* Deal with fileptr_type_node.  FILE type is not known 		 at the time we create the builtins.  */
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|,
name|t2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
init|;
name|t1
operator|||
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
if|if
condition|(
operator|!
name|t1
operator|||
operator|!
name|t2
condition|)
break|break;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
operator|==
name|fileptr_type_node
condition|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"FILE"
argument_list|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|oldargs
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|types_match
operator|=
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|types_match
condition|)
return|return
name|duplicate_decls
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|,
name|newdecl_is_friend
argument_list|)
return|;
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
name|oldargs
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* A near match; override the builtin.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"new declaration %q#D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ambiguates built-in declaration %q#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"shadowing %s function %q#D"
argument_list|,
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|?
literal|"built-in"
else|:
literal|"library"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Discard the old built-in function.  */
return|return
name|NULL_TREE
return|;
comment|/* Replace the old RTL to avoid problems with inlining.  */
name|COPY_DECL_RTL
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Even if the types match, prefer the new declarations type for 	 built-ins which have not been explicitly declared, for 	 exception lists, etc...  */
elseif|else
if|if
condition|(
name|DECL_ANTICIPATED
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|attribs
init|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|cp_build_type_attribute_variant
argument_list|(
name|type
argument_list|,
name|attribs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
comment|/* Whether or not the builtin can throw exceptions has no 	 bearing on this declarator.  */
name|TREE_NOTHROW
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_THIS_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* If a builtin function is redeclared as `static', merge 	     the declarations, but make the original one static.  */
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Make the old declaration consistent with the new one so 	     that all remnants of the builtin-ness of this function 	     will be banished.  */
name|SET_DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|COPY_DECL_RTL
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We do nothing special here, because C++ does such nasty 	     things with TYPE_DECLs.  Instead, just let the TYPE_DECL 	     get shadowed, and know that if we need to find a TYPE_DECL 	     for a given name, we can look in the IDENTIFIER_TYPE_VALUE 	     slot of the identifier.  */
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
name|error
argument_list|(
literal|"%q#D redeclared as different kind of symbol"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of %q+#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CP_DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* These are certainly not duplicate declarations; they're 	   from different scopes.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* The name of a class template may not be declared to refer to 	     any other template, class, function, object, namespace, value, 	     or type in the same scope.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"declaration of template %q#D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with previous declaration %q+#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
comment|/* Template functions can be disambiguated by 		      return type.  */
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"new declaration %q#D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"ambiguates old declaration %q+#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_EXTERN_C_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of C function %q#D conflicts with"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration %q+#D here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"new declaration %q#D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"ambiguates old declaration %q+#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"conflicting declaration %q#D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%q+D has a previous declaration as %q#D"
argument_list|,
name|olddecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_TI_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
comment|/* It's OK to have a template specialization and a non-template        with the same type, or to have specializations of two        different templates with the same type.  Note that if one is a        specialization, and the other is an instantiation of the same        template, that we do not exit at this point.  That situation        can occur if we instantiate a template class, and then        specialize one of its methods.  This situation is valid, but        the declarations must be merged in the usual way.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|||
operator|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
comment|/* One of the declarations is a template instantiation, and the        other is not a template at all.  That's OK.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
comment|/* In [namespace.alias] we have:  	   In a declarative region, a namespace-alias-definition can be 	   used to redefine a namespace-alias declared in that declarative 	   region to refer only to the namespace to which it already 	   refers.  	 Therefore, if we encounter a second alias directive for the same 	 alias, we can just ignore the second directive.  */
if|if
condition|(
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|(
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
name|olddecl
return|;
comment|/* [namespace.alias]  	 A namespace-name or namespace-alias shall not be declared as 	 the name of any other entity in the same declarative region. 	 A namespace-name defined at global scope shall not be 	 declared as the name of any other entity in any global scope 	 of the program.  */
name|error
argument_list|(
literal|"declaration of namespace %qD conflicts with"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of namespace %q+D here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|error
argument_list|(
name|errmsg
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|error
argument_list|(
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|namespace_bindings_p
argument_list|()
operator|)
condition|?
literal|"%q+#D previously defined here"
else|:
literal|"%q+#D previously declared here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Prototype decl follows defn w/o prototype.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"prototype for %q+#D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Jfollows non-prototype definition here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* [dcl.link] 	     If two declarations of the same function or object 	     specify different linkage-specifications ..., the program 	     is ill-formed.... Except for functions with C++ linkage, 	     a function declaration without a linkage specification 	     shall not precede the first linkage specification for 	     that function.  A function can be declared without a 	     linkage specification after an explicit linkage 	     specification has been seen; the linkage explicitly 	     specified in the earlier declaration is not affected by 	     such a function declaration.  	     DR 563 raises the question why the restrictions on 	     functions should not also apply to objects.  Older 	     versions of G++ silently ignore the linkage-specification 	     for this example:  	       namespace N {                   extern int i;    	         extern "C" int i;                }               which is clearly wrong.  Therefore, we now treat objects 	     like functions.  */
if|if
condition|(
name|current_lang_depth
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* There is no explicit linkage-specification, so we use 		 the linkage from the previous declaration.  */
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"previous declaration of %q+#D with %qL linkage"
argument_list|,
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with new declaration with %qL linkage"
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|t1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t1
operator|&&
name|t1
operator|!=
name|void_list_node
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
literal|1
operator|==
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"default argument given for parameter %d of %q#D"
argument_list|,
name|i
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"after previous specification in %q+#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"default argument given for parameter %d of %q#D"
argument_list|,
name|i
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"after previous specification in %q+#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|warn_inline
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q#D was used before it was declared inline"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Jprevious non-inline declaration here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Do not merge an implicit typedef with an explicit one.  In:         class A;        ...        typedef class A A __attribute__ ((foo));       the attribute should apply only to the typedef.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If new decl is `static' and an `extern' was seen previously,      warn about it.  */
name|warn_extern_redeclared_static
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* We have committed to returning 1 at this point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Now that functions must hold information normally held 	 by field decls, there is extra work to do so that 	 declaration information does not get destroyed during 	 definition.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_VINDEX
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INVALID_OVERRIDER_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INVALID_OVERRIDER_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_THIS_STATIC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|newdecl
argument_list|,
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|new_defines_function
operator|=
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
comment|/* Optionally warn about more than one declaration for the same 	 name, but don't warn about a function declaration followed by a 	 definition.  */
if|if
condition|(
name|warn_redundant_decls
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|new_defines_function
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
operator|)
comment|/* Don't warn about extern decl followed by definition.  */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
comment|/* Don't warn about friends, let add_friend take care of it.  */
operator|&&
operator|!
operator|(
name|newdecl_is_friend
operator|||
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wredundant_decls
argument_list|,
literal|"redundant redeclaration of %qD in same scope"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wredundant_decls
argument_list|,
literal|"previous declaration of %q+D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deal with C++: must preserve virtual function table size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|newtype
operator|!=
name|error_mark_node
operator|&&
name|oldtype
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|newtype
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|oldtype
argument_list|)
condition|)
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|newtype
argument_list|)
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.  */
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_decl_attributes
call|)
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|old_result
decl_stmt|;
name|tree
name|new_result
decl_stmt|;
name|old_result
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|new_result
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|old_result
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|old_result
argument_list|)
operator||=
name|DECL_INLINE
argument_list|(
name|new_result
argument_list|)
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|old_result
argument_list|)
operator||=
name|DECL_DECLARED_INLINE_P
argument_list|(
name|new_result
argument_list|)
expr_stmt|;
name|check_redeclaration_exception_specification
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* If the new declaration is a definition, update the file and 	 line information on the declaration.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|old_result
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|new_result
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|DECL_SOURCE_LOCATION
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|old_result
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|old_result
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|new_result
argument_list|)
expr_stmt|;
block|}
return|return
name|olddecl
return|;
block|}
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Automatically handles default parameters.  */
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
decl_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|newtype
operator|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If merge_types produces a non-typedef type, just use the old type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|newtype
operator|==
name|DECL_ORIGINAL_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|newtype
operator|=
name|oldtype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|DECL_THIS_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIALIZED_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INITIALIZED_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NONTRIVIALLY_INITIALIZED_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NONTRIVIALLY_INITIALIZED_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the threadprivate attribute from OLDDECL into NEWDECL.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|CP_DECL_THREADPRIVATE_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* Allocate a LANG_SPECIFIC structure for NEWDECL, if needed.  */
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_TLS_MODEL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TLS_MODEL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|CP_DECL_THREADPRIVATE_P
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Do this after calling `merge_types' so that default 	 parameters don't confuse us.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|check_redeclaration_exception_specification
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|check_default_args
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
operator|(
name|processing_template_decl
operator|&&
name|uses_template_parms
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|!
operator|(
name|processing_template_decl
operator|&&
name|uses_template_parms
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_NOTHROW
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge deprecatedness.  */
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_DEPRECATED
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_SAVED_TREE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Merge the section attribute. 	 We want to issue an error if the sections conflict but that must be 	 done later in decl_attributes since we are called before attributes 	 are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_LIMIT_STACK
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_LIMIT_STACK
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_NOTHROW
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_IS_MALLOC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_IS_MALLOC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_IS_PURE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_IS_PURE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Keep the old RTL.  */
name|COPY_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
comment|/* Keep the old RTL.  We cannot keep the old RTL if the old 	     declaration was for an incomplete object and the new 	     declaration is not since many attributes of the RTL will 	     change.  */
name|COPY_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
comment|/* Clean out any memory we had of the old declaration.  */
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|olddecl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
name|TREE_VALUE
argument_list|(
name|oldstatic
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
name|merge_weak
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_ONE_ONLY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_DEFER_OUTPUT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|new_template
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INTERFACE_KNOWN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_COMDAT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If the OLDDECL is an instantiation and/or specialization, 	 then the NEWDECL must be too.  But, it may not yet be marked 	 as such if the caller has created NEWDECL, but has not yet 	 figured out that it is a redeclaration.  */
if|if
condition|(
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_USE_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_USE_TEMPLATE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't really know how much of the language-specific 	 values we should copy from old to new.  */
name|DECL_IN_AGGR_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_IN_AGGR_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
operator|->
name|decl_flags
operator|.
name|u2
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|->
name|decl_flags
operator|.
name|u2
expr_stmt|;
name|DECL_NONCONVERTING_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_NONCONVERTING_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_REPO_AVAILABLE_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_REPO_AVAILABLE_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
condition|)
name|new_template
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|olddecl_friend
operator|=
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|hidden_friend
operator|=
operator|(
name|DECL_ANTICIPATED
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|newdecl_is_friend
operator|)
expr_stmt|;
comment|/* Only functions have DECL_BEFRIENDING_CLASSES.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|newdecl
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DECL_THUNKS is only valid for virtual functions, 	     otherwise it is a DECL_FRIEND_CONTEXT.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_THUNKS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_THUNKS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If newdecl is not a specialization, then it is not a 	     template-related function at all.  And that means that we 	     should have exited above, returning 0.  */
name|gcc_assert
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* From [temp.expl.spec]:  	       If a template, a member template or the member of a class 	       template is explicitly specialized then that 	       specialization shall be declared before the first use of 	       that specialization that would cause an implicit 	       instantiation to take place, in every translation unit in 	       which such a use occurs.  */
name|error
argument_list|(
literal|"explicit specialization of %qD after first use"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't propagate visibility from the template to the 	     specialization here.  We'll do that in determine_visibility if 	     appropriate.  */
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* [temp.expl.spec/14] We don't inline explicit specialization 	     just because the primary template says so.  */
block|}
else|else
block|{
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If either decl says `inline', this fn is inline, unless 	     its definition was passed already.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|=
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Preserve abstractness on cloned [cd]tors.  */
name|DECL_ABSTRACT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ABSTRACT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|SET_DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|COPY_DECL_RTL
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|types_match
operator|||
name|new_defines_function
condition|)
block|{
comment|/* These need to be copied so that the names are available. 	     Note that if the types do match, we'll preserve inline 	     info and other bits, but if not, we won't.  */
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_defines_function
condition|)
comment|/* If defining a function declared with other language 	   linkage, use the previously declared language linkage.  */
name|SET_DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* If redeclaring a builtin function, and not a definition, 	     it stays built in.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If we're keeping the built-in definition, keep the rtl, 		 regardless of declaration matches.  */
name|COPY_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't clear out the arguments if we're redefining a function.  */
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|NAMESPACE_LEVEL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|NAMESPACE_LEVEL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Now preserve various other info from the definition.  */
name|TREE_ADDRESSABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_COMMON
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Warn about conflicting visibility specifications.  */
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%q+D: visibility attribute ignored "
literal|"because it"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%Jconflicts with previous "
literal|"declaration here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Choose the declaration which specified visibility.  */
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Init priority used to be merged from newdecl to olddecl by the memcpy,      so keep this behavior.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HAS_INIT_PRIORITY_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|SET_DECL_INIT_PRIORITY
argument_list|(
name|olddecl
argument_list|,
name|DECL_INIT_PRIORITY
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_HAS_INIT_PRIORITY_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The DECL_LANG_SPECIFIC information in OLDDECL will be replaced      with that from NEWDECL below.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_free
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|function_size
decl_stmt|;
name|function_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
name|function_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_function_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_template
condition|)
comment|/* If newdecl is a template instantiation, it is possible that 	   the following sequence of events has occurred:  	   o A friend function was declared in a class template.  The 	   class template was instantiated.  	   o The instantiation of the friend declaration was 	   recorded on the instantiation list, and is newdecl.  	   o Later, however, instantiate_class_template called pushdecl 	   on the newdecl to perform name injection.  But, pushdecl in 	   turn called duplicate_decls when it discovered that another 	   declaration of a global function with the same name already 	   existed.  	   o Here, in duplicate_decls, we decided to clobber newdecl.  	   If we're going to do that, we'd better make sure that 	   olddecl, and not newdecl, is on the list of 	   instantiations so that if we try to do the instantiation 	   again we won't get the clobbered declaration.  */
name|reregister_specialization
argument_list|(
name|newdecl
argument_list|,
name|new_template
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|size
init|=
name|tree_code_size
argument_list|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
case|case
name|LABEL_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|CONST_DECL
case|:
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
operator|+
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_non_common
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
operator|+
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
if|if
condition|(
name|olddecl_friend
condition|)
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hidden_friend
condition|)
block|{
name|DECL_ANTICIPATED
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* NEWDECL contains the merged attribute lists.      Update OLDDECL to be the same.  */
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If OLDDECL had its DECL_RTL instantiated, re-invoke make_decl_rtl     so that encode_section_info has a chance to look at the new decl     flags and attributes.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
name|make_decl_rtl
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* The NEWDECL will no longer be needed.  Because every out-of-class      declaration of a member results in a call to duplicate_decls,      freeing these nodes represents in a significant savings.  */
name|ggc_free
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|olddecl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Because C++ can put things into name space for free, 	 constructs like "typedef struct foo { ... } foo" 	 would look like an erroneous redeclaration.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
literal|"redefinition of %q#D"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If this is a pure function, its olddecl will actually be 	 the original initialization to `0' (which we force to call 	 abort()).  Don't complain about redefinition in this case.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL
return|;
comment|/* If both functions come from different namespaces, this is not 	 a redeclaration - this is a conflict with a used function.  */
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|decls_match
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
condition|)
return|return
literal|"%qD conflicts with used function"
return|;
comment|/* We'll complain about linkage mismatches in 	 warn_extern_redeclared_static.  */
comment|/* Defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|"%q#D not declared in class"
return|;
else|else
return|return
literal|"redefinition of %q#D"
return|;
block|}
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|nt
decl_stmt|,
name|ot
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
return|return
literal|"redefinition of %q#D"
return|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|nt
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|nt
argument_list|)
condition|)
name|nt
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|template_for_substitution
argument_list|(
name|nt
argument_list|)
argument_list|)
expr_stmt|;
name|ot
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|ot
argument_list|)
condition|)
name|ot
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|template_for_substitution
argument_list|(
name|ot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|nt
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|ot
argument_list|)
condition|)
return|return
literal|"redefinition of %q#D"
return|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_THREAD_LOCAL_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|CP_DECL_THREADPRIVATE_P
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_THREAD_LOCAL_P
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
comment|/* Only variables can be thread-local, and all declarations must 	 agree on this property.  */
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"thread-local declaration of %q#D follows "
literal|"non-thread-local declaration"
return|;
else|else
return|return
literal|"non-thread-local declaration of %q#D follows "
literal|"thread-local declaration"
return|;
block|}
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
operator|||
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* The objects have been declared at namespace scope.  If either 	 is a member of an anonymous union, then this is an invalid 	 redeclaration.  For example:  	   int i; 	   union { int i; };  	   is invalid.  */
if|if
condition|(
name|DECL_ANON_UNION_VAR_P
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_ANON_UNION_VAR_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|"redeclaration of %q#D"
return|;
comment|/* If at least one declaration is a reference, there is no 	 conflict.  For example:  	   int i = 3; 	   extern int i;  	 is valid.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Reject two definitions.  */
return|return
literal|"redefinition of %q#D"
return|;
block|}
else|else
block|{
comment|/* Objects declared with block scope:  */
comment|/* Reject two definitions, and reject a definition 	 together with an external reference.  */
if|if
condition|(
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|"redeclaration of %q#D"
return|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash and equality functions for the named_label table.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|named_label_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|named_label_entry
modifier|*
name|ent
init|=
operator|(
specifier|const
expr|struct
name|named_label_entry
operator|*
operator|)
name|data
decl_stmt|;
return|return
name|DECL_UID
argument_list|(
name|ent
operator|->
name|label_decl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|named_label_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|named_label_entry
modifier|*
name|ent_a
init|=
operator|(
specifier|const
expr|struct
name|named_label_entry
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|struct
name|named_label_entry
modifier|*
name|ent_b
init|=
operator|(
specifier|const
expr|struct
name|named_label_entry
operator|*
operator|)
name|b
decl_stmt|;
return|return
name|ent_a
operator|->
name|label_decl
operator|==
name|ent_b
operator|->
name|label_decl
return|;
block|}
end_function

begin_comment
comment|/* Create a new label, named ID.  */
end_comment

begin_function
specifier|static
name|tree
name|make_label_decl
parameter_list|(
name|tree
name|id
parameter_list|,
name|int
name|local_p
parameter_list|)
block|{
name|struct
name|named_label_entry
modifier|*
name|ent
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
operator|=
name|local_p
expr_stmt|;
comment|/* Say where one reference is to the label, for the sake of the      error if it is not defined.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|input_location
expr_stmt|;
comment|/* Record the fact that this identifier is bound to this label.  */
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Create the label htab for the function on demand.  */
if|if
condition|(
operator|!
name|named_labels
condition|)
name|named_labels
operator|=
name|htab_create_ggc
argument_list|(
literal|13
argument_list|,
name|named_label_entry_hash
argument_list|,
name|named_label_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Record this label on the list of labels used in this function.      We do this before calling make_label_decl so that we get the      IDENTIFIER_LABEL_VALUE before the new label is declared.  */
name|ent
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|named_label_entry
argument_list|)
expr_stmt|;
name|ent
operator|->
name|label_decl
operator|=
name|decl
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|named_labels
argument_list|,
name|ent
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|slot
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|ent
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Look for a label named ID in the current function.  If one cannot    be found, create one.  (We keep track of used, but undefined,    labels, and complain about them at the end of a function.)  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* You can't use labels at global scope.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"label %qE referenced outside of any function"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* See if we've already got this label.  */
name|decl
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|make_label_decl
argument_list|(
name|id
argument_list|,
comment|/*local_p=*/
literal|0
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declare a local label named ID.  */
end_comment

begin_function
name|tree
name|declare_local_label
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|shadow
decl_stmt|;
comment|/* Add a new entry to the SHADOWED_LABELS list so that when we leave      this scope we can restore the old value of IDENTIFIER_TYPE_VALUE.  */
name|shadow
operator|=
name|tree_cons
argument_list|(
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|current_binding_level
operator|->
name|shadowed_labels
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|shadowed_labels
operator|=
name|shadow
expr_stmt|;
name|decl
operator|=
name|make_label_decl
argument_list|(
name|id
argument_list|,
comment|/*local_p=*/
literal|1
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|shadow
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it is ill-formed to jump past the declaration of    DECL.  Returns 2 if it's also a real problem.  */
end_comment

begin_function
specifier|static
name|int
name|decl_jump_unsafe
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|DECL_NONTRIVIALLY_INITIALIZED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|pod_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The POD stuff is just pedantry; why should it matter if the class      contains a field of pointer to member type?  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of check_previous_goto_1 to identify a branch to the user.  */
end_comment

begin_function
specifier|static
name|void
name|identify_goto
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|location_t
modifier|*
name|locus
parameter_list|)
block|{
if|if
condition|(
name|decl
condition|)
name|pedwarn
argument_list|(
literal|"jump to label %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"jump to case label"
argument_list|)
expr_stmt|;
if|if
condition|(
name|locus
condition|)
name|pedwarn
argument_list|(
literal|"%H  from here"
argument_list|,
name|locus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that a single previously seen jump to a newly defined label    is OK.  DECL is the LABEL_DECL or 0; LEVEL is the binding_level for    the jump context; NAMES are the names in scope in LEVEL at the jump    context; LOCUS is the source position of the jump or 0.  Returns    true if all is well.  */
end_comment

begin_function
specifier|static
name|bool
name|check_previous_goto_1
parameter_list|(
name|tree
name|decl
parameter_list|,
name|struct
name|cp_binding_level
modifier|*
name|level
parameter_list|,
name|tree
name|names
parameter_list|,
name|bool
name|exited_omp
parameter_list|,
specifier|const
name|location_t
modifier|*
name|locus
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|bool
name|identified
init|=
name|false
decl_stmt|,
name|saw_eh
init|=
name|false
decl_stmt|,
name|saw_omp
init|=
name|false
decl_stmt|;
if|if
condition|(
name|exited_omp
condition|)
block|{
name|identify_goto
argument_list|(
name|decl
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  exits OpenMP structured block"
argument_list|)
expr_stmt|;
name|identified
operator|=
name|saw_omp
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|new_decls
decl_stmt|,
name|old_decls
init|=
operator|(
name|b
operator|==
name|level
condition|?
name|names
else|:
name|NULL_TREE
operator|)
decl_stmt|;
for|for
control|(
name|new_decls
operator|=
name|b
operator|->
name|names
init|;
name|new_decls
operator|!=
name|old_decls
condition|;
name|new_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|new_decls
argument_list|)
control|)
block|{
name|int
name|problem
init|=
name|decl_jump_unsafe
argument_list|(
name|new_decls
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|problem
condition|)
continue|continue;
if|if
condition|(
operator|!
name|identified
condition|)
block|{
name|identify_goto
argument_list|(
name|decl
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|identified
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|problem
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"  crosses initialization of %q+#D"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"  enters scope of non-POD %q+#D"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
name|level
condition|)
break|break;
if|if
condition|(
operator|(
name|b
operator|->
name|kind
operator|==
name|sk_try
operator|||
name|b
operator|->
name|kind
operator|==
name|sk_catch
operator|)
operator|&&
operator|!
name|saw_eh
condition|)
block|{
if|if
condition|(
operator|!
name|identified
condition|)
block|{
name|identify_goto
argument_list|(
name|decl
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|identified
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_try
condition|)
name|error
argument_list|(
literal|"  enters try block"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"  enters catch block"
argument_list|)
expr_stmt|;
name|saw_eh
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_omp
operator|&&
operator|!
name|saw_omp
condition|)
block|{
if|if
condition|(
operator|!
name|identified
condition|)
block|{
name|identify_goto
argument_list|(
name|decl
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|identified
operator|=
name|true
expr_stmt|;
block|}
name|error
argument_list|(
literal|"  enters OpenMP structured block"
argument_list|)
expr_stmt|;
name|saw_omp
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
operator|!
name|identified
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_previous_goto
parameter_list|(
name|tree
name|decl
parameter_list|,
name|struct
name|named_label_use_entry
modifier|*
name|use
parameter_list|)
block|{
name|check_previous_goto_1
argument_list|(
name|decl
argument_list|,
name|use
operator|->
name|binding_level
argument_list|,
name|use
operator|->
name|names_in_scope
argument_list|,
name|use
operator|->
name|in_omp_scope
argument_list|,
operator|&
name|use
operator|->
name|o_goto_locus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|check_switch_goto
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|level
parameter_list|)
block|{
return|return
name|check_previous_goto_1
argument_list|(
name|NULL_TREE
argument_list|,
name|level
argument_list|,
name|level
operator|->
name|names
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check that a new jump to a label DECL is OK.  Called by    finish_goto_stmt.  */
end_comment

begin_function
name|void
name|check_goto
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|named_label_entry
modifier|*
name|ent
decl_stmt|,
name|dummy
decl_stmt|;
name|bool
name|saw_catch
init|=
name|false
decl_stmt|,
name|identified
init|=
name|false
decl_stmt|;
name|tree
name|bad
decl_stmt|;
comment|/* We can't know where a computed goto is jumping.      So we assume that it's OK.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
return|return;
comment|/* We didn't record any information about this label when we created it,      and there's not much point since it's trivial to analyze as a return.  */
if|if
condition|(
name|decl
operator|==
name|cdtor_label
condition|)
return|return;
name|dummy
operator|.
name|label_decl
operator|=
name|decl
expr_stmt|;
name|ent
operator|=
operator|(
expr|struct
name|named_label_entry
operator|*
operator|)
name|htab_find
argument_list|(
name|named_labels
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the label hasn't been defined yet, defer checking.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|struct
name|named_label_use_entry
modifier|*
name|new_use
decl_stmt|;
comment|/* Don't bother creating another use if the last goto had the 	 same data, and will therefore create the same set of errors.  */
if|if
condition|(
name|ent
operator|->
name|uses
operator|&&
name|ent
operator|->
name|uses
operator|->
name|names_in_scope
operator|==
name|current_binding_level
operator|->
name|names
condition|)
return|return;
name|new_use
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|named_label_use_entry
argument_list|)
expr_stmt|;
name|new_use
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|new_use
operator|->
name|names_in_scope
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|new_use
operator|->
name|o_goto_locus
operator|=
name|input_location
expr_stmt|;
name|new_use
operator|->
name|in_omp_scope
operator|=
name|false
expr_stmt|;
name|new_use
operator|->
name|next
operator|=
name|ent
operator|->
name|uses
expr_stmt|;
name|ent
operator|->
name|uses
operator|=
name|new_use
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ent
operator|->
name|in_try_scope
operator|||
name|ent
operator|->
name|in_catch_scope
operator|||
name|ent
operator|->
name|in_omp_scope
operator|||
name|ent
operator|->
name|bad_decls
condition|)
block|{
name|pedwarn
argument_list|(
literal|"jump to label %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"  from here"
argument_list|)
expr_stmt|;
name|identified
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|bad
operator|=
name|ent
operator|->
name|bad_decls
init|;
name|bad
condition|;
name|bad
operator|=
name|TREE_CHAIN
argument_list|(
name|bad
argument_list|)
control|)
block|{
name|tree
name|b
init|=
name|TREE_VALUE
argument_list|(
name|bad
argument_list|)
decl_stmt|;
name|int
name|u
init|=
name|decl_jump_unsafe
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|>
literal|1
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* Can't skip init of __exception_info.  */
name|error
argument_list|(
literal|"%J  enters catch block"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|saw_catch
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"  skips initialization of %q+#D"
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"  enters scope of non-POD %q+#D"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|in_try_scope
condition|)
name|error
argument_list|(
literal|"  enters try block"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ent
operator|->
name|in_catch_scope
operator|&&
operator|!
name|saw_catch
condition|)
name|error
argument_list|(
literal|"  enters catch block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|in_omp_scope
condition|)
name|error
argument_list|(
literal|"  enters OpenMP structured block"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_openmp
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
if|if
condition|(
name|b
operator|==
name|ent
operator|->
name|binding_level
condition|)
break|break;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_omp
condition|)
block|{
if|if
condition|(
operator|!
name|identified
condition|)
block|{
name|pedwarn
argument_list|(
literal|"jump to label %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"  from here"
argument_list|)
expr_stmt|;
name|identified
operator|=
name|true
expr_stmt|;
block|}
name|error
argument_list|(
literal|"  exits OpenMP structured block"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check that a return is ok wrt OpenMP structured blocks.    Called by finish_return_stmt.  Returns true if all is well.  */
end_comment

begin_function
name|bool
name|check_omp_return
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_omp
condition|)
block|{
name|error
argument_list|(
literal|"invalid exit from OpenMP structured block"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|location_t
name|location
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|struct
name|named_label_entry
modifier|*
name|ent
decl_stmt|,
name|dummy
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lookup_label
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dummy
operator|.
name|label_decl
operator|=
name|decl
expr_stmt|;
name|ent
operator|=
operator|(
expr|struct
name|named_label_entry
operator|*
operator|)
name|htab_find
argument_list|(
name|named_labels
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* After labels, make any new cleanups in the function go into their      own new (temporary) binding contour.  */
for|for
control|(
name|p
operator|=
name|current_binding_level
init|;
name|p
operator|->
name|kind
operator|!=
name|sk_function_parms
condition|;
name|p
operator|=
name|p
operator|->
name|level_chain
control|)
name|p
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|get_identifier
argument_list|(
literal|"wchar_t"
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"label named wchar_t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"duplicate label %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|named_label_use_entry
modifier|*
name|use
decl_stmt|;
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Say where in the source.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|location
expr_stmt|;
name|ent
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|ent
operator|->
name|names_in_scope
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
for|for
control|(
name|use
operator|=
name|ent
operator|->
name|uses
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next
control|)
name|check_previous_goto
argument_list|(
name|decl
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|ent
operator|->
name|uses
operator|=
name|NULL
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|cp_switch
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
name|struct
name|cp_switch
modifier|*
name|next
decl_stmt|;
comment|/* The SWITCH_STMT being built.  */
name|tree
name|switch_stmt
decl_stmt|;
comment|/* A splay-tree mapping the low element of a case range to the high      element, or NULL_TREE if there is no high element.  Used to      determine whether or not a new case label duplicates an old case      label.  We need a tree, rather than simply a hash table, because      of the GNU case range extension.  */
name|splay_tree
name|cases
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A stack of the currently active switch statements.  The innermost    switch statement is on the top of the stack.  There is no need to    mark the stack for garbage collection because it is only active    during the processing of the body of a function, and we never    collect at that point.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cp_switch
modifier|*
name|switch_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called right after a switch-statement condition is parsed.    SWITCH_STMT is the switch statement being parsed.  */
end_comment

begin_function
name|void
name|push_switch
parameter_list|(
name|tree
name|switch_stmt
parameter_list|)
block|{
name|struct
name|cp_switch
modifier|*
name|p
init|=
name|XNEW
argument_list|(
expr|struct
name|cp_switch
argument_list|)
decl_stmt|;
name|p
operator|->
name|level
operator|=
name|current_binding_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|switch_stack
expr_stmt|;
name|p
operator|->
name|switch_stmt
operator|=
name|switch_stmt
expr_stmt|;
name|p
operator|->
name|cases
operator|=
name|splay_tree_new
argument_list|(
name|case_compare
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|switch_stack
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_switch
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_switch
modifier|*
name|cs
init|=
name|switch_stack
decl_stmt|;
name|location_t
name|switch_location
decl_stmt|;
comment|/* Emit warnings as needed.  */
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|cs
operator|->
name|switch_stmt
argument_list|)
condition|)
name|switch_location
operator|=
name|EXPR_LOCATION
argument_list|(
name|cs
operator|->
name|switch_stmt
argument_list|)
expr_stmt|;
else|else
name|switch_location
operator|=
name|input_location
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|c_do_switch_warnings
argument_list|(
name|cs
operator|->
name|cases
argument_list|,
name|switch_location
argument_list|,
name|SWITCH_STMT_TYPE
argument_list|(
name|cs
operator|->
name|switch_stmt
argument_list|)
argument_list|,
name|SWITCH_STMT_COND
argument_list|(
name|cs
operator|->
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|splay_tree_delete
argument_list|(
name|cs
operator|->
name|cases
argument_list|)
expr_stmt|;
name|switch_stack
operator|=
name|switch_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that we've seen a definition of a case label, and complain if this    is a bad place for one.  */
end_comment

begin_function
name|tree
name|finish_case_label
parameter_list|(
name|tree
name|low_value
parameter_list|,
name|tree
name|high_value
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|label
decl_stmt|;
comment|/* For templates, just add the case label; we'll do semantic 	 analysis at instantiation-time.  */
name|label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|,
name|label
argument_list|)
argument_list|)
return|;
block|}
comment|/* Find the condition on which this switch statement depends.  */
name|cond
operator|=
name|SWITCH_STMT_COND
argument_list|(
name|switch_stack
operator|->
name|switch_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|cond
operator|=
name|TREE_VALUE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_switch_goto
argument_list|(
name|switch_stack
operator|->
name|level
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|r
operator|=
name|c_add_case_label
argument_list|(
name|switch_stack
operator|->
name|cases
argument_list|,
name|cond
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|low_value
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
comment|/* After labels, make any new cleanups in the function go into their      own new (temporary) binding contour.  */
for|for
control|(
name|p
operator|=
name|current_binding_level
init|;
name|p
operator|->
name|kind
operator|!=
name|sk_function_parms
condition|;
name|p
operator|=
name|p
operator|->
name|level_chain
control|)
name|p
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|typename_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|k
parameter_list|)
block|{
name|hashval_t
name|hash
decl_stmt|;
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|k
decl_stmt|;
name|hash
operator|=
operator|(
name|htab_hash_pointer
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|^
name|htab_hash_pointer
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|typename_info
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|template_id
decl_stmt|;
name|bool
name|enum_p
decl_stmt|;
name|bool
name|class_p
decl_stmt|;
block|}
name|typename_info
typedef|;
end_typedef

begin_comment
comment|/* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */
end_comment

begin_function
specifier|static
name|int
name|typename_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|tree
name|t1
decl_stmt|;
specifier|const
name|typename_info
modifier|*
name|t2
decl_stmt|;
name|t1
operator|=
operator|(
name|tree
operator|)
name|k1
expr_stmt|;
name|t2
operator|=
operator|(
specifier|const
name|typename_info
operator|*
operator|)
name|k2
expr_stmt|;
return|return
operator|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|t2
operator|->
name|name
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
operator|==
name|t2
operator|->
name|scope
operator|&&
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t1
argument_list|)
operator|==
name|t2
operator|->
name|template_id
operator|&&
name|TYPENAME_IS_ENUM_P
argument_list|(
name|t1
argument_list|)
operator|==
name|t2
operator|->
name|enum_p
operator|&&
name|TYPENAME_IS_CLASS_P
argument_list|(
name|t1
argument_list|)
operator|==
name|t2
operator|->
name|class_p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is    the type of `T', NAME is the IDENTIFIER_NODE for `t'.     Returns the new TYPENAME_TYPE.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (union tree_node))
argument_list|)
name|htab_t
name|typename_htab
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|build_typename_type
parameter_list|(
name|tree
name|context
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|fullname
parameter_list|,
name|enum
name|tag_types
name|tag_type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|d
decl_stmt|;
name|typename_info
name|ti
decl_stmt|;
name|void
modifier|*
modifier|*
name|e
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
if|if
condition|(
name|typename_htab
operator|==
name|NULL
condition|)
name|typename_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|61
argument_list|,
operator|&
name|typename_hash
argument_list|,
operator|&
name|typename_compare
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ti
operator|.
name|scope
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ti
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|ti
operator|.
name|template_id
operator|=
name|fullname
expr_stmt|;
name|ti
operator|.
name|enum_p
operator|=
name|tag_type
operator|==
name|enum_type
expr_stmt|;
name|ti
operator|.
name|class_p
operator|=
operator|(
name|tag_type
operator|==
name|class_type
operator|||
name|tag_type
operator|==
name|record_type
operator|||
name|tag_type
operator|==
name|union_type
operator|)
expr_stmt|;
name|hash
operator|=
operator|(
name|htab_hash_pointer
argument_list|(
name|ti
operator|.
name|scope
argument_list|)
operator|^
name|htab_hash_pointer
argument_list|(
name|ti
operator|.
name|name
argument_list|)
operator|)
expr_stmt|;
comment|/* See if we already have this type.  */
name|e
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|typename_htab
argument_list|,
operator|&
name|ti
argument_list|,
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|e
condition|)
name|t
operator|=
operator|(
name|tree
operator|)
operator|*
name|e
expr_stmt|;
else|else
block|{
comment|/* Build the TYPENAME_TYPE.  */
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TYPENAME_TYPE
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|ti
operator|.
name|scope
expr_stmt|;
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
operator|=
name|ti
operator|.
name|template_id
expr_stmt|;
name|TYPENAME_IS_ENUM_P
argument_list|(
name|t
argument_list|)
operator|=
name|ti
operator|.
name|enum_p
expr_stmt|;
name|TYPENAME_IS_CLASS_P
argument_list|(
name|t
argument_list|)
operator|=
name|ti
operator|.
name|class_p
expr_stmt|;
comment|/* Build the corresponding TYPE_DECL.  */
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Store it in the hash table.  */
operator|*
name|e
operator|=
name|t
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Resolve `typename CONTEXT::NAME'.  TAG_TYPE indicates the tag    provided to name the type.  Returns an appropriate type, unless an    error occurs, in which case error_mark_node is returned.  If we    locate a non-artificial TYPE_DECL and TF_KEEP_TYPE_DECL is set, we    return that, rather than the _TYPE it corresponds to, in other    cases we look through the type decl.  If TF_ERROR is set, complain    about errors, otherwise be quiet.  */
end_comment

begin_function
name|tree
name|make_typename_type
parameter_list|(
name|tree
name|context
parameter_list|,
name|tree
name|name
parameter_list|,
name|enum
name|tag_types
name|tag_type
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|tree
name|fullname
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|bool
name|want_template
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
operator|||
name|context
operator|==
name|NULL_TREE
operator|||
name|context
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|name
argument_list|)
operator|||
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|name
argument_list|)
operator|)
operator|)
condition|)
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* Create a TEMPLATE_ID_EXPR for the type.  */
name|name
operator|=
name|build_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|name
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|fullname
argument_list|,
literal|0
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
name|error
argument_list|(
literal|"%qD is not a type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%qD used without template parameters"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When the CONTEXT is a dependent type,  NAME could refer to a      dependent base class of CONTEXT.  So we cannot peek inside it,      even if CONTEXT is a currently open scope.  */
if|if
condition|(
name|dependent_type_p
argument_list|(
name|context
argument_list|)
condition|)
return|return
name|build_typename_type
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
name|fullname
argument_list|,
name|tag_type
argument_list|)
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"%q#T is not a class"
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|want_template
operator|=
name|TREE_CODE
argument_list|(
name|fullname
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
expr_stmt|;
comment|/* We should only set WANT_TYPE when we're a nested typename type.      Then we can give better diagnostics if we find a non-type.  */
name|t
operator|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
comment|/*want_type=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
name|want_template
condition|?
literal|"no class template named %q#T in %q#T"
else|:
literal|"no type named %q#T in %q#T"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|want_template
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"%<typename %T::%D%> names %q#T, which is not a class template"
argument_list|,
name|context
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|want_template
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"%<typename %T::%D%> names %q#T, which is not a type"
argument_list|,
name|context
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|context
argument_list|)
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_template
condition|)
return|return
name|lookup_template_class
argument_list|(
name|t
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fullname
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|context
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|,
name|tf_warning_or_error
operator||
name|tf_user
argument_list|)
return|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|||
operator|!
operator|(
name|complain
operator|&
name|tf_keep_type_decl
operator|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Resolve `CONTEXT::template NAME'.  Returns a TEMPLATE_DECL if the name    can be resolved or an UNBOUND_CLASS_TEMPLATE, unless an error occurs,    in which case error_mark_node is returned.     If PARM_LIST is non-NULL, also make sure that the template parameter    list of TEMPLATE_DECL matches.     If COMPLAIN zero, don't complain about any errors that occur.  */
end_comment

begin_function
name|tree
name|make_unbound_class_template
parameter_list|(
name|tree
name|context
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|parm_list
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dependent_type_p
argument_list|(
name|context
argument_list|)
operator|||
name|currently_open_class
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
name|tmpl
operator|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpl
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"no class template named %q#T in %q#T"
argument_list|,
name|name
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|parm_list
operator|&&
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|parm_list
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
name|error
argument_list|(
literal|"template parameters do not match template"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%q+D declared here"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|context
argument_list|)
argument_list|,
name|tmpl
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
comment|/* Build the UNBOUND_CLASS_TEMPLATE.  */
name|t
operator|=
name|make_aggr_type
argument_list|(
name|UNBOUND_CLASS_TEMPLATE
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Build the corresponding TEMPLATE_DECL.  */
name|d
operator|=
name|build_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|d
argument_list|)
operator|=
name|parm_list
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push the declarations of builtin types into the namespace.    RID_INDEX is the index of the builtin type in the array    RID_POINTERS.  NAME is the name used when looking up the builtin    type.  TYPE is the _TYPE node for the builtin type.  */
end_comment

begin_function
name|void
name|record_builtin_type
parameter_list|(
name|enum
name|rid
name|rid_index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|rname
init|=
name|NULL_TREE
decl_stmt|,
name|tname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tdecl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
name|rname
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|tname
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* The calls to SET_IDENTIFIER_GLOBAL_VALUE below should be      eliminated.  Built-in types should not be looked up name; their      names are keywords that the parser can recognize.  However, there      is code in c-common.c that uses identifier_global_value to look      up built-in types by name.  */
if|if
condition|(
name|tname
condition|)
block|{
name|tdecl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|tname
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tname
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rname
condition|)
block|{
if|if
condition|(
operator|!
name|tdecl
condition|)
block|{
name|tdecl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|rname
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|rname
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|tdecl
expr_stmt|;
if|if
condition|(
name|tdecl
condition|)
name|debug_hooks
operator|->
name|type_decl
argument_list|(
name|tdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record one of the standard Java types.  * Declare it as having the given NAME.  * If SIZE> 0, it is the size of one of the integral types;  * otherwise it is the negative of the size of one of the other types.  */
end_comment

begin_function
specifier|static
name|tree
name|record_builtin_java_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|type
operator|=
name|make_signed_type
argument_list|(
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
operator|-
literal|32
condition|)
block|{
comment|/* "__java_char" or ""__java_boolean".  */
name|type
operator|=
name|make_unsigned_type
argument_list|(
operator|-
name|size
argument_list|)
expr_stmt|;
comment|/*if (size == -1)	TREE_SET_CODE (type, BOOLEAN_TYPE);*/
block|}
else|else
block|{
comment|/* "__java_float" or ""__java_double".  */
name|type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
operator|-
name|size
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Suppress generate debug symbol entries for these types,      since for normal C++ they are just clutter.      However, push_lang_context undoes this if extern "Java" is seen.  */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Push a type into the namespace so that the back-ends ignore it.  */
end_comment

begin_function
specifier|static
name|void
name|record_unknown_type
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure the "unknown type" typedecl gets ignored for debug info.  */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A string for which we should create an IDENTIFIER_NODE at    startup.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|predefined_identifier
block|{
comment|/* The name of the identifier.  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* The place where the IDENTIFIER_NODE should be stored.  */
name|tree
modifier|*
specifier|const
name|node
decl_stmt|;
comment|/* Nonzero if this is the name of a constructor or destructor.  */
specifier|const
name|int
name|ctor_or_dtor_p
decl_stmt|;
block|}
name|predefined_identifier
typedef|;
end_typedef

begin_comment
comment|/* Create all the predefined identifiers.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_predefined_identifiers
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|predefined_identifier
modifier|*
name|pid
decl_stmt|;
comment|/* A table of identifiers to create at startup.  */
specifier|static
specifier|const
name|predefined_identifier
name|predefined_identifiers
index|[]
init|=
block|{
block|{
literal|"C++"
block|,
operator|&
name|lang_name_cplusplus
block|,
literal|0
block|}
block|,
block|{
literal|"C"
block|,
operator|&
name|lang_name_c
block|,
literal|0
block|}
block|,
block|{
literal|"Java"
block|,
operator|&
name|lang_name_java
block|,
literal|0
block|}
block|,
comment|/* Some of these names have a trailing space so that it is        impossible for them to conflict with names written by users.  */
block|{
literal|"__ct "
block|,
operator|&
name|ctor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__base_ctor "
block|,
operator|&
name|base_ctor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__comp_ctor "
block|,
operator|&
name|complete_ctor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__dt "
block|,
operator|&
name|dtor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__comp_dtor "
block|,
operator|&
name|complete_dtor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__base_dtor "
block|,
operator|&
name|base_dtor_identifier
block|,
literal|1
block|}
block|,
block|{
literal|"__deleting_dtor "
block|,
operator|&
name|deleting_dtor_identifier
block|,
literal|1
block|}
block|,
block|{
name|IN_CHARGE_NAME
block|,
operator|&
name|in_charge_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"nelts"
block|,
operator|&
name|nelts_identifier
block|,
literal|0
block|}
block|,
block|{
name|THIS_NAME
block|,
operator|&
name|this_identifier
block|,
literal|0
block|}
block|,
block|{
name|VTABLE_DELTA_NAME
block|,
operator|&
name|delta_identifier
block|,
literal|0
block|}
block|,
block|{
name|VTABLE_PFN_NAME
block|,
operator|&
name|pfn_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"_vptr"
block|,
operator|&
name|vptr_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"__vtt_parm"
block|,
operator|&
name|vtt_parm_identifier
block|,
literal|0
block|}
block|,
block|{
literal|"::"
block|,
operator|&
name|global_scope_name
block|,
literal|0
block|}
block|,
block|{
literal|"std"
block|,
operator|&
name|std_identifier
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
for|for
control|(
name|pid
operator|=
name|predefined_identifiers
init|;
name|pid
operator|->
name|name
condition|;
operator|++
name|pid
control|)
block|{
operator|*
name|pid
operator|->
name|node
operator|=
name|get_identifier
argument_list|(
name|pid
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|->
name|ctor_or_dtor_p
condition|)
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
operator|*
name|pid
operator|->
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|cxx_init_decl_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|void_ftype
decl_stmt|;
name|tree
name|void_ftype_ptr
decl_stmt|;
name|build_common_tree_nodes
argument_list|(
name|flag_signed_char
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Create all the identifiers we need.  */
name|initialize_predefined_identifiers
argument_list|()
expr_stmt|;
comment|/* Create the global variables.  */
name|push_to_top_level
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|current_binding_level
operator|=
name|NULL
expr_stmt|;
comment|/* Enter the global namespace.  */
name|gcc_assert
argument_list|(
name|global_namespace
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|global_namespace
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|global_scope_name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|global_namespace
argument_list|)
operator|=
literal|1
expr_stmt|;
name|begin_scope
argument_list|(
name|sk_namespace
argument_list|,
name|global_namespace
argument_list|)
expr_stmt|;
name|current_lang_name
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Adjust various flags based on command-line settings.  */
if|if
condition|(
operator|!
name|flag_permissive
condition|)
name|flag_pedantic_errors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
block|{
name|flag_inline_trees
operator|=
literal|1
expr_stmt|;
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag_inline_functions
condition|)
name|flag_inline_trees
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|flag_visibility_ms_compat
condition|)
name|default_visibility
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
comment|/* Initially, C.  */
name|current_lang_name
operator|=
name|lang_name_c
expr_stmt|;
comment|/* Create the `std' namespace.  */
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|std_node
operator|=
name|current_namespace
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|c_common_nodes_and_builtins
argument_list|()
expr_stmt|;
name|java_byte_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_byte"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|java_short_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_short"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|java_int_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_int"
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|java_long_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_long"
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|java_float_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_float"
argument_list|,
operator|-
literal|32
argument_list|)
expr_stmt|;
name|java_double_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_double"
argument_list|,
operator|-
literal|64
argument_list|)
expr_stmt|;
name|java_char_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_char"
argument_list|,
operator|-
literal|16
argument_list|)
expr_stmt|;
name|java_boolean_type_node
operator|=
name|record_builtin_java_type
argument_list|(
literal|"__java_boolean"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|integer_two_node
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|integer_three_node
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_BOOL
argument_list|,
literal|"bool"
argument_list|,
name|boolean_type_node
argument_list|)
expr_stmt|;
name|truthvalue_type_node
operator|=
name|boolean_type_node
expr_stmt|;
name|truthvalue_false_node
operator|=
name|boolean_false_node
expr_stmt|;
name|truthvalue_true_node
operator|=
name|boolean_true_node
expr_stmt|;
name|empty_except_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|record_builtin_type (RID_MAX, NULL, string_type_node);
endif|#
directive|endif
name|delta_type_node
operator|=
name|ptrdiff_type_node
expr_stmt|;
name|vtable_index_type
operator|=
name|ptrdiff_type_node
expr_stmt|;
name|vtt_parm_type
operator|=
name|build_pointer_type
argument_list|(
name|const_ptr_type_node
argument_list|)
expr_stmt|;
name|void_ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|void_ftype_ptr
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr
operator|=
name|build_exception_variant
argument_list|(
name|void_ftype_ptr
argument_list|,
name|empty_except_spec
argument_list|)
expr_stmt|;
comment|/* C++ extensions */
name|unknown_type_node
operator|=
name|make_node
argument_list|(
name|UNKNOWN_TYPE
argument_list|)
expr_stmt|;
name|record_unknown_type
argument_list|(
name|unknown_type_node
argument_list|,
literal|"unknown type"
argument_list|)
expr_stmt|;
comment|/* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */
name|TREE_TYPE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same      result.  */
name|TYPE_POINTER_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|{
comment|/* Make sure we get a unique function type, so we can give        its pointer type a name.  (This wins for gdb.) */
name|tree
name|vfunc_type
init|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_pointer_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_qualified_type
argument_list|(
name|vtbl_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL
argument_list|,
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL
argument_list|,
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|push_namespace
argument_list|(
name|get_identifier
argument_list|(
literal|"__cxxabiv1"
argument_list|)
argument_list|)
expr_stmt|;
name|abi_node
operator|=
name|current_namespace
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|global_type_node
operator|=
name|make_node
argument_list|(
name|LANG_TYPE
argument_list|)
expr_stmt|;
name|record_unknown_type
argument_list|(
name|global_type_node
argument_list|,
literal|"global type"
argument_list|)
expr_stmt|;
comment|/* Now, C++.  */
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
block|{
name|tree
name|bad_alloc_id
decl_stmt|;
name|tree
name|bad_alloc_type_node
decl_stmt|;
name|tree
name|bad_alloc_decl
decl_stmt|;
name|tree
name|newtype
decl_stmt|,
name|deltype
decl_stmt|;
name|tree
name|ptr_ftype_sizetype
decl_stmt|;
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|bad_alloc_id
operator|=
name|get_identifier
argument_list|(
literal|"bad_alloc"
argument_list|)
expr_stmt|;
name|bad_alloc_type_node
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|bad_alloc_type_node
argument_list|)
operator|=
name|current_namespace
expr_stmt|;
name|bad_alloc_decl
operator|=
name|create_implicit_typedef
argument_list|(
name|bad_alloc_id
argument_list|,
name|bad_alloc_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|bad_alloc_decl
argument_list|)
operator|=
name|current_namespace
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|bad_alloc_type_node
argument_list|)
operator|=
name|bad_alloc_decl
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|ptr_ftype_sizetype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|newtype
operator|=
name|build_exception_variant
argument_list|(
name|ptr_ftype_sizetype
argument_list|,
name|add_exception_specifier
argument_list|(
name|NULL_TREE
argument_list|,
name|bad_alloc_type_node
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|deltype
operator|=
name|build_exception_variant
argument_list|(
name|void_ftype_ptr
argument_list|,
name|empty_except_spec
argument_list|)
expr_stmt|;
name|push_cp_library_fn
argument_list|(
name|NEW_EXPR
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
name|push_cp_library_fn
argument_list|(
name|VEC_NEW_EXPR
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
name|global_delete_fndecl
operator|=
name|push_cp_library_fn
argument_list|(
name|DELETE_EXPR
argument_list|,
name|deltype
argument_list|)
expr_stmt|;
name|push_cp_library_fn
argument_list|(
name|VEC_DELETE_EXPR
argument_list|,
name|deltype
argument_list|)
expr_stmt|;
block|}
name|abort_fndecl
operator|=
name|build_library_fn_ptr
argument_list|(
literal|"__cxa_pure_virtual"
argument_list|,
name|void_ftype
argument_list|)
expr_stmt|;
comment|/* Perform other language dependent initializations.  */
name|init_class_processing
argument_list|()
expr_stmt|;
name|init_rtti_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_exceptions
condition|)
name|init_exception_processing
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|supports_one_only
argument_list|()
condition|)
name|flag_weak
operator|=
literal|0
expr_stmt|;
name|make_fname_decl
operator|=
name|cp_make_fname_decl
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
comment|/* Show we use EH for cleanups.  */
if|if
condition|(
name|flag_exceptions
condition|)
name|using_eh_for_cleanups
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an initializer for a function naming variable from    NAME. NAME may be NULL, to indicate a dependent name.  TYPE_P is    filled in with the type of the init.  */
end_comment

begin_function
name|tree
name|cp_fname_init
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
modifier|*
name|type_p
parameter_list|)
block|{
name|tree
name|domain
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
name|size_t
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|domain
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|length
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
operator|*
name|type_p
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|init
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the    decl, NAME is the initialization string and TYPE_DEP indicates whether    NAME depended on the type of the function. We make use of that to detect    __PRETTY_FUNCTION__ inside a template fn. This is being done    lazily at the point of first use, so we mustn't push the decl now.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_make_fname_decl
parameter_list|(
name|tree
name|id
parameter_list|,
name|int
name|type_dep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
operator|(
name|type_dep
operator|&&
name|processing_template_decl
condition|?
name|NULL
else|:
name|fname_as_string
argument_list|(
name|type_dep
argument_list|)
operator|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|init
init|=
name|cp_fname_init
argument_list|(
name|name
argument_list|,
operator|&
name|type
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
comment|/* As we're using pushdecl_with_scope, we must set the context.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_PRETTY_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
name|type_dep
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|b
operator|->
name|level_chain
operator|->
name|kind
operator|!=
name|sk_function_parms
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|pushdecl_with_scope
argument_list|(
name|decl
argument_list|,
name|b
argument_list|,
comment|/*is_friend=*/
name|false
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
block|}
else|else
name|pushdecl_top_level_and_finish
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Make a definition for a builtin function named NAME in the current    namespace, whose data type is TYPE and whose context is CONTEXT.    TYPE should be a function type with argument types.     CLASS and CODE tell later passes how to compile calls to this function.    See tree.h for possible values.     If LIBNAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.    If ATTRS is nonzero, use that for the function's attribute    list.  */
end_comment

begin_function
specifier|static
name|tree
name|builtin_function_1
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|context
parameter_list|,
name|enum
name|built_in_function
name|code
parameter_list|,
name|enum
name|built_in_class
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|libname
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
name|build_library_fn_1
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|ERROR_MARK
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|=
name|class
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|code
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,      we cannot change DECL_ASSEMBLER_NAME until we have installed this      function in the namespace.  */
if|if
condition|(
name|libname
condition|)
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|libname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A function in the user's namespace should have an explicit      declaration before it is used.  Mark the built-in function as      anticipated but not actually declared.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
name|DECL_ANTICIPATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Possibly apply some default attributes to this built-in function.  */
if|if
condition|(
name|attrs
condition|)
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
name|ATTR_FLAG_BUILT_IN
argument_list|)
expr_stmt|;
else|else
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Entry point for the benefit of c_common_nodes_and_builtins.     Make a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.  This    function places the anticipated declaration in the global namespace    and additionally in the std namespace if appropriate.     CLASS and CODE tell later passes how to compile calls to this function.    See tree.h for possible values.     If LIBNAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.     If ATTRS is nonzero, use that for the function's attribute    list.  */
end_comment

begin_function
name|tree
name|builtin_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|code
parameter_list|,
name|enum
name|built_in_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
name|libname
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
comment|/* All builtins that don't begin with an '_' should additionally      go in the 'std' namespace.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|builtin_function_1
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|std_node
argument_list|,
name|code
argument_list|,
name|cl
argument_list|,
name|libname
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
block|}
return|return
name|builtin_function_1
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|code
argument_list|,
name|cl
argument_list|,
name|libname
argument_list|,
name|attrs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a FUNCTION_DECL with the typical flags for a runtime library    function.  Not called directly.  */
end_comment

begin_function
specifier|static
name|tree
name|build_library_fn_1
parameter_list|(
name|tree
name|name
parameter_list|,
name|enum
name|tree_code
name|operator_code
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fn
init|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|fn
argument_list|,
name|operator_code
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|fn
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
comment|/* Runtime library routines are, by definition, available in an      external shared object.  */
name|DECL_VISIBILITY
argument_list|(
name|fn
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Returns the _DECL for a library function with C linkage.    We assume that such functions never throw; if this is incorrect,    callers should unset TREE_NOTHROW.  */
end_comment

begin_function
name|tree
name|build_library_fn
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fn
init|=
name|build_library_fn_1
argument_list|(
name|name
argument_list|,
name|ERROR_MARK
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Returns the _DECL for a library function with C++ linkage.  */
end_comment

begin_function
specifier|static
name|tree
name|build_cp_library_fn
parameter_list|(
name|tree
name|name
parameter_list|,
name|enum
name|tree_code
name|operator_code
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fn
init|=
name|build_library_fn_1
argument_list|(
name|name
argument_list|,
name|operator_code
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
name|TYPE_NOTHROW_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|fn
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Like build_library_fn, but takes a C string instead of an    IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_library_fn_ptr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
return|return
name|build_library_fn
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like build_cp_library_fn, but takes a C string instead of an    IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_cp_library_fn_ptr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
return|return
name|build_cp_library_fn
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|ERROR_MARK
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like build_library_fn, but also pushes the function so that we will    be able to find it via IDENTIFIER_GLOBAL_VALUE.  */
end_comment

begin_function
name|tree
name|push_library_fn
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fn
init|=
name|build_library_fn
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Like build_cp_library_fn, but also pushes the function so that it    will be found by normal lookup.  */
end_comment

begin_function
specifier|static
name|tree
name|push_cp_library_fn
parameter_list|(
name|enum
name|tree_code
name|operator_code
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fn
init|=
name|build_cp_library_fn
argument_list|(
name|ansi_opname
argument_list|(
name|operator_code
argument_list|)
argument_list|,
name|operator_code
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|pushdecl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Like push_library_fn, but takes a TREE_LIST of parm types rather than    a FUNCTION_TYPE.  */
end_comment

begin_function
name|tree
name|push_void_library_fn
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|parmtypes
parameter_list|)
block|{
name|tree
name|type
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parmtypes
argument_list|)
decl_stmt|;
return|return
name|push_library_fn
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like push_library_fn, but also note that this function throws    and does not return.  Used for __throw_foo and the like.  */
end_comment

begin_function
name|tree
name|push_throw_library_fn
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fn
init|=
name|push_library_fn
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When we call finish_struct for an anonymous union, we create    default copy constructors and such.  But, an anonymous union    shouldn't have such things; this function undoes the damage to the    anonymous union type T.     (The reason that we create the synthesized methods is that we don't    distinguish `union { int i; }' from `typedef union { int i; } U'.    The first is an anonymous union; the second is just an ordinary    union type.)  */
end_comment

begin_function
name|void
name|fixup_anonymous_aggr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
modifier|*
name|q
decl_stmt|;
comment|/* Wipe out memory of synthesized methods.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Splice the implicitly generated functions out of the TYPE_METHODS      list.  */
name|q
operator|=
operator|&
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* ISO C++ 9.5.3.  Anonymous unions may not have function members.  */
if|if
condition|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jan anonymous union cannot have function members"
argument_list|,
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Anonymous aggregates cannot have fields with ctors, dtors or complex      assignment operators (because they cannot have these methods themselves).      For anonymous unions this is already checked because they are not allowed      in any union, otherwise we have to check it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"member %q+#D with constructor not allowed "
literal|"in anonymous aggregate"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"member %q+#D with destructor not allowed "
literal|"in anonymous aggregate"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"member %q+#D with copy assignment operator "
literal|"not allowed in anonymous aggregate"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make sure that a declaration with no declarator is well-formed, i.e.    just declares a tagged type or anonymous union.     Returns the type declared; or NULL_TREE if none.  */
end_comment

begin_function
name|tree
name|check_tag_decl
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|)
block|{
name|int
name|saw_friend
init|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_friend
index|]
operator|!=
literal|0
decl_stmt|;
name|int
name|saw_typedef
init|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
operator|!=
literal|0
decl_stmt|;
comment|/* If a class, struct, or enum type is declared by the DECLSPECS      (i.e, if a class-specifier, enum-specifier, or non-typename      elaborated-type-specifier appears in the DECLSPECS),      DECLARED_TYPE is set to the corresponding type.  */
name|tree
name|declared_type
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|error_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|multiple_types_p
condition|)
name|error
argument_list|(
literal|"multiple types in one declaration"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|redefined_builtin_type
condition|)
block|{
if|if
condition|(
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"redeclaration of C++ built-in type %qT"
argument_list|,
name|declspecs
operator|->
name|redefined_builtin_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|declspecs
operator|->
name|type
operator|&&
name|TYPE_P
argument_list|(
name|declspecs
operator|->
name|type
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|declspecs
operator|->
name|type
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|declspecs
operator|->
name|type
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|declspecs
operator|->
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|declared_type
operator|=
name|declspecs
operator|->
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|type
operator|==
name|error_mark_node
condition|)
name|error_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|declared_type
operator|==
name|NULL_TREE
operator|&&
operator|!
name|saw_friend
operator|&&
operator|!
name|error_p
condition|)
name|pedwarn
argument_list|(
literal|"declaration does not declare anything"
argument_list|)
expr_stmt|;
comment|/* Check for an anonymous union.  */
elseif|else
if|if
condition|(
name|declared_type
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|declared_type
argument_list|)
argument_list|)
operator|&&
name|TYPE_ANONYMOUS_P
argument_list|(
name|declared_type
argument_list|)
condition|)
block|{
comment|/* 7/3 In a simple-declaration, the optional init-declarator-list 	 can be omitted only when declaring a class (clause 9) or 	 enumeration (7.2), that is, when the decl-specifier-seq contains 	 either a class-specifier, an elaborated-type-specifier with 	 a class-key (9.1), or an enum-specifier.  In these cases and 	 whenever a class-specifier or enum-specifier is present in the 	 decl-specifier-seq, the identifiers in these specifiers are among 	 the names being declared by the declaration (as class-name, 	 enum-names, or enumerators, depending on the syntax).  In such 	 cases, and except for the declaration of an unnamed bit-field (9.6), 	 the decl-specifier-seq shall introduce one or more names into the 	 program, or shall redeclare a name introduced by a previous 	 declaration.  [Example: 	     enum { };			// ill-formed 	     typedef class { };		// ill-formed 	 --end example]  */
if|if
condition|(
name|saw_typedef
condition|)
block|{
name|error
argument_list|(
literal|"missing type-name in typedef-declaration"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Anonymous unions are objects, so they can have specifiers.  */
empty_stmt|;
name|SET_ANON_AGGR_TYPE_P
argument_list|(
name|declared_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declared_type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ prohibits anonymous structs"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_inline
index|]
operator|||
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_virtual
index|]
condition|)
name|error
argument_list|(
literal|"%qs can only be specified for functions"
argument_list|,
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_inline
index|]
condition|?
literal|"inline"
else|:
literal|"virtual"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|saw_friend
operator|&&
operator|(
operator|!
name|current_class_type
operator|||
name|current_scope
argument_list|()
operator|!=
name|current_class_type
operator|)
condition|)
name|error
argument_list|(
literal|"%<friend%> can only be specified inside a class"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_explicit
index|]
condition|)
name|error
argument_list|(
literal|"%<explicit%> can only be specified for constructors"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|storage_class
condition|)
name|error
argument_list|(
literal|"a storage class can only be specified for objects "
literal|"and functions"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_const
index|]
operator|||
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_volatile
index|]
operator|||
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_restrict
index|]
operator|||
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_thread
index|]
condition|)
name|error
argument_list|(
literal|"qualifiers can only be specified for objects "
literal|"and functions"
argument_list|)
expr_stmt|;
block|}
return|return
name|declared_type
return|;
block|}
end_function

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.     C++: may have to grok the declspecs to learn about static,    complain for anonymous unions.     Returns the TYPE declared -- or NULL_TREE if none.  */
end_comment

begin_function
name|tree
name|shadow_tag
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|)
block|{
name|tree
name|t
init|=
name|check_tag_decl
argument_list|(
name|declspecs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|declspecs
operator|->
name|attributes
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"attribute ignored in declaration of %q+#T"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"attribute for %q+#T must follow the %qs keyword"
argument_list|,
name|t
argument_list|,
name|class_key_or_enum_as_string
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maybe_process_partial_specialization
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
comment|/* This is where the variables in an anonymous union are      declared.  An anonymous union declaration looks like:      union { ... } ;      because there is no declarator after the union, the parser      sends that declaration here.  */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|fixup_anonymous_aggr
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
comment|/*declarator=*/
name|NULL
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|finish_anon_union
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|type_specifiers
parameter_list|,
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|)
block|{
name|tree
name|attrs
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|attrs
operator|=
name|type_specifiers
operator|->
name|attributes
expr_stmt|;
name|type_specifiers
operator|->
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
name|type
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|type_specifiers
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `cp_finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_function
name|tree
name|start_decl
parameter_list|(
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|,
name|int
name|initialized
parameter_list|,
name|tree
name|attributes
parameter_list|,
name|tree
name|prefix_attributes
parameter_list|,
name|tree
modifier|*
name|pushed_scope_p
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|bool
name|was_public
decl_stmt|;
operator|*
name|pushed_scope_p
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* An object declared as __attribute__((deprecated)) suppresses      warnings of uses of other deprecated items.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"deprecated"
argument_list|,
name|attributes
argument_list|)
condition|)
name|deprecated_state
operator|=
name|DEPRECATED_SUPPRESS
expr_stmt|;
name|attributes
operator|=
name|chainon
argument_list|(
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
operator|&
name|attributes
argument_list|)
expr_stmt|;
name|deprecated_state
operator|=
name|DEPRECATED_NORMAL
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
block|{
operator|*
name|pushed_scope_p
operator|=
name|push_scope
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* We are only interested in class contexts, later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `cp_finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
name|error
argument_list|(
literal|"typedef %qD is initialized (use __typeof__ instead)"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function %q#D is initialized like a variable"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"declaration of %q#D has %<extern%> and is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dllimported symbols cannot be defined.  Static data members (which      can be initialized in-class and dllimported) go through grokfield,      not here, so we don't need to exclude those decls when checking for      a definition.  */
if|if
condition|(
name|initialized
operator|&&
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"definition of %q#D is marked %<dllimport%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If #pragma weak was used, mark the decl weak now.  */
name|maybe_apply_pragma_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"inline function %q+D given attribute noinline"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|context
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|error
argument_list|(
literal|"%q#D is not a static member of %q#T"
argument_list|,
name|decl
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|context
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
name|context
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ does not permit %<%T::%D%> "
literal|"to be defined as %<%T::%D%>"
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_specialization
operator|&&
name|template_class_depth
argument_list|(
name|context
argument_list|)
operator|==
literal|0
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|context
argument_list|)
condition|)
name|error
argument_list|(
literal|"template header not allowed in member definition "
literal|"of explicitly specialized class"
argument_list|)
expr_stmt|;
comment|/* Static data member are tricky; an in-class initialization 		 still doesn't provide a definition, so the in-class 		 declaration will have DECL_EXTERNAL set, but will have an 		 initialization.  Thus, duplicate_decls won't warn 		 about this situation, and so we check here.  */
if|if
condition|(
name|initialized
operator|&&
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|field
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate initialization of %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|field
argument_list|,
comment|/*newdecl_is_friend=*/
name|false
argument_list|)
condition|)
name|decl
operator|=
name|field
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|field
init|=
name|check_classfn
argument_list|(
name|context
argument_list|,
name|decl
argument_list|,
operator|(
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|context
argument_list|)
operator|)
condition|?
name|current_template_parms
else|:
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|&&
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|field
argument_list|,
comment|/*newdecl_is_friend=*/
name|false
argument_list|)
condition|)
name|decl
operator|=
name|field
expr_stmt|;
block|}
comment|/* cp_finish_decl sets DECL_EXTERNAL if DECL_IN_AGGR_P is set.  */
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do not mark DECL as an explicit specialization if it was not 	 already marked as an instantiation; a declaration should 	 never be marked as a specialization unless we know what 	 template is being specialized.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* [temp.expl.spec] An explicit specialization of a static data 	     member of a template is a definition if the declaration 	     includes an initializer; otherwise, it is a declaration.  	     We check for processing_specialization so this only applies 	     to the new specialization syntax.  */
if|if
condition|(
operator|!
name|initialized
operator|&&
name|processing_specialization
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"declaration of %q#D outside of class is not definition"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|was_public
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Enter this declaration into the symbol table.  */
name|tem
operator|=
name|maybe_push_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|tem
operator|=
name|push_template_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Tell the back-end to use or not use .common as appropriate.  If we say      -fconserve-space, we want this to save .data space, at the expense of      wrong semantics.  If we say -fno-conserve-space, we want this to      produce errors about redefs; to do this we force variables into the      data segment.  */
if|if
condition|(
name|flag_conserve_space
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|have_global_bss_p
argument_list|()
condition|)
name|DECL_COMMON
argument_list|(
name|tem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|was_public
operator|&&
operator|!
name|DECL_THIS_STATIC
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
comment|/* This is a const variable with implicit 'static'.  Set 	 DECL_THIS_STATIC so we can tell it from variables that are 	 !TREE_PUBLIC because of the anonymous namespace.  */
name|gcc_assert
argument_list|(
name|cp_type_readonly
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_THIS_STATIC
argument_list|(
name|tem
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|start_decl_1
argument_list|(
name|tem
argument_list|,
name|initialized
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_function
name|void
name|start_decl_1
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|initialized
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|processing_template_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `cp_finish_decl' to ignore the initializer once it is parsed.  */
block|{
comment|/* Don't allow initializations for incomplete types except for 	 arrays which might be completed by the initialization.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* A complete type is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable %q#D has initializer but incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"elements of array %q#D have incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* else we already gave an error in start_decl.  */
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"aggregate %q#D has incomplete type and cannot be defined"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Change the type so that assemble_variable will give 	     DECL an rtl we can live with: (mem (const_int 0)).  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
comment|/* If any base type in the hierarchy of TYPE needs a constructor, 	     then we set initialized to 1.  This way any nodes which are 	     created for the purposes of initializing this aggregate 	     will live as long as it does.  This is necessary for global 	     aggregates which do not have their initializers processed until 	     the end of the file.  */
name|initialized
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create a new scope to hold this declaration if necessary.      Whether or not a new scope is necessary cannot be determined      until after the type has been completed; if the type is a      specialization of a class template it is not until after      instantiation has occurred that TYPE_HAS_NONTRIVIAL_DESTRUCTOR      will be set correctly.  */
name|maybe_push_cleanup_level
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle initialization of references.  DECL, TYPE, and INIT have the    same meaning as in cp_finish_decl.  *CLEANUP must be NULL on entry,    but will be set to a new CLEANUP_STMT if a temporary is created    that must be destroyed subsequently.     Returns an initializer expression to use to initialize DECL, or    NULL if the initialization can be performed statically.     Quotes on semantics can be found in ARM 8.4.3.  */
end_comment

begin_function
specifier|static
name|tree
name|grok_reference_init
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
modifier|*
name|cleanup
parameter_list|)
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD declared as reference but not initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|error
argument_list|(
literal|"ISO C++ forbids use of initializer list to "
literal|"initialize reference %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_x_compound_expr_from_list
argument_list|(
name|init
argument_list|,
literal|"initializer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
comment|/* Note: default conversion is only called in very special cases.  */
name|init
operator|=
name|decay_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Convert INIT to the reference type TYPE.  This may involve the      creation of a temporary, whose lifetime must be the same as that      of the reference.  If so, a DECL_EXPR for the temporary will be      added just after the DECL_EXPR for DECL.  That's why we don't set      DECL_INITIAL for local references (instead assigning to them      explicitly); we need to allow the temporary to be initialized      first.  */
name|tmp
operator|=
name|initialize_reference
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"cannot initialize %qT from %qT"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|tmp
argument_list|)
condition|)
return|return
name|tmp
return|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|tmp
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Designated initializers in arrays are not supported in GNU C++.    The parser cannot detect this error since it does not know whether    a given brace-enclosed initializer is for a class type or for an    array.  This function checks that CE does not use a designated    initializer.  If it does, an error is issued.  Returns true if CE    is valid, i.e., does not have a designated initializer.  */
end_comment

begin_function
specifier|static
name|bool
name|check_array_designated_initializer
parameter_list|(
specifier|const
name|constructor_elt
modifier|*
name|ce
parameter_list|)
block|{
comment|/* Designated initializers for array elements arenot supported.  */
if|if
condition|(
name|ce
operator|->
name|index
condition|)
block|{
comment|/* The parser only allows identifiers as designated 	 intializers.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"name %qD used in a GNU-style designated "
literal|"initializer for an array"
argument_list|,
name|ce
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* When parsing `int a[] = {1, 2};' we don't know the size of the    array until we finish parsing the initializer.  If that's the    situation we're in, update DECL accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_deduce_size_from_array_init
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
comment|/* do_default is really a C-ism to deal with tentative definitions. 	 But let's leave it here to ease the eventual merge.  */
name|int
name|do_default
init|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|initializer
init|=
name|init
condition|?
name|init
else|:
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|;
comment|/* Check that there are no designated initializers in INIT, as 	 those are not supported in GNU C++, and as the middle-end 	 will crash if presented with a non-numeric designated 	 initializer.  */
if|if
condition|(
name|initializer
operator|&&
name|TREE_CODE
argument_list|(
name|initializer
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initializer
argument_list|)
expr_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|i
argument_list|,
name|ce
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|check_array_designated_initializer
argument_list|(
name|ce
argument_list|)
condition|)
name|failure
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failure
condition|)
block|{
name|failure
operator|=
name|cp_complete_array_type
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|initializer
argument_list|,
name|do_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"initializer fails to determine size of %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
block|{
name|error
argument_list|(
literal|"array size missing in %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If a `static' var's size isn't known, make it extern as 		 well as static, so it does not get allocated.  If it's not 		 `static', then don't mark it extern; finish_incomplete_decl 		 will give it a default size and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|failure
operator|==
literal|3
condition|)
block|{
name|error
argument_list|(
literal|"zero-size array %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
name|cp_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set DECL_SIZE, DECL_ALIGN, etc. for DECL (a VAR_DECL), and issue    any appropriate error messages regarding the layout.  */
end_comment

begin_function
specifier|static
name|void
name|layout_var_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* If we haven't already layed out this declaration, do so now.      Note that we must not call complete type for an external object      because it's type might involve templates that we are not      supposed to instantiate yet.  (And it's perfectly valid to say      `extern X x' for some incomplete type `X'.)  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* An automatic variable with an incomplete type: that is an error. 	 Don't talk about array types here, since we took care of that 	 message in grokdeclarator.  */
name|error
argument_list|(
literal|"storage size of %qD isn't known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Keep this code around in case we later want to control debug info      based on whether a type is "used".  (jason 1999-11-11) */
block|else if (!DECL_EXTERNAL (decl)&& IS_AGGR_TYPE (ttype))
comment|/* Let debugger know it should output info for this type.  */
block|note_debug_info_needed (ttype);    if (TREE_STATIC (decl)&& DECL_CLASS_SCOPE_P (decl))     note_debug_info_needed (DECL_CONTEXT (decl));
endif|#
directive|endif
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"storage size of %qD isn't constant"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If a local static variable is declared in an inline function, or if    we have a weak definition, we must endeavor to create only one    instance of the variable at link-time.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_commonize_var
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Static data in a function with comdat linkage also has comdat      linkage.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Don't mess with __FUNCTION__.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
comment|/* Unfortunately, import_export_decl has not always been called 	 before the function is processed, so we cannot simply check 	 DECL_COMDAT.  */
operator|&&
operator|(
name|DECL_COMDAT
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|flag_weak
condition|)
block|{
comment|/* With weak symbols, we simply make the variable COMDAT; 	     that will cause copies in multiple translations units to 	     be merged.  */
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Without weak symbols, we can use COMMON to merge 		 uninitialized variables.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* While for initialized variables, we must use internal 		 linkage -- which means that multiple copies will not 		 be merged.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"sorry: semantics of inline function static "
literal|"data %q+#D are wrong (you'll wind up "
literal|"with multiple copies)"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%J  you can work around this by removing "
literal|"the initializer"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Set it up again; we might have set DECL_INITIAL since the last        time.  */
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue an error message if DECL is an uninitialized const variable.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_uninitialized_const_var
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* ``Unless explicitly declared extern, a const object does not have      external linkage and must be initialized. ($8.4; $12.1)'' ARM      7.1.6 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"uninitialized const %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure holding the current initializer being processed by reshape_init.    CUR is a pointer to the current element being processed, END is a pointer    after the last element present in the initializer.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reshape_iterator_t
block|{
name|constructor_elt
modifier|*
name|cur
decl_stmt|;
name|constructor_elt
modifier|*
name|end
decl_stmt|;
block|}
name|reshape_iter
typedef|;
end_typedef

begin_function_decl
specifier|static
name|tree
name|reshape_init_r
parameter_list|(
name|tree
parameter_list|,
name|reshape_iter
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIELD is a FIELD_DECL or NULL.  In the former case, the value    returned is the next FIELD_DECL (possibly FIELD itself) that can be    initialized.  If there are no more such fields, the return value    will be NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|next_initializable_field
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
while|while
condition|(
name|field
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|(
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|)
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|)
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|field
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of reshape_init_array and reshape_init_vector, which does    the actual work. ELT_TYPE is the element type of the array. MAX_INDEX is an    INTEGER_CST representing the size of the array minus one (the maximum index),    or NULL_TREE if the array was declared without specifying the size. D is    the iterator within the constructor.  */
end_comment

begin_function
specifier|static
name|tree
name|reshape_init_array_1
parameter_list|(
name|tree
name|elt_type
parameter_list|,
name|tree
name|max_index
parameter_list|,
name|reshape_iter
modifier|*
name|d
parameter_list|)
block|{
name|tree
name|new_init
decl_stmt|;
name|bool
name|sized_array_p
init|=
operator|(
name|max_index
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_index_cst
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|index
decl_stmt|;
comment|/* The initializer for an array is always a CONSTRUCTOR.  */
name|new_init
operator|=
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sized_array_p
condition|)
block|{
comment|/* Minus 1 is used for zero sized arrays.  */
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|max_index
argument_list|)
condition|)
return|return
name|new_init
return|;
if|if
condition|(
name|host_integerp
argument_list|(
name|max_index
argument_list|,
literal|1
argument_list|)
condition|)
name|max_index_cst
operator|=
name|tree_low_cst
argument_list|(
name|max_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* sizetype is sign extended, not zero extended.  */
else|else
name|max_index_cst
operator|=
name|tree_low_cst
argument_list|(
name|fold_convert
argument_list|(
name|size_type_node
argument_list|,
name|max_index
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Loop until there are no more initializers.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|d
operator|->
name|cur
operator|!=
name|d
operator|->
name|end
operator|&&
operator|(
operator|!
name|sized_array_p
operator|||
name|index
operator|<=
name|max_index_cst
operator|)
condition|;
operator|++
name|index
control|)
block|{
name|tree
name|elt_init
decl_stmt|;
name|check_array_designated_initializer
argument_list|(
name|d
operator|->
name|cur
argument_list|)
expr_stmt|;
name|elt_init
operator|=
name|reshape_init_r
argument_list|(
name|elt_type
argument_list|,
name|d
argument_list|,
comment|/*first_initializer_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt_init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|new_init
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|elt_init
argument_list|)
expr_stmt|;
block|}
return|return
name|new_init
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of reshape_init_r, processes the initializers for arrays.    Parameters are the same of reshape_init_r.  */
end_comment

begin_function
specifier|static
name|tree
name|reshape_init_array
parameter_list|(
name|tree
name|type
parameter_list|,
name|reshape_iter
modifier|*
name|d
parameter_list|)
block|{
name|tree
name|max_index
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
name|max_index
operator|=
name|array_type_nelts
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|reshape_init_array_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|max_index
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of reshape_init_r, processes the initializers for vectors.    Parameters are the same of reshape_init_r.  */
end_comment

begin_function
specifier|static
name|tree
name|reshape_init_vector
parameter_list|(
name|tree
name|type
parameter_list|,
name|reshape_iter
modifier|*
name|d
parameter_list|)
block|{
name|tree
name|max_index
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rtype
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMPOUND_LITERAL_P
argument_list|(
name|d
operator|->
name|cur
operator|->
name|value
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|d
operator|->
name|cur
operator|->
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid type %qT as initializer for a vector of type %qT"
argument_list|,
name|TREE_TYPE
argument_list|(
name|d
operator|->
name|cur
operator|->
name|value
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
operator|++
name|d
operator|->
name|cur
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* For a vector, the representation type is a struct       containing a single member which is an array of the       appropriate size.  */
name|rtype
operator|=
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|rtype
argument_list|)
argument_list|)
argument_list|)
condition|)
name|max_index
operator|=
name|array_type_nelts
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|rtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reshape_init_array_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|max_index
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of reshape_init_r, processes the initializers for classes    or union. Parameters are the same of reshape_init_r.  */
end_comment

begin_function
specifier|static
name|tree
name|reshape_init_class
parameter_list|(
name|tree
name|type
parameter_list|,
name|reshape_iter
modifier|*
name|d
parameter_list|,
name|bool
name|first_initializer_p
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
name|tree
name|new_init
decl_stmt|;
name|gcc_assert
argument_list|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The initializer for a class is always a CONSTRUCTOR.  */
name|new_init
operator|=
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|field
operator|=
name|next_initializable_field
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
block|{
comment|/* [dcl.init.aggr]  	An initializer for an aggregate member that is an 	empty class shall have the form of an empty 	initializer-list {}.  */
if|if
condition|(
operator|!
name|first_initializer_p
condition|)
block|{
name|error
argument_list|(
literal|"initializer for %qT must be brace-enclosed"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|new_init
return|;
block|}
comment|/* Loop through the initializable fields, gathering initializers.  */
while|while
condition|(
name|d
operator|->
name|cur
operator|!=
name|d
operator|->
name|end
condition|)
block|{
name|tree
name|field_init
decl_stmt|;
comment|/* Handle designated initializers, as an extension.  */
if|if
condition|(
name|d
operator|->
name|cur
operator|->
name|index
condition|)
block|{
name|field
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|d
operator|->
name|cur
operator|->
name|index
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%qT has no non-static data member named %qD"
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|cur
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* If we processed all the member of the class, we are done.  */
if|if
condition|(
operator|!
name|field
condition|)
break|break;
name|field_init
operator|=
name|reshape_init_r
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|d
argument_list|,
comment|/*first_initializer_p=*/
name|false
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|new_init
argument_list|)
argument_list|,
name|field
argument_list|,
name|field_init
argument_list|)
expr_stmt|;
comment|/* [dcl.init.aggr]  	When a union  is  initialized with a brace-enclosed 	initializer, the braces shall only contain an 	initializer for the first member of the union.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
break|break;
name|field
operator|=
name|next_initializable_field
argument_list|(
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|new_init
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of reshape_init, which processes a single initializer (part of    a CONSTRUCTOR). TYPE is the type of the variable being initialized, D is the    iterator within the CONSTRUCTOR which points to the initializer to process.    FIRST_INITIALIZER_P is true if this is the first initializer of the    CONSTRUCTOR node.  */
end_comment

begin_function
specifier|static
name|tree
name|reshape_init_r
parameter_list|(
name|tree
name|type
parameter_list|,
name|reshape_iter
modifier|*
name|d
parameter_list|,
name|bool
name|first_initializer_p
parameter_list|)
block|{
name|tree
name|init
init|=
name|d
operator|->
name|cur
operator|->
name|value
decl_stmt|;
comment|/* A non-aggregate type is always initialized with a single      initializer.  */
if|if
condition|(
operator|!
name|CP_AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* It is invalid to initialize a non-aggregate type with a 	 brace-enclosed initializer. 	 We need to check for BRACE_ENCLOSED_INITIALIZER_P here because 	 of g++.old-deja/g++.mike/p7626.C: a pointer-to-member constant is 	 a CONSTRUCTOR (with a record type).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
condition|)
comment|/* p7626.C */
block|{
name|error
argument_list|(
literal|"braces around scalar initializer for type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|d
operator|->
name|cur
operator|++
expr_stmt|;
return|return
name|init
return|;
block|}
comment|/* [dcl.init.aggr]       All implicit type conversions (clause _conv_) are considered when      initializing the aggregate member with an initializer from an      initializer-list.  If the initializer can initialize a member,      the member is initialized.  Otherwise, if the member is itself a      non-empty subaggregate, brace elision is assumed and the      initializer is considered for the initialization of the first      member of the subaggregate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|&&
name|can_convert_arg
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
condition|)
block|{
name|d
operator|->
name|cur
operator|++
expr_stmt|;
return|return
name|init
return|;
block|}
comment|/* [dcl.init.string]        A char array (whether plain char, signed char, or unsigned char)       can be initialized by a string-literal (optionally enclosed in       braces); a wchar_t array can be initialized by a wide       string-literal (optionally enclosed in braces).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|char_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|str_init
init|=
name|init
decl_stmt|;
comment|/* Strip one level of braces if and only if they enclose a single 	 element (as allowed by [dcl.init.string]).  */
if|if
condition|(
operator|!
name|first_initializer_p
operator|&&
name|TREE_CODE
argument_list|(
name|str_init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|str_init
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|str_init
operator|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|str_init
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|->
name|value
expr_stmt|;
block|}
comment|/* If it's a string literal, then it's the initializer for the array 	 as a whole. Otherwise, continue with normal initialization for 	 array types (one value per array element).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|str_init
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|d
operator|->
name|cur
operator|++
expr_stmt|;
return|return
name|str_init
return|;
block|}
block|}
comment|/* The following cases are about aggregates. If we are not within a full      initializer already, and there is not a CONSTRUCTOR, it means that there      is a missing set of braces (that is, we are processing the case for      which reshape_init exists).  */
if|if
condition|(
operator|!
name|first_initializer_p
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
comment|/* There is no need to reshape pointer-to-member function 	       initializers, as they are always constructed correctly 	       by the front end.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|COMPOUND_LITERAL_P
argument_list|(
name|init
argument_list|)
condition|)
comment|/* For a nested compound literal, there is no need to reshape since 	     brace elision is not allowed. Even if we decided to allow it, 	     we should add a call to reshape_init in finish_compound_literal, 	     before calling digest_init, so changing this code would still 	     not be necessary.  */
name|gcc_assert
argument_list|(
operator|!
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|d
operator|->
name|cur
expr_stmt|;
name|gcc_assert
argument_list|(
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reshape_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
return|;
block|}
block|}
name|warning
argument_list|(
name|OPT_Wmissing_braces
argument_list|,
literal|"missing braces around initializer for %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Dispatch to specialized routines.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|reshape_init_class
argument_list|(
name|type
argument_list|,
name|d
argument_list|,
name|first_initializer_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|reshape_init_array
argument_list|(
name|type
argument_list|,
name|d
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|reshape_init_vector
argument_list|(
name|type
argument_list|,
name|d
argument_list|)
return|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo the brace-elision allowed by [dcl.init.aggr] in a    brace-enclosed aggregate initializer.     INIT is the CONSTRUCTOR containing the list of initializers describing    a brace-enclosed initializer for an entity of the indicated aggregate TYPE.    It may not presently match the shape of the TYPE; for example:       struct S { int a; int b; };      struct S a[] = { 1, 2, 3, 4 };     Here INIT will hold a VEC of four elements, rather than a    VEC of two elements, each itself a VEC of two elements.  This    routine transforms INIT from the former form into the latter.  The    revised CONSTRUCTOR node is returned.  */
end_comment

begin_function
name|tree
name|reshape_init
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
expr_stmt|;
name|reshape_iter
name|d
decl_stmt|;
name|tree
name|new_init
decl_stmt|;
name|gcc_assert
argument_list|(
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* An empty constructor does not need reshaping, and it is always a valid      initializer.  */
if|if
condition|(
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|)
condition|)
return|return
name|init
return|;
comment|/* Recurse on this CONSTRUCTOR.  */
name|d
operator|.
name|cur
operator|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|.
name|end
operator|=
name|d
operator|.
name|cur
operator|+
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|new_init
operator|=
name|reshape_init_r
argument_list|(
name|type
argument_list|,
operator|&
name|d
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Make sure all the element of the constructor were used. Otherwise,      issue an error about exceeding initializers.  */
if|if
condition|(
name|d
operator|.
name|cur
operator|!=
name|d
operator|.
name|end
condition|)
name|error
argument_list|(
literal|"too many initializers for %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|new_init
return|;
block|}
end_function

begin_comment
comment|/* Verify INIT (the initializer for DECL), and record the    initialization in DECL_INITIAL, if appropriate.  CLEANUP is as for    grok_reference_init.     If the return value is non-NULL, it is an expression that must be    evaluated dynamically to initialize DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|check_initializer
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
modifier|*
name|cleanup
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|init_code
init|=
name|NULL
decl_stmt|;
comment|/* Things that are going to be initialized need to have complete      type.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
comment|/* We will have already complained.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|element_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* The array type itself need not be complete, because the 	 initializer may tell us how many elements are in the array. 	 But, the elements of the array must be complete.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|element_type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"elements of array %q#D have incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* It is not valid to initialize an a VLA.  */
if|if
condition|(
name|init
operator|&&
operator|(
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|element_type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object %qD may not be initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD has incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
comment|/* There is no way to make a variable-sized class type in GNU C++.  */
name|gcc_assert
argument_list|(
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CP_AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|init
operator|&&
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
operator|&&
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"scalar object %qD requires one element in initializer"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|gcc_assert
argument_list|(
name|init
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|init
operator|=
name|grok_reference_init
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|init
condition|)
block|{
comment|/* Do not reshape constructors of vectors (they don't need to be 	 reshaped.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|COMPOUND_LITERAL_P
argument_list|(
name|init
argument_list|)
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
condition|)
comment|/* ptrmemfunc */
block|{
name|init
operator|=
name|reshape_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|vector_opaque_p
call|)
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"opaque vector types cannot be initialized"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
comment|/* If DECL has an array type without a specific bound, deduce the 	 array size from the initializer.  */
name|maybe_deduce_size_from_array_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
goto|goto
name|initialize_aggr
goto|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
name|TYPE_NON_AGGREGATE_CLASS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD must be initialized by constructor, "
literal|"not by %<{...}%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
goto|goto
name|dont_use_constructor
goto|;
block|}
else|else
block|{
name|int
name|saved_stmts_are_full_exprs_p
decl_stmt|;
name|initialize_aggr
label|:
name|saved_stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
block|{
name|saved_stmts_are_full_exprs_p
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
block|}
name|init
operator|=
name|build_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|saved_stmts_are_full_exprs_p
expr_stmt|;
return|return
name|init
return|;
block|}
block|}
else|else
block|{
name|dont_use_constructor
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_VEC
condition|)
block|{
name|init_code
operator|=
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|PAREN_STRING_LITERAL_P
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"array %qD initialized by parenthesized string literal %qE"
argument_list|,
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|initialize_aggr
goto|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|core_type
init|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|core_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"structure %qD with uninitialized const members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|core_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"structure %qD with uninitialized reference members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|check_for_uninitialized_const_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|check_for_uninitialized_const_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|init
operator|!=
name|error_mark_node
condition|)
name|init_code
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|init_code
return|;
block|}
end_function

begin_comment
comment|/* If DECL is not a local variable, give it RTL.  */
end_comment

begin_function
specifier|static
name|void
name|make_rtl_for_nonlocal_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|)
block|{
name|int
name|toplev
init|=
name|toplevel_bindings_p
argument_list|()
decl_stmt|;
name|int
name|defer_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Set the DECL_ASSEMBLER_NAME for the object.  */
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* The `register' keyword, when used together with an 	 asm-specification, indicates that the variable should be 	 placed in a particular register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|set_user_assembler_name
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|DECL_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
name|set_builtin_user_assembler_name
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|set_user_assembler_name
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle non-variables up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|toplev
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we see a class member here, it should be a static data      member.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An in-class declaration of a static data member should be 	 external; it is only a declaration, and not a definition. */
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|gcc_assert
argument_list|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We don't create any RTL for local variables.  */
if|if
condition|(
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* We defer emission of local statics until the corresponding      DECL_EXPR is expanded.  */
name|defer_p
operator|=
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We try to defer namespace-scope static constants so that they are      not emitted into the object file unnecessarily.  */
name|filename
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|filename
operator|!=
name|NULL
operator|&&
operator|!
name|EMPTY_CONSTRUCTOR_P
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|toplev
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Fool with the linkage of static consts according to #pragma 	 interface.  */
name|struct
name|c_fileinfo
modifier|*
name|finfo
init|=
name|get_fileinfo
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|interface_unknown
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|finfo
operator|->
name|interface_only
expr_stmt|;
block|}
name|defer_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Likewise for template instantiations.  */
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
name|defer_p
operator|=
literal|1
expr_stmt|;
comment|/* If we're not deferring, go ahead and assemble the variable.  */
if|if
condition|(
operator|!
name|defer_p
condition|)
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|toplev
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to initialize DECL (a local variable).  */
end_comment

begin_function
specifier|static
name|void
name|initialize_local_var
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
name|int
name|already_used
decl_stmt|;
comment|/* Compute and store the initial value.  */
name|already_used
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Perform the initialization.  */
if|if
condition|(
name|init
condition|)
block|{
name|int
name|saved_stmts_are_full_exprs_p
decl_stmt|;
name|gcc_assert
argument_list|(
name|building_stmt_tree
argument_list|()
argument_list|)
expr_stmt|;
name|saved_stmts_are_full_exprs_p
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|saved_stmts_are_full_exprs_p
expr_stmt|;
block|}
comment|/* Set this to 0 so we can tell whether an aggregate which was 	 initialized was ever used.  Don't do this if it has a 	 destructor, so we don't complain about the 'resource 	 allocation is initialization' idiom.  Now set 	 attribute((unused)) on types so decls of that type will be 	 marked used. (see TREE_USED, above.)  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|already_used
operator|&&
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|already_used
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Generate a cleanup, if necessary.  */
name|cleanup
operator|=
name|cxx_maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|cleanup
condition|)
name|finish_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL for a compiler-generated variable with static    storage duration (like a virtual table) whose initializer is a    compile-time constant.  INIT must be either a TREE_LIST of values,    or a CONSTRUCTOR.  Initialize the variable and provide it to the    back end.  */
end_comment

begin_function
name|void
name|initialize_artificial_var
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|DECL_INITIALIZED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|determine_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|layout_var_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|maybe_commonize_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|make_rtl_for_nonlocal_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
comment|/*asmspec=*/
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* INIT is the initializer for a variable, as represented by the    parser.  Returns true iff INIT is value-dependent.  */
end_comment

begin_function
specifier|static
name|bool
name|value_dependent_init_p
parameter_list|(
name|tree
name|init
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* A parenthesized initializer, e.g.: int i (3, 2); ? */
return|return
name|any_value_dependent_elements_p
argument_list|(
name|init
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
comment|/* A brace-enclosed initializer, e.g.: int i = { 3 }; ? */
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|elts
expr_stmt|;
name|size_t
name|nelts
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|elts
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|elts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|value_dependent_init_p
argument_list|(
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|elts
argument_list|,
name|i
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return
name|true
return|;
block|}
else|else
comment|/* It must be a simple expression, e.g., int i = 3;  */
return|return
name|value_dependent_expression_p
argument_list|(
name|init
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its line number and initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.     INIT is the initializer (if any) for DECL.  If INIT_CONST_EXPR_P is    true, then INIT is an integral constant expression.     FLAGS is LOOKUP_ONLYCONVERTING if the = init syntax was used, else 0    if the (init) syntax was used.  */
end_comment

begin_function
name|void
name|cp_finish_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|init_const_expr_p
parameter_list|,
name|tree
name|asmspec_tree
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
init|=
name|NULL
decl_stmt|;
name|int
name|was_readonly
init|=
literal|0
decl_stmt|;
name|bool
name|var_definition_p
init|=
name|false
decl_stmt|;
name|int
name|saved_processing_template_decl
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|decl
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|error
argument_list|(
literal|"assignment (not initialization) in declaration"
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|RESULT_DECL
argument_list|)
expr_stmt|;
comment|/* Parameters are handled by store_parm_decls, not cp_finish_decl.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Assume no cleanup is required.  */
name|cleanup
operator|=
name|NULL_TREE
expr_stmt|;
name|saved_processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
comment|/* If a name was specified, get the string.  */
if|if
condition|(
name|global_scope_p
argument_list|(
name|current_binding_level
argument_list|)
condition|)
name|asmspec_tree
operator|=
name|maybe_apply_renaming_pragma
argument_list|(
name|decl
argument_list|,
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec_tree
operator|&&
name|asmspec_tree
operator|!=
name|error_mark_node
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
name|init
operator|)
condition|)
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|bool
name|type_dependent_p
decl_stmt|;
comment|/* Add this declaration to the statement-tree.  */
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
name|add_decl_expr
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|type_dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|init_const_expr_p
condition|)
block|{
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INTEGRAL_CONSTANT_VAR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Generally, initializers in templates are expanded when the 	 template is instantiated.  But, if DECL is an integral 	 constant static data member, then it can be used in future 	 integral constant expressions, and its value must be 	 available. */
if|if
condition|(
operator|!
operator|(
name|init
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INTEGRAL_CONSTANT_VAR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|type_dependent_p
operator|&&
operator|!
name|value_dependent_init_p
argument_list|(
name|init
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_PRETTY_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|type_dependent_p
condition|)
name|maybe_deduce_size_from_array_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
name|init
operator|=
name|fold_non_dependent_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Take care of TYPE_DECLs up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|type
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"shadowing previous type declaration of %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* If we have installed this as the canonical typedef for this 	 type, and that type has not been defined yet, delay emitting 	 the debug information for it, as we will emit it later.  */
if|if
condition|(
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|decl
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
comment|/* A reference will be modified here, as it is initialized.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|was_readonly
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Only PODs can have thread-local storage.  Other types may require 	 various kinds of non-trivial initialization.  */
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|pod_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD cannot be thread-local because it has non-POD type %qT"
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a local variable that will need a mangled name, 	 register it now.  We must do this before processing the 	 initializer for the variable, since the initialization might 	 require a guard variable, and since the mangled name of the 	 guard variable will depend on the mangled name of this 	 variable.  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|push_local_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Convert the initializer to the type of DECL, if we have not 	 already initialized DECL.  */
if|if
condition|(
operator|!
name|DECL_INITIALIZED_P
argument_list|(
name|decl
argument_list|)
comment|/* If !DECL_EXTERNAL then DECL is being defined.  In the 	     case of a static data member initialized inside the 	     class-specifier, there can be an initializer even if DECL 	     is *not* defined.  */
operator|&&
operator|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|init
operator|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
block|{
name|DECL_NONTRIVIALLY_INITIALIZED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|init_const_expr_p
condition|)
block|{
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INTEGRAL_CONSTANT_VAR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|init
operator|=
name|check_initializer
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|flags
argument_list|,
operator|&
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Thread-local storage cannot be dynamically initialized.  */
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|init
condition|)
block|{
name|error
argument_list|(
literal|"%qD is thread-local and so cannot be dynamically "
literal|"initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Check that the initializer for a static data member was a 	     constant.  Although we check in the parser that the 	     initializer is an integral constant expression, we do not 	     simplify division-by-zero at the point at which it 	     occurs.  Therefore, in:  	       struct S { static const int i = 7 / 0; };  	     we issue an error at this point.  It would 	     probably be better to forbid division by zero in 	     integral constant expressions.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|init
condition|)
block|{
name|error
argument_list|(
literal|"%qD cannot be initialized by a non-constant expression"
literal|" when being declared"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Handle:  	     [dcl.init]  	     The memory occupied by any object of static storage 	     duration is zero-initialized at program startup before 	     any other initialization takes place.  	     We cannot create an appropriate initializer until after 	     the type of DECL is finalized.  If DECL_INITIAL is set, 	     then the DECL is statically initialized, and any 	     necessary zero-initialization has already been performed.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_zero_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*nelts=*/
name|NULL_TREE
argument_list|,
comment|/*static_storage_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Remember that the initialization for this variable has 	     taken place.  */
name|DECL_INITIALIZED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This declaration is the definition of this variable, 	     unless we are initializing a static data member within 	     the class specifier.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|var_definition_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the variable has an array type, lay out the type, even if 	 there is no initializer.  It is valid to index through the 	 array, and we must get TYPE_ALIGN set correctly on the array 	 type.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Add this declaration to the statement-tree.  This needs to happen      after the call to check_initializer so that the DECL_EXPR for a      reference temp is added before the DECL_EXPR for the reference itself.  */
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
name|add_decl_expr
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Let the middle end know about variables and functions -- but not      static data members in uninstantiated class templates.  */
if|if
condition|(
operator|!
name|saved_processing_template_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|layout_var_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|maybe_commonize_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|make_rtl_for_nonlocal_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Check for abstractness of the type. Notice that there is no 	 need to strip array types here since the check for those types 	 is already done within create_array_type_for_decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* This needs to happen after the linkage is set. */
name|determine_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* No initialization required.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
else|else
block|{
comment|/* A variable definition.  */
if|if
condition|(
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Initialize the local variable.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|initialize_local_var
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
comment|/* If a variable is defined, and then a subsequent 	     definition with external linkage is encountered, we will 	     get here twice for the same variable.  We want to avoid 	     calling expand_static_init more than once.  For variables 	     that are not static data members, we can call 	     expand_static_init only when we actually process the 	     initializer.  It is not legal to redeclare a static data 	     member, so this issue does not arise in that case.  */
if|if
condition|(
name|var_definition_p
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If a TREE_READONLY variable needs initialization 		 at runtime, it is no longer readonly and we need to 		 avoid MEM_READONLY_P being set on RTL created for it.  */
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|was_readonly
operator|=
literal|0
expr_stmt|;
block|}
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If a CLEANUP_STMT was created to destroy a temporary bound to a      reference, insert it in the statement-tree now.  */
if|if
condition|(
name|cleanup
condition|)
name|push_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|finish_end
label|:
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
if|if
condition|(
name|was_readonly
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this was marked 'used', be sure it will be output.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|mark_decl_referenced
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is here for a midend callback from c-common.c.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
name|asmspec_tree
parameter_list|)
block|{
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
name|asmspec_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a declaration for a VAR_DECL as if:       extern "C" TYPE NAME;     had been seen.  Used to create compiler-generated global    variables.  */
end_comment

begin_function
specifier|static
name|tree
name|declare_global_var
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If the user has explicitly declared this variable (perhaps      because the code we are compiling is part of a low-level runtime      library), then it is possible that our declaration will be merged      with theirs by pushdecl.  */
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns a pointer to the `atexit' function.  Note that if    FLAG_USE_CXA_ATEXIT is nonzero, then this will actually be the new    `__cxa_atexit' function specified in the IA64 C++ ABI.  */
end_comment

begin_function
specifier|static
name|tree
name|get_atexit_node
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|atexit_fndecl
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
name|tree
name|fn_type
decl_stmt|;
name|tree
name|fn_ptr_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bool
name|use_aeabi_atexit
decl_stmt|;
if|if
condition|(
name|atexit_node
condition|)
return|return
name|atexit_node
return|;
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
block|{
comment|/* The declaration for `__cxa_atexit' is:  	   int __cxa_atexit (void (*)(void *), void *, void *)  	 We build up the argument types and then then function type 	 itself.  */
name|use_aeabi_atexit
operator|=
name|targetm
operator|.
name|cxx
operator|.
name|use_aeabi_atexit
argument_list|()
expr_stmt|;
comment|/* First, build the pointer-to-function type for the first 	 argument.  */
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|fn_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
comment|/* Then, build the rest of the argument types.  */
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_aeabi_atexit
condition|)
block|{
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn_ptr_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn_ptr_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
block|}
comment|/* And the final __cxa_atexit type.  */
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|fn_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_aeabi_atexit
condition|)
name|name
operator|=
literal|"__aeabi_atexit"
expr_stmt|;
else|else
name|name
operator|=
literal|"__cxa_atexit"
expr_stmt|;
block|}
else|else
block|{
comment|/* The declaration for `atexit' is:  	   int atexit (void (*)());  	 We build up the argument types and then then function type 	 itself.  */
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|fn_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn_ptr_type
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
comment|/* Build the final atexit type.  */
name|fn_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"atexit"
expr_stmt|;
block|}
comment|/* Now, build the function declaration.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|atexit_fndecl
operator|=
name|build_library_fn_ptr
argument_list|(
name|name
argument_list|,
name|fn_type
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|atexit_fndecl
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
name|atexit_node
operator|=
name|decay_conversion
argument_list|(
name|atexit_fndecl
argument_list|)
expr_stmt|;
return|return
name|atexit_node
return|;
block|}
end_function

begin_comment
comment|/* Returns the __dso_handle VAR_DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|get_dso_handle_node
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dso_handle_node
condition|)
return|return
name|dso_handle_node
return|;
comment|/* Declare the variable.  */
name|dso_handle_node
operator|=
name|declare_global_var
argument_list|(
name|get_identifier
argument_list|(
literal|"__dso_handle"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
return|return
name|dso_handle_node
return|;
block|}
end_function

begin_comment
comment|/* Begin a new function with internal linkage whose job will be simply    to destroy some particular variable.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|start_cleanup_cnt
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|start_cleanup_fn
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
comment|/* No need to mangle this.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* Build the parameter-types.  */
name|parmtypes
operator|=
name|void_list_node
expr_stmt|;
comment|/* Functions passed to __cxa_atexit take an additional parameter.      We'll just ignore it.  After we implement the new calling      convention for destructors, we can eliminate the use of      additional cleanup functions entirely in the -fnew-abi case.  */
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* Build the function type itself.  */
name|fntype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* Build the name of the function.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__tcf_%d"
argument_list|,
name|start_cleanup_cnt
operator|++
argument_list|)
expr_stmt|;
comment|/* Build the function declaration.  */
name|fndecl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
comment|/* It's a function with internal linkage, generated by the      compiler.  */
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make the function `inline' so that it is only emitted if it is      actually needed.  It is unlikely that it will be inlined, since      it is only called via a function pointer, but we avoid unnecessary      emissions this way.  */
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Build the parameter.  */
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
block|{
name|tree
name|parmdecl
decl_stmt|;
name|parmdecl
operator|=
name|cp_build_parm_decl
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|parmdecl
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|TREE_USED
argument_list|(
name|parmdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|parmdecl
expr_stmt|;
block|}
name|pushdecl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|start_preparsed_function
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
return|return
name|current_function_decl
return|;
block|}
end_function

begin_comment
comment|/* Finish the cleanup function begun by start_cleanup_fn.  */
end_comment

begin_function
specifier|static
name|void
name|end_cleanup_fn
parameter_list|(
name|void
parameter_list|)
block|{
name|expand_or_defer_fn
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to handle the destruction of DECL, an object with    static storage duration.  */
end_comment

begin_function
name|tree
name|register_dtor_fn
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|cleanup
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|fcall
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|void_zero_node
return|;
comment|/* Call build_cleanup before we enter the anonymous function so that      any access checks will be done relative to the current scope,      rather than the scope of the anonymous function.  */
name|build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Now start the function.  */
name|cleanup
operator|=
name|start_cleanup_fn
argument_list|()
expr_stmt|;
comment|/* Now, recompute the cleanup.  It may contain SAVE_EXPRs that refer      to the original function, rather than the anonymous one.  That      will make the back-end think that nested functions are in use,      which causes confusion.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|fcall
operator|=
name|build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Create the body of the anonymous function.  */
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_FN_BODY
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|fcall
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
name|end_cleanup_fn
argument_list|()
expr_stmt|;
comment|/* Call atexit with the cleanup function.  */
name|cxx_mark_addressable
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
block|{
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_dso_handle_node
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|use_aeabi_atexit
argument_list|()
condition|)
block|{
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|null_pointer_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|null_pointer_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|get_atexit_node
argument_list|()
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL with static storage duration.  INIT, if present,    is its initializer.  Generate code to handle the construction    and destruction of DECL.  */
end_comment

begin_function
specifier|static
name|void
name|expand_static_init
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some variables require no initialization.  */
if|if
condition|(
operator|!
name|init
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Emit code to perform this initialization but once.  */
name|tree
name|if_stmt
init|=
name|NULL_TREE
decl_stmt|,
name|inner_if_stmt
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|then_clause
init|=
name|NULL_TREE
decl_stmt|,
name|inner_then_clause
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|guard
decl_stmt|,
name|guard_addr
decl_stmt|,
name|guard_addr_list
decl_stmt|;
name|tree
name|acquire_fn
decl_stmt|,
name|release_fn
decl_stmt|,
name|abort_fn
decl_stmt|;
name|tree
name|flag
decl_stmt|,
name|begin
decl_stmt|;
comment|/* Emit code to perform this initialization but once.  This code 	 looks like:  	   static<type> guard; 	   if (!guard.first_byte) { 	     if (__cxa_guard_acquire (&guard)) { 	       bool flag = false; 	       try { 		 // Do initialization. 		 flag = true; __cxa_guard_release (&guard); 		 // Register variable for destruction at end of program. 	       } catch { 		 if (!flag) __cxa_guard_abort (&guard); 	       } 	   }  	 Note that the `flag' variable is only set to 1 *after* the 	 initialization is complete.  This ensures that an exception, 	 thrown during the construction, will cause the variable to 	 reinitialized when we pass through this code again, as per:  	   [stmt.dcl]  	   If the initialization exits by throwing an exception, the 	   initialization is not complete, so it will be tried again 	   the next time control enters the declaration.  	 This process should be thread-safe, too; multiple threads 	 should not be able to initialize the variable more than 	 once.  */
comment|/* Create the guard variable.  */
name|guard
operator|=
name|get_guard
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* This optimization isn't safe on targets with relaxed memory 	 consistency.  On such targets we force synchronization in 	 __cxa_guard_acquire.  */
if|if
condition|(
operator|!
name|targetm
operator|.
name|relaxed_ordering
operator|||
operator|!
name|flag_threadsafe_statics
condition|)
block|{
comment|/* Begin the conditional initialization.  */
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|get_guard_cond
argument_list|(
name|guard
argument_list|)
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|then_clause
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_NO_SCOPE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_threadsafe_statics
condition|)
block|{
name|guard_addr
operator|=
name|build_address
argument_list|(
name|guard
argument_list|)
expr_stmt|;
name|guard_addr_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|guard_addr
argument_list|)
expr_stmt|;
name|acquire_fn
operator|=
name|get_identifier
argument_list|(
literal|"__cxa_guard_acquire"
argument_list|)
expr_stmt|;
name|release_fn
operator|=
name|get_identifier
argument_list|(
literal|"__cxa_guard_release"
argument_list|)
expr_stmt|;
name|abort_fn
operator|=
name|get_identifier
argument_list|(
literal|"__cxa_guard_abort"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_global_value_if_present
argument_list|(
name|acquire_fn
argument_list|,
operator|&
name|acquire_fn
argument_list|)
condition|)
block|{
name|tree
name|argtypes
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|guard_addr
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|vfntype
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|argtypes
argument_list|)
decl_stmt|;
name|acquire_fn
operator|=
name|push_library_fn
argument_list|(
name|acquire_fn
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|argtypes
argument_list|)
argument_list|)
expr_stmt|;
name|release_fn
operator|=
name|push_library_fn
argument_list|(
name|release_fn
argument_list|,
name|vfntype
argument_list|)
expr_stmt|;
name|abort_fn
operator|=
name|push_library_fn
argument_list|(
name|abort_fn
argument_list|,
name|vfntype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|release_fn
operator|=
name|identifier_global_value
argument_list|(
name|release_fn
argument_list|)
expr_stmt|;
name|abort_fn
operator|=
name|identifier_global_value
argument_list|(
name|abort_fn
argument_list|)
expr_stmt|;
block|}
name|inner_if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|build_call
argument_list|(
name|acquire_fn
argument_list|,
name|guard_addr_list
argument_list|)
argument_list|,
name|inner_if_stmt
argument_list|)
expr_stmt|;
name|inner_then_clause
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_NO_SCOPE
argument_list|)
expr_stmt|;
name|begin
operator|=
name|get_target_expr
argument_list|(
name|boolean_false_node
argument_list|)
expr_stmt|;
name|flag
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|begin
argument_list|)
expr_stmt|;
name|TARGET_EXPR_CLEANUP
argument_list|(
name|begin
argument_list|)
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|flag
argument_list|,
name|void_zero_node
argument_list|,
name|build_call
argument_list|(
name|abort_fn
argument_list|,
name|guard_addr_list
argument_list|)
argument_list|)
expr_stmt|;
name|CLEANUP_EH_ONLY
argument_list|(
name|begin
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do the initialization itself.  */
name|init
operator|=
name|add_stmt_to_compound
argument_list|(
name|begin
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|add_stmt_to_compound
argument_list|(
name|init
argument_list|,
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|flag
argument_list|,
name|boolean_true_node
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|add_stmt_to_compound
argument_list|(
name|init
argument_list|,
name|build_call
argument_list|(
name|release_fn
argument_list|,
name|guard_addr_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|add_stmt_to_compound
argument_list|(
name|init
argument_list|,
name|set_guard
argument_list|(
name|guard
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use atexit to register a function for destroying this static 	 variable.  */
name|init
operator|=
name|add_stmt_to_compound
argument_list|(
name|init
argument_list|,
name|register_dtor_fn
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_threadsafe_statics
condition|)
block|{
name|finish_compound_stmt
argument_list|(
name|inner_then_clause
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|inner_if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|inner_if_stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|targetm
operator|.
name|relaxed_ordering
operator|||
operator|!
name|flag_threadsafe_statics
condition|)
block|{
name|finish_compound_stmt
argument_list|(
name|then_clause
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|static_aggregates
operator|=
name|tree_cons
argument_list|(
name|init
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 0 if DO_DEFAULT),    3 if the initializer list is empty (in pedantic mode). */
end_comment

begin_function
name|int
name|cp_complete_array_type
parameter_list|(
name|tree
modifier|*
name|ptype
parameter_list|,
name|tree
name|initial_value
parameter_list|,
name|bool
name|do_default
parameter_list|)
block|{
name|int
name|failure
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|elt_type
decl_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* An array of character type can be initialized from a 	 brace-enclosed string constant.  	 FIXME: this code is duplicated from reshape_init. Probably 	 we should just call reshape_init here?  */
if|if
condition|(
name|char_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|ptype
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
condition|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
expr_stmt|;
name|tree
name|value
init|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|)
operator|==
literal|1
condition|)
name|initial_value
operator|=
name|value
expr_stmt|;
block|}
block|}
name|failure
operator|=
name|complete_array_type
argument_list|(
name|ptype
argument_list|,
name|initial_value
argument_list|,
name|do_default
argument_list|)
expr_stmt|;
comment|/* We can create the array before the element type is complete, which      means that we didn't have these two bits set in the original type      either.  In completing the type, we are expected to propagate these      bits.  See also complete_type which does the same thing for arrays      of fixed size.  */
name|type
operator|=
operator|*
name|ptype
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|elt_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
block|}
return|return
name|failure
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return zero if something is declared to be a member of type    CTYPE when in the context of CUR_TYPE.  STRING is the error    message to print in that case.  Otherwise, quietly return 1.  */
end_comment

begin_function
specifier|static
name|int
name|member_function_or_else
parameter_list|(
name|tree
name|ctype
parameter_list|,
name|tree
name|cur_type
parameter_list|,
name|enum
name|overload_flags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|ctype
operator|&&
name|ctype
operator|!=
name|cur_type
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
name|error
argument_list|(
literal|"destructor for alien class %qT cannot be a member"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"constructor for alien class %qT cannot be a member"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `grokdeclarator'.  */
end_comment

begin_comment
comment|/* Generate errors possibly applicable for a given set of specifiers.    This is for ARM $7.1.2.  */
end_comment

begin_function
specifier|static
name|void
name|bad_specifiers
parameter_list|(
name|tree
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|virtualp
parameter_list|,
name|int
name|quals
parameter_list|,
name|int
name|inlinep
parameter_list|,
name|int
name|friendp
parameter_list|,
name|int
name|raises
parameter_list|)
block|{
if|if
condition|(
name|virtualp
condition|)
name|error
argument_list|(
literal|"%qD declared as a %<virtual%> %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|error
argument_list|(
literal|"%qD declared as an %<inline%> %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
name|error
argument_list|(
literal|"%<const%> and %<volatile%> function specifiers on "
literal|"%qD invalid in %s declaration"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|friendp
condition|)
name|error
argument_list|(
literal|"%q+D declared as a friend"
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
operator|!
name|TYPE_PTRFN_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_REFFN_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"%q+D declared with an exception specification"
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a member function or static data member and is presently    being defined.  Check that the definition is taking place in a    valid namespace.  */
end_comment

begin_function
specifier|static
name|void
name|check_class_member_definition_namespace
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* These checks only apply to member functions and static data      members.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
comment|/* We check for problems with specializations in pt.c in      check_specialization_namespace, where we can issue better      diagnostics.  */
if|if
condition|(
name|processing_specialization
condition|)
return|return;
comment|/* There are no restrictions on the placement of      explicit instantiations.  */
if|if
condition|(
name|processing_explicit_instantiation
condition|)
return|return;
comment|/* [class.mfct]       A member function definition that appears outside of the      class definition shall appear in a namespace scope enclosing      the class definition.       [class.static.data]       The definition for a static data member shall appear in a      namespace scope enclosing the member's class definition.  */
if|if
condition|(
operator|!
name|is_ancestor
argument_list|(
name|current_namespace
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"definition of %qD is not in namespace enclosing %qT"
argument_list|,
name|decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a PARM_DECL for the "this" parameter.  TYPE is the    METHOD_TYPE for a non-static member function; QUALS are the    cv-qualifiers that apply to the function.  */
end_comment

begin_function
name|tree
name|build_this_parm
parameter_list|(
name|tree
name|type
parameter_list|,
name|cp_cv_quals
name|quals
parameter_list|)
block|{
name|tree
name|this_type
decl_stmt|;
name|tree
name|qual_type
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|cp_cv_quals
name|this_quals
decl_stmt|;
name|this_type
operator|=
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The `this' parameter is implicitly `const'; it cannot be      assigned to.  */
name|this_quals
operator|=
operator|(
name|quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator||
name|TYPE_QUAL_CONST
expr_stmt|;
name|qual_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|this_type
argument_list|,
name|this_quals
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_artificial_parm
argument_list|(
name|this_identifier
argument_list|,
name|qual_type
argument_list|)
expr_stmt|;
name|cp_apply_type_quals_to_decl
argument_list|(
name|this_quals
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return
name|parm
return|;
block|}
end_function

begin_comment
comment|/* CTYPE is class type, or null if non-class.    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE    or METHOD_TYPE.    DECLARATOR is the function's name.    PARMS is a chain of PARM_DECLs for the function.    VIRTUALP is truthvalue of whether the function is virtual or not.    FLAGS are to be passed through to `grokclassfn'.    QUALS are qualifiers indicating whether the function is `const'    or `volatile'.    RAISES is a list of exceptions that this function can raise.    CHECK is 1 if we must find this method in CTYPE, 0 if we should    not look, and -1 if we should not call `grokclassfn' at all.     SFK is the kind of special function (if any) for the new function.     Returns `NULL_TREE' if something goes wrong, after issuing    applicable error messages.  */
end_comment

begin_function
specifier|static
name|tree
name|grokfndecl
parameter_list|(
name|tree
name|ctype
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|declarator
parameter_list|,
name|tree
name|parms
parameter_list|,
name|tree
name|orig_declarator
parameter_list|,
name|int
name|virtualp
parameter_list|,
name|enum
name|overload_flags
name|flags
parameter_list|,
name|cp_cv_quals
name|quals
parameter_list|,
name|tree
name|raises
parameter_list|,
name|int
name|check
parameter_list|,
name|int
name|friendp
parameter_list|,
name|int
name|publicp
parameter_list|,
name|int
name|inlinep
parameter_list|,
name|special_function_kind
name|sfk
parameter_list|,
name|bool
name|funcdef_flag
parameter_list|,
name|int
name|template_count
parameter_list|,
name|tree
name|in_namespace
parameter_list|,
name|tree
modifier|*
name|attrlist
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|staticp
init|=
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|raises
condition|)
name|type
operator|=
name|build_exception_variant
argument_list|(
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|parm
decl_stmt|;
name|parm
operator|=
name|build_this_parm
argument_list|(
name|type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|parms
expr_stmt|;
name|parms
operator|=
name|parm
expr_stmt|;
block|}
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|parms
expr_stmt|;
comment|/* Propagate volatile out from type to decl.  */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If pointers to member functions use the least significant bit to      indicate whether a function is virtual, ensure a pointer      to this function will have that bit clear.  */
if|if
condition|(
name|TARGET_PTRMEMFUNC_VBIT_LOCATION
operator|==
name|ptrmemfunc_vbit_in_pfn
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|<
literal|2
operator|*
name|BITS_PER_UNIT
condition|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|2
operator|*
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|friendp
operator|&&
name|TREE_CODE
argument_list|(
name|orig_declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
name|funcdef_flag
condition|)
name|error
argument_list|(
literal|"defining explicit specialization %qD in friend declaration"
argument_list|,
name|orig_declarator
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|fns
init|=
name|TREE_OPERAND
argument_list|(
name|orig_declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|orig_declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
block|{
comment|/* Something like `template<class T> friend void f<T>()'.  */
name|error
argument_list|(
literal|"invalid use of template-id %qD in declaration "
literal|"of primary template"
argument_list|,
name|orig_declarator
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* A friend declaration of the form friend void f<>().  Record 	     the information in the TEMPLATE_ID_EXPR.  */
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
comment|/* Due to bison parser ickiness, we will have already looked 		 up an operator_name or PFUNCNAME within the current class 		 (see template_id in parse.y). If the current class contains 		 such a name, we'll get a COMPONENT_REF here. Undo that.  */
name|gcc_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|current_class_type
argument_list|)
expr_stmt|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|fns
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|error
argument_list|(
literal|"default arguments are not allowed in declaration "
literal|"of friend template specialization %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|error
argument_list|(
literal|"%<inline%> is not allowed in declaration of friend "
literal|"template specialization %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|}
comment|/* If this decl has namespace scope, set that up.  */
if|if
condition|(
name|in_namespace
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|in_namespace
argument_list|,
name|friendp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ctype
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* `main' and builtins have implicit 'C' linkage.  */
if|if
condition|(
operator|(
name|MAIN_NAME_P
argument_list|(
name|declarator
argument_list|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
name|ctype
operator|==
name|NULL_TREE
comment|/* NULL_TREE means global namespace.  */
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|decl
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
comment|/* Should probably propagate const out from type to decl I bet (mrs).  */
if|if
condition|(
name|staticp
condition|)
block|{
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
if|if
condition|(
name|ctype
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
name|check_class_member_definition_namespace
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|DECL_MAIN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|error
argument_list|(
literal|"cannot declare %<::main%> to be a template"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|error
argument_list|(
literal|"cannot declare %<::main%> to be inline"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|publicp
condition|)
name|error
argument_list|(
literal|"cannot declare %<::main%> to be static"
argument_list|)
expr_stmt|;
name|inlinep
operator|=
literal|0
expr_stmt|;
name|publicp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Members of anonymous types and local classes have no linkage; make      them internal.  If a typedef is made later, this will be changed.  */
if|if
condition|(
name|ctype
operator|&&
operator|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|ctype
argument_list|)
operator|||
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|)
condition|)
name|publicp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|publicp
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the name of a class 	 or enumeration declared in a local scope) shall not be used to 	 declare an entity with linkage.  	 Only check this for public decls for now.  See core 319, 389.  */
name|t
operator|=
name|no_linkage_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*relaxed_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_EXTERN_C_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Allow this; it's pretty common in C.  */
empty_stmt|;
else|else
block|{
name|pedwarn
argument_list|(
literal|"non-local function %q#D uses anonymous type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%q+#D does not refer to the unqualified "
literal|"type, so it is not used for linkage"
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pedwarn
argument_list|(
literal|"non-local function %q#D uses local type %qT"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|publicp
expr_stmt|;
if|if
condition|(
operator|!
name|publicp
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the declaration was declared inline, mark it as such.  */
if|if
condition|(
name|inlinep
condition|)
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We inline functions that are explicitly declared inline, or, when      the user explicitly asks us to, all functions.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|flag_inline_trees
operator|==
literal|2
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
name|funcdef_flag
operator|)
condition|)
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%smember function %qD cannot have cv-qualifier"
argument_list|,
operator|(
name|ctype
condition|?
literal|"static "
else|:
literal|"non-"
operator|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|grok_op_properties
argument_list|(
name|decl
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|ctype
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
comment|/* Make the init_value nonzero so pushdecl knows this is not        tentative.  error_mark_node is replaced later with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|TYPE_NOTHROW_P
argument_list|(
name|type
argument_list|)
operator|||
name|nothrow_libfn_p
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Caller will do the rest of this.  */
if|if
condition|(
name|check
operator|<
literal|0
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|sfk
operator|==
name|sfk_constructor
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|check_explicit_specialization
argument_list|(
name|orig_declarator
argument_list|,
name|decl
argument_list|,
name|template_count
argument_list|,
literal|2
operator|*
name|funcdef_flag
operator|+
literal|4
operator|*
operator|(
name|friendp
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|attrlist
condition|)
block|{
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
operator|*
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|attrlist
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Check main's type after attributes have been applied.  */
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|DECL_MAIN_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|oldtypeargs
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newtype
decl_stmt|;
name|error
argument_list|(
literal|"%<::main%> must return %<int%>"
argument_list|)
expr_stmt|;
name|newtype
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|oldtypeargs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|newtype
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|ctype
argument_list|)
operator|||
name|check_java_method
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|check
condition|)
block|{
name|tree
name|old_decl
decl_stmt|;
name|old_decl
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
operator|(
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|ctype
argument_list|)
operator|)
condition|?
name|current_template_parms
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
condition|)
block|{
name|tree
name|ok
decl_stmt|;
name|tree
name|pushed_scope
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* Because grokfndecl is always supposed to return a 	       FUNCTION_DECL, we pull out the DECL_TEMPLATE_RESULT 	       here.  We depend on our callers to figure out that its 	       really a template that's being returned.  */
name|old_decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
comment|/* Remove the `this' parm added by grokclassfn. 	       XXX Isn't this done in start_function, too?  */
name|revert_static_member_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|old_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"definition of implicitly-declared %qD"
argument_list|,
name|old_decl
argument_list|)
expr_stmt|;
comment|/* Since we've smashed OLD_DECL to its 	     DECL_TEMPLATE_RESULT, we must do the same to DECL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Attempt to merge the declarations.  This can fail, in 	     the case of some invalid specialization declarations.  */
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|old_decl
argument_list|,
name|friendp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|error
argument_list|(
literal|"no %q#D member function declared in class %qT"
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|old_decl
return|;
block|}
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|grok_ctor_properties
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|||
name|check
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|virtualp
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL for a static data member.  Set flags to reflect    the linkage that DECL will receive in the object file.  */
end_comment

begin_function
specifier|static
name|void
name|set_linkage_for_static_data_member
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* A static data member always has static storage duration and      external linkage.  Note that static data members are forbidden in      local classes -- the only situation in which a class has      non-external linkage.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* For non-template classes, static data members are always put      out in exactly those files where they are defined, just as      with ordinary namespace-scope variables.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a VAR_DECL named NAME with the indicated TYPE.     If SCOPE is non-NULL, it is the class type or namespace containing    the variable.  If SCOPE is NULL, the variable should is created in    the innermost enclosings scope.  */
end_comment

begin_function
specifier|static
name|tree
name|grokvardecl
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|name
parameter_list|,
specifier|const
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|,
name|int
name|initialized
parameter_list|,
name|int
name|constp
parameter_list|,
name|tree
name|scope
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|explicit_scope
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|name
operator|||
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
comment|/* Compute the scope in which to place the variable, but remember      whether or not that scope was explicitly specified by the user.   */
name|explicit_scope
operator|=
name|scope
expr_stmt|;
if|if
condition|(
operator|!
name|scope
condition|)
block|{
comment|/* An explicit "extern" specifier indicates a namespace-scope 	 variable.  */
if|if
condition|(
name|declspecs
operator|->
name|storage_class
operator|==
name|sc_extern
condition|)
name|scope
operator|=
name|current_namespace
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|at_function_scope_p
argument_list|()
condition|)
name|scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|&&
operator|(
comment|/* If the variable is a namespace-scope variable declared in a 	     template, we need DECL_LANG_SPECIFIC.  */
operator|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|processing_template_decl
operator|)
comment|/* Similarly for namespace-scope variables with language linkage 	     other than C++.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|current_lang_name
operator|!=
name|lang_name_cplusplus
operator|)
comment|/* Similarly for static data members.  */
operator|||
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|)
condition|)
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_scope
operator|&&
name|TREE_CODE
argument_list|(
name|explicit_scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|set_decl_namespace
argument_list|(
name|decl
argument_list|,
name|explicit_scope
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|storage_class
operator|==
name|sc_extern
condition|)
block|{
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|set_linkage_for_static_data_member
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* This function is only called with out-of-class definitions.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|check_class_member_definition_namespace
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* At top level, either `static' or no s.c. makes a definition      (perhaps tentative), and absence of `static' makes it public.  */
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|declspecs
operator|->
name|storage_class
operator|!=
name|sc_static
operator|&&
operator|(
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|constp
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
name|declspecs
operator|->
name|storage_class
operator|==
name|sc_static
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_thread
index|]
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_tls
condition|)
name|DECL_TLS_MODEL
argument_list|(
name|decl
argument_list|)
operator|=
name|decl_default_tls_model
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* A mere warning is sure to result in improper semantics 	   at runtime.  Don't bother to allow this to compile.  */
name|error
argument_list|(
literal|"thread-local storage not supported for this target"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the name of a class 	 or enumeration declared in a local scope) shall not be used to 	 declare an entity with linkage.  	 Only check this for public decls for now.  */
name|tree
name|t
init|=
name|no_linkage_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*relaxed_p=*/
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_EXTERN_C_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Allow this; it's pretty common in C.  */
empty_stmt|;
else|else
block|{
comment|/* DRs 132, 319 and 389 seem to indicate types with 		     no linkage can only be used to declare extern "C" 		     entities.  Since it's not always an error in the 		     ISO C++ 90 Standard, we only issue a warning.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"non-local variable %q#D uses anonymous type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q+#D does not refer to the unqualified "
literal|"type, so it is not used for linkage"
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"non-local variable %q#D uses local type %qT"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create and return a canonical pointer to member function type, for    TYPE, which is a POINTER_TYPE to a METHOD_TYPE.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|unqualified_variant
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|type
return|;
comment|/* If a canonical type already exists for this type, use it.  We use      this method instead of type_hash_canon, because it only does a      simple equality check on the list of field members.  */
if|if
condition|(
operator|(
name|t
operator|=
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
comment|/* Make sure that we always have the unqualified pointer-to-member      type first.  */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|unqualified_variant
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|xref_basetypes
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Let the front-end know this is a pointer to member function...  */
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ... and not really an aggregate.  */
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|finish_builtin_struct
argument_list|(
name|t
argument_list|,
literal|"__ptrmemfunc_type"
argument_list|,
name|fields
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* Zap out the name so that the back-end will give us the debugging      information for this anonymous RECORD_TYPE.  */
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If this is not the unqualified form of this pointer-to-member      type, set the TYPE_MAIN_VARIANT for this type to be the      unqualified type.  Since they are actually RECORD_TYPEs that are      not variants of each other, we must do this manually.  */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|t
operator|=
name|build_qualified_type
argument_list|(
name|t
argument_list|,
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|unqualified_variant
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|unqualified_variant
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|unqualified_variant
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* Cache this pointer-to-member type so that we can find it again      later.  */
name|TYPE_SET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create and return a pointer to data member type.  */
end_comment

begin_function
name|tree
name|build_ptrmem_type
parameter_list|(
name|tree
name|class_type
parameter_list|,
name|tree
name|member_type
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|arg_types
decl_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|member_type
argument_list|)
expr_stmt|;
name|class_type
operator|=
operator|(
name|cp_build_qualified_type
argument_list|(
name|class_type
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|member_type
operator|=
name|build_method_type_directly
argument_list|(
name|class_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|member_type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|member_type
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|member_type
argument_list|)
operator|!=
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
return|return
name|build_offset_type
argument_list|(
name|class_type
argument_list|,
name|member_type
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL defined in-class, whose TYPE is also given.    Check to see that the definition is valid.  Issue appropriate error    messages.  Return 1 if the definition is particularly bad, or 0    otherwise.  */
end_comment

begin_function
name|int
name|check_static_variable_definition
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Motion 10 at San Diego: If a static const integral data member is      initialized with an integral constant expression, the initializer      may appear either in the declaration (within the class), or in      the definition, but not both.  If it appears in the class, the      member is a member constant.  The file-scope definition is always      required.  */
if|if
condition|(
operator|!
name|ARITHMETIC_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid in-class initialization of static data member "
literal|"of non-integral type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If we just return the declaration, crashes will sometimes 	 occur.  We therefore return void_type_node, as if this were a 	 friend declaration, to cause callers to completely ignore 	 this declaration.  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"ISO C++ forbids in-class initialization of non-const "
literal|"static member %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids initialization of member constant "
literal|"%qD of non-integral type %qT"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given the SIZE (i.e., number of elements) in an array, compute an    appropriate index type for the array.  If non-NULL, NAME is the    name of the thing being declared.  */
end_comment

begin_function
name|tree
name|compute_array_index_type
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|size
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|itype
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|size
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* The array bound must be an integer type.  */
if|if
condition|(
operator|!
name|dependent_type_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"size of array %qD has non-integral type %qT"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"size of array has non-integral type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
comment|/* We should only handle value dependent expressions specially.  */
condition|?
name|value_dependent_expression_p
argument_list|(
name|size
argument_list|)
comment|/* But for abi-1, we handled all instances in templates. This 	 effects the manglings produced.  */
else|:
name|processing_template_decl
condition|)
return|return
name|build_index_type
argument_list|(
name|build_min
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
return|;
comment|/* The size might be the result of a cast.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* It might be a const variable or enumeration constant.  */
name|size
operator|=
name|integral_constant_value
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Normally, the array-bound will be a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Check to see if the array bound overflowed.  Make that an 	 error, no matter how generous we're being.  */
name|int
name|old_flag_pedantic_errors
init|=
name|flag_pedantic_errors
decl_stmt|;
name|int
name|old_pedantic
init|=
name|pedantic
decl_stmt|;
name|pedantic
operator|=
name|flag_pedantic_errors
operator|=
literal|1
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|pedantic
operator|=
name|old_pedantic
expr_stmt|;
name|flag_pedantic_errors
operator|=
name|old_flag_pedantic_errors
expr_stmt|;
comment|/* An array must have a positive number of elements.  */
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|size
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"size of array %qD is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"size of array is negative"
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
comment|/* As an extension we allow zero-sized arrays.  We always allow 	 them in system headers because glibc uses them.  */
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|size
argument_list|)
operator|&&
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids zero-size array %qD"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C++ forbids zero-size array"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* `(int)&fn' is not a valid array bound.  */
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"size of array %qD is not an integral constant-expression"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"size of array is not an integral constant-expression"
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|warn_vla
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids variable length array %qD"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C++ forbids variable length array"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_vla
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|warning
argument_list|(
name|OPT_Wvla
argument_list|,
literal|"variable length array %qD is used"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wvla
argument_list|,
literal|"variable length array is used"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
comment|/* A variable sized array.  */
name|itype
operator|=
name|build_min
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|saved_processing_template_decl
decl_stmt|;
comment|/* Compute the index of the largest element in the array.  It is 	 one less than the number of elements in the array.  We save 	 and restore PROCESSING_TEMPLATE_DECL so that computations in 	 cp_build_binary_op will be appropriately folded.  */
name|saved_processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|itype
operator|=
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|ssizetype
argument_list|,
name|size
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|ssizetype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|itype
operator|=
name|fold
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|itype
argument_list|)
condition|)
comment|/* A variable sized array.  */
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
comment|/* Make sure that there was no overflow when creating to a signed 	 index type.  (For example, on a 32-bit machine, an array with 	 size 2^32 - 1 is too big.)  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"overflow in array dimension"
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Create and return the appropriate index type.  */
return|return
name|build_index_type
argument_list|(
name|itype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the scope (if any) in which the entity declared by    DECLARATOR will be located.  If the entity was declared with an    unqualified name, NULL_TREE is returned.  */
end_comment

begin_function
name|tree
name|get_scope_of_declarator
parameter_list|(
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|)
block|{
while|while
condition|(
name|declarator
operator|&&
name|declarator
operator|->
name|kind
operator|!=
name|cdk_id
condition|)
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
comment|/* If the declarator-id is a SCOPE_REF, the scope in which the      declaration occurs is the first operand.  */
if|if
condition|(
name|declarator
operator|&&
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
condition|)
return|return
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
return|;
comment|/* Otherwise, the declarator is not a qualified name; the entity will      be declared in the current scope.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns an ARRAY_TYPE for an array with SIZE elements of the    indicated TYPE.  If non-NULL, NAME is the NAME of the declaration    with this type.  */
end_comment

begin_function
specifier|static
name|tree
name|create_array_type_for_decl
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|size
parameter_list|)
block|{
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_msg
decl_stmt|;
comment|/* If things have already gone awry, bail now.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|size
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Assume that everything will go OK.  */
name|error_msg
operator|=
name|NULL
expr_stmt|;
comment|/* There are some types which cannot be array elements.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
name|error_msg
operator|=
literal|"array of void"
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|error_msg
operator|=
literal|"array of functions"
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|error_msg
operator|=
literal|"array of references"
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|error_msg
operator|=
literal|"array of function members"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If something went wrong, issue an error-message and return.  */
if|if
condition|(
name|error_msg
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"declaration of %qD as %s"
argument_list|,
name|name
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"creating %s"
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [dcl.array]       The constant expressions that specify the bounds of the arrays      can be omitted only for the first member of the sequence.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"declaration of %qD as multidimensional array must "
literal|"have bounds for all dimensions except the first"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"multidimensional array must have bounds for all "
literal|"dimensions except the first"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Figure out the index type for the array.  */
if|if
condition|(
name|size
condition|)
name|itype
operator|=
name|compute_array_index_type
argument_list|(
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* [dcl.array]      T is called the array element type; this type shall not be [...] an      abstract class type.  */
name|abstract_virtuals_error
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check that it's OK to declare a function with the indicated TYPE.    SFK indicates the kind of special function (if any) that this    function is.  OPTYPE is the type given in a conversion operator    declaration, or the class type for a constructor/destructor.    Returns the actual return type of the function; that    may be different than TYPE if an error occurs, or for certain    special functions.  */
end_comment

begin_function
specifier|static
name|tree
name|check_special_function_return_type
parameter_list|(
name|special_function_kind
name|sfk
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|optype
parameter_list|)
block|{
switch|switch
condition|(
name|sfk
condition|)
block|{
case|case
name|sfk_constructor
case|:
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"return type specification for constructor invalid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|optype
argument_list|)
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|optype
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|sfk_destructor
case|:
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"return type specification for destructor invalid"
argument_list|)
expr_stmt|;
comment|/* We can't use the proper return type here because we run into 	 problems with ambiguous bases and covariant returns. 	 Java classes are left unchanged because (void *) isn't a valid 	 Java type, and we don't want to change the Java ABI.  */
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|optype
argument_list|)
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|sfk_conversion
case|:
if|if
condition|(
name|type
operator|&&
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|optype
argument_list|)
condition|)
name|error
argument_list|(
literal|"operator %qT declared to return %qT"
argument_list|,
name|optype
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
condition|)
name|pedwarn
argument_list|(
literal|"return type specified for %<operator %T%>"
argument_list|,
name|optype
argument_list|)
expr_stmt|;
name|type
operator|=
name|optype
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* A variable or data member (whose unqualified name is IDENTIFIER)    has been declared with the indicated TYPE.  If the TYPE is not    acceptable, issue an error message and return a type to use for    error-recovery purposes.  */
end_comment

begin_function
name|tree
name|check_var_type
parameter_list|(
name|tree
name|identifier
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|identifier
condition|)
name|error
argument_list|(
literal|"unnamed variable or field declared void"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|identifier
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|IDENTIFIER_OPNAME_P
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"variable or field %qE declared void"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"variable or field declared void"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given declspecs and a declarator (abstract or otherwise), determine    the name and type of the object declared and construct a DECL node    for it.     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      MEMFUNCDEF for a function definition.  Like FUNCDEF but prepares to       handle member functions (which have FIELD context).       Return value may be zero meaning this definition is too screwy to       try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      CATCHPARM for a parameter declaration before a catch clause.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.      BITFIELD for a field with specified width.    INITIALIZED is 1 if the decl has an initializer.     ATTRLIST is a pointer to the list of attributes, which may be NULL    if there are none; *ATTRLIST may be modified if attributes from inside    the declarator should be applied to the declaration.     When this function is called, scoping variables (such as    CURRENT_CLASS_TYPE) should reflect the scope in which the    declaration occurs, not the scope in which the new declaration will    be placed.  For example, on:       void S::f() { ... }     when grokdeclarator is called for `S::f', the CURRENT_CLASS_TYPE    should not be `S'.     Returns a DECL (if a declarator is present), a TYPE (if there is no    declarator, in cases like "struct S;"), or the ERROR_MARK_NODE if an    error occurs. */
end_comment

begin_function
name|tree
name|grokdeclarator
parameter_list|(
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
specifier|const
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|,
name|enum
name|decl_context
name|decl_context
parameter_list|,
name|int
name|initialized
parameter_list|,
name|tree
modifier|*
name|attrlist
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|explicitp
decl_stmt|,
name|friendp
decl_stmt|,
name|inlinep
decl_stmt|,
name|staticp
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|int
name|defaulted_int
init|=
literal|0
decl_stmt|;
name|tree
name|dependent_name
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|typedef_decl
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|tree
name|typedef_type
init|=
name|NULL_TREE
decl_stmt|;
comment|/* True if this declarator is a function definition.  */
name|bool
name|funcdef_flag
init|=
name|false
decl_stmt|;
name|cp_declarator_kind
name|innermost_code
init|=
name|cdk_error
decl_stmt|;
name|int
name|bitfield
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
comment|/* See the code below that used this.  */
block|tree decl_attr = NULL_TREE;
endif|#
directive|endif
comment|/* Keep track of what sort of function is being processed      so that we can warn about default return values, or explicit      return values which do not match prescribed defaults.  */
name|special_function_kind
name|sfk
init|=
name|sfk_none
decl_stmt|;
name|tree
name|dname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctor_return_type
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|overload_flags
name|flags
init|=
name|NO_SPECIAL
decl_stmt|;
comment|/* cv-qualifiers that apply to the declarator, for a declaration of      a member function.  */
name|cp_cv_quals
name|memfn_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
comment|/* cv-qualifiers that apply to the type specified by the DECLSPECS.  */
name|int
name|type_quals
decl_stmt|;
name|tree
name|raises
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_count
init|=
literal|0
decl_stmt|;
name|tree
name|returned_attrs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parms
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|cp_declarator
modifier|*
name|id_declarator
decl_stmt|;
comment|/* The unqualified name of the declarator; either an      IDENTIFIER_NODE, BIT_NOT_EXPR, or TEMPLATE_ID_EXPR.  */
name|tree
name|unqualified_id
decl_stmt|;
comment|/* The class type, if any, in which this entity is located,      or NULL_TREE if none.  Note that this value may be different from      the current class type; for example if an attempt is made to declare      "A::f" inside "B", this value will be "A".  */
name|tree
name|ctype
init|=
name|current_class_type
decl_stmt|;
comment|/* The NAMESPACE_DECL for the namespace in which this entity is      located.  If an unqualified name is used to declare the entity,      this value will be NULL_TREE, even if the entity is located at      namespace scope.  */
name|tree
name|in_namespace
init|=
name|NULL_TREE
decl_stmt|;
name|cp_storage_class
name|storage_class
decl_stmt|;
name|bool
name|unsigned_p
decl_stmt|,
name|signed_p
decl_stmt|,
name|short_p
decl_stmt|,
name|long_p
decl_stmt|,
name|thread_p
decl_stmt|;
name|bool
name|type_was_error_mark_node
init|=
name|false
decl_stmt|;
name|signed_p
operator|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_signed
index|]
expr_stmt|;
name|unsigned_p
operator|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_unsigned
index|]
expr_stmt|;
name|short_p
operator|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_short
index|]
expr_stmt|;
name|long_p
operator|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_long
index|]
expr_stmt|;
name|longlong
operator|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_long
index|]
operator|>=
literal|2
expr_stmt|;
name|thread_p
operator|=
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_thread
index|]
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
name|true
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|MEMFUNCDEF
condition|)
name|funcdef_flag
operator|=
name|true
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|BITFIELD
condition|)
name|bitfield
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
for|for
control|(
name|id_declarator
operator|=
name|declarator
init|;
name|id_declarator
condition|;
name|id_declarator
operator|=
name|id_declarator
operator|->
name|declarator
control|)
block|{
if|if
condition|(
name|id_declarator
operator|->
name|kind
operator|!=
name|cdk_id
condition|)
name|innermost_code
operator|=
name|id_declarator
operator|->
name|kind
expr_stmt|;
switch|switch
condition|(
name|id_declarator
operator|->
name|kind
condition|)
block|{
case|case
name|cdk_function
case|:
if|if
condition|(
name|id_declarator
operator|->
name|declarator
operator|&&
name|id_declarator
operator|->
name|declarator
operator|->
name|kind
operator|==
name|cdk_id
condition|)
block|{
name|sfk
operator|=
name|id_declarator
operator|->
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|sfk
expr_stmt|;
if|if
condition|(
name|sfk
operator|==
name|sfk_destructor
condition|)
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
block|}
break|break;
case|case
name|cdk_id
case|:
block|{
name|tree
name|qualifying_scope
init|=
name|id_declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
decl_stmt|;
name|tree
name|decl
init|=
name|id_declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
break|break;
if|if
condition|(
name|qualifying_scope
condition|)
block|{
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
block|{
comment|/* [dcl.meaning]   		       A declarator-id shall not be qualified except 		       for ...   		       None of the cases are permitted in block 		       scope.  */
if|if
condition|(
name|qualifying_scope
operator|==
name|global_namespace
condition|)
name|error
argument_list|(
literal|"invalid use of qualified-name %<::%D%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|qualifying_scope
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of qualified-name %<%T::%D%>"
argument_list|,
name|qualifying_scope
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid use of qualified-name %<%D::%D%>"
argument_list|,
name|qualifying_scope
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|qualifying_scope
argument_list|)
condition|)
block|{
name|ctype
operator|=
name|qualifying_scope
expr_stmt|;
if|if
condition|(
name|innermost_code
operator|!=
name|cdk_function
operator|&&
name|current_class_type
operator|&&
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type %qT is not derived from type %qT"
argument_list|,
name|ctype
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|qualifying_scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|in_namespace
operator|=
name|qualifying_scope
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|BIT_NOT_EXPR
case|:
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|innermost_code
operator|!=
name|cdk_function
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qD as non-function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|qualifying_scope
operator|&&
operator|!
operator|(
name|current_class_type
operator|&&
name|at_class_scope_p
argument_list|()
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qD as non-member"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|dname
operator|=
name|decl
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|fns
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dname
operator|=
name|fns
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|gcc_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|dname
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declarator-id missing; using reserved word %qD"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|dname
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TYPENAME_FLAG
expr_stmt|;
name|ctor_return_type
operator|=
name|TREE_TYPE
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|sfk
operator|=
name|sfk_conversion
expr_stmt|;
if|if
condition|(
name|is_typename_at_global_scope
argument_list|(
name|dname
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|"<invalid operator>"
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|cdk_array
case|:
case|case
name|cdk_pointer
case|:
case|case
name|cdk_reference
case|:
case|case
name|cdk_ptrmem
case|:
break|break;
case|case
name|cdk_error
case|:
return|return
name|error_mark_node
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|id_declarator
operator|->
name|kind
operator|==
name|cdk_id
condition|)
break|break;
block|}
comment|/* [dcl.fct.edf]       The declarator in a function-definition shall have the form      D1 ( parameter-declaration-clause) ...  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|cdk_function
condition|)
block|{
name|error
argument_list|(
literal|"function definition does not declare parameters"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|dname
operator|&&
name|IDENTIFIER_OPNAME_P
argument_list|(
name|dname
argument_list|)
operator|)
operator|||
name|flags
operator|==
name|TYPENAME_FLAG
operator|)
operator|&&
name|innermost_code
operator|!=
name|cdk_function
operator|&&
operator|!
operator|(
name|ctype
operator|&&
operator|!
name|declspecs
operator|->
name|any_specifiers_p
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qD as non-function"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* This heuristic cannot be applied to C++ nodes! Fixed, however,      by not allowing C++ class definitions to specify their parameters      with xdecls (must be spec.d in the parmlist).       Since we now wait to push a class scope until we are sure that      we are in a legitimate method context, we must set oldcname      explicitly (since current_class_name is not yet alive).       We also want to avoid calling this a PARM if it is in a namespace.  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
literal|0
operator|&&
name|toplevel_bindings_p
argument_list|()
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|decl_context
operator|==
name|PARM
condition|?
literal|"parameter"
else|:
literal|"type name"
expr_stmt|;
comment|/* If there were multiple types specified in the decl-specifier-seq,      issue an error message.  */
if|if
condition|(
name|declspecs
operator|->
name|multiple_types_p
condition|)
block|{
name|error
argument_list|(
literal|"two or more data types in declaration of %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Extract the basic type from the decl-specifier-seq.  */
name|type
operator|=
name|declspecs
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|type
operator|=
name|NULL_TREE
expr_stmt|;
name|type_was_error_mark_node
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the entire declaration is itself tagged as deprecated then      suppress reports of deprecated items.  */
if|if
condition|(
name|type
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|type
argument_list|)
operator|&&
name|deprecated_state
operator|!=
name|DEPRECATED_SUPPRESS
condition|)
name|warn_deprecated_use
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|typedef_decl
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|typedef_decl
argument_list|)
expr_stmt|;
block|}
comment|/* No type at all: default to `int', and set DEFAULTED_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|&&
operator|(
name|signed_p
operator|||
name|unsigned_p
operator|||
name|long_p
operator|||
name|short_p
operator|)
condition|)
block|{
comment|/* These imply 'int'.  */
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|defaulted_int
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Gather flags.  */
name|explicit_int
operator|=
name|declspecs
operator|->
name|explicit_int_p
expr_stmt|;
name|explicit_char
operator|=
name|declspecs
operator|->
name|explicit_char_p
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See the code below that used this.  */
block|if (typedef_decl)     decl_attr = DECL_ATTRIBUTES (typedef_decl);
endif|#
directive|endif
name|typedef_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|sfk
operator|!=
name|sfk_conversion
condition|)
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|sfk
operator|!=
name|sfk_none
condition|)
name|type
operator|=
name|check_special_function_return_type
argument_list|(
name|sfk
argument_list|,
name|type
argument_list|,
name|ctor_return_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|is_main
decl_stmt|;
name|explicit_int
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We handle `main' specially here, because 'main () { }' is so 	 common.  With no options, it is allowed.  With -Wreturn-type, 	 it is a warning.  It is only an error with -pedantic-errors.  */
name|is_main
operator|=
operator|(
name|funcdef_flag
operator|&&
name|dname
operator|&&
name|MAIN_NAME_P
argument_list|(
name|dname
argument_list|)
operator|&&
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|in_namespace
operator|==
name|NULL_TREE
operator|&&
name|current_namespace
operator|==
name|global_namespace
operator|)
expr_stmt|;
if|if
condition|(
name|type_was_error_mark_node
condition|)
comment|/* We've already issued an error, don't complain more.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|in_system_header
operator|||
name|flag_ms_extensions
condition|)
comment|/* Allow it, sigh.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|||
operator|!
name|is_main
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids declaration of %qs with no type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_return_type
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ISO C++ forbids declaration of %qs with no type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
name|long_p
operator|&&
operator|!
name|longlong
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|long_p
operator|=
name|false
expr_stmt|;
name|type
operator|=
name|build_qualified_type
argument_list|(
name|long_double_type_node
argument_list|,
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|unsigned_p
operator|||
name|signed_p
operator|||
name|long_p
operator|||
name|short_p
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|signed_p
operator|||
name|unsigned_p
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"%<signed%> or %<unsigned%> invalid for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|signed_p
operator|&&
name|unsigned_p
condition|)
name|error
argument_list|(
literal|"%<signed%> and %<unsigned%> specified together for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"%<long long%> invalid for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|long_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"%<long%> invalid for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|short_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"%<short%> invalid for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|long_p
operator|||
name|short_p
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"%<long%> or %<short%> invalid for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|long_p
operator|||
name|short_p
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"%<long%> or %<short%> specified with char for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|long_p
operator|&&
name|short_p
condition|)
name|error
argument_list|(
literal|"%<long%> and %<short%> specified together for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|defaulted_int
operator|&&
operator|!
name|explicit_char
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"long, short, signed or unsigned used invalidly for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|unsigned_p
operator|=
name|false
expr_stmt|;
name|signed_p
operator|=
name|false
expr_stmt|;
name|long_p
operator|=
name|false
expr_stmt|;
name|short_p
operator|=
name|false
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bitfields as signed by default.  */
if|if
condition|(
name|unsigned_p
comment|/* [class.bit]  	 It is implementation-defined whether a plain (neither 	 explicitly signed or unsigned) char, short, int, or long 	 bit-field is signed or unsigned.  	 Naturally, we extend this to long long as well.  Note that 	 this does not include wchar_t.  */
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|!
name|signed_p
comment|/* A typedef for plain `int' without `signed' can be 	     controlled just like plain `int', but a typedef for 	     `signed int' cannot be so controlled.  */
operator|&&
operator|!
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|wchar_type_node
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|long_p
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|short_p
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|signed_p
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|long_p
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|short_p
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_complex
index|]
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"complex invalid for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If we just have "complex", it is equivalent to 	 "complex double", but if any modifiers at all are specified it is 	 the complex form of TYPE.  E.g, "complex short" is 	 "complex short int".  */
elseif|else
if|if
condition|(
name|defaulted_int
operator|&&
operator|!
name|longlong
operator|&&
operator|!
operator|(
name|long_p
operator|||
name|short_p
operator|||
name|signed_p
operator|||
name|unsigned_p
operator|)
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
name|type
operator|=
name|complex_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|complex_float_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|type
operator|=
name|complex_long_double_type_node
expr_stmt|;
else|else
name|type
operator|=
name|build_complex_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_const
index|]
condition|)
name|type_quals
operator||=
name|TYPE_QUAL_CONST
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_volatile
index|]
condition|)
name|type_quals
operator||=
name|TYPE_QUAL_VOLATILE
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_restrict
index|]
condition|)
name|type_quals
operator||=
name|TYPE_QUAL_RESTRICT
expr_stmt|;
if|if
condition|(
name|sfk
operator|==
name|sfk_conversion
operator|&&
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|error
argument_list|(
literal|"qualifiers are not allowed on declaration of %<operator %T%>"
argument_list|,
name|ctor_return_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
comment|/* This was an error in C++98 (cv-qualifiers cannot be added to 	 a function type), but DR 295 makes the code well-formed by 	 dropping the extra qualifiers. */
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|bad_type
init|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
decl_stmt|;
name|pedwarn
argument_list|(
literal|"ignoring %qV qualifiers added to function type %qT"
argument_list|,
name|bad_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
name|type_quals
operator||=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|,
operator|(
operator|(
name|typedef_decl
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|typedef_decl
argument_list|)
condition|?
name|tf_ignore_bad_quals
else|:
literal|0
operator|)
operator||
name|tf_warning_or_error
operator|)
argument_list|)
expr_stmt|;
comment|/* We might have ignored or rejected some of the qualifiers.  */
name|type_quals
operator|=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_inline
index|]
expr_stmt|;
name|virtualp
operator|=
operator|!
operator|!
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_virtual
index|]
expr_stmt|;
name|explicitp
operator|=
operator|!
operator|!
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_explicit
index|]
expr_stmt|;
name|storage_class
operator|=
name|declspecs
operator|->
name|storage_class
expr_stmt|;
if|if
condition|(
name|storage_class
operator|==
name|sc_static
condition|)
name|staticp
operator|=
literal|1
operator|+
operator|(
name|decl_context
operator|==
name|FIELD
operator|)
expr_stmt|;
if|if
condition|(
name|virtualp
operator|&&
name|staticp
operator|==
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"member %qD cannot be declared both virtual and static"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
name|friendp
operator|=
operator|!
operator|!
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_friend
index|]
expr_stmt|;
if|if
condition|(
name|dependent_name
operator|&&
operator|!
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"%<%T::%D%> is not a valid declarator"
argument_list|,
name|ctype
argument_list|,
name|dependent_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Issue errors about use of storage classes for parameters.  */
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
condition|)
block|{
name|error
argument_list|(
literal|"typedef declaration invalid in parameter declaration"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|sc_static
operator|||
name|storage_class
operator|==
name|sc_extern
operator|||
name|thread_p
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in parameter declarations"
argument_list|)
expr_stmt|;
block|}
comment|/* Give error if `virtual' is used outside of class declaration.  */
if|if
condition|(
name|virtualp
operator|&&
operator|(
name|current_class_name
operator|==
name|NULL_TREE
operator|||
name|decl_context
operator|!=
name|FIELD
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"virtual outside class declaration"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Static anonymous unions are dealt with here.  */
if|if
condition|(
name|staticp
operator|&&
name|decl_context
operator|==
name|TYPENAME
operator|&&
name|declspecs
operator|->
name|type
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|declspecs
operator|->
name|type
argument_list|)
condition|)
name|decl_context
operator|=
name|FIELD
expr_stmt|;
comment|/* Warn about storage classes that are invalid for certain      kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|thread_p
operator|&&
operator|(
operator|(
name|storage_class
operator|&&
name|storage_class
operator|!=
name|sc_extern
operator|&&
name|storage_class
operator|!=
name|sc_static
operator|)
operator|||
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"multiple storage classes in declaration of %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|thread_p
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|declspecs
operator|->
name|conflicting_specifiers_p
condition|)
block|{
name|error
argument_list|(
literal|"conflicting specifiers in declaration of %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
operator|(
operator|(
name|storage_class
operator|!=
name|sc_none
operator|&&
name|storage_class
operator|!=
name|sc_mutable
operator|)
operator|||
name|thread_p
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
operator|)
operator|&&
operator|(
name|storage_class
operator|==
name|sc_register
operator|||
name|storage_class
operator|==
name|sc_auto
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
comment|/* C++ allows static class elements.  */
operator|&&
name|storage_class
operator|==
name|sc_static
condition|)
comment|/* C++ also allows inlines and signed and unsigned elements, 	   but in those cases we don't come in here.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|error
argument_list|(
literal|"storage class specified for %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
condition|)
name|error
argument_list|(
literal|"storage class specified for parameter %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"storage class specified for typename"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage_class
operator|==
name|sc_register
operator|||
name|storage_class
operator|==
name|sc_auto
operator|||
name|storage_class
operator|==
name|sc_extern
operator|||
name|thread_p
condition|)
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|sc_extern
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
comment|/* It's common practice (and completely valid) to have a const 	     be initialized and declared extern.  */
if|if
condition|(
operator|!
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qs initialized and declared %<extern%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"%qs has both %<extern%> and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|sc_extern
operator|&&
name|funcdef_flag
operator|&&
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"nested function %qs declared %<extern%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|storage_class
operator|==
name|sc_auto
condition|)
name|error
argument_list|(
literal|"top-level declaration of %qs specifies %<auto%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|thread_p
operator|&&
name|storage_class
operator|!=
name|sc_extern
operator|&&
name|storage_class
operator|!=
name|sc_static
condition|)
block|{
name|error
argument_list|(
literal|"function-scope %qs implicitly auto and declared %<__thread%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|thread_p
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|storage_class
operator|&&
name|friendp
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in friend function declarations"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id_declarator
condition|)
name|unqualified_id
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|unqualified_id
operator|=
name|id_declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|unqualified_id
argument_list|)
condition|)
block|{
case|case
name|BIT_NOT_EXPR
case|:
name|unqualified_id
operator|=
name|constructor_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|unqualified_id
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|TEMPLATE_ID_EXPR
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Determine the type of the entity declared by recurring on the      declarator.  */
for|for
control|(
init|;
name|declarator
condition|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
control|)
block|{
specifier|const
name|cp_declarator
modifier|*
name|inner_declarator
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|attrs
operator|=
name|declarator
operator|->
name|attributes
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
block|{
name|int
name|attr_flags
decl_stmt|;
name|attr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL
operator|||
name|declarator
operator|->
name|kind
operator|==
name|cdk_id
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
expr_stmt|;
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_function
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
expr_stmt|;
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_array
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
expr_stmt|;
name|returned_attrs
operator|=
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|chainon
argument_list|(
name|returned_attrs
argument_list|,
name|attrs
argument_list|)
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_id
condition|)
break|break;
name|inner_declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
switch|switch
condition|(
name|declarator
operator|->
name|kind
condition|)
block|{
case|case
name|cdk_array
case|:
name|type
operator|=
name|create_array_type_for_decl
argument_list|(
name|dname
argument_list|,
name|type
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|bounds
argument_list|)
expr_stmt|;
break|break;
case|case
name|cdk_function
case|:
block|{
name|tree
name|arg_types
decl_stmt|;
name|int
name|funcdecl_p
decl_stmt|;
comment|/* Declaring a function type. 	       Make sure we have a valid type for the function to return.  */
comment|/* We now know that the TYPE_QUALS don't apply to the 	       decl, but to its return type.  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%qs declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%qs declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Pick up type qualifiers which should be applied to `this'.  */
name|memfn_quals
operator|=
name|declarator
operator|->
name|u
operator|.
name|function
operator|.
name|qualifiers
expr_stmt|;
comment|/* Pick up the exception specifications.  */
name|raises
operator|=
name|declarator
operator|->
name|u
operator|.
name|function
operator|.
name|exception_specification
expr_stmt|;
comment|/* Say it's a definition only for the CALL_EXPR 	       closest to the identifier.  */
name|funcdecl_p
operator|=
name|inner_declarator
operator|&&
name|inner_declarator
operator|->
name|kind
operator|==
name|cdk_id
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
name|funcdecl_p
operator|&&
operator|(
name|friendp
operator|==
literal|0
operator|||
name|dname
operator|==
name|current_class_name
operator|)
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
operator|(
name|sfk
operator|==
name|sfk_constructor
operator|||
name|sfk
operator|==
name|sfk_destructor
operator|)
condition|)
block|{
comment|/* We are within a class's scope. If our declarator name 		   is the same as the class name, and we are defining 		   a function, then it is a constructor/destructor, and 		   therefore returns a void type.  */
comment|/* ISO C++ 12.4/2.  A destructor may not be declared 		   const or volatile.  A destructor may not be 		   static.  		   ISO C++ 12.1.  A constructor may not be declared 		   const or volatile.  A constructor may not be 		   virtual.  A constructor may not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
operator|(
name|flags
operator|==
name|DTOR_FLAG
operator|)
condition|?
literal|"destructor cannot be static member function"
else|:
literal|"constructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memfn_quals
condition|)
block|{
name|error
argument_list|(
operator|(
name|flags
operator|==
name|DTOR_FLAG
operator|)
condition|?
literal|"destructors may not be cv-qualified"
else|:
literal|"constructors may not be cv-qualified"
argument_list|)
expr_stmt|;
name|memfn_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|flags
operator|!=
name|DTOR_FLAG
condition|)
block|{
comment|/* It's a constructor.  */
if|if
condition|(
name|explicitp
operator|==
literal|1
condition|)
name|explicitp
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
name|pedwarn
argument_list|(
literal|"constructors cannot be declared virtual"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|sfk
operator|!=
name|sfk_constructor
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|initialized
condition|)
name|error
argument_list|(
literal|"can't initialize friend function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
comment|/* Cannot be both friend and virtual.  */
name|error
argument_list|(
literal|"virtual functions cannot be friends"
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
condition|)
name|error
argument_list|(
literal|"friend declaration not in class definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|funcdef_flag
condition|)
name|error
argument_list|(
literal|"can't define friend function %qs in a local "
literal|"class definition"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|arg_types
operator|=
name|grokparms
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|function
operator|.
name|parameters
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_declarator
operator|&&
name|inner_declarator
operator|->
name|kind
operator|==
name|cdk_id
operator|&&
name|inner_declarator
operator|->
name|u
operator|.
name|id
operator|.
name|sfk
operator|==
name|sfk_destructor
operator|&&
name|arg_types
operator|!=
name|void_list_node
condition|)
block|{
name|error
argument_list|(
literal|"destructors may not have parameters"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
name|parms
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|cdk_pointer
case|:
case|case
name|cdk_reference
case|:
case|case
name|cdk_ptrmem
case|:
comment|/* Filter out pointers-to-references and references-to-references. 	     We can get these if a TYPE_DECL is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_reference
condition|?
literal|"cannot declare reference to %q#T"
else|:
literal|"cannot declare pointer to %q#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_reference
condition|)
name|error
argument_list|(
literal|"cannot declare reference to %q#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_ptrmem
condition|)
name|error
argument_list|(
literal|"cannot declare pointer to %q#T member"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* We now know that the TYPE_QUALS don't apply to the decl, 	     but to the target of the pointer.  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_ptrmem
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|memfn_quals
operator|)
condition|)
block|{
name|memfn_quals
operator||=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_memfn_type
argument_list|(
name|type
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|class_type
argument_list|,
name|memfn_quals
argument_list|)
expr_stmt|;
name|memfn_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_reference
condition|)
block|{
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_ptrmem
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|class_type
argument_list|)
operator|!=
name|NAMESPACE_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|class_type
operator|==
name|error_mark_node
condition|)
comment|/* We will already have complained.  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|type
operator|=
name|build_ptrmem_type
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|class_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords (such as 	     const or volatile) that were given inside the `*' or `&'.  */
if|if
condition|(
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|qualifiers
condition|)
block|{
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|qualifiers
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|cdk_error
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unqualified_id
operator|&&
name|TREE_CODE
argument_list|(
name|unqualified_id
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"template-id %qD used as a declarator"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
name|unqualified_id
operator|=
name|dname
expr_stmt|;
block|}
comment|/* If TYPE is a FUNCTION_TYPE, but the function name was explicitly      qualified with a class-name, turn it into a METHOD_TYPE, unless      we know that the function is static.  We take advantage of this      opportunity to do other processing that pertains to entities      explicitly declared to be class members.  Note that if DECLARATOR      is non-NULL, we know it is a cdk_id declarator; otherwise, we      would not have exited the loop above.  */
if|if
condition|(
name|declarator
operator|&&
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
operator|&&
name|TYPE_P
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|ctype
operator|=
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
expr_stmt|;
name|ctype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|t
operator|=
name|ctype
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* You're supposed to have one `template<...>' for every 	     template class, but you don't need one for a full 	     specialization.  For example:  	       template<class T> struct S{}; 	       template<> struct S<int> { void f(); }; 	       void S<int>::f () {}  	     is correct; there shouldn't be a `template<>' for the 	     definition of `S<int>::f'.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|any_dependent_template_arguments_p
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
comment|/* T is an explicit (not partial) specialization.  All 	       containing classes must therefore also be explicitly 	       specialized.  */
break|break;
if|if
condition|(
operator|(
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
operator|||
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|template_count
operator|+=
literal|1
expr_stmt|;
name|t
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
block|{
if|if
condition|(
name|friendp
condition|)
name|pedwarn
argument_list|(
literal|"member functions are implicitly friends of their class"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"extra qualification %<%T::%> on member %qs"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
comment|/* If the qualifying type is already complete, then we 		  can skip the following checks.  */
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|(
comment|/* If the function is being defined, then 		      qualifying type must certainly be complete.  */
name|funcdef_flag
comment|/* A friend declaration of "T::f" is OK, even if 		      "T" is a template parameter.  But, if this 		      function is not a friend, the qualifying type 		      must be a class.  */
operator|||
operator|(
operator|!
name|friendp
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|ctype
argument_list|)
operator|)
comment|/* For a declaration, the type need not be 		      complete, if either it is dependent (since there 		      is no meaningful definition of complete in that 		      case) or the qualifying class is currently being 		      defined.  */
operator|||
operator|!
operator|(
name|dependent_type_p
argument_list|(
name|ctype
argument_list|)
operator|||
name|currently_open_class
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
comment|/* Check that the qualifying type is complete.  */
operator|&&
operator|!
name|complete_type_or_else
argument_list|(
name|ctype
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|sname
init|=
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
operator|(
operator|!
name|friendp
operator|||
name|funcdef_flag
operator|)
condition|)
block|{
name|error
argument_list|(
name|funcdef_flag
condition|?
literal|"cannot define member function %<%T::%s%> within %<%T%>"
else|:
literal|"cannot declare member function %<%T::%s%> within %<%T%>"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|NEW_DELETE_OPNAME_P
argument_list|(
name|sname
argument_list|)
condition|)
comment|/* Overloaded operator new and operator delete 	       are always static functions.  */
empty_stmt|;
else|else
name|type
operator|=
name|build_memfn_type
argument_list|(
name|type
argument_list|,
name|ctype
argument_list|,
name|memfn_quals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
operator|&&
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare member %<%T::%s%> within %qT"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Now TYPE has the actual type.  */
if|if
condition|(
name|returned_attrs
condition|)
block|{
if|if
condition|(
name|attrlist
condition|)
operator|*
name|attrlist
operator|=
name|chainon
argument_list|(
name|returned_attrs
argument_list|,
operator|*
name|attrlist
argument_list|)
expr_stmt|;
else|else
name|attrlist
operator|=
operator|&
name|returned_attrs
expr_stmt|;
block|}
comment|/* Did array size calculations overflow?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array %qs is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If we proceed with the array type as it is, we'll eventually 	 crash in tree_low_cst().  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|decl_context
operator|==
name|FIELD
operator|||
name|decl_context
operator|==
name|PARM
operator|)
operator|&&
operator|!
name|processing_template_decl
operator|&&
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|error
argument_list|(
literal|"data member may not have variably modified type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter may not have variably modified type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|explicitp
operator|==
literal|1
operator|||
operator|(
name|explicitp
operator|&&
name|friendp
operator|)
condition|)
block|{
comment|/* [dcl.fct.spec] The explicit specifier shall only be used in 	 declarations of constructors within a class definition.  */
name|error
argument_list|(
literal|"only declarations of constructors can be %<explicit%>"
argument_list|)
expr_stmt|;
name|explicitp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|storage_class
operator|==
name|sc_mutable
condition|)
block|{
if|if
condition|(
name|decl_context
operator|!=
name|FIELD
operator|||
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"non-member %qs cannot be declared %<mutable%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
operator|||
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
condition|)
block|{
name|error
argument_list|(
literal|"non-object member %qs cannot be declared %<mutable%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function %qs cannot be declared %<mutable%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|staticp
condition|)
block|{
name|error
argument_list|(
literal|"static %qs cannot be declared %<mutable%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
condition|)
block|{
name|error
argument_list|(
literal|"const %qs cannot be declared %<mutable%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
block|}
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
operator|&&
name|decl_context
operator|!=
name|TYPENAME
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This declaration:  	   typedef void f(int) const;  	 declares a function type which is not a member of any 	 particular class, but which is cv-qualified; for 	 example "f S::*" declares a pointer to a const-qualified 	 member function of S.  We record the cv-qualification in the 	 function type.  */
if|if
condition|(
name|memfn_quals
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|memfn_quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|unqualified_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|unqualified_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_declarator
operator|&&
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
condition|)
name|error
argument_list|(
literal|"%Jtypedef name may not be a nested-name-specifier"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|!=
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|current_function_decl
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
operator|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
comment|/* The TYPE_DECL is "abstract" because there will be 	       clones of this constructor/destructor, and there will 	       be copies of this TYPE_DECL generated in those 	       clones.  */
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constructor_name_p
argument_list|(
name|unqualified_id
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids nested type %qD with same name "
literal|"as enclosing class"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
comment|/* If the user declares "typedef struct {...} foo" then the 	 struct will have an anonymous name.  Fill that name in now. 	 Nothing can refer to it, so nothing needs know about the name 	 change.  */
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|unqualified_id
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_ANONYMOUS_P
argument_list|(
name|type
argument_list|)
comment|/* Don't do this if there are attributes.  */
operator|&&
operator|(
operator|!
name|attrlist
operator|||
operator|!
operator|*
name|attrlist
operator|)
operator|&&
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
condition|)
block|{
name|tree
name|oldname
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Replace the anonymous name with the real name everywhere.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|oldname
condition|)
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is a typedef within a template class, the nested 	     type is a (non-primary) template.  The name for the 	     template needs updating as well.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* FIXME remangle member functions; member functions of a 	     type with external linkage have external linkage.  */
block|}
comment|/* Any qualifiers on a function type typedef have already been 	   dealt with. */
if|if
condition|(
name|memfn_quals
operator|&&
operator|!
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|memfn_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|signed_p
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"type"
argument_list|,
name|virtualp
argument_list|,
name|memfn_quals
operator|!=
name|TYPE_UNQUALIFIED
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that the array's domain can be      individually set by the object's initializer.  */
if|if
condition|(
name|type
operator|&&
name|typedef_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|typedef_type
argument_list|)
condition|)
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Detect where we're using a typedef of function type to declare a      function. PARMS will not be set, so we must create it now.  */
if|if
condition|(
name|type
operator|==
name|typedef_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|args
decl_stmt|;
for|for
control|(
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|cp_build_parm_decl
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|decls
expr_stmt|;
name|decls
operator|=
name|decl
expr_stmt|;
block|}
name|parms
operator|=
name|nreverse
argument_list|(
name|decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|!=
name|TYPENAME
condition|)
block|{
comment|/* A cv-qualifier-seq shall only be part of the function type 	     for a non-static member function. [8.3.5/4 dcl.fct] */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
operator|&&
operator|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|staticp
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"qualified function types cannot be used to declare %s functions"
argument_list|,
operator|(
name|staticp
condition|?
literal|"static member"
else|:
literal|"free"
operator|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* The qualifiers on the function type become the qualifiers on 	     the non-static member function. */
name|memfn_quals
operator||=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
comment|/* Special case: "friend class foo" looks like a TYPENAME context.  */
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|error
argument_list|(
literal|"type qualifiers specified for friend class declaration"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|error
argument_list|(
literal|"%<inline%> specified for friend class declaration"
argument_list|)
expr_stmt|;
name|inlinep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_aggr
condition|)
block|{
comment|/* Don't allow friend declaration without a class-key.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|pedwarn
argument_list|(
literal|"template parameters cannot be friends"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"friend declaration requires class-key, "
literal|"i.e. %<friend class %T::%D%>"
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"friend declaration requires class-key, "
literal|"i.e. %<friend %#T%>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Only try to do this stuff if we didn't already give up.  */
if|if
condition|(
name|type
operator|!=
name|integer_type_node
condition|)
block|{
comment|/* A friendly class?  */
if|if
condition|(
name|current_class_type
condition|)
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to make class %qT a friend of global scope"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|memfn_quals
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|error
argument_list|(
literal|"invalid qualifiers on non-member function type"
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
condition|)
name|type
operator|=
name|build_memfn_type
argument_list|(
name|type
argument_list|,
name|ctype
argument_list|,
name|memfn_quals
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
elseif|else
if|if
condition|(
name|unqualified_id
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
name|decl_context
operator|!=
name|CATCHPARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
operator|!
name|bitfield
condition|)
block|{
name|error
argument_list|(
literal|"abstract declarator %qT used as declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Only functions may be declared using an operator-function-id.  */
if|if
condition|(
name|unqualified_id
operator|&&
name|IDENTIFIER_OPNAME_P
argument_list|(
name|unqualified_id
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qD as non-function"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We don't check parameter types here because we can emit a better      error message later.  */
if|if
condition|(
name|decl_context
operator|!=
name|PARM
condition|)
block|{
name|type
operator|=
name|check_var_type
argument_list|(
name|unqualified_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|||
name|decl_context
operator|==
name|CATCHPARM
condition|)
block|{
if|if
condition|(
name|ctype
operator|||
name|in_namespace
condition|)
name|error
argument_list|(
literal|"cannot use %<::%> in parameter declaration"
argument_list|)
expr_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	 One declared as a function is really a pointer to a function. 	 One declared as a member is really a pointer to member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|decl
operator|=
name|cp_build_parm_decl
argument_list|(
name|unqualified_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"parameter"
argument_list|,
name|virtualp
argument_list|,
name|memfn_quals
operator|!=
name|TYPE_UNQUALIFIED
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
comment|/* The C99 flexible array extension.  */
if|if
condition|(
operator|!
name|staticp
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|itype
init|=
name|compute_array_index_type
argument_list|(
name|dname
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|itype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Happens when declaring arrays of sizes which 	       are error_mark_node, for example.  */
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_namespace
operator|&&
operator|!
name|friendp
condition|)
block|{
comment|/* Something like struct S { int N::j; };  */
name|error
argument_list|(
literal|"invalid use of %<::%>"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|int
name|publicp
init|=
literal|0
decl_stmt|;
name|tree
name|function_context
decl_stmt|;
if|if
condition|(
name|friendp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"can't make %qD into a method -- not in a class"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* ``A union may [ ... ] not [ have ] virtual functions.'' 		   ARM 9.5 */
if|if
condition|(
name|virtualp
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function %qD declared virtual inside a union"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|NEW_DELETE_OPNAME_P
argument_list|(
name|unqualified_id
argument_list|)
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"%qD cannot be declared virtual, since it "
literal|"is always static"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_memfn_type
argument_list|(
name|type
argument_list|,
name|ctype
argument_list|,
name|memfn_quals
argument_list|)
expr_stmt|;
block|}
comment|/* Check that the name used for a destructor makes sense.  */
if|if
condition|(
name|sfk
operator|==
name|sfk_destructor
condition|)
block|{
if|if
condition|(
operator|!
name|ctype
condition|)
block|{
name|gcc_assert
argument_list|(
name|friendp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"expected qualified name in friend declaration "
literal|"for destructor %qD"
argument_list|,
name|id_declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|id_declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ctype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qD as member of %qT"
argument_list|,
name|id_declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */
name|function_context
operator|=
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|)
condition|?
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|ctype
argument_list|)
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|publicp
operator|=
operator|(
operator|!
name|friendp
operator|||
operator|!
name|staticp
operator|)
operator|&&
name|function_context
operator|==
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|TREE_CODE
argument_list|(
name|unqualified_id
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|?
name|unqualified_id
else|:
name|dname
argument_list|,
name|parms
argument_list|,
name|unqualified_id
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|memfn_quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|friendp
argument_list|,
name|publicp
argument_list|,
name|inlinep
argument_list|,
name|sfk
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|,
name|attrlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* This clobbers the attrs stored in `decl' from `attrlist'.  */
comment|/* The decl and setting of decl_attr is also turned off.  */
block|decl = build_decl_attribute_variant (decl, decl_attr);
endif|#
directive|endif
comment|/* [class.conv.ctor]  	       A constructor declared without the function-specifier 	       explicit that can be called with a single parameter 	       specifies a conversion from the type of its first 	       parameter to the type of its class.  Such a constructor 	       is called a converting constructor.  */
if|if
condition|(
name|explicitp
operator|==
literal|2
condition|)
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* The constructor can be called with exactly one 		   parameter if there is at least one parameter, and 		   any subsequent parameters have default arguments. 		   Ignore any compiler-added parms.  */
name|tree
name|arg_types
init|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|void_list_node
operator|||
operator|(
name|arg_types
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|!=
name|void_list_node
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|)
condition|)
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* We only get here for friend declarations of 	       members of other classes.  */
comment|/* All method decls are public, so tell grokfndecl to set 	       TREE_PUBLIC, also.  */
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|TREE_CODE
argument_list|(
name|unqualified_id
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|?
name|unqualified_id
else|:
name|dname
argument_list|,
name|parms
argument_list|,
name|unqualified_id
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|memfn_quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|friendp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|sfk
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|,
name|attrlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|staticp
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|initialized
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|unqualified_id
condition|)
name|error
argument_list|(
literal|"field %qD has incomplete type"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"name %qT has incomplete type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If we're instantiating a template, tell them which 	       instantiation made the field's type be incomplete.  */
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
operator|&&
name|declspecs
operator|->
name|type
operator|&&
name|declspecs
operator|->
name|type
operator|==
name|type
condition|)
name|error
argument_list|(
literal|"  in instantiation of template %qT"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
if|if
condition|(
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"%qE is neither function nor member function; "
literal|"cannot be declared friend"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* Friends are treated specially.  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
empty_stmt|;
comment|/* We already issued a pedwarn.  */
elseif|else
if|if
condition|(
name|decl
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|decl
operator|=
name|check_explicit_specialization
argument_list|(
name|unqualified_id
argument_list|,
name|decl
argument_list|,
name|template_count
argument_list|,
literal|2
operator|*
name|funcdef_flag
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|do_friend
argument_list|(
name|ctype
argument_list|,
name|unqualified_id
argument_list|,
name|decl
argument_list|,
operator|*
name|attrlist
argument_list|,
name|flags
argument_list|,
name|funcdef_flag
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
comment|/* Structure field.  It may not be a function, except for C++.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|staticp
condition|)
block|{
comment|/* An attempt is being made to initialize a non-static 		       member.  But, from [class.mem]:  		       4 A member-declarator can contain a 		       constant-initializer only if it declares a static 		       member (_class.static_) of integral or enumeration 		       type, see _class.static.data_.  		       This used to be relatively common practice, but 		       the rest of the compiler does not correctly 		       handle the initialization unless the member is 		       static so we make it static below.  */
name|pedwarn
argument_list|(
literal|"ISO C++ forbids initialization of member %qD"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"making %qD static"
argument_list|,
name|unqualified_id
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
comment|/* We'll check at instantiation time.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|check_static_variable_definition
argument_list|(
name|unqualified_id
argument_list|,
name|type
argument_list|)
condition|)
comment|/* If we just return the declaration, crashes 		     will sometimes occur.  We therefore return 		     void_type_node, as if this was a friend 		     declaration, to cause callers to completely 		     ignore this declaration.  */
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|staticp
condition|)
block|{
comment|/* C++ allows static class members.  All other work 		   for this is done by grokfield.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|unqualified_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|set_linkage_for_static_data_member
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Even if there is an in-class initialization, DECL 		   is considered undefined until an out-of-class 		   definition is provided.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|thread_p
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_tls
condition|)
name|DECL_TLS_MODEL
argument_list|(
name|decl
argument_list|)
operator|=
name|decl_default_tls_model
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* A mere warning is sure to result in improper 			 semantics at runtime.  Don't bother to allow this to 			 compile.  */
name|error
argument_list|(
literal|"thread-local storage not supported for this target"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|unqualified_id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
name|bitfield
expr_stmt|;
if|if
condition|(
name|storage_class
operator|==
name|sc_mutable
condition|)
block|{
name|DECL_MUTABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
block|}
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"field"
argument_list|,
name|virtualp
argument_list|,
name|memfn_quals
operator|!=
name|TYPE_UNQUALIFIED
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|original_name
decl_stmt|;
name|int
name|publicp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|unqualified_id
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|unqualified_id
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|original_name
operator|=
name|dname
expr_stmt|;
else|else
name|original_name
operator|=
name|unqualified_id
expr_stmt|;
if|if
condition|(
name|storage_class
operator|==
name|sc_auto
condition|)
name|error
argument_list|(
literal|"storage class %<auto%> invalid for function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|sc_register
condition|)
name|error
argument_list|(
literal|"storage class %<register%> invalid for function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|thread_p
condition|)
name|error
argument_list|(
literal|"storage class %<__thread%> invalid for function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
operator|&&
operator|(
name|storage_class
operator|==
name|sc_static
operator|||
name|declspecs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_inline
index|]
operator|)
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|storage_class
operator|==
name|sc_static
condition|)
name|pedwarn
argument_list|(
literal|"%<static%> specified invalid for function %qs "
literal|"declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"%<inline%> specifier invalid for function %qs "
literal|"declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"virtual non-class function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|staticp
operator|<
literal|2
operator|&&
operator|!
name|NEW_DELETE_OPNAME_P
argument_list|(
name|original_name
argument_list|)
condition|)
name|type
operator|=
name|build_method_type_directly
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record presence of `static'.  */
name|publicp
operator|=
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|||
name|storage_class
operator|==
name|sc_extern
operator|||
name|storage_class
operator|!=
name|sc_static
operator|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|original_name
argument_list|,
name|parms
argument_list|,
name|unqualified_id
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|memfn_quals
argument_list|,
name|raises
argument_list|,
literal|1
argument_list|,
name|friendp
argument_list|,
name|publicp
argument_list|,
name|inlinep
argument_list|,
name|sfk
argument_list|,
name|funcdef_flag
argument_list|,
name|template_count
argument_list|,
name|in_namespace
argument_list|,
name|attrlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|int
name|invalid_static
init|=
literal|0
decl_stmt|;
comment|/* Don't allow a static member function in a class, and forbid 	       declaring main to be static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"cannot declare member function %qD to have "
literal|"static linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|invalid_static
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
block|{
comment|/* FIXME need arm citation */
name|error
argument_list|(
literal|"cannot declare static function inside another function"
argument_list|)
expr_stmt|;
name|invalid_static
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|invalid_static
condition|)
block|{
name|staticp
operator|=
literal|0
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|decl
operator|=
name|grokvardecl
argument_list|(
name|type
argument_list|,
name|unqualified_id
argument_list|,
name|declspecs
argument_list|,
name|initialized
argument_list|,
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|!=
literal|0
argument_list|,
name|ctype
condition|?
name|ctype
else|:
name|in_namespace
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"variable"
argument_list|,
name|virtualp
argument_list|,
name|memfn_quals
operator|!=
name|TYPE_UNQUALIFIED
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|pedwarn
argument_list|(
literal|"%<static%> may not be used when defining "
literal|"(as opposed to declaring) a static data member"
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
if|if
condition|(
name|storage_class
operator|==
name|sc_register
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"static member %qD declared %<register%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
if|if
condition|(
name|storage_class
operator|==
name|sc_extern
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"cannot explicitly declare member %q#D to have "
literal|"extern linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|storage_class
operator|=
name|sc_none
expr_stmt|;
block|}
block|}
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|storage_class
operator|==
name|sc_register
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|sc_extern
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|sc_static
condition|)
name|DECL_THIS_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  There's no need to do this        when processing a template; we'll do this for the instantiated        declaration based on the type of DECL.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|cp_apply_type_quals_to_decl
argument_list|(
name|type_quals
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of start_function.  Ensure that each of the parameter    types (as listed in PARMS) is complete, as is required for a    function definition.  */
end_comment

begin_function
specifier|static
name|void
name|require_complete_types_for_parms
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
name|complete_type_or_else
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|parms
argument_list|)
condition|)
block|{
name|relayout_decl
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|type_passed_as
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* grokparms or complete_type_or_else will have already issued 	   an error.  */
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns nonzero if T is a local variable.  */
end_comment

begin_function
name|int
name|local_variable_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
comment|/* A VAR_DECL with a context that is a _TYPE is a static data 	  member.  */
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
comment|/* Any other non-local variable must be at namespace scope.  */
operator|&&
operator|!
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|t
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if T is an automatic local variable or a label.    (These are the declarations that need to be remapped when the code    containing them is duplicated.)  */
end_comment

begin_function
name|int
name|nonstatic_local_decl_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
operator|(
name|local_variable_p
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RESULT_DECL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like local_variable_p, but suitable for use as a tree-walking    function.  */
end_comment

begin_function
specifier|static
name|tree
name|local_variable_p_walkfn
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|local_variable_p
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
return|return
operator|*
name|tp
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check that ARG, which is a default-argument expression for a    parameter DECL, is valid.  Returns ARG, or ERROR_MARK_NODE, if    something goes wrong.  DECL may also be a _TYPE node, rather than a    DECL, if there is no DECL available.  */
end_comment

begin_function
name|tree
name|check_default_argument
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|decl_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
comment|/* We get a DEFAULT_ARG when looking at an in-class declaration        with a default argument.  Ignore the argument for now; we'll        deal with it after the class is complete.  */
return|return
name|arg
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|decl_type
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|error_mark_node
operator|||
name|decl_type
operator|==
name|error_mark_node
condition|)
comment|/* Something already went wrong.  There's no need to check        further.  */
return|return
name|error_mark_node
return|;
comment|/* [dcl.fct.default]       A default argument expression is implicitly converted to the      parameter type.  */
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|||
operator|!
name|can_convert_arg
argument_list|(
name|decl_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|error
argument_list|(
literal|"default argument for %q#D has type %qT"
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"default argument for parameter of type %qT has type %qT"
argument_list|,
name|decl_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [dcl.fct.default]       Local variables shall not be used in default argument      expressions.       The keyword `this' shall not be used in a default argument of a      member function.  */
name|var
operator|=
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|arg
argument_list|,
name|local_variable_p_walkfn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
condition|)
block|{
name|error
argument_list|(
literal|"default argument %qE uses local variable %qD"
argument_list|,
name|arg
argument_list|,
name|var
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* All is well.  */
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Decode the list of parameter types for a function type.    Given the list of things declared inside the parens,    return a list of types.     If this parameter does not end with an ellipsis, we append    void_list_node.     *PARMS is set to the chain of PARM_DECLs created.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|cp_parameter_declarator
modifier|*
name|first_parm
parameter_list|,
name|tree
modifier|*
name|parms
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|ellipsis
init|=
operator|!
name|first_parm
operator|||
name|first_parm
operator|->
name|ellipsis_p
decl_stmt|;
name|cp_parameter_declarator
modifier|*
name|parm
decl_stmt|;
name|int
name|any_error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|first_parm
init|;
name|parm
operator|!=
name|NULL
condition|;
name|parm
operator|=
name|parm
operator|->
name|next
control|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|init
init|=
name|parm
operator|->
name|default_argument
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|parm
operator|==
name|no_parameters
condition|)
break|break;
name|attrs
operator|=
name|parm
operator|->
name|decl_specifiers
operator|.
name|attributes
expr_stmt|;
name|parm
operator|->
name|decl_specifiers
operator|.
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|parm
operator|->
name|declarator
argument_list|,
operator|&
name|parm
operator|->
name|decl_specifiers
argument_list|,
name|PARM
argument_list|,
name|init
operator|!=
name|NULL_TREE
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|attrs
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|void_type_node
argument_list|)
operator|&&
name|DECL_SELF_REFERENCE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|result
operator|&&
operator|!
name|parm
operator|->
name|next
operator|&&
operator|!
name|ellipsis
condition|)
comment|/* this is a parmlist of `(void)', which is ok.  */
break|break;
name|cxx_incomplete_type_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* It's not a good idea to actually create parameters of 	     type `void'; other parts of the compiler assume that a 	     void type terminates the parameter list.  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Top-level qualifiers on the parameters are 	     ignored for function types.  */
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"parameter %qD invalidly declared method type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
condition|)
name|any_error
operator|=
literal|1
expr_stmt|;
comment|/* Seems like a good idea.  */
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* [dcl.fct]/6, parameter types cannot contain pointers 		 (references) to arrays of unknown bound.  */
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|ptr
init|=
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|t
argument_list|)
condition|)
name|ptr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
break|break;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"parameter %qD includes %s to array of unknown "
literal|"bound %qT"
argument_list|,
name|decl
argument_list|,
name|ptr
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_error
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|init
operator|&&
operator|!
name|processing_template_decl
condition|)
name|init
operator|=
name|check_default_argument
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|decls
expr_stmt|;
name|decls
operator|=
name|decl
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|init
argument_list|,
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|decls
operator|=
name|nreverse
argument_list|(
name|decls
argument_list|)
expr_stmt|;
name|result
operator|=
name|nreverse
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ellipsis
condition|)
name|result
operator|=
name|chainon
argument_list|(
name|result
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
operator|*
name|parms
operator|=
name|decls
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* D is a constructor or overloaded `operator='.     Let T be the class in which D is declared. Then, this function    returns:     -1 if D's is an ill-formed constructor or copy assignment operator       whose first parameter is of type `T'.    0  if D is not a copy constructor or copy assignment       operator.    1  if D is a copy constructor or copy assignment operator whose       first parameter is a reference to const qualified T.    2  if D is a copy constructor or copy assignment operator whose       first parameter is a reference to non-const qualified T.     This function can be used as a predicate. Positive values indicate    a copy constructor and nonzero values indicate a copy assignment    operator.  */
end_comment

begin_function
name|int
name|copy_fn_p
parameter_list|(
name|tree
name|d
parameter_list|)
block|{
name|tree
name|args
decl_stmt|;
name|tree
name|arg_type
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
operator|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
operator|&&
name|DECL_MEMBER_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* Instantiations of template member functions are never copy        functions.  Note that member functions of templated classes are        represented as template functions internally, and we must        accept those as copy functions.  */
return|return
literal|0
return|;
name|args
operator|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
return|return
literal|0
return|;
name|arg_type
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg_type
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|/* Pass by value copy assignment operator.  */
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg_type
argument_list|)
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg_type
argument_list|)
argument_list|)
condition|)
name|result
operator|=
literal|2
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|args
argument_list|)
condition|)
comment|/* There are more non-optional args.  */
return|return
literal|0
return|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Remember any special properties of member function DECL.  */
end_comment

begin_function
name|void
name|grok_special_member_properties
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|class_type
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|class_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|ctor
init|=
name|copy_fn_p
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctor
operator|>
literal|0
condition|)
block|{
comment|/* [class.copy]  	     A non-template constructor for class X is a copy 	     constructor if its first parameter is of type X&, const 	     X&, volatile X& or const volatile X&, and either there 	     are no other parameters or else all other parameters have 	     default arguments.  */
name|TYPE_HAS_INIT_REF
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctor
operator|>
literal|1
condition|)
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sufficient_parms_p
argument_list|(
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* [class.copy]  	 A non-template assignment operator for class X is a copy 	 assignment operator if its parameter is of type X, X&, const 	 X&, volatile X& or const volatile X&.  */
name|int
name|assop
init|=
name|copy_fn_p
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|assop
condition|)
block|{
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|assop
operator|!=
literal|1
condition|)
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check a constructor DECL has the correct form.  Complains    if the class has a constructor of the form X(X).  */
end_comment

begin_function
name|int
name|grok_ctor_properties
parameter_list|(
name|tree
name|ctype
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|int
name|ctor_parm
init|=
name|copy_fn_p
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctor_parm
operator|<
literal|0
condition|)
block|{
comment|/* [class.copy]  	 A declaration of a constructor for a class X is ill-formed if 	 its first parameter is of type (optionally cv-qualified) X 	 and either there are no other parameters or else all other 	 parameters have default arguments.  	 We *don't* complain about member template instantiations that 	 have this form, though; they can occur as we try to decide 	 what constructor to use during overload resolution.  Since 	 overload resolution will never prefer such a constructor to 	 the non-template copy constructor (which is either explicitly 	 or implicitly defined), there's no need to worry about their 	 existence.  Theoretically, they should never even be 	 instantiated, but that's hard to forestall.  */
name|error
argument_list|(
literal|"invalid constructor; you probably meant %<%T (const %T&)%>"
argument_list|,
name|ctype
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* An operator with this code is unary, but can also be binary.  */
end_comment

begin_function
specifier|static
name|int
name|ambi_op_p
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|INDIRECT_REF
operator|||
name|code
operator|==
name|ADDR_EXPR
operator|||
name|code
operator|==
name|UNARY_PLUS_EXPR
operator|||
name|code
operator|==
name|NEGATE_EXPR
operator|||
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* An operator with this name can only be unary.  */
end_comment

begin_function
specifier|static
name|int
name|unary_op_p
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|||
name|code
operator|==
name|BIT_NOT_EXPR
operator|||
name|code
operator|==
name|COMPONENT_REF
operator|||
name|code
operator|==
name|TYPE_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is a declaration for an overloaded operator.  If COMPLAIN is true,    errors are issued for invalid declarations.  */
end_comment

begin_function
name|bool
name|grok_op_properties
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argtype
decl_stmt|;
name|int
name|methodp
init|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|operator_code
decl_stmt|;
name|int
name|arity
decl_stmt|;
name|bool
name|ellipsis_p
decl_stmt|;
name|tree
name|class_type
decl_stmt|;
comment|/* Count the number of arguments and check for ellipsis.  */
for|for
control|(
name|argtype
operator|=
name|argtypes
operator|,
name|arity
operator|=
literal|0
init|;
name|argtype
operator|&&
name|argtype
operator|!=
name|void_list_node
condition|;
name|argtype
operator|=
name|TREE_CHAIN
argument_list|(
name|argtype
argument_list|)
control|)
operator|++
name|arity
expr_stmt|;
name|ellipsis_p
operator|=
operator|!
name|argtype
expr_stmt|;
name|class_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_type
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|class_type
argument_list|)
condition|)
name|class_type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
name|operator_code
operator|=
name|TYPE_EXPR
expr_stmt|;
else|else
do|do
block|{
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|CODE
parameter_list|,
name|MANGLING
parameter_list|,
name|ARITY
parameter_list|,
name|ASSN_P
parameter_list|)
define|\
value|if (ansi_opname (CODE) == name)				\ 	  {							\ 	    operator_code = (CODE);				\ 	    break;						\ 	  }							\ 	else if (ansi_assopname (CODE) == name)			\ 	  {							\ 	    operator_code = (CODE);				\ 	    DECL_ASSIGNMENT_OPERATOR_P (decl) = 1;		\ 	    break;						\ 	  }
include|#
directive|include
file|"operators.def"
undef|#
directive|undef
name|DEF_OPERATOR
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|gcc_assert
argument_list|(
name|operator_code
operator|!=
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|decl
argument_list|,
name|operator_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_type
condition|)
switch|switch
condition|(
name|operator_code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DELETE_EXPR
case|:
name|TYPE_GETS_DELETE
argument_list|(
name|class_type
argument_list|)
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|VEC_NEW_EXPR
case|:
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VEC_DELETE_EXPR
case|:
name|TYPE_GETS_DELETE
argument_list|(
name|class_type
argument_list|)
operator||=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* [basic.std.dynamic.allocation]/1:         A program is ill-formed if an allocation function is declared        in a namespace scope other than global scope or declared static        in global scope.         The same also holds true for deallocation functions.  */
if|if
condition|(
name|operator_code
operator|==
name|NEW_EXPR
operator|||
name|operator_code
operator|==
name|VEC_NEW_EXPR
operator|||
name|operator_code
operator|==
name|DELETE_EXPR
operator|||
name|operator_code
operator|==
name|VEC_DELETE_EXPR
condition|)
block|{
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|global_namespace
condition|)
block|{
name|error
argument_list|(
literal|"%qD may not be declared within a namespace"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD may not be declared as static"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
if|if
condition|(
name|operator_code
operator|==
name|NEW_EXPR
operator|||
name|operator_code
operator|==
name|VEC_NEW_EXPR
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_new_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operator_code
operator|==
name|DELETE_EXPR
operator|||
name|operator_code
operator|==
name|VEC_DELETE_EXPR
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_delete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* An operator function must either be a non-static member function 	 or have at least one parameter of a class, a reference to a class, 	 an enumeration, or a reference to an enumeration.  13.4.0.6 */
if|if
condition|(
operator|!
name|methodp
operator|||
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|operator_code
operator|==
name|TYPE_EXPR
operator|||
name|operator_code
operator|==
name|CALL_EXPR
operator|||
name|operator_code
operator|==
name|COMPONENT_REF
operator|||
name|operator_code
operator|==
name|ARRAY_REF
operator|||
name|operator_code
operator|==
name|NOP_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"%qD must be a nonstatic member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|tree
name|p
decl_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD must be either a non-static member "
literal|"function or a non-member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|p
operator|=
name|argtypes
init|;
name|p
operator|&&
name|p
operator|!=
name|void_list_node
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|non_reference
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* IS_AGGR_TYPE, rather than CLASS_TYPE_P, is used 		     because these checks are performed even on 		     template functions.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|p
operator|||
name|p
operator|==
name|void_list_node
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"%qD must have an argument of class or "
literal|"enumerated type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
comment|/* There are no restrictions on the arguments to an overloaded 	 "operator ()".  */
if|if
condition|(
name|operator_code
operator|==
name|CALL_EXPR
condition|)
return|return
name|true
return|;
comment|/* Warn about conversion operators that will never be used.  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|warn_conversion
comment|/* Warn only declaring the function; there is no need to 	     warn again about out-of-class definitions.  */
operator|&&
name|class_type
operator|==
name|current_class_type
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|ref
init|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ref
condition|)
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|what
operator|=
literal|"void"
expr_stmt|;
elseif|else
if|if
condition|(
name|class_type
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|class_type
condition|)
name|what
operator|=
literal|"the same type"
expr_stmt|;
comment|/* Don't force t to be complete here.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|class_type
argument_list|)
condition|)
name|what
operator|=
literal|"a base class"
expr_stmt|;
block|}
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
name|OPT_Wconversion
argument_list|,
literal|"conversion to %s%s will never use a type "
literal|"conversion operator"
argument_list|,
name|ref
condition|?
literal|"a reference to "
else|:
literal|""
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operator_code
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* 13.4.0.3 */
name|error
argument_list|(
literal|"ISO C++ prohibits overloading operator ?:"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|ellipsis_p
condition|)
block|{
name|error
argument_list|(
literal|"%qD must not have variable number of arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|ambi_op_p
argument_list|(
name|operator_code
argument_list|)
condition|)
block|{
if|if
condition|(
name|arity
operator|==
literal|1
condition|)
comment|/* We pick the one-argument operator codes by default, so 	       we don't have to change anything.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|arity
operator|==
literal|2
condition|)
block|{
comment|/* If we thought this was a unary operator, we now know 		 it to be a binary operator.  */
switch|switch
condition|(
name|operator_code
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
name|operator_code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
name|operator_code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|UNARY_PLUS_EXPR
case|:
name|operator_code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
name|operator_code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
name|operator_code
operator|=
name|POSTINCREMENT_EXPR
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
name|operator_code
operator|=
name|POSTDECREMENT_EXPR
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|decl
argument_list|,
name|operator_code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|operator_code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|POSTDECREMENT_EXPR
operator|)
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"postfix %qD must take %<int%> as its argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"postfix %qD must take %<int%> as its second "
literal|"argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"%qD must take either zero or one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qD must take either one or two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* More Effective C++ rule 6.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|(
name|operator_code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|operator_code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|PREDECREMENT_EXPR
operator|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|argtypes
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|methodp
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|operator_code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|PREDECREMENT_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ret
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ret
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Weffc__
argument_list|,
literal|"prefix %qD should return %qT"
argument_list|,
name|decl
argument_list|,
name|build_reference_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ret
argument_list|)
argument_list|,
name|arg
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Weffc__
argument_list|,
literal|"postfix %qD should return %qT"
argument_list|,
name|decl
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|unary_op_p
argument_list|(
name|operator_code
argument_list|)
condition|)
block|{
if|if
condition|(
name|arity
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"%qD must take %<void%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qD must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
comment|/* if (binary_op_p (operator_code)) */
block|{
if|if
condition|(
name|arity
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|error
argument_list|(
literal|"%qD must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qD must take exactly two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* More Effective C++ rule 7.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|(
name|operator_code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|operator_code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|operator_code
operator|==
name|COMPOUND_EXPR
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Weffc__
argument_list|,
literal|"user-defined %qD always evaluates both arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Effective C++ rule 23.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|arity
operator|==
literal|2
operator|&&
operator|!
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|operator_code
operator|==
name|PLUS_EXPR
operator|||
name|operator_code
operator|==
name|MINUS_EXPR
operator|||
name|operator_code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|operator_code
operator|==
name|MULT_EXPR
operator|||
name|operator_code
operator|==
name|TRUNC_MOD_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|warning
argument_list|(
name|OPT_Weffc__
argument_list|,
literal|"%qD should return by value"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* [over.oper]/8 */
for|for
control|(
init|;
name|argtypes
operator|&&
name|argtypes
operator|!=
name|void_list_node
condition|;
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|operator_code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|operator_code
operator|==
name|POSTDECREMENT_EXPR
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"%qD cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%qD cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a string giving the keyword associate with CODE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tag_name
parameter_list|(
name|enum
name|tag_types
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|record_type
case|:
return|return
literal|"struct"
return|;
case|case
name|class_type
case|:
return|return
literal|"class"
return|;
case|case
name|union_type
case|:
return|return
literal|"union"
return|;
case|case
name|enum_type
case|:
return|return
literal|"enum"
return|;
case|case
name|typename_type
case|:
return|return
literal|"typename"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Name lookup in an elaborated-type-specifier (after the keyword    indicated by TAG_CODE) has found the TYPE_DECL DECL.  If the    elaborated-type-specifier is invalid, issue a diagnostic and return    error_mark_node; otherwise, return the *_TYPE to which it referred.    If ALLOW_TEMPLATE_P is true, TYPE may be a class template.  */
end_comment

begin_function
name|tree
name|check_elaborated_type_specifier
parameter_list|(
name|enum
name|tag_types
name|tag_code
parameter_list|,
name|tree
name|decl
parameter_list|,
name|bool
name|allow_template_p
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* In the case of:         struct S { struct S *p; };       name lookup will find the TYPE_DECL for the implicit "S::S"      typedef.  Adjust for that here.  */
if|if
condition|(
name|DECL_SELF_REFERENCE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Check TEMPLATE_TYPE_PARM first because DECL_IMPLICIT_TYPEDEF_P      is false for this case as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|error
argument_list|(
literal|"using template type parameter %qT after %qs"
argument_list|,
name|type
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/*   [dcl.type.elab]         If the identifier resolves to a typedef-name or a template        type-parameter, the elaborated-type-specifier is ill-formed.       In other words, the only legitimate declaration to use in the      elaborated type specifier is the implicit typedef created when      the type is declared.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|tag_code
operator|!=
name|typename_type
condition|)
block|{
name|error
argument_list|(
literal|"using typedef-name %qD after %qs"
argument_list|,
name|decl
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%q+D has a previous declaration here"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|tag_code
operator|!=
name|enum_type
operator|&&
name|tag_code
operator|!=
name|typename_type
condition|)
block|{
name|error
argument_list|(
literal|"%qT referred to as %qs"
argument_list|,
name|type
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%q+T has a previous declaration here"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|tag_code
operator|==
name|enum_type
condition|)
block|{
name|error
argument_list|(
literal|"%qT referred to as enum"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%q+T has a previous declaration here"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|allow_template_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* If a class template appears as elaborated type specifier 	 without a template header such as:  	   template<class T> class C {}; 	   void f(class C);		// No template header here  	 then the required template argument is missing.  */
name|error
argument_list|(
literal|"template argument required for %<%s %T%>"
argument_list|,
name|tag_name
argument_list|(
name|tag_code
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Lookup NAME in elaborate type specifier in scope according to    SCOPE and issue diagnostics if necessary.    Return *_TYPE node upon success, NULL_TREE when the NAME is not    found, and ERROR_MARK_NODE for type error.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_and_check_tag
parameter_list|(
name|enum
name|tag_types
name|tag_code
parameter_list|,
name|tree
name|name
parameter_list|,
name|tag_scope
name|scope
parameter_list|,
name|bool
name|template_header_p
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|ts_global
condition|)
block|{
comment|/* First try ordinary name lookup, ignoring hidden class name 	 injected via friend declaration.  */
name|decl
operator|=
name|lookup_name_prefer_type
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If that fails, the name will be placed in the smallest 	 non-class, non-function-prototype scope according to 3.3.1/5. 	 We may already have a hidden name declared as friend in this 	 scope.  So lookup again but not ignoring hidden names. 	 If we find one, that name will be made visible rather than 	 creating a new tag.  */
if|if
condition|(
operator|!
name|decl
condition|)
name|decl
operator|=
name|lookup_type_scope
argument_list|(
name|name
argument_list|,
name|ts_within_enclosing_non_class
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|lookup_type_scope
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Look for invalid nested type: 	   class C { 	     class C {}; 	   };  */
if|if
condition|(
name|scope
operator|==
name|ts_current
operator|&&
name|DECL_SELF_REFERENCE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD has the same name as the class in which it is "
literal|"declared"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Two cases we need to consider when deciding if a class 	 template is allowed as an elaborated type specifier: 	 1. It is a self reference to its own class. 	 2. It comes with a template header.  	 For example:  	   template<class T> class C { 	     class C *c1;		// DECL_SELF_REFERENCE_P is true 	     class D; 	   }; 	   template<class U> class C; // template_header_p is true 	   template<class T> class C<T>::D { 	     class C *c2;		// DECL_SELF_REFERENCE_P is true 	   };  */
name|t
operator|=
name|check_elaborated_type_specifier
argument_list|(
name|tag_code
argument_list|,
name|decl
argument_list|,
name|template_header_p
operator||
name|DECL_SELF_REFERENCE_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Get the struct, enum or union (TAG_CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.     If a declaration is given, process it here, and report an error if    multiple declarations are not identical.     SCOPE is TS_CURRENT when this is also a definition.  Only look in    the current frame for the name (since C++ allows new names in any    scope.)  It is TS_WITHIN_ENCLOSING_NON_CLASS if this is a friend    declaration.  Only look beginning from the current scope outward up    till the nearest non-class scope.  Otherwise it is TS_GLOBAL.     TEMPLATE_HEADER_P is true when this declaration is preceded by    a set of template parameters.  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|enum
name|tag_types
name|tag_code
parameter_list|,
name|tree
name|name
parameter_list|,
name|tag_scope
name|scope
parameter_list|,
name|bool
name|template_header_p
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag_code
condition|)
block|{
case|case
name|record_type
case|:
case|case
name|class_type
case|:
name|code
operator|=
name|RECORD_TYPE
expr_stmt|;
break|break;
case|case
name|union_type
case|:
name|code
operator|=
name|UNION_TYPE
expr_stmt|;
break|break;
case|case
name|enum_type
case|:
name|code
operator|=
name|ENUMERAL_TYPE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* In case of anonymous name, xref_tag is only called to      make type node and push name.  Name lookup is not required.  */
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|t
operator|=
name|lookup_and_check_tag
argument_list|(
name|tag_code
argument_list|,
name|name
argument_list|,
name|scope
argument_list|,
name|template_header_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|!=
name|ts_current
operator|&&
name|t
operator|&&
name|current_class_type
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|template_header_p
condition|)
block|{
comment|/* Since SCOPE is not TS_CURRENT, we are not looking at a 	 definition of this tag.  Since, in addition, we are currently 	 processing a (member) template declaration of a template 	 class, we must be very careful; consider:  	   template<class X> 	   struct S1  	   template<class U> 	   struct S2 	   { template<class V> 	   friend struct S1; };  	 Here, the S2::S1 declaration should not be confused with the 	 outer declaration.  In particular, the inner version should 	 have a template parameter of level 2, not level 1.  This 	 would be particularly important if the member declaration 	 were instead:  	   template<class V = U> friend struct S1;  	 say, when we should tsubst into `U' when instantiating 	 S2.  On the other hand, when presented with:  	   template<class T> 	   struct S1 { 	     template<class U> 	     struct S2 {}; 	     template<class U> 	     friend struct S2; 	   };  	 we must find the inner binding eventually.  We 	 accomplish this by making sure that the new type we 	 create to represent this declaration has the right 	 TYPE_CONTEXT.  */
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|t
condition|)
block|{
comment|/* If no such tag is yet defined, create a forward-reference node 	 and record it as the "definition". 	 When a real declaration of this type is found, 	 the forward-reference will be altered into a real type.  */
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"use of enum %q#D without previous declaration"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|context
expr_stmt|;
name|t
operator|=
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|template_header_p
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|redeclare_class_template
argument_list|(
name|t
argument_list|,
name|current_template_parms
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"redeclaration of %qT as a non-template"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration %q+D"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
comment|/* Make injected friend class visible.  */
if|if
condition|(
name|scope
operator|!=
name|ts_within_enclosing_non_class
operator|&&
name|hidden_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_ANTICIPATED
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|DECL_ANTICIPATED
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|xref_tag_from_type
parameter_list|(
name|tree
name|old
parameter_list|,
name|tree
name|id
parameter_list|,
name|tag_scope
name|scope
parameter_list|)
block|{
name|enum
name|tag_types
name|tag_kind
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|tag_kind
operator|=
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|old
argument_list|)
condition|?
name|class_type
else|:
name|record_type
operator|)
expr_stmt|;
else|else
name|tag_kind
operator|=
name|union_type
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL_TREE
condition|)
name|id
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|xref_tag
argument_list|(
name|tag_kind
argument_list|,
name|id
argument_list|,
name|scope
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create the binfo hierarchy for REF with (possibly NULL) base list    BASE_LIST.  For each element on BASE_LIST the TREE_PURPOSE is an    access_* node, and the TREE_VALUE is the type of the base-class.    Non-NULL TREE_TYPE indicates virtual inheritance.        Returns true if the binfo heirarchy was successfully created,    false if an error was detected. */
end_comment

begin_function
name|bool
name|xref_basetypes
parameter_list|(
name|tree
name|ref
parameter_list|,
name|tree
name|base_list
parameter_list|)
block|{
name|tree
modifier|*
name|basep
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|unsigned
name|max_vbases
init|=
literal|0
decl_stmt|;
comment|/* Maximum direct& indirect virtual bases.  */
name|unsigned
name|max_bases
init|=
literal|0
decl_stmt|;
comment|/* Maximum direct bases.  */
name|int
name|i
decl_stmt|;
name|tree
name|default_access
decl_stmt|;
name|tree
name|igo_prev
decl_stmt|;
comment|/* Track Inheritance Graph Order.  */
if|if
condition|(
name|ref
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* The base of a derived class is private by default, all others are      public.  */
name|default_access
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
condition|?
name|access_private_node
else|:
name|access_public_node
operator|)
expr_stmt|;
comment|/* First, make sure that any templates in base-classes are      instantiated.  This ensures that if we call ourselves recursively      we do not get confused about which classes are marked and which      are not.  */
name|basep
operator|=
operator|&
name|base_list
expr_stmt|;
while|while
condition|(
operator|*
name|basep
condition|)
block|{
name|tree
name|basetype
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|basep
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|processing_template_decl
operator|&&
name|uses_template_parms
argument_list|(
name|basetype
argument_list|)
operator|)
operator|&&
operator|!
name|complete_type_or_else
argument_list|(
name|basetype
argument_list|,
name|NULL
argument_list|)
condition|)
comment|/* An incomplete type.  Remove it from the list.  */
operator|*
name|basep
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|basep
argument_list|)
expr_stmt|;
else|else
block|{
name|max_bases
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
operator|*
name|basep
argument_list|)
condition|)
name|max_vbases
operator|++
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|max_vbases
operator|+=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|basep
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|basep
argument_list|)
expr_stmt|;
block|}
block|}
name|TYPE_MARKED_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The binfo slot should be empty, unless this is an (ill-formed)      redefinition.  */
name|gcc_assert
argument_list|(
operator|!
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ref
argument_list|)
operator|==
name|ref
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|make_tree_binfo
argument_list|(
name|max_bases
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|=
name|ref
expr_stmt|;
if|if
condition|(
name|max_bases
condition|)
block|{
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|max_bases
argument_list|)
expr_stmt|;
comment|/* An aggregate cannot have baseclasses.  */
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"derived union %qT invalid"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|max_bases
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Java class %qT cannot have multiple bases"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|max_vbases
condition|)
block|{
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|max_vbases
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Java class %qT cannot have virtual bases"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
for|for
control|(
name|igo_prev
operator|=
name|binfo
init|;
name|base_list
condition|;
name|base_list
operator|=
name|TREE_CHAIN
argument_list|(
name|base_list
argument_list|)
control|)
block|{
name|tree
name|access
init|=
name|TREE_PURPOSE
argument_list|(
name|base_list
argument_list|)
decl_stmt|;
name|int
name|via_virtual
init|=
name|TREE_TYPE
argument_list|(
name|base_list
argument_list|)
operator|!=
name|NULL_TREE
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_VALUE
argument_list|(
name|base_list
argument_list|)
decl_stmt|;
if|if
condition|(
name|access
operator|==
name|access_default_node
condition|)
name|access
operator|=
name|default_access
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|error
argument_list|(
literal|"base type %qT fails to be a struct or class type"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|current_lang_depth
argument_list|()
operator|==
literal|0
operator|)
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|base_binfo
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|base_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* The original basetype could have been a typedef'd type.  */
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* Inherit flags from the base.  */
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_DELETE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_DIAMOND_SHAPED_P
argument_list|(
name|ref
argument_list|)
operator||=
name|CLASSTYPE_DIAMOND_SHAPED_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_REPEATED_BASE_P
argument_list|(
name|ref
argument_list|)
operator||=
name|CLASSTYPE_REPEATED_BASE_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* We must do this test after we've seen through a typedef 	 type.  */
if|if
condition|(
name|TYPE_MARKED_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|ref
condition|)
name|error
argument_list|(
literal|"recursive type %qT undefined"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"duplicate base type %qT invalid"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|TYPE_MARKED_P
argument_list|(
name|basetype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|base_binfo
operator|=
name|copy_binfo
argument_list|(
name|base_binfo
argument_list|,
name|basetype
argument_list|,
name|ref
argument_list|,
operator|&
name|igo_prev
argument_list|,
name|via_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BINFO_BASE_APPEND
argument_list|(
name|binfo
argument_list|,
name|base_binfo
argument_list|)
expr_stmt|;
name|BINFO_BASE_ACCESS_APPEND
argument_list|(
name|binfo
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VEC_space
argument_list|(
name|tree
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|ref
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* If we have space in the vbase vector, we must have shared at        least one of them, and are therefore diamond shaped.  */
name|CLASSTYPE_DIAMOND_SHAPED_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Unmark all the types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
name|TYPE_MARKED_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_MARKED_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now see if we have a repeated base type.  */
if|if
condition|(
operator|!
name|CLASSTYPE_REPEATED_BASE_P
argument_list|(
name|ref
argument_list|)
condition|)
block|{
for|for
control|(
name|base_binfo
operator|=
name|binfo
init|;
name|base_binfo
condition|;
name|base_binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|TYPE_MARKED_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|CLASSTYPE_REPEATED_BASE_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|TYPE_MARKED_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|base_binfo
operator|=
name|binfo
init|;
name|base_binfo
condition|;
name|base_binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
control|)
if|if
condition|(
name|TYPE_MARKED_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
name|TYPE_MARKED_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name.    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|enumtype
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
name|enumtype
operator|=
name|lookup_and_check_tag
argument_list|(
name|enum_type
argument_list|,
name|name
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|,
comment|/*template_header_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"multiple definition of %q#T"
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jprevious definition here"
argument_list|,
name|TYPE_MAIN_DECL
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear out TYPE_VALUES, and start again.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
comment|/* In case of error, make a dummy enum to allow parsing to 	 continue.  */
if|if
condition|(
name|enumtype
operator|==
name|error_mark_node
condition|)
name|name
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|enumtype
operator|=
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|)
expr_stmt|;
block|}
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of name-value pairs.  */
end_comment

begin_function
name|void
name|finish_enum
parameter_list|(
name|tree
name|enumtype
parameter_list|)
block|{
name|tree
name|values
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|minnode
decl_stmt|;
name|tree
name|maxnode
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|bool
name|unsignedp
decl_stmt|;
name|bool
name|use_short_enum
decl_stmt|;
name|int
name|lowprec
decl_stmt|;
name|int
name|highprec
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|integer_type_kind
name|itk
decl_stmt|;
name|tree
name|underlying_type
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We built up the VALUES in reverse order.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For an enum defined in a template, just set the type of the values;      all further processing is postponed until the template is      instantiated.  We need to set the type so that tsubst of a CONST_DECL      works.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
for|for
control|(
name|values
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
name|add_stmt
argument_list|(
name|build_min
argument_list|(
name|TAG_DEFN
argument_list|,
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine the minimum and maximum values of the enumerators.  */
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
condition|)
block|{
name|minnode
operator|=
name|maxnode
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|values
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
block|{
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
expr_stmt|;
comment|/* [dcl.enum]: Following the closing brace of an enum-specifier, 	     each enumerator has the type of its enumeration.  Prior to the 	     closing brace, the type of each enumerator is the type of its 	     initializing value.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|enumtype
expr_stmt|;
comment|/* Update the minimum and maximum values, if appropriate.  */
name|value
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
name|value
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Figure out what the minimum and maximum values of the 	     enumerators are.  */
if|if
condition|(
operator|!
name|minnode
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
block|}
else|else
comment|/* [dcl.enum]         If the enumerator-list is empty, the underlying type is as if        the enumeration had a single enumerator with value 0.  */
name|minnode
operator|=
name|maxnode
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Compute the number of bits require to represent all values of the      enumeration.  We must do this before the type of MINNODE and      MAXNODE are transformed, since min_precision relies on the      TREE_TYPE of the value it is passed.  */
name|unsignedp
operator|=
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|lowprec
operator|=
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|highprec
operator|=
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|precision
operator|=
name|MAX
argument_list|(
name|lowprec
argument_list|,
name|highprec
argument_list|)
expr_stmt|;
comment|/* Determine the underlying type of the enumeration.         [dcl.enum]         The underlying type of an enumeration is an integral type that        can represent all the enumerator values defined in the        enumeration.  It is implementation-defined which integral type is        used as the underlying type for an enumeration except that the        underlying type shall not be larger than int unless the value of        an enumerator cannot fit in an int or unsigned int.       We use "int" or an "unsigned int" as the underlying type, even if      a smaller integral type would work, unless the user has      explicitly requested that we use the smallest possible type.  The      user can request that for all enumerations with a command line      flag, or for just one enumeration with an attribute.  */
name|use_short_enum
operator|=
name|flag_short_enums
operator|||
name|lookup_attribute
argument_list|(
literal|"packed"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|itk
operator|=
operator|(
name|use_short_enum
condition|?
name|itk_char
else|:
name|itk_int
operator|)
init|;
name|itk
operator|!=
name|itk_none
condition|;
name|itk
operator|++
control|)
block|{
name|underlying_type
operator|=
name|integer_types
index|[
name|itk
index|]
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|underlying_type
argument_list|)
operator|>=
name|precision
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|underlying_type
argument_list|)
operator|==
name|unsignedp
condition|)
break|break;
block|}
if|if
condition|(
name|itk
operator|==
name|itk_none
condition|)
block|{
comment|/* DR 377  	 IF no integral type can represent all the enumerator values, the 	 enumeration is ill-formed.  */
name|error
argument_list|(
literal|"no integral type can represent all of the enumerator values "
literal|"for %qT"
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
expr_stmt|;
name|underlying_type
operator|=
name|integer_types
index|[
name|itk_unsigned_long_long
index|]
expr_stmt|;
block|}
comment|/* Compute the minium and maximum values for the type.       [dcl.enum]       For an enumeration where emin is the smallest enumerator and emax      is the largest, the values of the enumeration are the values of the      underlying type in the range bmin to bmax, where bmin and bmax are,      respectively, the smallest and largest values of the smallest bit-      field that can store emin and emax.  */
comment|/* The middle-end currently assumes that types with TYPE_PRECISION      narrower than their underlying type are suitably zero or sign      extended to fill their mode.  g++ doesn't make these guarantees.      Until the middle-end can represent such paradoxical types, we      set the TYPE_PRECISION to the width of the underlying type.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|underlying_type
argument_list|)
expr_stmt|;
name|set_min_and_max_values_for_integral_type
argument_list|(
name|enumtype
argument_list|,
name|precision
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* [dcl.enum]       The value of sizeof() applied to an enumeration type, an object      of an enumeration type, or an enumerator, is the value of sizeof()      applied to the underlying type.  */
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|underlying_type
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|underlying_type
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|underlying_type
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|underlying_type
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|underlying_type
argument_list|)
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|underlying_type
argument_list|)
expr_stmt|;
comment|/* Convert each of the enumerators to the type of the underlying      type of the enumeration.  */
for|for
control|(
name|values
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
block|{
name|location_t
name|saved_location
decl_stmt|;
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|saved_location
operator|=
name|input_location
expr_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|perform_implicit_conversion
argument_list|(
name|underlying_type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|saved_location
expr_stmt|;
comment|/* Do not clobber shared ints.  */
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|namespace_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for an enumeration constant of the    enumeration type ENUMTYPE whose NAME and VALUE (if any) are provided.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|void
name|build_enumerator
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|enumtype
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* If the VALUE was erroneous, pretend it wasn't there; that will      result in the enum being assigned the next value in sequence.  */
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
name|value
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* Validate and default VALUE.  */
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
block|{
name|value
operator|=
name|integral_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|value
operator|=
name|perform_integral_promotions
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"enumerator value for %qD not integer constant"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Default based on previous value.  */
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|tree
name|prev_value
decl_stmt|;
name|bool
name|overflowed
decl_stmt|;
comment|/* The next value is the previous value plus one.  We can 		 safely assume that the previous value is an INTEGER_CST. 		 add_double doesn't know the type of the target expression, 		 so we must check with int_fits_type_p as well.  */
name|prev_value
operator|=
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|overflowed
operator|=
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|prev_value
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|prev_value
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|prev_value
argument_list|)
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|overflowed
operator||=
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|prev_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflowed
condition|)
block|{
name|error
argument_list|(
literal|"overflow in enumeration values at %qD"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
name|value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* Remove no-op casts from the value.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* C++ associates enums with global, function, or class declarations.  */
name|context
operator|=
name|current_scope
argument_list|()
expr_stmt|;
comment|/* Build the actual enumeration constant.  Note that the enumeration     constants have the type of their initializers until the     enumeration is complete:        [ dcl.enum ]        Following the closing brace of an enum-specifier, each enumer-       ator has the type of its enumeration.  Prior to the closing       brace, the type of each enumerator is the type of its       initializing value.      In finish_enum we will reset the type.  Of course, if we're     processing a template, there may be no value.  */
name|type
operator|=
name|value
condition|?
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|context
operator|==
name|current_class_type
condition|)
comment|/* This enum declaration is local to the class.  We need the full        lang_decl so that we can record DECL_CLASS_CONTEXT, for example.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
comment|/* It's a global enum, or it's local to a function.  (Note local to       a function could mean local to a class method.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|context
operator|==
name|current_class_type
condition|)
comment|/* In something like `struct S { enum E { i = 7 }; };' we put `i'        on the TYPE_FIELDS list for `S'.  (That's so that you can say        things like `S::i' later.)  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Add this enumeration constant to the list for this type.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We're defining DECL.  Make sure that it's type is OK.  */
end_comment

begin_function
specifier|static
name|void
name|check_function_type
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|current_function_parms
parameter_list|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|return_type
init|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
decl_stmt|;
comment|/* In a function definition, arg types must be complete.  */
name|require_complete_types_for_parms
argument_list|(
name|current_function_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|return_type
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|return_type
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"return type %q#T is incomplete"
argument_list|,
name|return_type
argument_list|)
expr_stmt|;
comment|/* Make it return void instead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|fntype
operator|=
name|build_method_type_directly
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|void_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fntype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     FLAGS is a bitwise or of SF_PRE_PARSED (indicating that the    DECLARATOR is really the DECL for the function we are about to    process and that DECLSPECS should be ignored), SF_INCLASS_INLINE    indicating that the function is an inline defined in-class.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     For C++, we must first check whether that datum makes any sense.    For example, "class A local_a(1,2);" means that variable local_a    is an aggregate of type A, which should have a constructor    applied to it with the argument list [1, 2].  */
end_comment

begin_function
name|void
name|start_preparsed_function
parameter_list|(
name|tree
name|decl1
parameter_list|,
name|tree
name|attrs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|restype
decl_stmt|;
name|int
name|doing_friend
init|=
literal|0
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|bl
decl_stmt|;
name|tree
name|current_function_parms
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|finfo
init|=
name|get_fileinfo
argument_list|(
name|LOCATION_FILE
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|honor_interface
decl_stmt|;
comment|/* Sanity check.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|void_list_node
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* ISO C++ 11.4/5.  A friend function defined in a class is in      the (lexical) scope of the class in which it is defined.  */
if|if
condition|(
operator|!
name|ctype
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|ctype
operator|=
name|DECL_FRIEND_CONTEXT
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* CTYPE could be null here if we're dealing with a template; 	 for example, `inline friend float foo()' inside a template 	 will have no CTYPE set.  */
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|doing_friend
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|attrs
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"inline function %q+D given attribute noinline"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
condition|)
comment|/* This is a constructor, we must ensure that any default args        introduced by this definition are propagated to the clones        now. The clones are used directly in overload resolution.  */
name|adjust_clone_args
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Sometimes we don't notice that a function is a static member, and      build a METHOD_TYPE for it.  Fix that up now.  */
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|revert_static_member_fn
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Set up current_class_type, and enter the scope of the class, if      appropriate.  */
if|if
condition|(
name|ctype
condition|)
name|push_nested_class
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that we have entered the scope of the class, we must restore      the bindings for any template parameters surrounding DECL1, if it      is an inline member template.  (Order is important; consider the      case where a template parameter has the same name as a field of      the class.)  It is not until after this point that      PROCESSING_TEMPLATE_DECL is guaranteed to be set up correctly.  */
if|if
condition|(
name|flags
operator|&
name|SF_INCLASS_INLINE
condition|)
name|maybe_begin_member_template_processing
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Effective C++ rule 15.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|warning
argument_list|(
name|OPT_Weffc__
argument_list|,
literal|"%<operator=%> should return a reference to %<*this%>"
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We must call push_template_decl after current_class_type is set      up.  (If we are processing inline definitions after exiting a      class scope, current_class_type will be NULL_TREE until set above      by push_nested_class.)  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* FIXME: Handle error_mark_node more gracefully.  */
name|tree
name|newdecl1
init|=
name|push_template_decl
argument_list|(
name|decl1
argument_list|)
decl_stmt|;
if|if
condition|(
name|newdecl1
operator|!=
name|error_mark_node
condition|)
name|decl1
operator|=
name|newdecl1
expr_stmt|;
block|}
comment|/* We are now in the scope of the function being defined.  */
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Make sure the parameter and return types are reasonable.  When      you declare a function, these types can be incomplete, but they      must be complete when you define the function.  */
name|check_function_type
argument_list|(
name|decl1
argument_list|,
name|current_function_parms
argument_list|)
expr_stmt|;
comment|/* Build the return declaration for the function.  */
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|restype
argument_list|)
condition|)
name|restype
operator|=
name|type_promotes_to
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|resdecl
decl_stmt|;
name|resdecl
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|resdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|resdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|resdecl
expr_stmt|;
name|cp_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|restype
argument_list|)
argument_list|,
name|resdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize RTL machinery.  We cannot do this until      CURRENT_FUNCTION_DECL and DECL_RESULT are set up.  We do this      even when processing a template; this is how we get      CFUN set up, and our per-function variables initialized.      FIXME factor out the non-RTL stuff.  */
name|bl
operator|=
name|current_binding_level
expr_stmt|;
name|allocate_struct_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|bl
expr_stmt|;
comment|/* Even though we're inside a function body, we still don't want to      call expand_expr to calculate the size of a variable-sized array.      We haven't necessarily assigned RTL to all variables yet, so it's      not safe to try to expand expressions involving them.  */
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|1
expr_stmt|;
comment|/* Start the statement-tree, start the tree now.  */
name|DECL_SAVED_TREE
argument_list|(
name|decl1
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
comment|/* Let the user know we're compiling this function.  */
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SF_PRE_PARSED
operator|)
condition|)
block|{
comment|/* A specialization is not used to guide overload resolution.  */
if|if
condition|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_USE_TEMPLATE
argument_list|(
name|decl1
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|olddecl
init|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
decl_stmt|;
if|if
condition|(
name|olddecl
operator|==
name|error_mark_node
condition|)
comment|/* If something went wrong when registering the declaration, 	       use DECL1; we have to have a FUNCTION_DECL to use when 	       parsing the body of the function.  */
empty_stmt|;
else|else
comment|/* Otherwise, OLDDECL is either a previous declaration of 	       the same function or DECL1 itself.  */
name|decl1
operator|=
name|olddecl
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to set the DECL_CONTEXT.  */
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* If #pragma weak applies, mark the decl appropriately now. 	 The pragma only applies to global functions.  Because 	 determining whether or not the #pragma applies involves 	 computing the mangled name for the declaration, we cannot 	 apply the pragma until after we have merged this declaration 	 with any previous declarations; if the original declaration 	 has a linkage specification, that specification applies to 	 the definition as well, and may affect the mangled name.  */
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
condition|)
name|maybe_apply_pragma_weak
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
comment|/* Reset these in case the call to pushdecl changed them.  */
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
name|cfun
operator|->
name|decl
operator|=
name|decl1
expr_stmt|;
comment|/* If we are (erroneously) defining a function that we have already      defined before, wipe out what we knew before.  */
if|if
condition|(
operator|!
name|DECL_PENDING_INLINE_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|decl1
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
operator|!
name|doing_friend
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
comment|/* We know that this was set up by `grokclassfn'.  We do not 	 wait until `store_parm_decls', since evil parse errors may 	 never get us to that point.  Here we keep the consistency 	 between `current_class_type' and `current_class_ptr'.  */
name|tree
name|t
init|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|cp_function_chain
operator|->
name|x_current_class_ref
operator|=
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp_function_chain
operator|->
name|x_current_class_ptr
operator|=
name|t
expr_stmt|;
comment|/* Constructors and destructors need to know whether they're "in 	 charge" of initializing virtual base classes.  */
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|current_in_charge_parm
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|vtt_parm_identifier
argument_list|)
expr_stmt|;
name|current_vtt_parm
operator|=
name|t
expr_stmt|;
block|}
block|}
name|honor_interface
operator|=
operator|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
comment|/* Implicitly-defined methods (like the 			destructor for a class in which no destructor 			is explicitly declared) must not be defined 			until their definition is needed.  So, we 			ignore interface specifications for 			compiler-generated functions.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|tree
name|ctx
init|=
name|decl_function_context
argument_list|(
name|decl1
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL_TREE
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|ctx
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|ctx
argument_list|)
condition|)
comment|/* This is a function in a local class in an extern inline 	   function.  */
name|comdat_linkage
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
comment|/* If this function belongs to an interface, it is public.      If it belongs to someone else's interface, it is also external.      This only affects inlines and template instantiations.  */
elseif|else
if|if
condition|(
operator|!
name|finfo
operator|->
name|interface_unknown
operator|&&
name|honor_interface
condition|)
block|{
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|||
name|processing_template_decl
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
operator|(
name|finfo
operator|->
name|interface_only
operator|||
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|decl1
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* For WIN32 we also want to put these in linkonce sections.  */
name|maybe_make_one_only
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this function is in an interface implemented in this file, 	 make sure that the backend knows to emit this function 	 here.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
condition|)
name|mark_needed
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|finfo
operator|->
name|interface_unknown
operator|&&
name|finfo
operator|->
name|interface_only
operator|&&
name|honor_interface
condition|)
block|{
comment|/* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma 	 interface, we will have both finfo->interface_unknown and 	 finfo->interface_only set.  In that case, we don't want to 	 use the normal heuristics because someone will supply a 	 #pragma implementation elsewhere, and deducing it here would 	 produce a conflict.  */
name|comdat_linkage
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a definition, not a reference. 	 So clear DECL_EXTERNAL.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
comment|/* Don't try to defer nested functions for now.  */
operator|&&
operator|!
name|decl_function_context
argument_list|(
name|decl1
argument_list|)
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Determine the ELF visibility attribute for the function.  We must not      do this before calling "pushdecl", as we must allow "duplicate_decls"      to merge any attributes appropriately.  We also need to wait until      linkage is set.  */
if|if
condition|(
operator|!
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|determine_visibility
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|begin_scope
argument_list|(
name|sk_function_parms
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
operator|++
name|function_depth
expr_stmt|;
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
operator|||
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
operator|)
condition|)
block|{
name|cdtor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|cdtor_label
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
block|}
name|start_fname_decls
argument_list|()
expr_stmt|;
name|store_parm_decls
argument_list|(
name|current_function_parms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like start_preparsed_function, except that instead of a    FUNCTION_DECL, this function takes DECLSPECS and DECLARATOR.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|,
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|tree
name|decl1
decl_stmt|;
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition,      cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl1
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|decl1
argument_list|)
condition|)
comment|/* main must return int.  grokfndecl should have corrected it        (and issued a diagnostic) if the user got it wrong.  */
name|gcc_assert
argument_list|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|start_preparsed_function
argument_list|(
name|decl1
argument_list|,
name|attrs
argument_list|,
comment|/*flags=*/
name|SF_DEFAULT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns true iff an EH_SPEC_BLOCK should be created in the body of    FN.  */
end_comment

begin_function
specifier|static
name|bool
name|use_eh_spec_block
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
return|return
operator|(
name|flag_exceptions
operator|&&
name|flag_enforce_eh_specs
operator|&&
operator|!
name|processing_template_decl
operator|&&
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
comment|/* We insert the EH_SPEC_BLOCK only in the original 	     function; then, it is copied automatically to the 	     clones.  */
operator|&&
operator|!
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fn
argument_list|)
comment|/* Implicitly-generated constructors and destructors have 	     exception specifications.  However, those specifications 	     are the union of the possible exceptions specified by the 	     constructors/destructors for bases and members, so no 	     unallowed exception will ever reach this function.  By 	     not creating the EH_SPEC_BLOCK we save a little memory, 	     and we avoid spurious warnings about unreachable 	     code.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     Also install to binding contour return value identifier, if any.  */
end_comment

begin_function
specifier|static
name|void
name|store_parm_decls
parameter_list|(
name|tree
name|current_function_parms
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|current_function_parms
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
name|tree
name|next
decl_stmt|;
comment|/* Must clear this because it might contain TYPE_DECLs declared 	     at class level.  */
name|current_binding_level
operator|->
name|names
operator|=
name|NULL
expr_stmt|;
comment|/* If we're doing semantic analysis, then we'll call pushdecl 	     for each of these.  We must do them in reverse order so that 	     they end in the correct forward order.  */
name|specparms
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter %qD declared void"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we find an enum constant or a type tag, 		 put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order and record in the 	 function.  This is all and only the PARM_DECLs that were 	 pushed into scope by the loop above.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
block|}
else|else
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now store the final chain of decls for the arguments      as the decl-chain of the current lexical scope.      Put the enumerators in as well, at the front so that      DECL_ARGUMENTS is not modified.  */
name|current_binding_level
operator|->
name|names
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_eh_spec_block
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|current_eh_spec_block
operator|=
name|begin_eh_spec_block
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have finished doing semantic analysis on DECL, but have not yet    generated RTL for its body.  Save away our current state, so that    when we want to generate RTL later we know what to do.  */
end_comment

begin_function
specifier|static
name|void
name|save_function_data
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|language_function
modifier|*
name|f
decl_stmt|;
comment|/* Save the language-specific per-function data so that we can      get it back when we really expand this function.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_PENDING_INLINE_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a copy.  */
name|f
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|language_function
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|cp_function_chain
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|language_function
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|decl
argument_list|)
operator|=
name|f
expr_stmt|;
comment|/* Clear out the bits we don't need.  */
name|f
operator|->
name|base
operator|.
name|x_stmt_tree
operator|.
name|x_cur_stmt_list
operator|=
name|NULL_TREE
expr_stmt|;
name|f
operator|->
name|bindings
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_local_names
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the return value of the constructor (if present).  */
end_comment

begin_function
specifier|static
name|void
name|finish_constructor_body
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|exprstmt
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
condition|)
block|{
comment|/* Any return from a constructor will end up here.  */
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_EXPR
argument_list|,
name|cdtor_label
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|val
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Return the address of the object.  */
name|exprstmt
operator|=
name|build_stmt
argument_list|(
name|RETURN_EXPR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do all the processing for the beginning of a destructor; set up the    vtable pointers and cleanups for bases and members.  */
end_comment

begin_function
specifier|static
name|void
name|begin_destructor_body
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|compound_stmt
decl_stmt|;
comment|/* If the CURRENT_CLASS_TYPE is incomplete, we will have already      issued an error message.  We still want to try to process the      body of the function, but initialize_vtbl_ptrs will crash if      TYPE_BINFO is NULL.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Make all virtual function table pointers in non-virtual base 	 classes point to CURRENT_CLASS_TYPE's virtual function 	 tables.  */
name|initialize_vtbl_ptrs
argument_list|(
name|current_class_ptr
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
comment|/* And insert cleanups for our bases and members so that they 	 will be properly destroyed if we throw.  */
name|push_base_cleanups
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* At the end of every destructor we generate code to delete the object if    necessary.  Do that now.  */
end_comment

begin_function
specifier|static
name|void
name|finish_destructor_body
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|exprstmt
decl_stmt|;
comment|/* Any return from a destructor will end up here; that way all base      and member cleanups will be run when the function returns.  */
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_EXPR
argument_list|,
name|cdtor_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In a virtual destructor, we must call delete.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|tree
name|if_stmt
decl_stmt|;
name|tree
name|virtual_size
init|=
name|cxx_sizeof
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
comment|/* [class.dtor]        At the point of definition of a virtual destructor (including       an implicit definition), non-placement operator delete shall       be looked up in the scope of the destructor's class and if       found shall be accessible and unambiguous.  */
name|exprstmt
operator|=
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|current_class_ptr
argument_list|,
name|virtual_size
argument_list|,
comment|/*global_p=*/
name|false
argument_list|,
comment|/*placement=*/
name|NULL_TREE
argument_list|,
comment|/*alloc_fn=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
condition|)
block|{
name|tree
name|val
decl_stmt|;
name|val
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|val
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Return the address of the object.  */
name|exprstmt
operator|=
name|build_stmt
argument_list|(
name|RETURN_EXPR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do the necessary processing for the beginning of a function body, which    in this case includes member-initializers, but not the catch clauses of    a function-try-block.  Currently, this means opening a binding level    for the member-initializers (in a ctor) and member cleanups (in a dtor).  */
end_comment

begin_function
name|tree
name|begin_function_body
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
operator|!
name|FUNCTION_NEEDS_BODY_BLOCK
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Do nothing now.  */
empty_stmt|;
else|else
comment|/* Always keep the BLOCK node associated with the outermost pair of        curly braces of a function.  These are needed for correct        operation of dwarfout.c.  */
name|keep_next_level
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_FN_BODY
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Do nothing now.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|begin_destructor_body
argument_list|()
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* Do the processing for the end of a function body.  Currently, this means    closing out the cleanups for fully-constructed bases and members, and in    the case of the destructor, deleting the object if desired.  Again, this    is only meaningful for [cd]tors, since they are the only functions where    there is a significant distinction between the main body and any    function catch clauses.  Handling, say, main() return semantics here    would be wrong, as flowing off the end of a function catch clause for    main() would also need to return 0.  */
end_comment

begin_function
name|void
name|finish_function_body
parameter_list|(
name|tree
name|compstmt
parameter_list|)
block|{
if|if
condition|(
name|compstmt
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* Close the block.  */
name|finish_compound_stmt
argument_list|(
name|compstmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Do nothing now.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_constructor_body
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_destructor_body
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a function, returns the BLOCK corresponding to the outermost level    of curly braces, skipping the artificial block created for constructor    initializers.  */
end_comment

begin_function
specifier|static
name|tree
name|outer_curly_brace_block
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|block
init|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|FUNCTION_NEEDS_BODY_BLOCK
argument_list|(
name|current_function_decl
argument_list|)
condition|)
comment|/* Skip the artificial function body block.  */
name|block
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     FLAGS is a bitwise or of the following values:      2 - INCLASS_INLINE        We just finished processing the body of an in-class inline        function definition.  (This processing will have taken place        after the class definition is complete.)  */
end_comment

begin_function
name|tree
name|finish_function
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
decl_stmt|,
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|inclass_inline
init|=
operator|(
name|flags
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|nested
decl_stmt|;
comment|/* When we get some parse errors, we can end up without a      current_function_decl, so cope.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|fnclass
init|=
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|fnclass
argument_list|)
condition|)
name|keyed_classes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fnclass
argument_list|,
name|keyed_classes
argument_list|)
expr_stmt|;
block|}
name|nested
operator|=
name|function_depth
operator|>
literal|1
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;       This caused&foo to be of type ptr-to-const-function       which then got a warning when stored in a ptr-to-function variable.  */
name|gcc_assert
argument_list|(
name|building_stmt_tree
argument_list|()
argument_list|)
expr_stmt|;
comment|/* For a cloned function, we've already got all the code we need;      there's no need to add any extra bits.  */
if|if
condition|(
operator|!
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Make it so that `main' always returns 0 by default (or 	     1 for VMS).  */
if|#
directive|if
name|VMS_TARGET
name|stmt
operator|=
name|finish_return_stmt
argument_list|(
name|integer_one_node
argument_list|)
expr_stmt|;
else|#
directive|else
name|stmt
operator|=
name|finish_return_stmt
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Hack.  We don't want the middle-end to warn that this 	     return is unreachable, so put the statement on the 	     special line 0.  */
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|UNKNOWN_LOCATION
argument_list|)
expr_stmt|;
else|#
directive|else
name|annotate_with_file_line
argument_list|(
name|stmt
argument_list|,
name|input_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|use_eh_spec_block
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_eh_spec_block
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_eh_spec_block
argument_list|)
expr_stmt|;
block|}
comment|/* If we're saving up tree structure, tie off the function now.  */
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|finish_fname_decls
argument_list|()
expr_stmt|;
comment|/* If this function can't throw any exceptions, remember that.  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|!
name|cp_function_chain
operator|->
name|can_throw
operator|&&
operator|!
name|flag_non_call_exceptions
operator|&&
operator|!
name|DECL_REPLACEABLE_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|TREE_NOTHROW
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This must come after expand_function_end because cleanups might      have declarations (from inline functions) that need to go into      this function's blocks.  */
comment|/* If the current binding level isn't the outermost binding level      for this function, either there is a bug, or we have experienced      syntax errors and the statement tree is malformed.  */
if|if
condition|(
name|current_binding_level
operator|->
name|kind
operator|!=
name|sk_function_parms
condition|)
block|{
comment|/* Make sure we have already experienced errors.  */
name|gcc_assert
argument_list|(
name|errorcount
argument_list|)
expr_stmt|;
comment|/* Throw away the broken statement tree and extra binding 	 levels.  */
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
while|while
condition|(
name|current_binding_level
operator|->
name|kind
operator|!=
name|sk_function_parms
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
else|else
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Statements should always be full-expressions at the outermost set      of curly braces for a function.  */
name|gcc_assert
argument_list|(
name|stmts_are_full_exprs_p
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set up the named return value optimization, if we can.  Candidate      variables are selected in check_return_expr.  */
if|if
condition|(
name|current_function_return_value
condition|)
block|{
name|tree
name|r
init|=
name|current_function_return_value
decl_stmt|;
name|tree
name|outer
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|error_mark_node
comment|/* This is only worth doing for fns that return in memory--and 	     simpler, since we don't have to worry about promoted modes.  */
operator|&&
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|fndecl
argument_list|)
comment|/* Only allow this for variables declared in the outer scope of 	     the function so we know that their lifetime always ends with a 	     return; see g++.dg/opt/nrv6.C.  We could be more flexible if 	     we were to do this optimization in tree-ssa.  */
operator|&&
operator|(
name|outer
operator|=
name|outer_curly_brace_block
argument_list|(
name|fndecl
argument_list|)
operator|)
operator|&&
name|chain_member
argument_list|(
name|r
argument_list|,
name|BLOCK_VARS
argument_list|(
name|outer
argument_list|)
argument_list|)
condition|)
name|finalize_nrv
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|r
argument_list|,
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Remember that we were in class scope.  */
if|if
condition|(
name|current_class_name
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point      to the FUNCTION_DECL node itself.  */
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Save away current state, if appropriate.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|save_function_data
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Complain if there's just no return statement.  */
if|if
condition|(
name|warn_return_type
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|&&
operator|!
name|current_function_returns_value
operator|&&
operator|!
name|current_function_returns_null
comment|/* Don't complain if we abort or throw.  */
operator|&&
operator|!
name|current_function_returns_abnormally
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
comment|/* Normally, with -Wreturn-type, flow will complain.  Unless we're an 	 inline function, as we might never be compiled separately.  */
operator|&&
operator|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|||
name|processing_template_decl
operator|)
comment|/* Structor return values (if any) are set by the compiler.  */
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wreturn_type
argument_list|,
literal|"no return statement in function returning non-void"
argument_list|)
expr_stmt|;
comment|/* Store the end of the function, so that we get good line number      info for the epilogue.  */
name|cfun
operator|->
name|function_end_locus
operator|=
name|input_location
expr_stmt|;
comment|/* Genericize before inlining.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|struct
name|language_function
modifier|*
name|f
init|=
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|cp_genericize
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Clear out the bits we don't need.  */
name|f
operator|->
name|x_current_class_ptr
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_current_class_ref
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_eh_spec_block
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_in_charge_parm
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_vtt_parm
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_return_value
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|bindings
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|extern_decl_map
operator|=
name|NULL
expr_stmt|;
comment|/* Handle attribute((warn_unused_result)).  Relies on gimple input.  */
name|c_warn_unused_result
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out the bits we don't need.  */
name|local_names
operator|=
name|NULL
expr_stmt|;
comment|/* We're leaving the context of this function, so zap cfun.  It's still in      DECL_STRUCT_FUNCTION, and we'll restore it in tree_rest_of_compilation.  */
name|cfun
operator|=
name|NULL
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
comment|/* If this is an in-class inline definition, we may have to pop the      bindings for the template parameters that we added in      maybe_begin_member_template_processing when start_function was      called.  */
if|if
condition|(
name|inclass_inline
condition|)
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
comment|/* Leave the scope of the class.  */
if|if
condition|(
name|ctype
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
operator|--
name|function_depth
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
operator|!
name|nested
condition|)
comment|/* Let the error reporting routines know that we're outside a        function.  For a nested function, this value is used in        cxx_pop_function_context and then reset via pop_function_context.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the return type and the name of the function,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns a FUNCTION_DECL on success.     If the DECLARATOR is not suitable for a function (it defines a datum    instead), we return 0, which tells yyparse to report a parse error.     May return void_type_node indicating that this method is actually    a friend.  See grokfield for more details.     Came here with a `.pushlevel' .     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `grokfield'.  */
end_comment

begin_function
name|tree
name|start_method
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|,
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|tree
name|attrlist
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
operator|&
name|attrlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fndecl
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"invalid member function declaration"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|attrlist
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|fndecl
argument_list|,
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pass friends other than inline friend functions back.  */
if|if
condition|(
name|fndecl
operator|==
name|void_type_node
condition|)
return|return
name|fndecl
return|;
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|error
argument_list|(
literal|"%qD is already defined in class %qT"
argument_list|,
name|fndecl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|check_template_shadow
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_default_inline
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We process method specializations in finish_struct_1.  */
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|fndecl
operator|=
name|push_template_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|error_mark_node
condition|)
return|return
name|fndecl
return|;
block|}
if|if
condition|(
operator|!
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|finish_decl
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Make a place for the parms.  */
name|begin_scope
argument_list|(
name|sk_function_parms
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Go through the motions of finishing a function definition.    We don't compile this method until after the whole class has    been processed.     FINISH_METHOD must return something that looks as though it    came from GROKFIELD (since we are defining a method, after all).     This is called after parsing the body of the function definition.    STMTS is the chain of statements that makes up the function body.     DECL is the ..._DECL that `start_method' provided.  */
end_comment

begin_function
name|tree
name|finish_method
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|decl
decl_stmt|;
name|tree
name|old_initial
decl_stmt|;
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|decl
return|;
name|old_initial
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the level for the parms (from start_method).      This is like poplevel, but it causes nothing to be      saved.  Saving information here confuses symbol-table      output routines.  Besides, this information will      be correctly output when this method is actually      compiled.  */
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|pop_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|!=
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|old_initial
expr_stmt|;
comment|/* We used to check if the context of FNDECL was different from      current_class_type as another way to get inside here.  This didn't work      for String.cc in libg++.  */
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VAR is a VAR_DECL.  If its type is incomplete, remember VAR so that    we can lay it out later, when and if its type becomes complete.  */
end_comment

begin_function
name|void
name|maybe_register_incomplete_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
comment|/* Keep track of variables with incomplete types.  */
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|inner_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|)
comment|/* RTTI TD entries are created while defining the type_info.  */
operator|||
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|inner_type
argument_list|)
operator|)
condition|)
name|incomplete_vars
operator|=
name|tree_cons
argument_list|(
name|inner_type
argument_list|,
name|var
argument_list|,
name|incomplete_vars
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called when a class type (given by TYPE) is defined.  If there are    any existing VAR_DECLs whose type hsa been completed by this    declaration, update them now.  */
end_comment

begin_function
name|void
name|complete_vars
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
modifier|*
name|list
init|=
operator|&
name|incomplete_vars
decl_stmt|;
name|gcc_assert
argument_list|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|list
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|list
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
comment|/* Complete the type of the variable.  The VAR_DECL itself 	     will be laid out in expand_expr.  */
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cp_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Remove this entry from the list.  */
operator|*
name|list
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
else|else
name|list
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* Check for pending declarations which may have abstract type.  */
name|complete_type_check_abstract
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup    here.  */
end_comment

begin_function
name|tree
name|cxx_maybe_build_cleanup
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|bool
name|has_vbases
init|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|rval
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|cxx_mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize for space over speed here.  */
if|if
condition|(
operator|!
name|has_vbases
operator|||
name|flag_expensive_optimizations
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
name|rval
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When a stmt has been parsed, this function is called.  */
end_comment

begin_function
name|void
name|finish_stmt
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* DECL was originally constructed as a non-static member function,    but turned out to be static.  Update it accordingly.  */
end_comment

begin_function
name|void
name|revert_static_member_fn
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|function
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|error
argument_list|(
literal|"static member function %q#D declared with type qualifiers"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_qualified_type
argument_list|(
name|tmp
argument_list|,
name|cp_type_quals
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_exception_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the variables used during compilation of a C++    function.  */
end_comment

begin_function
name|void
name|cxx_push_function_context
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|language_function
modifier|*
name|p
init|=
name|GGC_CNEW
argument_list|(
expr|struct
name|language_function
argument_list|)
decl_stmt|;
name|f
operator|->
name|language
operator|=
name|p
expr_stmt|;
comment|/* Whenever we start a new function, we destroy temporaries in the      usual way.  */
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|decl
condition|)
block|{
name|tree
name|fn
init|=
name|f
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If we already parsed this function, and we're just expanding it 	     now, restore saved state.  */
operator|*
name|cp_function_chain
operator|=
operator|*
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* We don't need the saved data anymore.  Unless this is an inline 	     function; we need the named return value info for 	     declare_return_variable.  */
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
condition|)
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free the language-specific parts of F, now that we've finished    compiling the function.  */
end_comment

begin_function
name|void
name|cxx_pop_function_context
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|f
operator|->
name|language
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return which tree structure is used by T, or TS_CP_GENERIC if T is    one of the language-independent trees.  */
end_comment

begin_function
name|enum
name|cp_tree_node_structure_enum
name|cp_tree_node_structure
parameter_list|(
name|union
name|lang_tree_node
modifier|*
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|&
name|t
operator|->
name|generic
argument_list|)
condition|)
block|{
case|case
name|DEFAULT_ARG
case|:
return|return
name|TS_CP_DEFAULT_ARG
return|;
case|case
name|IDENTIFIER_NODE
case|:
return|return
name|TS_CP_IDENTIFIER
return|;
case|case
name|OVERLOAD
case|:
return|return
name|TS_CP_OVERLOAD
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
return|return
name|TS_CP_TPI
return|;
case|case
name|TINST_LEVEL
case|:
return|return
name|TS_CP_TINST_LEVEL
return|;
case|case
name|PTRMEM_CST
case|:
return|return
name|TS_CP_PTRMEM
return|;
case|case
name|BASELINK
case|:
return|return
name|TS_CP_BASELINK
return|;
default|default:
return|return
name|TS_CP_GENERIC
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build the void_list_node (void_type_node having been created).  */
end_comment

begin_function
name|tree
name|build_void_list_node
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|bool
name|cp_missing_noreturn_ok_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* A missing noreturn is ok for the `main' function.  */
return|return
name|DECL_MAIN_P
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the COMDAT group into which DECL should be placed.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cxx_comdat_group
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
comment|/* Virtual tables, construction virtual tables, and virtual table      tables all go in a single COMDAT group, named after the primary      virtual table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|decl
argument_list|)
condition|)
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|CLASSTYPE_VTABLES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For all other DECLs, the COMDAT group is the mangled name of the      declaration itself.  */
else|else
block|{
while|while
condition|(
name|DECL_THUNK_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If TARGET_USE_LOCAL_THUNK_ALIAS_P, use_thunk puts the thunk 	     into the same section as the target function.  In that case 	     we must return target's name.  */
name|tree
name|target
init|=
name|THUNK_TARGET
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_USE_LOCAL_THUNK_ALIAS_P
argument_list|(
name|target
argument_list|)
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|target
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|target
argument_list|)
condition|)
name|decl
operator|=
name|target
expr_stmt|;
else|else
break|break;
block|}
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-decl.h"
end_include

end_unit

