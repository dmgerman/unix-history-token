begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Call-backs for C++ error reporting.    This code is non-reentrant.    Copyright (C) 1993, 94-97, 1998 Free Software Foundation, Inc.     This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_typedef
typedef|typedef
name|char
modifier|*
name|cp_printer
parameter_list|()
function_decl|;
end_typedef

begin_define
define|#
directive|define
name|A
value|args_as_string
end_define

begin_define
define|#
directive|define
name|C
value|code_as_string
end_define

begin_define
define|#
directive|define
name|D
value|decl_as_string
end_define

begin_define
define|#
directive|define
name|E
value|expr_as_string
end_define

begin_define
define|#
directive|define
name|L
value|language_as_string
end_define

begin_define
define|#
directive|define
name|O
value|op_as_string
end_define

begin_define
define|#
directive|define
name|P
value|parm_as_string
end_define

begin_define
define|#
directive|define
name|Q
value|assop_as_string
end_define

begin_define
define|#
directive|define
name|T
value|type_as_string
end_define

begin_define
define|#
directive|define
name|V
value|cv_as_string
end_define

begin_define
define|#
directive|define
name|o
value|(cp_printer *) 0
end_define

begin_decl_stmt
name|cp_printer
modifier|*
name|cp_printers
index|[
literal|256
index|]
init|=
block|{
comment|/*0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
comment|/* 0x00 */
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
comment|/* 0x10 */
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
comment|/* 0x20 */
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
comment|/* 0x30 */
name|o
block|,
name|A
block|,
name|o
block|,
name|C
block|,
name|D
block|,
name|E
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|L
block|,
name|o
block|,
name|o
block|,
name|O
block|,
comment|/* 0x40 */
name|P
block|,
name|Q
block|,
name|o
block|,
name|o
block|,
name|T
block|,
name|o
block|,
name|V
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
comment|/* 0x50 */
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
comment|/* 0x60 */
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
name|o
block|,
comment|/* 0x70 */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|C
end_undef

begin_undef
undef|#
directive|undef
name|D
end_undef

begin_undef
undef|#
directive|undef
name|E
end_undef

begin_undef
undef|#
directive|undef
name|L
end_undef

begin_undef
undef|#
directive|undef
name|O
end_undef

begin_undef
undef|#
directive|undef
name|P
end_undef

begin_undef
undef|#
directive|undef
name|Q
end_undef

begin_undef
undef|#
directive|undef
name|T
end_undef

begin_undef
undef|#
directive|undef
name|V
end_undef

begin_undef
undef|#
directive|undef
name|o
end_undef

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Obstack where we build text strings for overloading, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OB_INIT
parameter_list|()
value|(scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)
end_define

begin_define
define|#
directive|define
name|OB_PUTC
parameter_list|(
name|C
parameter_list|)
value|(obstack_1grow (&scratch_obstack, (C)))
end_define

begin_define
define|#
directive|define
name|OB_PUTC2
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|(obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))
end_define

begin_define
define|#
directive|define
name|OB_PUTS
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))
end_define

begin_define
define|#
directive|define
name|OB_PUTID
parameter_list|(
name|ID
parameter_list|)
define|\
value|(obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),	\ 		 IDENTIFIER_LENGTH (ID)))
end_define

begin_define
define|#
directive|define
name|OB_PUTCP
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), strlen (S)))
end_define

begin_define
define|#
directive|define
name|OB_FINISH
parameter_list|()
value|(obstack_1grow (&scratch_obstack, '\0'))
end_define

begin_define
define|#
directive|define
name|OB_PUTI
parameter_list|(
name|CST
parameter_list|)
value|do { sprintf (digit_buffer, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)(CST)); \ 			   OB_PUTCP (digit_buffer); } while (0)
end_define

begin_define
define|#
directive|define
name|OB_UNPUT
parameter_list|(
name|N
parameter_list|)
value|obstack_blank (&scratch_obstack, - (N));
end_define

begin_define
define|#
directive|define
name|NEXT_CODE
parameter_list|(
name|t
parameter_list|)
value|(TREE_CODE (TREE_TYPE (t)))
end_define

begin_enum
enum|enum
name|pad
block|{
name|none
block|,
name|before
block|,
name|after
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|dump_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_type_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_simple_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_function_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_expr
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_unary_op
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_binary_op
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_aggr_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_type_prefix
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_type_suffix
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_function_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_expr_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_global_iord
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_readonly_or_volatile
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|pad
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_char
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aggr_variety
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ident_fndecl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_error
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_readonly_or_volatile
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|enum
name|pad
name|p
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|before
condition|)
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|after
condition|)
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This must be large enough to hold any printed integer or floating-point    value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digit_buffer
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump into the obstack a human-readable equivalent of TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_type_real
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|,
name|canonical_name
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* verbose? */
name|int
name|canonical_name
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
goto|goto
name|offset_type
goto|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|OB_PUTS
argument_list|(
literal|"{error}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
name|OB_PUTS
argument_list|(
literal|"{unknown type}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
comment|/* i.e. function taking no arguments */
if|if
condition|(
name|t
operator|!=
name|void_list_node
condition|)
block|{
name|dump_type_real
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
comment|/* Can this happen other than for default arguments? */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|v
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|OB_PUTC2
argument_list|(
literal|','
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|dump_type_real
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|" ..."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|OB_PUTID
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_VEC
case|:
name|dump_type_real
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|t
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|dump_type_real
argument_list|(
name|SIGNATURE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
else|else
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_aggr_type
argument_list|(
name|t
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|OB_PUTS
argument_list|(
literal|"complex "
argument_list|)
expr_stmt|;
name|dump_type_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"unsigned "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"signed "
argument_list|)
expr_stmt|;
comment|/* fall through.  */
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
block|{
name|tree
name|type
decl_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|type
operator|=
name|canonical_name
condition|?
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
else|:
name|t
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Types like intQI_type_node and friends have no names. 	     These don't come up in user error messages, but it's nice 	     to be able to print them from the debugger.  */
name|OB_PUTS
argument_list|(
literal|"{anonymous}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* For parameters inside template signature. */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OB_PUTS
argument_list|(
literal|"{anonymous template template parm}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|args
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type_real
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|1
condition|)
name|OB_PUTC2
argument_list|(
literal|','
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OB_PUTS
argument_list|(
literal|"{anonymous template type parm}"
argument_list|)
expr_stmt|;
break|break;
comment|/* This is not always necessary for pointers and such, but doing this 	 reduces code size.  */
case|case
name|ARRAY_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|offset_type
label|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|t
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|t
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
name|OB_PUTS
argument_list|(
literal|"typename "
argument_list|)
expr_stmt|;
name|dump_type_real
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sorry
argument_list|(
literal|"`%s' not supported by dump_type"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|aggr_variety
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
literal|"enum"
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|"union"
return|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|"class"
return|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|"signature"
return|;
else|else
return|return
literal|"struct"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_type
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* verbose? */
block|{
name|dump_type_real
argument_list|(
name|t
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a class declaration, in the form `class foo'.  */
end_comment

begin_function
specifier|static
name|void
name|dump_aggr_type
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|,
name|canonical_name
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* verbose? */
name|int
name|canonical_name
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
name|char
modifier|*
name|variety
init|=
name|aggr_variety
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|OB_PUTCP
argument_list|(
name|variety
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|canonical_name
condition|?
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
else|:
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|DECL_CONTEXT
argument_list|(
name|name
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|name
argument_list|)
operator|!=
name|global_namespace
condition|)
block|{
comment|/* FUNCTION_DECL or RECORD_TYPE */
name|dump_decl
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
comment|/* kludge around weird behavior on g++.brendan/line1.C */
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
operator|||
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"{anonymous"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|variety
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
name|OB_PUTID
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump into the obstack the initial part of the output for a given type.    This is necessary when dealing with things like functions returning    functions.  Examples:     return type of `int (* fee ())()': pointer -> function -> int.  Both    pointer (and reference and offset) and function (and member) types must    deal with prefix and suffix.     Arrays must also do this for DECL nodes, like int a[], and for things like    int *[]&.  */
end_comment

begin_function
specifier|static
name|void
name|dump_type_prefix
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|,
name|canonical_name
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* verbosity */
name|int
name|canonical_name
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|offset_type
goto|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
block|{
name|tree
name|sub
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|dump_type_prefix
argument_list|(
name|sub
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
comment|/* A tree for a member pointer looks like pointer to offset, 	   so let the OFFSET_TYPE case handle it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
comment|/* We don't want int ( *)() */
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
break|break;
case|case
name|ARRAY_TYPE
case|:
name|OB_PUTC2
argument_list|(
literal|' '
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
comment|/* We don't want "char * *" */
if|if
condition|(
operator|!
operator|(
name|TYPE_READONLY
argument_list|(
name|sub
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|sub
argument_list|)
operator|)
condition|)
break|break;
comment|/* But we do want "char *const *" */
default|default:
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|none
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|sub
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|dump_type_prefix
argument_list|(
name|sub
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
name|OB_PUTC2
argument_list|(
literal|' '
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
comment|/* We don't want "char *&" */
if|if
condition|(
operator|!
operator|(
name|TYPE_READONLY
argument_list|(
name|sub
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|sub
argument_list|)
operator|)
condition|)
break|break;
comment|/* But we do want "char *const&" */
default|default:
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|none
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|offset_type
label|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
comment|/* pmfs deal with this in d_t_p */
block|{
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dump_type_real
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|none
argument_list|)
expr_stmt|;
break|break;
comment|/* Can only be reached through function pointer -- this would not be          correct if FUNCTION_DECLs used it.  */
case|case
name|FUNCTION_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|' '
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|' '
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_aggr_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TREE_LIST
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|TREE_VEC
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|UNKNOWN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
name|dump_type_real
argument_list|(
name|t
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sorry
argument_list|(
literal|"`%s' not supported by dump_type_prefix"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_type_suffix
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|,
name|canonical_name
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* verbose? */
name|int
name|canonical_name
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
comment|/* Can only be reached through function pointer */
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|arg
decl_stmt|;
name|OB_PUTC2
argument_list|(
literal|')'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|dump_type
argument_list|(
name|arg
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|OB_PUTI
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TREE_LIST
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|TREE_VEC
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|UNKNOWN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
break|break;
default|default:
name|sorry
argument_list|(
literal|"`%s' not supported by dump_type_suffix"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a function declaration which corresponds to the IDENTIFIER_NODE    argument.  */
end_comment

begin_function
specifier|static
name|tree
name|ident_fndecl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|n
init|=
name|lookup_name
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|n
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
return|;
name|my_friendly_abort
argument_list|(
literal|66
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|GLOBAL_THING
value|"_GLOBAL_$"
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DOT_IN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|GLOBAL_THING
value|"_GLOBAL_."
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GLOBAL_THING
value|"_GLOBAL__"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GLOBAL_IORD_P
parameter_list|(
name|NODE
parameter_list|)
define|\
value|! strncmp (IDENTIFIER_POINTER(NODE), GLOBAL_THING, sizeof (GLOBAL_THING) - 1)
end_define

begin_function
specifier|static
name|void
name|dump_global_iord
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"(static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
sizeof|sizeof
argument_list|(
name|GLOBAL_THING
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'I'
condition|)
name|OB_PUTS
argument_list|(
literal|"initializers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
sizeof|sizeof
argument_list|(
name|GLOBAL_THING
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'D'
condition|)
name|OB_PUTS
argument_list|(
literal|"destructors"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|352
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" for "
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_simple_decl
parameter_list|(
name|t
parameter_list|,
name|type
parameter_list|,
name|v
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|dump_type_prefix
argument_list|(
name|type
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|OB_PUTS
argument_list|(
literal|"{anon}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0
condition|)
name|dump_type_suffix
argument_list|(
name|type
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_decl
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* verbosity */
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|OB_PUTS
argument_list|(
literal|" /* decl error */ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
block|{
comment|/* Don't say 'typedef class A' */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|v
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
comment|/* Say `class T' not just `T'. */
name|OB_PUTS
argument_list|(
literal|"class "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|v
operator|>
literal|0
condition|)
name|OB_PUTS
argument_list|(
literal|"typedef "
argument_list|)
expr_stmt|;
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|VTABLE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"vtable for "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
case|case
name|FIELD_DECL
case|:
case|case
name|PARM_DECL
case|:
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|global_namespace
condition|)
block|{
name|dump_decl
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
comment|/* So that we can do dump_decl in dump_aggr_type and have it work for 	 both class and function scope.  */
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_type
argument_list|(
name|t
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
name|my_friendly_abort
argument_list|(
literal|69
argument_list|)
expr_stmt|;
break|break;
comment|/* These special cases are duplicated here so that other functions 	 can feed identifiers to cp_error and get them demangled properly.  */
case|case
name|IDENTIFIER_NODE
case|:
block|{
name|tree
name|f
decl_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|f
operator|=
name|ident_fndecl
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|f
argument_list|)
operator|==
name|lang_cplusplus
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|f
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
comment|/* Not exactly IDENTIFIER_TYPE_VALUE.  */
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name_string
init|=
name|operator_name_string
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|name_string
argument_list|)
expr_stmt|;
block|}
else|else
name|OB_PUTID
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|GLOBAL_IORD_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|dump_global_iord
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"{internal}"
argument_list|)
expr_stmt|;
else|else
name|dump_function_decl
argument_list|(
name|t
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_DECL
case|:
block|{
name|tree
name|orig_args
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|args
operator|=
name|orig_args
operator|=
name|nreverse
argument_list|(
name|orig_args
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"template<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|defval
init|=
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"class "
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"class"
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_decl
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|defval
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|defval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|defval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC2
argument_list|(
literal|','
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|OB_UNPUT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'>'
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|nreverse
argument_list|(
name|orig_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|my_friendly_abort
argument_list|(
literal|353
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
name|dump_function_decl
argument_list|(
name|t
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This case can occur with some illegal code.  */
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|args
decl_stmt|;
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
condition|)
name|OB_PUTC2
argument_list|(
literal|','
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOOKUP_EXPR
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|||
operator|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
operator|)
condition|)
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OB_PUTS
argument_list|(
literal|"enumerator"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING_DECL
case|:
name|OB_PUTS
argument_list|(
literal|"using "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sorry
argument_list|(
literal|"`%s' not supported by dump_decl"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pretty printing for announce_function.  T is the declaration of the    function we are interested in seeing.  V is non-zero if we should print    the type that this function returns.  */
end_comment

begin_function
specifier|static
name|void
name|dump_function_decl
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|cname
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Friends have DECL_CLASS_CONTEXT set, but not DECL_CONTEXT.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|cname
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* this is for partially instantiated template methods */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|cname
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|>
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cname
condition|)
block|{
name|dump_type
argument_list|(
name|cname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|parmtypes
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Skip past "in_charge" identifier.  */
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|name
argument_list|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|==
name|lang_cplusplus
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|dump_function_name
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtypes
condition|)
name|dump_type
argument_list|(
name|parmtypes
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&&
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|cname
argument_list|)
condition|)
comment|/* We look at the type pointed to by the `optr' field of `this.'  */
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|before
argument_list|)
expr_stmt|;
else|else
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the function name for a FUNCTION_DECL node, grokking operators    and destructors properly.  */
end_comment

begin_function
specifier|static
name|void
name|dump_function_name
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* There ought to be a better way to find out whether or not something is      a destructor.  */
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|==
name|lang_cplusplus
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* This cannot use the hack that the operator's return 	 type is stashed off of its name because it may be 	 used for error reporting.  In the case of conflicting 	 declarations, both will have the same name, yet 	 the types will be different, hence the TREE_TYPE field 	 of the first name will be clobbered by the second.  */
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name_string
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|name_string
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_decl
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
comment|/* This next clause checks that there is only one level of 	     template arguments.  In that case, they are the 	     arguments for the class context.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|TREE_VEC
operator|)
operator|)
condition|)
comment|/* We have something like this: 	    	   template<class T> struct S { void f(); }; 	    	   and we are printing S<int>::f().  This is a template 	   instantiation, but we don't print anything after the f.  */
empty_stmt|;
else|else
block|{
name|OB_PUTC
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
comment|/* Be careful only to print things when we have them, so as not 	     to crash producing error messages.  */
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|arg
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_comma
condition|)
name|OB_PUTS
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|||
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|args
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|a
init|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_comma
condition|)
name|OB_PUTS
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|||
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|OB_PUTC
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TARGET_NEWLINE
case|:
name|OB_PUTS
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_TAB
case|:
name|OB_PUTS
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_VT
case|:
name|OB_PUTS
argument_list|(
literal|"\\v"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_BS
case|:
name|OB_PUTS
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_CR
case|:
name|OB_PUTS
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_FF
case|:
name|OB_PUTS
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_BELL
case|:
name|OB_PUTS
argument_list|(
literal|"\\a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|OB_PUTS
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|OB_PUTS
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|OB_PUTS
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print out a list of initializers (subr of dump_expr) */
end_comment

begin_function
specifier|static
name|void
name|dump_expr_list
parameter_list|(
name|l
parameter_list|)
name|tree
name|l
decl_stmt|;
block|{
while|while
condition|(
name|l
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
condition|)
name|OB_PUTC2
argument_list|(
literal|','
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|l
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out an expression */
end_comment

begin_function
specifier|static
name|void
name|dump_expr
parameter_list|(
name|t
parameter_list|,
name|nop
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|nop
decl_stmt|;
comment|/* suppress parens */
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|NAMESPACE_DECL
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|type
operator|!=
literal|0
argument_list|,
literal|81
argument_list|)
expr_stmt|;
comment|/* If it's an enum, output its tag, rather than its value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|enum_name_string
argument_list|(
name|t
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|OB_PUTCP
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|boolean_false_node
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|OB_PUTS
argument_list|(
literal|"false"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|boolean_true_node
condition|)
name|OB_PUTS
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|dump_char
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|tree
name|val
init|=
name|t
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|-
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Would "%x%0*x" or "%x%*0x" get zero-padding on all 	       systems?  */
block|{
specifier|static
name|char
name|format
index|[
literal|10
index|]
decl_stmt|;
comment|/* "%x%09999x\0" */
if|if
condition|(
operator|!
name|format
index|[
literal|0
index|]
condition|)
name|sprintf
argument_list|(
name|format
argument_list|,
literal|"%%x%%0%dx"
argument_list|,
name|HOST_BITS_PER_INT
operator|/
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
name|format
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTI
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REAL_CST
case|:
ifndef|#
directive|ifndef
name|REAL_IS_NOT_DOUBLE
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"%g"
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|digit_buffer
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|t
operator|)
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|digit_buffer
operator|+
literal|2
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
block|{
name|char
modifier|*
name|p
init|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|dump_char
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|","
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" ? "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" : "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"new "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PARM_DECL_EXPR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AGGR_INIT_EXPR
case|:
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_expr_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|ob
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|ob
argument_list|)
argument_list|)
argument_list|,
literal|"this"
argument_list|)
condition|)
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'-'
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
block|}
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEW_EXPR
case|:
block|{
name|tree
name|type
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"new "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_index_type
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TARGET_EXPR
case|:
comment|/* Note that this only works for G++ target exprs.  If somebody 	 builds a general TARGET_EXPR, there's no way to represent that 	 it initializes anything other that the parameter slot for the 	 default argument.  Note we may have cleared out the first 	 operand in expand_expr, so don't go killing ourselves.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|dump_binary_op
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"/"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"%"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|ob
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|ob
operator|=
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|ob
argument_list|)
argument_list|)
argument_list|,
literal|"this"
argument_list|)
condition|)
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'-'
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_REF
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONVERT_EXPR
case|:
name|dump_unary_op
argument_list|(
literal|"+"
argument_list|,
name|t
argument_list|,
name|nop
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"&"
argument_list|,
name|t
argument_list|,
name|nop
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|237
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nop
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"*"
argument_list|,
name|t
argument_list|,
name|nop
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
name|dump_unary_op
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|t
argument_list|,
name|nop
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* FIXME: This is a KLUDGE workaround for a parsing problem.  There 	 should be another level of INDIRECT_REF so that I don't have to do 	 this.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|next
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|next
operator|=
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|nop
condition|)
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nop
condition|)
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else FALLTHRU */
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nop
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|idx
init|=
name|build_component_ref
argument_list|(
name|t
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|idx
argument_list|)
condition|)
block|{
name|tree
name|pfn
init|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|dump_expr
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|idx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|virtuals
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|/* Map vtable index back one, to allow for the null pointer to 		 member.  */
operator|--
name|n
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|virtuals
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|virtuals
condition|)
block|{
name|dump_expr
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|OB_PUTC
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_REF
case|:
block|{
name|tree
name|ob
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* A::f */
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" .* "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|dump_decl
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|OB_PUTID
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAST_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOOKUP_EXPR
case|:
name|OB_PUTID
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARROW_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nop
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SIZEOF_EXPR
condition|)
name|OB_PUTS
argument_list|(
literal|"sizeof ("
argument_list|)
expr_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ALIGNOF_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"__alignof__ ("
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"*"
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFAULT_ARG
case|:
name|OB_PUTS
argument_list|(
literal|"{unparsed}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nop
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' does not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|sorry
argument_list|(
literal|"`%s' not supported by dump_expr"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* fall through to ERROR_MARK...  */
case|case
name|ERROR_MARK
case|:
name|OB_PUTCP
argument_list|(
literal|"{error}"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|opstring
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_unary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|,
name|nop
parameter_list|)
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|nop
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|nop
condition|)
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|opstring
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nop
condition|)
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|fndecl_as_string
parameter_list|(
name|fndecl
parameter_list|,
name|print_ret_type_p
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|print_ret_type_p
decl_stmt|;
block|{
return|return
name|decl_as_string
argument_list|(
name|fndecl
argument_list|,
name|print_ret_type_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same, but handle a _TYPE.    Called from convert_to_reference, mangle_class_name_for_template,    build_unary_op, and GNU_xref_decl.  If CANONICAL_NAME is non-zero,    when describing a typedef, we use the name of the type described,    rather than the name of the typedef.  */
end_comment

begin_function
name|char
modifier|*
name|type_as_string_real
parameter_list|(
name|typ
parameter_list|,
name|v
parameter_list|,
name|canonical_name
parameter_list|)
name|tree
name|typ
decl_stmt|;
name|int
name|v
decl_stmt|;
name|int
name|canonical_name
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|dump_type_real
argument_list|(
name|typ
argument_list|,
name|v
argument_list|,
name|canonical_name
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|type_as_string
parameter_list|(
name|typ
parameter_list|,
name|v
parameter_list|)
name|tree
name|typ
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
return|return
name|type_as_string_real
argument_list|(
name|typ
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|expr_as_string
parameter_list|(
name|decl
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|dump_expr
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A cross between type_as_string and fndecl_as_string.    Only called from substitute_nice_name.  */
end_comment

begin_function
name|char
modifier|*
name|decl_as_string
parameter_list|(
name|decl
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|decl
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the three forms of printable names for lang_printable_name.  */
end_comment

begin_function
name|char
modifier|*
name|lang_decl_name
parameter_list|(
name|decl
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|>=
literal|2
condition|)
return|return
name|decl_as_string
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
return|;
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|1
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|cname
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cname
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|cname
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|cname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|dump_function_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cp_file_of
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|DECL_SOURCE_FILE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
return|return
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
else|else
return|return
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|cp_line_of
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|line
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
name|lineno
return|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|code_as_string
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|enum
name|tree_code
name|c
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|tree_code_name
index|[
name|c
index|]
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|language_as_string
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|enum
name|languages
name|c
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|lang_c
case|:
return|return
literal|"C"
return|;
case|case
name|lang_cplusplus
case|:
return|return
literal|"C++"
return|;
case|case
name|lang_java
case|:
return|return
literal|"Java"
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|355
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the proper printed version of a parameter to a C++ function.  */
end_comment

begin_function
name|char
modifier|*
name|parm_as_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|int
name|p
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|<
literal|0
condition|)
return|return
literal|"`this'"
return|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"%d"
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|digit_buffer
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|op_as_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|enum
name|tree_code
name|p
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[]
init|=
literal|"operator                "
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|"{unknown}"
return|;
name|strcpy
argument_list|(
name|buf
operator|+
literal|9
argument_list|,
name|opname_tab
index|[
name|p
index|]
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|assop_as_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|enum
name|tree_code
name|p
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[]
init|=
literal|"operator                "
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|"{unknown}"
return|;
name|strcpy
argument_list|(
name|buf
operator|+
literal|9
argument_list|,
name|assignop_tab
index|[
name|p
index|]
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|args_as_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|tree
name|p
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL_TREE
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
return|return
name|type_as_string
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
return|;
name|OB_INIT
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|==
name|null_node
condition|)
name|OB_PUTS
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
else|else
name|dump_type
argument_list|(
name|error_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cv_as_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|tree
name|p
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|p
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

end_unit

