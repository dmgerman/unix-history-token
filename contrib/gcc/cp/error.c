begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Call-backs for C++ error reporting.    This code is non-reentrant.    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002    Free Software Foundation, Inc.    This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_enum
enum|enum
name|pad
block|{
name|none
block|,
name|before
block|,
name|after
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|sorry_for_unsupported_tree
parameter_list|(
name|T
parameter_list|)
define|\
value|sorry ("`%s' not supported by %s", tree_code_name[(int) TREE_CODE (T)], \              __FUNCTION__)
end_define

begin_define
define|#
directive|define
name|print_scope_operator
parameter_list|(
name|BUFFER
parameter_list|)
value|output_add_string ((BUFFER), "::")
end_define

begin_define
define|#
directive|define
name|print_left_paren
parameter_list|(
name|BUFFER
parameter_list|)
value|output_add_character ((BUFFER), '(')
end_define

begin_define
define|#
directive|define
name|print_right_paren
parameter_list|(
name|BUFFER
parameter_list|)
value|output_add_character ((BUFFER), ')')
end_define

begin_define
define|#
directive|define
name|print_left_bracket
parameter_list|(
name|BUFFER
parameter_list|)
value|output_add_character ((BUFFER), '[')
end_define

begin_define
define|#
directive|define
name|print_right_bracket
parameter_list|(
name|BUFFER
parameter_list|)
value|output_add_character ((BUFFER), ']')
end_define

begin_define
define|#
directive|define
name|print_template_argument_list_start
parameter_list|(
name|BUFFER
parameter_list|)
define|\
value|print_non_consecutive_character ((BUFFER), '<')
end_define

begin_define
define|#
directive|define
name|print_template_argument_list_end
parameter_list|(
name|BUFFER
parameter_list|)
define|\
value|print_non_consecutive_character ((BUFFER), '>')
end_define

begin_define
define|#
directive|define
name|print_whitespace
parameter_list|(
name|BUFFER
parameter_list|,
name|TFI
parameter_list|)
define|\
value|do {                                      \      output_add_space (BUFFER);              \      put_whitespace (TFI) = none;            \    } while (0)
end_define

begin_define
define|#
directive|define
name|print_tree_identifier
parameter_list|(
name|BUFFER
parameter_list|,
name|TID
parameter_list|)
define|\
value|output_add_string ((BUFFER), IDENTIFIER_POINTER (TID))
end_define

begin_define
define|#
directive|define
name|print_identifier
parameter_list|(
name|BUFFER
parameter_list|,
name|ID
parameter_list|)
value|output_add_string ((BUFFER), (ID))
end_define

begin_define
define|#
directive|define
name|separate_with_comma
parameter_list|(
name|BUFFER
parameter_list|)
value|output_add_string ((BUFFER), ", ")
end_define

begin_comment
comment|/* The global buffer where we dump everything.  It is there only for    transitional purpose.  It is expected, in the near future, to be    completely removed.  */
end_comment

begin_decl_stmt
specifier|static
name|output_buffer
name|scratch_buffer_rec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|output_buffer
modifier|*
name|scratch_buffer
init|=
operator|&
name|scratch_buffer_rec
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_CODE
parameter_list|(
name|T
parameter_list|)
value|(TREE_CODE (TREE_TYPE (T)))
end_define

begin_define
define|#
directive|define
name|reinit_global_formatting_buffer
parameter_list|()
define|\
value|output_clear_message_text (scratch_buffer)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|args_to_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|assop_to_string
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|code_to_string
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cv_to_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|decl_to_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|expr_to_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fndecl_to_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|op_to_string
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|parm_to_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|type_to_string
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_typename
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_simple_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_template_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_function_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_unary_op
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_binary_op
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_aggr_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|pad
name|dump_type_prefix
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_type_suffix
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_function_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_expr_list
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_global_iord
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|pad
name|dump_qualifiers
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|pad
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_char
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_parameters
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_exception_spec
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|class_key_or_enum
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_template_argument
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_template_argument_list
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_template_parameter
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_template_bindings
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_template_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|function_category
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_print_error_function
name|PARAMS
argument_list|(
operator|(
name|diagnostic_context
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_print_instantiation_context
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_instantiation_full_context
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_instantiation_partial_context
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_diagnostic_starter
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|diagnostic_context
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_diagnostic_finalizer
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|diagnostic_context
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_print_error_function
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|diagnostic_context
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_printer
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_non_consecutive_character
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_integer
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|locate_error
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_error
parameter_list|()
block|{
name|print_error_function
operator|=
name|lang_print_error_function
expr_stmt|;
name|diagnostic_starter
argument_list|(
name|global_dc
argument_list|)
operator|=
name|cp_diagnostic_starter
expr_stmt|;
name|diagnostic_finalizer
argument_list|(
name|global_dc
argument_list|)
operator|=
name|cp_diagnostic_finalizer
expr_stmt|;
name|diagnostic_format_decoder
argument_list|(
name|global_dc
argument_list|)
operator|=
name|cp_printer
expr_stmt|;
name|init_output_buffer
argument_list|(
name|scratch_buffer
argument_list|,
comment|/* prefix */
name|NULL
argument_list|,
comment|/* line-width */
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a scope, if deemed necessary.  */
end_comment

begin_function
specifier|static
name|void
name|dump_scope
parameter_list|(
name|scope
parameter_list|,
name|flags
parameter_list|)
name|tree
name|scope
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|f
init|=
operator|~
name|TFF_RETURN_TYPE
operator|&
operator|(
name|flags
operator|&
operator|(
name|TFF_SCOPE
operator||
name|TFF_CHASE_TYPEDEF
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|scope
operator|!=
name|global_namespace
condition|)
block|{
name|dump_decl
argument_list|(
name|scope
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|scope
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_SCOPE
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|dump_function_decl
argument_list|(
name|scope
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump type qualifiers, providing padding as requested. Return an    indication of whether we dumped something.  */
end_comment

begin_function
specifier|static
name|enum
name|pad
name|dump_qualifiers
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|enum
name|pad
name|p
decl_stmt|;
block|{
specifier|static
specifier|const
name|int
name|masks
index|[]
init|=
block|{
name|TYPE_QUAL_CONST
block|,
name|TYPE_QUAL_VOLATILE
block|,
name|TYPE_QUAL_RESTRICT
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|names
index|[]
init|=
block|{
literal|"const"
block|,
literal|"volatile"
block|,
literal|"__restrict"
block|}
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|int
name|quals
init|=
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|do_after
init|=
name|p
operator|==
name|after
decl_stmt|;
if|if
condition|(
name|quals
condition|)
block|{
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
literal|3
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|masks
index|[
name|ix
index|]
operator|&
name|quals
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|before
condition|)
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|p
operator|=
name|before
expr_stmt|;
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|names
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_after
condition|)
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|none
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* This must be large enough to hold any printed integer or floating-point    value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digit_buffer
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump the template ARGument under control of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_argument
parameter_list|(
name|arg
parameter_list|,
name|flags
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|arg
argument_list|,
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|arg
argument_list|,
operator|(
name|flags
operator||
name|TFF_EXPR_IN_PARENS
operator|)
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a template-argument-list ARGS (always a TREE_VEC) under control    of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_argument_list
parameter_list|(
name|args
parameter_list|,
name|flags
parameter_list|)
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_template_argument
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump a template parameter PARM (a TREE_LIST) under control of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_parameter
parameter_list|(
name|parm
parameter_list|,
name|flags
parameter_list|)
name|tree
name|parm
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|a
init|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
block|{
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
condition|)
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"{template default argument error}"
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_decl
argument_list|(
name|p
argument_list|,
name|flags
operator||
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
operator|)
operator|&&
name|a
operator|!=
name|NULL_TREE
condition|)
block|{
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|a
argument_list|,
name|flags
operator|&
operator|~
name|TFF_CHASE_TYPEDEF
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|a
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump, under control of FLAGS, a template-parameter-list binding.    PARMS is a TREE_LIST of TREE_VEC of TREE_LIST and ARGS is a    TREE_VEC.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_bindings
parameter_list|(
name|parms
parameter_list|,
name|args
parameter_list|)
name|tree
name|parms
decl_stmt|,
name|args
decl_stmt|;
block|{
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|lvl
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|arg_idx
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|p
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Don't crash if we had an invalid argument list.  */
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|>=
name|lvl
condition|)
block|{
name|tree
name|lvl_args
init|=
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|lvl
argument_list|)
decl_stmt|;
if|if
condition|(
name|NUM_TMPL_ARGS
argument_list|(
name|lvl_args
argument_list|)
operator|>
name|arg_idx
condition|)
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|lvl_args
argument_list|,
name|arg_idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_comma
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_template_parameter
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|dump_template_argument
argument_list|(
name|arg
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
else|else
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<missing>"
argument_list|)
expr_stmt|;
operator|++
name|arg_idx
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump into the obstack a human-readable equivalent of TYPE.  FLAGS    controls the format.  */
end_comment

begin_function
specifier|static
name|void
name|dump_type
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
goto|goto
name|offset_type
goto|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|UNKNOWN_TYPE
case|:
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<unknown type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
comment|/* A list of function parms.  */
name|dump_parameters
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_VEC
case|:
name|dump_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_aggr_type
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|flags
operator|&
name|TFF_CHASE_TYPEDEF
condition|)
block|{
name|dump_type
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fallthrough */
case|case
name|TEMPLATE_DECL
case|:
case|case
name|NAMESPACE_DECL
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"__complex__ "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"vector "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"unsigned "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"signed "
argument_list|)
expr_stmt|;
comment|/* fall through.  */
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
block|{
name|tree
name|type
decl_stmt|;
name|dump_qualifiers
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|type
operator|=
name|flags
operator|&
name|TFF_CHASE_TYPEDEF
condition|?
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
else|:
name|t
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Types like intQI_type_node and friends have no names. 	     These don't come up in user error messages, but it's nice 	     to be able to print them from the debugger.  */
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
comment|/* For parameters inside template signature. */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<anonymous template template parameter>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
block|{
name|tree
name|args
init|=
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|print_template_argument_list_start
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_template_argument_list
argument_list|(
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_template_argument_list_end
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|dump_qualifiers
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<anonymous template type parameter>"
argument_list|)
expr_stmt|;
break|break;
comment|/* This is not always necessary for pointers and such, but doing this 	 reduces code size.  */
case|case
name|ARRAY_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|offset_type
label|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|dump_type_prefix
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TYPENAME_TYPE
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"typename "
argument_list|)
expr_stmt|;
name|dump_typename
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
name|dump_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"template "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPEOF_TYPE
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"__typeof ("
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sorry_for_unsupported_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Fall through to error. */
case|case
name|ERROR_MARK
case|:
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<type error>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dump a TYPENAME_TYPE. We need to notice when the context is itself    a TYPENAME_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_typename
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|ctx
init|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|dump_typename
argument_list|(
name|ctx
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_type
argument_list|(
name|ctx
argument_list|,
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name of the supplied aggregate, or enumeral type.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|class_key_or_enum
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
literal|"enum"
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|"union"
return|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|"class"
return|;
else|else
return|return
literal|"struct"
return|;
block|}
end_function

begin_comment
comment|/* Print out a class declaration T under the control of FLAGS,    in the form `class foo'.  */
end_comment

begin_function
specifier|static
name|void
name|dump_aggr_type
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|variety
init|=
name|class_key_or_enum
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|typdef
init|=
literal|0
decl_stmt|;
name|int
name|tmplate
init|=
literal|0
decl_stmt|;
name|dump_qualifiers
argument_list|(
name|t
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_CLASS_KEY_OR_ENUM
condition|)
block|{
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|variety
argument_list|)
expr_stmt|;
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TFF_CHASE_TYPEDEF
condition|)
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|typdef
operator|=
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tmplate
operator|=
operator|!
name|typdef
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|name
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_SCOPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplate
condition|)
block|{
comment|/* Because the template names are mangled, we have to locate              the most general template, and use that name.  */
name|tree
name|tpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tpl
argument_list|)
condition|)
name|tpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|tpl
argument_list|)
expr_stmt|;
name|name
operator|=
name|tpl
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
operator|||
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_CLASS_KEY_OR_ENUM
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
else|else
name|output_printf
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<anonymous %s>"
argument_list|,
name|variety
argument_list|)
expr_stmt|;
block|}
else|else
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplate
condition|)
name|dump_template_parms
argument_list|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|,
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_TEMPLATE_HEADER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump into the obstack the initial part of the output for a given type.    This is necessary when dealing with things like functions returning    functions.  Examples:     return type of `int (* fee ())()': pointer -> function -> int.  Both    pointer (and reference and offset) and function (and member) types must    deal with prefix and suffix.     Arrays must also do this for DECL nodes, like int a[], and for things like    int *[]&.     Return indicates how you should pad an object name after this. I.e. you    want to pad non-*, non-& cores, but not pad * or& types.  */
end_comment

begin_function
specifier|static
name|enum
name|pad
name|dump_type_prefix
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|enum
name|pad
name|padding
init|=
name|before
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|offset_type
goto|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|sub
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|padding
operator|=
name|dump_type_prefix
argument_list|(
name|sub
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* A tree for a member pointer looks like pointer to offset, 	   so let the OFFSET_TYPE case handle it.  */
if|if
condition|(
operator|!
name|TYPE_PTRMEM_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|"&*"
index|[
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
index|]
argument_list|)
expr_stmt|;
name|padding
operator|=
name|dump_qualifiers
argument_list|(
name|t
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OFFSET_TYPE
case|:
name|offset_type
label|:
name|padding
operator|=
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
comment|/* pmfs deal with this in d_t_p */
block|{
if|if
condition|(
name|padding
operator|!=
name|none
condition|)
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|padding
operator|=
name|dump_qualifiers
argument_list|(
name|t
argument_list|,
name|none
argument_list|)
expr_stmt|;
break|break;
comment|/* Can only be reached through function pointer -- this would not be          correct if FUNCTION_DECLs used it.  */
case|case
name|FUNCTION_TYPE
case|:
name|padding
operator|=
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|padding
operator|!=
name|none
condition|)
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|padding
operator|=
name|none
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|padding
operator|=
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|padding
operator|!=
name|none
condition|)
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|padding
operator|=
name|none
expr_stmt|;
name|dump_aggr_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|padding
operator|=
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TREE_LIST
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|TREE_VEC
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|UNKNOWN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
name|dump_type
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|padding
operator|=
name|before
expr_stmt|;
break|break;
default|default:
name|sorry_for_unsupported_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* fall through.  */
case|case
name|ERROR_MARK
case|:
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<typeprefixerror>"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|padding
return|;
block|}
end_function

begin_comment
comment|/* Dump the suffix of type T, under control of FLAGS.  This is the part    which appears after the identifier (or function parms).  */
end_comment

begin_function
specifier|static
name|void
name|dump_type_suffix
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
comment|/* Can only be reached through function pointer */
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|arg
decl_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Function pointers don't have default args.  Not in standard C++, 	   anyway; they may in g++, but we'll just pretend otherwise.  */
name|dump_parameters
argument_list|(
name|arg
argument_list|,
name|flags
operator|&
operator|~
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|dump_qualifiers
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|dump_exception_spec
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
name|print_left_bracket
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|print_integer
argument_list|(
name|scratch_buffer
argument_list|,
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|fold
argument_list|(
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
name|print_right_bracket
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TREE_LIST
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|TREE_VEC
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|UNKNOWN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
break|break;
default|default:
name|sorry_for_unsupported_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|ERROR_MARK
case|:
comment|/* Don't mark it here, we should have already done in          dump_type_prefix.  */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_global_iord
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_GLOBAL_CTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|p
operator|=
literal|"initializers"
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_GLOBAL_DTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|p
operator|=
literal|"destructors"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|output_printf
argument_list|(
name|scratch_buffer
argument_list|,
literal|"(static %s for %s)"
argument_list|,
name|p
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_simple_decl
parameter_list|(
name|t
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
block|{
if|if
condition|(
name|dump_type_prefix
argument_list|(
name|type
argument_list|,
name|flags
argument_list|)
operator|!=
name|none
condition|)
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
name|dump_type_suffix
argument_list|(
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a human readable string for the decl T under control of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_decl
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
block|{
comment|/* Don't say 'typedef class A' */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
comment|/* Say `class T' not just `T'. */
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|VTABLE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"vtable for "
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|20010720
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
case|case
name|FIELD_DECL
case|:
case|case
name|PARM_DECL
case|:
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<return value> "
argument_list|)
expr_stmt|;
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|anonymous_namespace_name
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<unnamed>"
argument_list|)
expr_stmt|;
else|else
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_left_bracket
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_bracket
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
comment|/* So that we can do dump_decl on an aggr type.  */
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_type
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
break|break;
comment|/* These special cases are duplicated here so that other functions 	 can feed identifiers to error and get them demangled properly.  */
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
comment|/* Not exactly IDENTIFIER_TYPE_VALUE.  */
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERLOAD
case|:
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_GLOBAL_CTOR_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_GLOBAL_DTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|dump_global_iord
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<internal>"
argument_list|)
expr_stmt|;
else|else
name|dump_function_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_DECL
case|:
name|dump_template_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|args
decl_stmt|;
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_template_argument_list_start
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|dump_template_argument
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
name|print_template_argument_list_end
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOOKUP_EXPR
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|||
operator|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
operator|)
condition|)
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
else|else
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"enumerator"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING_DECL
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"using "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sorry_for_unsupported_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Fallthrough to error.  */
case|case
name|ERROR_MARK
case|:
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<declaration error>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dump a template declaration T under control of FLAGS. This means the    'template<...> leaders plus the 'class X' or 'void fn(...)' part.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_decl
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|orig_parms
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_TEMPLATE_HEADER
condition|)
block|{
for|for
control|(
name|parms
operator|=
name|orig_parms
operator|=
name|nreverse
argument_list|(
name|orig_parms
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|inner_parms
init|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
decl_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"template<"
argument_list|)
expr_stmt|;
comment|/* If we've shown the template prefix, we'd better show the 	     parameters' and decl's type too.  */
name|flags
operator||=
name|TFF_DECL_SPECIFIERS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_template_parameter
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|print_template_argument_list_end
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
name|nreverse
argument_list|(
name|orig_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Say `template<arg> class TT' not just `template<arg> TT'. */
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|(
operator|(
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
operator|)
operator||
name|TFF_TEMPLATE_NAME
operator||
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|?
name|TFF_CLASS_KEY_OR_ENUM
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|dump_decl
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_TEMPLATE_NAME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
switch|switch
condition|(
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
name|dump_function_decl
argument_list|(
name|t
argument_list|,
name|flags
operator||
name|TFF_TEMPLATE_NAME
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This case can occur with some illegal code.  */
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|(
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
operator|)
operator||
name|TFF_TEMPLATE_NAME
operator||
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|?
name|TFF_CLASS_KEY_OR_ENUM
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pretty print a function decl. There are several ways we want to print a    function declaration. The TFF_ bits in FLAGS tells us how to behave.    As error can only apply the '#' flag once to give 0 and 1 for V, there    is %D which doesn't print the throw specs, and %F which does. */
end_comment

begin_function
specifier|static
name|void
name|dump_function_decl
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|fntype
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|cname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|template_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|template_parms
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|show_return
init|=
name|flags
operator|&
name|TFF_RETURN_TYPE
operator|||
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Pretty print template instantiations only.  */
if|if
condition|(
name|DECL_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|template_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|&&
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|template_parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|t
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|cname
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* this is for partially instantiated template methods */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|cname
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
operator|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|t
argument_list|)
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"virtual "
argument_list|)
expr_stmt|;
comment|/* Print the return type?  */
if|if
condition|(
name|show_return
condition|)
name|show_return
operator|=
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_return
condition|)
block|{
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Print the function name.  */
if|if
condition|(
name|cname
condition|)
block|{
name|dump_type
argument_list|(
name|cname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_function_name
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
name|dump_parameters
argument_list|(
name|parmtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|dump_qualifiers
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_EXCEPTION_SPECIFICATION
condition|)
name|dump_exception_spec
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_return
condition|)
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* If T is a template instantiation, dump the parameter binding.  */
if|if
condition|(
name|template_parms
operator|!=
name|NULL_TREE
operator|&&
name|template_args
operator|!=
name|NULL_TREE
condition|)
block|{
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|" [with "
argument_list|)
expr_stmt|;
name|dump_template_bindings
argument_list|(
name|template_parms
argument_list|,
name|template_args
argument_list|)
expr_stmt|;
name|print_right_bracket
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a parameter list. If this is for a member function, the    member object ptr (and any other hidden args) should have    already been removed. */
end_comment

begin_function
specifier|static
name|void
name|dump_parameters
parameter_list|(
name|parmtypes
parameter_list|,
name|flags
parameter_list|)
name|tree
name|parmtypes
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|first
decl_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|first
operator|=
literal|1
init|;
name|parmtypes
operator|!=
name|void_list_node
condition|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parmtypes
condition|)
block|{
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
break|break;
block|}
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
operator|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
block|}
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an exception specification. T is the exception specification. */
end_comment

begin_function
specifier|static
name|void
name|dump_exception_spec
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|t
condition|)
block|{
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|" throw ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
break|break;
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the function name for a FUNCTION_DECL node, grokking operators    and destructors properly.  */
end_comment

begin_function
specifier|static
name|void
name|dump_function_name
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Don't let the user see __comp_ctor et al.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|name
operator|=
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|name
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* This cannot use the hack that the operator's return 	 type is stashed off of its name because it may be 	 used for error reporting.  In the case of conflicting 	 declarations, both will have the same name, yet 	 the types will be different, hence the TREE_TYPE field 	 of the first name will be clobbered by the second.  */
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
name|dump_template_parms
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|,
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the template parameters from the template info INFO under control of    FLAGS. PRIMARY indicates whether this is a primary template decl, or    specialization (partial or complete). For partial specializations we show    the specialized parameter values. For a primary template we show no    decoration.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_parms
parameter_list|(
name|info
parameter_list|,
name|primary
parameter_list|,
name|flags
parameter_list|)
name|tree
name|info
decl_stmt|;
name|int
name|primary
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|args
init|=
name|info
condition|?
name|TI_ARGS
argument_list|(
name|info
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|primary
operator|&&
name|flags
operator|&
name|TFF_TEMPLATE_NAME
condition|)
return|return;
name|flags
operator|&=
operator|~
operator|(
name|TFF_CLASS_KEY_OR_ENUM
operator||
name|TFF_TEMPLATE_NAME
operator|)
expr_stmt|;
name|print_template_argument_list_start
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
comment|/* Be careful only to print things when we have them, so as not 	 to crash producing error messages.  */
if|if
condition|(
name|args
operator|&&
operator|!
name|primary
condition|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|ix
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|args
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ix
operator|!=
name|len
operator|&&
name|args
condition|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_comma
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<template parameter error>"
argument_list|)
expr_stmt|;
else|else
name|dump_template_argument
argument_list|(
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|primary
condition|)
block|{
name|tree
name|tpl
init|=
name|TI_TEMPLATE
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tpl
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ix
decl_stmt|;
name|parms
operator|=
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
condition|?
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|len
operator|=
name|parms
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|len
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|ix
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ix
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|parm
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
block|}
block|}
name|print_template_argument_list_end
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TARGET_NEWLINE
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_TAB
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_VT
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\v"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_BS
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_CR
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_FF
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_BELL
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print out a list of initializers (subr of dump_expr) */
end_comment

begin_function
specifier|static
name|void
name|dump_expr_list
parameter_list|(
name|l
parameter_list|,
name|flags
parameter_list|)
name|tree
name|l
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
while|while
condition|(
name|l
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|l
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out an expression E under control of FLAGS. */
end_comment

begin_function
specifier|static
name|void
name|dump_expr
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|NAMESPACE_DECL
case|:
case|case
name|OVERLOAD
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|type
operator|!=
literal|0
argument_list|,
literal|81
argument_list|)
expr_stmt|;
comment|/* If it's an enum, output its tag, rather than its value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|tree
name|values
init|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
break|break;
if|if
condition|(
name|values
condition|)
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Value must have been cast.  */
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
goto|goto
name|do_int
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|boolean_false_node
operator|||
name|integer_zerop
argument_list|(
name|t
argument_list|)
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|boolean_true_node
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
block|{
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|dump_char
argument_list|(
name|tree_low_cst
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_int
label|:
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|val
init|=
name|t
decl_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_int_2
argument_list|(
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|+
operator|!
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Would "%x%0*x" or "%x%*0x" get zero-padding on all 	           systems?  */
block|{
specifier|static
name|char
name|format
index|[
literal|10
index|]
decl_stmt|;
comment|/* "%x%09999x\0" */
if|if
condition|(
operator|!
name|format
index|[
literal|0
index|]
condition|)
name|sprintf
argument_list|(
name|format
argument_list|,
literal|"%%x%%0%dx"
argument_list|,
name|HOST_BITS_PER_INT
operator|/
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
name|format
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|print_integer
argument_list|(
name|scratch_buffer
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REAL_CST
case|:
ifndef|#
directive|ifndef
name|REAL_IS_NOT_DOUBLE
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"%g"
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|digit_buffer
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|t
operator|)
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|digit_buffer
operator|+
literal|2
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
name|digit_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTRMEM_CST
case|:
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|PTRMEM_CST_CLASS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|dump_char
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|" ? "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"new "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AGGR_INIT_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_expr_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|ob
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|ob
argument_list|)
argument_list|)
argument_list|,
literal|"this"
argument_list|)
condition|)
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
block|}
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|fn
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEW_EXPR
case|:
block|{
name|tree
name|type
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
condition|)
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"new "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_index_type
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TARGET_EXPR
case|:
comment|/* Note that this only works for G++ target exprs.  If somebody 	 builds a general TARGET_EXPR, there's no way to represent that 	 it initializes anything other that the parameter slot for the 	 default argument.  Note we may have cleared out the first 	 operand in expand_expr, so don't go killing ourselves.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
name|dump_binary_op
argument_list|(
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
operator|.
name|name
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"/"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"%"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|ob
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|ob
operator|=
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|ob
argument_list|)
argument_list|)
argument_list|,
literal|"this"
argument_list|)
condition|)
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_REF
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_left_bracket
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_right_bracket
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONVERT_EXPR
case|:
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_unary_op
argument_list|(
literal|"+"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
comment|/* An ADDR_EXPR can have reference type.  In that case, we 	     shouldn't print the `&' doing so indicates to the user 	     that the expression has pointer type.  */
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"&"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|237
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|NEXT_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"*"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
name|dump_unary_op
argument_list|(
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
operator|.
name|name
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* FIXME: This is a KLUDGE workaround for a parsing problem.  There 	 should be another level of INDIRECT_REF so that I don't have to do 	 this.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|next
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|next
operator|=
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else FALLTHRU */
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_WITH_FILE_LOCATION
case|:
name|dump_expr
argument_list|(
name|EXPR_WFL_NODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|idx
init|=
name|build_component_ref
argument_list|(
name|t
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|idx
argument_list|)
condition|)
block|{
comment|/* A NULL pointer-to-member constant.  */
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"(("
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|") 0)"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|idx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|virtuals
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|tree_low_cst
argument_list|(
name|idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Map vtable index back one, to allow for the null pointer to 		 member.  */
operator|--
name|n
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|virtuals
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|virtuals
condition|)
block|{
name|dump_expr
argument_list|(
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_REF
case|:
block|{
name|tree
name|ob
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_dummy_object
argument_list|(
name|ob
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* A::f */
name|dump_expr
argument_list|(
name|t
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BASELINK_P
argument_list|(
name|t
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"->*"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|".*"
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|dump_decl
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAST_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|")("
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATIC_CAST_EXPR
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"static_cast<"
argument_list|)
expr_stmt|;
goto|goto
name|cast
goto|;
case|case
name|REINTERPRET_CAST_EXPR
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"reinterpret_cast<"
argument_list|)
expr_stmt|;
goto|goto
name|cast
goto|;
case|case
name|CONST_CAST_EXPR
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"const_cast<"
argument_list|)
expr_stmt|;
goto|goto
name|cast
goto|;
case|case
name|DYNAMIC_CAST_EXPR
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"dynamic_cast<"
argument_list|)
expr_stmt|;
name|cast
label|:
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|">("
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOKUP_EXPR
case|:
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARROW_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SIZEOF_EXPR
condition|)
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"sizeof ("
argument_list|)
expr_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ALIGNOF_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"__alignof__ ("
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"*"
argument_list|,
name|t
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFAULT_ARG
case|:
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<unparsed>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PSEUDO_DTOR_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"::~"
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_EXPR
case|:
comment|/* We don't yet have a way of dumping statements in a 	 human-readable format.  */
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"({...})"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOP_EXPR
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"while (1) { "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|scratch_buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_EXPR
case|:
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|"if ("
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|scratch_buffer
argument_list|,
literal|") break; "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|print_tree_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' does not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|sorry_for_unsupported_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* fall through to ERROR_MARK...  */
case|case
name|ERROR_MARK
case|:
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<expression error>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|opstring
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|opstring
argument_list|)
expr_stmt|;
else|else
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"<unknown operator>"
argument_list|)
expr_stmt|;
name|output_add_space
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_unary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|print_left_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
name|opstring
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|print_right_paren
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exported interface to stringifying types, exprs and decls under TFF_*    control.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|type_as_string
parameter_list|(
name|typ
parameter_list|,
name|flags
parameter_list|)
name|tree
name|typ
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_type
argument_list|(
name|typ
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|expr_as_string
parameter_list|(
name|decl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_expr
argument_list|(
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|decl_as_string
parameter_list|(
name|decl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|context_as_string
parameter_list|(
name|context
parameter_list|,
name|flags
parameter_list|)
name|tree
name|context
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_scope
argument_list|(
name|context
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the three forms of printable names for lang_printable_name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|lang_decl_name
parameter_list|(
name|decl
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|>=
literal|2
condition|)
return|return
name|decl_as_string
argument_list|(
name|decl
argument_list|,
name|TFF_DECL_SPECIFIERS
argument_list|)
return|;
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|1
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
name|print_scope_operator
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|dump_function_name
argument_list|(
name|decl
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|cp_file_of
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|DECL_SOURCE_FILE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
return|return
name|DECL_SOURCE_FILE
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
else|else
return|return
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|cp_line_of
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|line
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
name|lineno
return|;
return|return
name|line
return|;
block|}
end_function

begin_comment
comment|/* Now the interfaces from error et al to dump_type et al. Each takes an    on/off VERBOSE flag and supply the appropriate TFF_ flags to a dump_    function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|decl_to_string
parameter_list|(
name|decl
parameter_list|,
name|verbose
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|flags
operator|=
name|TFF_CLASS_KEY_OR_ENUM
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator||=
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_RETURN_TYPE
expr_stmt|;
name|flags
operator||=
name|TFF_TEMPLATE_HEADER
expr_stmt|;
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|expr_to_string
parameter_list|(
name|decl
parameter_list|,
name|verbose
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_expr
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fndecl_to_string
parameter_list|(
name|fndecl
parameter_list|,
name|verbose
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|TFF_EXCEPTION_SPECIFICATION
operator||
name|TFF_DECL_SPECIFIERS
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
expr_stmt|;
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|fndecl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|code_to_string
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|enum
name|tree_code
name|c
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|tree_code_name
index|[
name|c
index|]
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|language_to_string
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|enum
name|languages
name|c
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|lang_c
case|:
return|return
literal|"C"
return|;
case|case
name|lang_cplusplus
case|:
return|return
literal|"C++"
return|;
case|case
name|lang_java
case|:
return|return
literal|"Java"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the proper printed version of a parameter to a C++ function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parm_to_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|int
name|p
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|<
literal|0
condition|)
return|return
literal|"`this'"
return|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"%d"
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|digit_buffer
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|op_to_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|enum
name|tree_code
name|p
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|p
index|]
operator|.
name|identifier
expr_stmt|;
return|return
name|id
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
else|:
literal|"{unknown}"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_to_string
parameter_list|(
name|typ
parameter_list|,
name|verbose
parameter_list|)
name|tree
name|typ
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_CLASS_KEY_OR_ENUM
expr_stmt|;
name|flags
operator||=
name|TFF_TEMPLATE_HEADER
expr_stmt|;
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_type
argument_list|(
name|typ
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|assop_to_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|enum
name|tree_code
name|p
decl_stmt|;
name|int
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|p
index|]
operator|.
name|identifier
expr_stmt|;
return|return
name|id
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
else|:
literal|"{unknown}"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|args_to_string
parameter_list|(
name|p
parameter_list|,
name|verbose
parameter_list|)
name|tree
name|p
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_CLASS_KEY_OR_ENUM
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL_TREE
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|type_as_string
argument_list|(
name|p
argument_list|,
name|flags
argument_list|)
return|;
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|==
name|null_node
condition|)
name|print_identifier
argument_list|(
name|scratch_buffer
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
else|else
name|dump_type
argument_list|(
name|error_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
condition|)
name|separate_with_comma
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cv_to_string
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|tree
name|p
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|reinit_global_formatting_buffer
argument_list|()
expr_stmt|;
name|dump_qualifiers
argument_list|(
name|p
argument_list|,
name|v
condition|?
name|before
else|:
name|none
argument_list|)
expr_stmt|;
return|return
name|output_finalize_message
argument_list|(
name|scratch_buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lang_print_error_function
parameter_list|(
name|context
parameter_list|,
name|file
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|output_state
name|os
decl_stmt|;
name|default_print_error_function
argument_list|(
name|context
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|os
operator|=
name|output_buffer_state
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|maybe_print_instantiation_context
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|context
argument_list|)
operator|=
name|os
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cp_diagnostic_starter
parameter_list|(
name|buffer
parameter_list|,
name|dc
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|diagnostic_context
modifier|*
name|dc
decl_stmt|;
block|{
name|report_problematic_module
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cp_print_error_function
argument_list|(
name|buffer
argument_list|,
name|dc
argument_list|)
expr_stmt|;
name|maybe_print_instantiation_context
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
name|buffer
argument_list|,
name|context_as_prefix
argument_list|(
name|diagnostic_file_location
argument_list|(
name|dc
argument_list|)
argument_list|,
name|diagnostic_line_location
argument_list|(
name|dc
argument_list|)
argument_list|,
name|diagnostic_is_warning
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|cp_diagnostic_finalizer
argument_list|(
name|buffer
argument_list|,
name|dc
argument_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|diagnostic_context
modifier|*
name|dc
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|output_destroy_prefix
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print current function onto BUFFER, in the process of reporting    a diagnostic message.  Called from cp_diagnostic_starter.  */
end_comment

begin_function
specifier|static
name|void
name|cp_print_error_function
parameter_list|(
name|buffer
parameter_list|,
name|dc
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|diagnostic_context
modifier|*
name|dc
decl_stmt|;
block|{
if|if
condition|(
name|error_function_changed
argument_list|()
condition|)
block|{
name|char
modifier|*
name|prefix
init|=
name|diagnostic_file_location
argument_list|(
name|dc
argument_list|)
condition|?
name|file_name_as_prefix
argument_list|(
name|diagnostic_file_location
argument_list|(
name|dc
argument_list|)
argument_list|)
else|:
name|NULL
decl_stmt|;
name|output_state
name|os
decl_stmt|;
name|os
operator|=
name|output_buffer_state
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
name|buffer
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
name|output_add_string
argument_list|(
name|buffer
argument_list|,
literal|"At global scope:"
argument_list|)
expr_stmt|;
else|else
name|output_printf
argument_list|(
name|buffer
argument_list|,
literal|"In %s `%s':"
argument_list|,
name|function_category
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|record_last_error_function
argument_list|()
expr_stmt|;
name|output_destroy_prefix
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|buffer
argument_list|)
operator|=
name|os
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns a description of FUNCTION using standard terminology.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|function_category
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"static member function"
return|;
elseif|else
if|if
condition|(
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"copy constructor"
return|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"constructor"
return|;
elseif|else
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"destructor"
return|;
else|else
return|return
literal|"member function"
return|;
block|}
else|else
return|return
literal|"function"
return|;
block|}
end_function

begin_comment
comment|/* Report the full context of a current template instantiation,    onto BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|print_instantiation_full_context
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|tree
name|p
init|=
name|current_instantiation
argument_list|()
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|!=
name|TINST_DECL
argument_list|(
name|p
argument_list|)
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
comment|/* We can get here during the processing of some synthesized 	   method.  Then, TINST_DECL (p) will be the function that's causing 	   the synthesis.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|TINST_DECL
argument_list|(
name|p
argument_list|)
condition|)
comment|/* Avoid redundancy with the the "In function" line.  */
empty_stmt|;
else|else
name|output_verbatim
argument_list|(
name|buffer
argument_list|,
literal|"%s: In instantiation of `%s':\n"
argument_list|,
name|file
argument_list|,
name|decl_as_string
argument_list|(
name|TINST_DECL
argument_list|(
name|p
argument_list|)
argument_list|,
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_RETURN_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|TINST_LINE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|file
operator|=
name|TINST_FILE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|print_instantiation_partial_context
argument_list|(
name|buffer
argument_list|,
name|p
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as above but less verbose.  */
end_comment

begin_function
specifier|static
name|void
name|print_instantiation_partial_context
parameter_list|(
name|buffer
parameter_list|,
name|t
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|tree
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|output_verbatim
argument_list|(
name|buffer
argument_list|,
literal|"%s:%d:   instantiated from `%s'\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|decl_as_string
argument_list|(
name|TINST_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_RETURN_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|TINST_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|file
operator|=
name|TINST_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|output_verbatim
argument_list|(
name|buffer
argument_list|,
literal|"%s:%d:   instantiated from here\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from cp_thing to print the template context for an error.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_print_instantiation_context
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|problematic_instantiation_changed
argument_list|()
operator|||
name|current_instantiation
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|record_last_problematic_instantiation
argument_list|()
expr_stmt|;
name|print_instantiation_full_context
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report the bare minimum context of a template instantiation.  */
end_comment

begin_function
name|void
name|print_instantiation_context
parameter_list|()
block|{
name|print_instantiation_partial_context
argument_list|(
name|diagnostic_buffer
argument_list|,
name|current_instantiation
argument_list|()
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|flush_diagnostic_buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from output_format -- during diagnostic message processing --    to handle C++ specific format specifier with the following meanings:    %A   function argument-list.    %C	tree code.    %D   declaration.    %E   expression.    %F   function declaration.    %L	language as used in extern "lang".    %O	binary operator.    %P   function parameter whose position is indicated by an integer.    %Q	assignment operator.    %T   type.    %V   cv-qualifier.  */
end_comment

begin_function
specifier|static
name|int
name|cp_printer
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|int
name|verbose
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
define|#
directive|define
name|next_tree
value|va_arg (output_buffer_format_args (buffer), tree)
define|#
directive|define
name|next_tcode
value|va_arg (output_buffer_format_args (buffer), enum tree_code)
define|#
directive|define
name|next_lang
value|va_arg (output_buffer_format_args (buffer), enum languages)
define|#
directive|define
name|next_int
value|va_arg (output_buffer_format_args (buffer), int)
if|if
condition|(
operator|*
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|==
literal|'+'
condition|)
operator|++
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|==
literal|'#'
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
operator|++
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
case|case
literal|'A'
case|:
name|result
operator|=
name|args_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|result
operator|=
name|code_to_string
argument_list|(
name|next_tcode
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|result
operator|=
name|decl_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|result
operator|=
name|expr_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|result
operator|=
name|fndecl_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|result
operator|=
name|language_to_string
argument_list|(
name|next_lang
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|result
operator|=
name|op_to_string
argument_list|(
name|next_tcode
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|result
operator|=
name|parm_to_string
argument_list|(
name|next_int
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|result
operator|=
name|assop_to_string
argument_list|(
name|next_tcode
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|result
operator|=
name|type_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|result
operator|=
name|cv_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
undef|#
directive|undef
name|next_tree
undef|#
directive|undef
name|next_tcode
undef|#
directive|undef
name|next_lang
undef|#
directive|undef
name|next_int
block|}
end_function

begin_function
specifier|static
name|void
name|print_integer
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|i
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_non_consecutive_character
parameter_list|(
name|buffer
parameter_list|,
name|c
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|output_last_position
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|==
name|c
condition|)
name|output_add_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_add_character
argument_list|(
name|buffer
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These are temporary wrapper functions which handle the historic    behavior of cp_*_at.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_error
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|tree
name|here
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|;
name|int
name|plus
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|msgid
init|;
operator|*
name|f
condition|;
name|f
operator|++
control|)
block|{
name|plus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|f
operator|==
literal|'%'
condition|)
block|{
name|f
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|f
operator|==
literal|'+'
condition|)
name|f
operator|++
operator|,
name|plus
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|f
operator|==
literal|'#'
condition|)
name|f
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
comment|/* Just ignore these possibilities.  */
case|case
literal|'%'
case|:
break|break;
case|case
literal|'d'
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|enum
name|languages
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'O'
case|:
case|case
literal|'Q'
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
break|break;
comment|/* These take a tree, which may be where the error is 		 located.  */
case|case
literal|'A'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'P'
case|:
case|case
literal|'T'
case|:
case|case
literal|'V'
case|:
name|t
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|here
operator|||
name|plus
condition|)
name|here
operator|=
name|t
expr_stmt|;
break|break;
default|default:
name|errorcount
operator|=
literal|0
expr_stmt|;
comment|/* damn ICE suppression */
name|internal_error
argument_list|(
literal|"unexpected letter `%c' in locate_error\n"
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|here
operator|==
literal|0
condition|)
name|here
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|)
expr_stmt|;
return|return
name|here
return|;
block|}
end_function

begin_decl_stmt
name|void
name|cp_error_at
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|tree
name|here
decl_stmt|;
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|here
operator|=
name|locate_error
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|cp_file_of
argument_list|(
name|here
argument_list|)
argument_list|,
name|cp_line_of
argument_list|(
name|here
argument_list|)
argument_list|,
comment|/* warning = */
literal|0
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|cp_warning_at
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|tree
name|here
decl_stmt|;
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|here
operator|=
name|locate_error
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|cp_file_of
argument_list|(
name|here
argument_list|)
argument_list|,
name|cp_line_of
argument_list|(
name|here
argument_list|)
argument_list|,
comment|/* warning = */
literal|1
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|cp_pedwarn_at
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|tree
name|here
decl_stmt|;
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|here
operator|=
name|locate_error
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|cp_file_of
argument_list|(
name|here
argument_list|)
argument_list|,
name|cp_line_of
argument_list|(
name|here
argument_list|)
argument_list|,
comment|/* warning = */
operator|!
name|flag_pedantic_errors
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

end_unit

