begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Call-backs for C++ error reporting.    This code is non-reentrant.    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002,    2003, 2004, 2005 Free Software Foundation, Inc.    This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"cxx-pretty-print.h"
end_include

begin_define
define|#
directive|define
name|pp_separate_with_comma
parameter_list|(
name|PP
parameter_list|)
value|pp_cxx_separate_with (PP, ',')
end_define

begin_comment
comment|/* The global buffer where we dump everything.  It is there only for    transitional purpose.  It is expected, in the near future, to be    completely removed.  */
end_comment

begin_decl_stmt
specifier|static
name|cxx_pretty_printer
name|scratch_pretty_printer
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cxx_pp
value|(&scratch_pretty_printer)
end_define

begin_define
define|#
directive|define
name|NEXT_CODE
parameter_list|(
name|T
parameter_list|)
value|(TREE_CODE (TREE_TYPE (T)))
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|args_to_string
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|assop_to_string
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|code_to_string
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|cv_to_string
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|decl_to_string
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|expr_to_string
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|fndecl_to_string
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|op_to_string
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|parm_to_string
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|type_to_string
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_type
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_typename
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_simple_decl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_template_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_function_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_expr
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_unary_op
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_binary_op
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_aggr_type
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_type_prefix
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_type_suffix
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_function_name
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_expr_list
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_global_iord
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_parameters
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_exception_spec
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_template_argument
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_template_argument_list
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_template_parameter
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_template_bindings
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_scope
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_template_parms
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|function_category
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_print_instantiation_context
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_instantiation_full_context
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_instantiation_partial_context
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|location_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_diagnostic_starter
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_diagnostic_finalizer
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_print_error_function
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_printer
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|text_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|location_t
name|location_of
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|init_error
parameter_list|(
name|void
parameter_list|)
block|{
name|diagnostic_starter
argument_list|(
name|global_dc
argument_list|)
operator|=
name|cp_diagnostic_starter
expr_stmt|;
name|diagnostic_finalizer
argument_list|(
name|global_dc
argument_list|)
operator|=
name|cp_diagnostic_finalizer
expr_stmt|;
name|diagnostic_format_decoder
argument_list|(
name|global_dc
argument_list|)
operator|=
name|cp_printer
expr_stmt|;
name|pp_construct
argument_list|(
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_cxx_pretty_printer_init
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a scope, if deemed necessary.  */
end_comment

begin_function
specifier|static
name|void
name|dump_scope
parameter_list|(
name|tree
name|scope
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|f
init|=
operator|~
name|TFF_RETURN_TYPE
operator|&
operator|(
name|flags
operator|&
operator|(
name|TFF_SCOPE
operator||
name|TFF_CHASE_TYPEDEF
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|scope
operator|!=
name|global_namespace
condition|)
block|{
name|dump_decl
argument_list|(
name|scope
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|scope
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_SCOPE
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|dump_function_decl
argument_list|(
name|scope
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump the template ARGument under control of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_argument
parameter_list|(
name|tree
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|arg
argument_list|,
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|arg
argument_list|,
operator|(
name|flags
operator||
name|TFF_EXPR_IN_PARENS
operator|)
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a template-argument-list ARGS (always a TREE_VEC) under control    of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_argument_list
parameter_list|(
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_template_argument
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump a template parameter PARM (a TREE_LIST) under control of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_parameter
parameter_list|(
name|tree
name|parm
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
name|tree
name|a
decl_stmt|;
if|if
condition|(
name|parm
operator|==
name|error_mark_node
condition|)
return|return;
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|a
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
block|{
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
condition|)
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
condition|)
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_canonical_template_parameter
argument_list|(
name|cxx_pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_decl
argument_list|(
name|p
argument_list|,
name|flags
operator||
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
operator|)
operator|&&
name|a
operator|!=
name|NULL_TREE
condition|)
block|{
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|dump_type
argument_list|(
name|a
argument_list|,
name|flags
operator|&
operator|~
name|TFF_CHASE_TYPEDEF
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|a
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump, under control of FLAGS, a template-parameter-list binding.    PARMS is a TREE_LIST of TREE_VEC of TREE_LIST and ARGS is a    TREE_VEC.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_bindings
parameter_list|(
name|tree
name|parms
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|lvl
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|arg_idx
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|p
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Don't crash if we had an invalid argument list.  */
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|>=
name|lvl
condition|)
block|{
name|tree
name|lvl_args
init|=
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|lvl
argument_list|)
decl_stmt|;
if|if
condition|(
name|NUM_TMPL_ARGS
argument_list|(
name|lvl_args
argument_list|)
operator|>
name|arg_idx
condition|)
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|lvl_args
argument_list|,
name|arg_idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_comma
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_template_parameter
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|dump_template_argument
argument_list|(
name|arg
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
else|else
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<missing>"
argument_list|)
expr_stmt|;
operator|++
name|arg_idx
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump a human-readable equivalent of TYPE.  FLAGS controls the    format.  */
end_comment

begin_function
specifier|static
name|void
name|dump_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
goto|goto
name|offset_type
goto|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|UNKNOWN_TYPE
case|:
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<unresolved overloaded function type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
comment|/* A list of function parms.  */
name|dump_parameters
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_BINFO
case|:
name|dump_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_aggr_type
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|flags
operator|&
name|TFF_CHASE_TYPEDEF
condition|)
block|{
name|dump_type
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Else fall through.  */
case|case
name|TEMPLATE_DECL
case|:
case|case
name|NAMESPACE_DECL
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
name|pp_type_specifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
comment|/* For parameters inside template signature.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_canonical_template_parameter
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
block|{
name|tree
name|args
init|=
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_template_argument_list
argument_list|(
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_end_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_canonical_template_parameter
argument_list|(
name|cxx_pp
argument_list|,
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* This is not always necessary for pointers and such, but doing this 	 reduces code size.  */
case|case
name|ARRAY_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
comment|/* APPLE LOCAL blocks 6040305 */
case|case
name|BLOCK_POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|offset_type
label|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|dump_type_prefix
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TYPENAME_TYPE
case|:
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|TYPENAME_IS_ENUM_P
argument_list|(
name|t
argument_list|)
condition|?
literal|"enum"
else|:
name|TYPENAME_IS_CLASS_P
argument_list|(
name|t
argument_list|)
condition|?
literal|"class"
else|:
literal|"typename"
argument_list|)
expr_stmt|;
name|dump_typename
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
name|dump_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"template"
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPEOF_TYPE
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"__typeof__"
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TYPEOF_TYPE_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Fall through to error.  */
case|case
name|ERROR_MARK
case|:
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<type error>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dump a TYPENAME_TYPE. We need to notice when the context is itself    a TYPENAME_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_typename
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|ctx
init|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|dump_typename
argument_list|(
name|ctx
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_type
argument_list|(
name|ctx
argument_list|,
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name of the supplied aggregate, or enumeral type.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|class_key_or_enum_as_string
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
literal|"enum"
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|"union"
return|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|"class"
return|;
else|else
return|return
literal|"struct"
return|;
block|}
end_function

begin_comment
comment|/* Print out a class declaration T under the control of FLAGS,    in the form `class foo'.  */
end_comment

begin_function
specifier|static
name|void
name|dump_aggr_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|variety
init|=
name|class_key_or_enum_as_string
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|typdef
init|=
literal|0
decl_stmt|;
name|int
name|tmplate
init|=
literal|0
decl_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_CLASS_KEY_OR_ENUM
condition|)
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|variety
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_CHASE_TYPEDEF
condition|)
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|typdef
operator|=
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tmplate
operator|=
operator|!
name|typdef
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|name
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_SCOPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplate
condition|)
block|{
comment|/* Because the template names are mangled, we have to locate 	     the most general template, and use that name.  */
name|tree
name|tpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tpl
argument_list|)
condition|)
name|tpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|tpl
argument_list|)
expr_stmt|;
name|name
operator|=
name|tpl
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
operator|||
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_CLASS_KEY_OR_ENUM
condition|)
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
else|else
name|pp_printf
argument_list|(
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
argument_list|,
literal|"<anonymous %s>"
argument_list|,
name|variety
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplate
condition|)
name|dump_template_parms
argument_list|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|,
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_TEMPLATE_HEADER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump into the obstack the initial part of the output for a given type.    This is necessary when dealing with things like functions returning    functions.  Examples:     return type of `int (* fee ())()': pointer -> function -> int.  Both    pointer (and reference and offset) and function (and member) types must    deal with prefix and suffix.     Arrays must also do this for DECL nodes, like int a[], and for things like    int *[]&.  */
end_comment

begin_function
specifier|static
name|void
name|dump_type_prefix
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|offset_type
goto|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
comment|/* APPLE LOCAL blocks 6040305 */
case|case
name|BLOCK_POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|sub
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|dump_type_prefix
argument_list|(
name|sub
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
comment|/* APPLE LOCAL begin blocks 6040305 */
name|pp_character
argument_list|(
name|cxx_pp
argument_list|,
literal|"&*^"
index|[
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|+
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BLOCK_POINTER_TYPE
operator|)
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end blocks 6040305 */
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OFFSET_TYPE
case|:
name|offset_type
label|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
comment|/* pmfs deal with this in d_t_p */
block|{
name|pp_maybe_space
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_star
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
break|break;
comment|/* Can only be reached through function pointer -- this would not be 	 correct if FUNCTION_DECLs used it.  */
case|case
name|FUNCTION_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_maybe_space
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_maybe_space
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_aggr_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TREE_LIST
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|TREE_VEC
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|UNKNOWN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|TYPEOF_TYPE
case|:
name|dump_type
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* fall through.  */
case|case
name|ERROR_MARK
case|:
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<typeprefixerror>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dump the suffix of type T, under control of FLAGS.  This is the part    which appears after the identifier (or function parms).  */
end_comment

begin_function
specifier|static
name|void
name|dump_type_suffix
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
comment|/* APPLE LOCAL blocks 6040305 */
case|case
name|BLOCK_POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
comment|/* Can only be reached through function pointer.  */
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|arg
decl_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Function pointers don't have default args.  Not in standard C++, 	   anyway; they may in g++, but we'll just pretend otherwise.  */
name|dump_parameters
argument_list|(
name|arg
argument_list|,
name|flags
operator|&
operator|~
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dump_exception_spec
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
name|pp_maybe_space
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|pp_wide_integer
argument_list|(
name|cxx_pp
argument_list|,
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|fold
argument_list|(
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_right_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TREE_LIST
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|TREE_VEC
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|UNKNOWN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|TYPEOF_TYPE
case|:
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
case|case
name|ERROR_MARK
case|:
comment|/* Don't mark it here, we should have already done in 	 dump_type_prefix.  */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_global_iord
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_GLOBAL_CTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|p
operator|=
literal|"initializers"
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_GLOBAL_DTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|p
operator|=
literal|"destructors"
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|pp_printf
argument_list|(
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
argument_list|,
literal|"(static %s for %s)"
argument_list|,
name|p
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_simple_decl
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
block|{
name|dump_type_prefix
argument_list|(
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_maybe_space
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
name|dump_type_suffix
argument_list|(
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a human readable string for the decl T under control of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_decl
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* Don't say 'typedef class A' */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
comment|/* Say `class T' not just `T'.  */
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|VTABLE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|"vtable for "
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Else fall through.  */
case|case
name|FIELD_DECL
case|:
case|case
name|PARM_DECL
case|:
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|"<return value> "
argument_list|)
expr_stmt|;
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
name|pp_cxx_declaration
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<unnamed>"
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCOPE_REF
case|:
name|pp_expression
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_left_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
comment|/* So that we can do dump_decl on an aggr type.  */
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_type
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* This is a pseudo destructor call which has not been folded into 	 a PSEUDO_DTOR_EXPR yet.  */
name|pp_cxx_complement
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
comment|/* These special cases are duplicated here so that other functions 	 can feed identifiers to error and get them demangled properly.  */
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
comment|/* Not exactly IDENTIFIER_TYPE_VALUE.  */
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERLOAD
case|:
if|if
condition|(
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dump_decl
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If there's only one function, just treat it like an ordinary 	 FUNCTION_DECL.  */
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<built-in>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_GLOBAL_CTOR_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_GLOBAL_DTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|dump_global_iord
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|dump_function_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_DECL
case|:
name|dump_template_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_template_argument_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_end_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LABEL_DECL
case|:
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|||
operator|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
operator|)
condition|)
name|dump_simple_decl
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
else|else
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<enumerator>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING_DECL
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"using"
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|USING_DECL_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|BASELINK
case|:
name|dump_decl
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_DEPENDENT_EXPR
case|:
name|dump_expr
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
if|if
condition|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|)
name|pp_cxx_declaration
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_type_id
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
name|dump_type
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Fall through to error.  */
case|case
name|ERROR_MARK
case|:
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<declaration error>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dump a template declaration T under control of FLAGS. This means the    'template<...> leaders plus the 'class X' or 'void fn(...)' part.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_decl
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|orig_parms
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_TEMPLATE_HEADER
condition|)
block|{
for|for
control|(
name|parms
operator|=
name|orig_parms
operator|=
name|nreverse
argument_list|(
name|orig_parms
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|inner_parms
init|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
decl_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"template"
argument_list|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
comment|/* If we've shown the template prefix, we'd better show the 	     parameters' and decl's type too.  */
name|flags
operator||=
name|TFF_DECL_SPECIFIERS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_template_parameter
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_end_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
name|nreverse
argument_list|(
name|orig_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Say `template<arg> class TT' not just `template<arg> TT'.  */
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|(
operator|(
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
operator|)
operator||
name|TFF_TEMPLATE_NAME
operator||
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|?
name|TFF_CLASS_KEY_OR_ENUM
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|dump_decl
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_TEMPLATE_NAME
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
name|dump_function_decl
argument_list|(
name|t
argument_list|,
name|flags
operator||
name|TFF_TEMPLATE_NAME
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This case can occur with some invalid code.  */
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|(
name|flags
operator|&
operator|~
name|TFF_CLASS_KEY_OR_ENUM
operator|)
operator||
name|TFF_TEMPLATE_NAME
operator||
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
condition|?
name|TFF_CLASS_KEY_OR_ENUM
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Pretty print a function decl. There are several ways we want to print a    function declaration. The TFF_ bits in FLAGS tells us how to behave.    As error can only apply the '#' flag once to give 0 and 1 for V, there    is %D which doesn't print the throw specs, and %F which does.  */
end_comment

begin_function
specifier|static
name|void
name|dump_function_decl
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|fntype
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|cname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|template_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|template_parms
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|show_return
init|=
name|flags
operator|&
name|TFF_RETURN_TYPE
operator|||
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Pretty print template instantiations only.  */
if|if
condition|(
name|DECL_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|template_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|&&
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|template_parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|t
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|cname
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* This is for partially instantiated template methods.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|cname
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TFF_DECL_SPECIFIERS
operator|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"virtual"
argument_list|)
expr_stmt|;
comment|/* Print the return type?  */
if|if
condition|(
name|show_return
condition|)
name|show_return
operator|=
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_return
condition|)
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Print the function name.  */
if|if
condition|(
name|cname
condition|)
block|{
name|dump_type
argument_list|(
name|cname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_function_name
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TFF_NO_FUNCTION_ARGUMENTS
operator|)
condition|)
block|{
name|dump_parameters
argument_list|(
name|parmtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TFF_EXCEPTION_SPECIFICATION
condition|)
block|{
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
name|dump_exception_spec
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_return
condition|)
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* If T is a template instantiation, dump the parameter binding.  */
if|if
condition|(
name|template_parms
operator|!=
name|NULL_TREE
operator|&&
name|template_args
operator|!=
name|NULL_TREE
condition|)
block|{
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"with"
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_template_bindings
argument_list|(
name|template_parms
argument_list|,
name|template_args
argument_list|)
expr_stmt|;
name|pp_cxx_right_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a parameter list. If this is for a member function, the    member object ptr (and any other hidden args) should have    already been removed.  */
end_comment

begin_function
specifier|static
name|void
name|dump_parameters
parameter_list|(
name|tree
name|parmtypes
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|first
decl_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
for|for
control|(
name|first
operator|=
literal|1
init|;
name|parmtypes
operator|!=
name|void_list_node
condition|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parmtypes
condition|)
block|{
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
break|break;
block|}
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
operator|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an exception specification. T is the exception specification.  */
end_comment

begin_function
specifier|static
name|void
name|dump_exception_spec
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|t
condition|)
block|{
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"throw"
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
break|break;
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the function name for a FUNCTION_DECL node, grokking operators    and destructors properly.  */
end_comment

begin_function
specifier|static
name|void
name|dump_function_name
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* We can get here with a decl that was synthesized by language-      independent machinery (e.g. coverage.c) in which case it won't      have a lang_specific structure attached and DECL_CONSTRUCTOR_P      will crash.  In this case it is safe just to print out the      literal name.  */
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Don't let the user see __comp_ctor et al.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|name
operator|=
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_cxx_complement
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|name
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* This cannot use the hack that the operator's return 	 type is stashed off of its name because it may be 	 used for error reporting.  In the case of conflicting 	 declarations, both will have the same name, yet 	 the types will be different, hence the TREE_TYPE field 	 of the first name will be clobbered by the second.  */
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
name|dump_template_parms
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|,
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the template parameters from the template info INFO under control of    FLAGS. PRIMARY indicates whether this is a primary template decl, or    specialization (partial or complete). For partial specializations we show    the specialized parameter values. For a primary template we show no    decoration.  */
end_comment

begin_function
specifier|static
name|void
name|dump_template_parms
parameter_list|(
name|tree
name|info
parameter_list|,
name|int
name|primary
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|args
init|=
name|info
condition|?
name|TI_ARGS
argument_list|(
name|info
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|primary
operator|&&
name|flags
operator|&
name|TFF_TEMPLATE_NAME
condition|)
return|return;
name|flags
operator|&=
operator|~
operator|(
name|TFF_CLASS_KEY_OR_ENUM
operator||
name|TFF_TEMPLATE_NAME
operator|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
comment|/* Be careful only to print things when we have them, so as not 	 to crash producing error messages.  */
if|if
condition|(
name|args
operator|&&
operator|!
name|primary
condition|)
block|{
name|int
name|len
decl_stmt|,
name|ix
decl_stmt|;
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
name|args
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|len
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|ix
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<template parameter error>"
argument_list|)
expr_stmt|;
else|else
name|dump_template_argument
argument_list|(
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|primary
condition|)
block|{
name|tree
name|tpl
init|=
name|TI_TEMPLATE
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tpl
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ix
decl_stmt|;
name|parms
operator|=
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
condition|?
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|len
operator|=
name|parms
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|len
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|parm
decl_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|ix
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<template parameter error>"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|ix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|parm
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_cxx_end_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a list of initializers (subr of dump_expr).  */
end_comment

begin_function
specifier|static
name|void
name|dump_expr_list
parameter_list|(
name|tree
name|l
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
while|while
condition|(
name|l
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|l
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out a vector of initializers (subr of dump_expr).  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dump_expr_init_vec
argument_list|(
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
argument_list|,
name|int
name|flags
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|v
argument_list|,
argument|idx
argument_list|,
argument|value
argument_list|)
block|{
name|dump_expr
argument_list|(
name|value
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|)
operator|-
literal|1
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* We've gotten an indirect REFERENCE (an OBJ_TYPE_REF) to a virtual    function.  Resolve it to a close relative -- in the sense of static    type -- variant being overridden.  That is close to what was written in    the source code.  Subroutine of dump_expr.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_virtual_fun_from_obj_type_ref
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|tree
name|obj_type
init|=
name|TREE_TYPE
argument_list|(
name|OBJ_TYPE_REF_OBJECT
argument_list|(
name|ref
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|index
init|=
name|tree_low_cst
argument_list|(
name|OBJ_TYPE_REF_TOKEN
argument_list|(
name|ref
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|fun
init|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|obj_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|index
condition|)
block|{
name|fun
operator|=
name|TREE_CHAIN
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|index
operator|-=
operator|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|?
name|TARGET_VTABLE_USES_DESCRIPTORS
else|:
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|BV_FN
argument_list|(
name|fun
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print out an expression E under control of FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_expr
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|NAMESPACE_DECL
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|OVERLOAD
case|:
case|case
name|IDENTIFIER_NODE
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
operator|(
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
operator|)
operator||
name|TFF_NO_FUNCTION_ARGUMENTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
name|pp_constant
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|THROW_EXPR
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"throw"
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTRMEM_CST
case|:
name|pp_ampersand
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|PTRMEM_CST_CLASS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_tree_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|DECL_NAME
argument_list|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|" ? "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"new"
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGGR_INIT_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|dump_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_expr_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Nobody is interested in seeing the guts of vcalls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|OBJ_TYPE_REF
condition|)
name|fn
operator|=
name|resolve_virtual_fun_from_obj_type_ref
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|ob
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_dot
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|ob
argument_list|)
argument_list|)
argument_list|,
literal|"this"
argument_list|)
condition|)
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_arrow
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|fn
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEW_EXPR
case|:
block|{
name|tree
name|type
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_index_type
argument_list|(
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|dump_expr_list
argument_list|(
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|init
operator|==
name|void_zero_node
condition|)
comment|/* This representation indicates an empty initializer, 		 e.g.: "new int()".  */
empty_stmt|;
else|else
name|dump_expr
argument_list|(
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TARGET_EXPR
case|:
comment|/* Note that this only works for G++ target exprs.  If somebody 	 builds a general TARGET_EXPR, there's no way to represent that 	 it initializes anything other that the parameter slot for the 	 default argument.  Note we may have cleared out the first 	 operand in expand_expr, so don't go killing ourselves.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
name|dump_binary_op
argument_list|(
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
operator|.
name|name
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"/"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"%"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|ob
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|ob
operator|=
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PARM_DECL
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|ob
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|ob
argument_list|)
argument_list|)
argument_list|,
literal|"this"
argument_list|)
operator|)
condition|)
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_arrow
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_dot
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_REF
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_left_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_right_bracket
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNARY_PLUS_EXPR
case|:
name|dump_unary_op
argument_list|(
literal|"+"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
comment|/* An ADDR_EXPR can have reference type.  In that case, we 	     shouldn't print the `&' doing so indicates to the user 	     that the expression has pointer type.  */
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|dump_unary_op
argument_list|(
literal|"&&"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"&"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|NEXT_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"*"
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
name|dump_unary_op
argument_list|(
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
operator|.
name|name
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* FIXME: This is a KLUDGE workaround for a parsing problem.  There 	 should be another level of INDIRECT_REF so that I don't have to do 	 this.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|NEXT_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|next
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|next
operator|=
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_star
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Else fall through.  */
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* It is a cast, but we cannot tell whether it is a 	       reinterpret or static cast. Use the C style notation.  */
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|op
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_expr
argument_list|(
name|op
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|idx
init|=
name|build_ptrmemfunc_access_expr
argument_list|(
name|t
argument_list|,
name|pfn_identifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|idx
argument_list|)
condition|)
block|{
comment|/* A NULL pointer-to-member constant.  */
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|cxx_pp
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|idx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|virtuals
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|tree_low_cst
argument_list|(
name|idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Map vtable index back one, to allow for the null pointer to 		 member.  */
operator|--
name|n
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|virtuals
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|virtuals
condition|)
block|{
name|dump_expr
argument_list|(
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|EMPTY_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_cxx_left_brace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr_init_vec
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_brace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OFFSET_REF
case|:
block|{
name|tree
name|ob
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_dummy_object
argument_list|(
name|ob
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* A::f */
name|dump_expr
argument_list|(
name|t
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BASELINK_P
argument_list|(
name|t
argument_list|)
condition|)
name|dump_expr
argument_list|(
name|OVL_CURRENT
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ob
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_arrow
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_star
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dump_expr
argument_list|(
name|ob
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_dot
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_star
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|dump_decl
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_DECL_SPECIFIERS
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
name|pp_expression
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAST_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATIC_CAST_EXPR
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"static_cast"
argument_list|)
expr_stmt|;
goto|goto
name|cast
goto|;
case|case
name|REINTERPRET_CAST_EXPR
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"reinterpret_cast"
argument_list|)
expr_stmt|;
goto|goto
name|cast
goto|;
case|case
name|CONST_CAST_EXPR
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"const_cast"
argument_list|)
expr_stmt|;
goto|goto
name|cast
goto|;
case|case
name|DYNAMIC_CAST_EXPR
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"dynamic_cast"
argument_list|)
expr_stmt|;
name|cast
label|:
name|pp_cxx_begin_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_end_template_argument_list
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARROW_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_arrow
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SIZEOF_EXPR
condition|)
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"sizeof"
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ALIGNOF_EXPR
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"__alignof__"
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|operator_name_info
index|[
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFAULT_ARG
case|:
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<unparsed>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PSEUDO_DTOR_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_dot
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_complement
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
name|dump_decl
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
case|case
name|STMT_EXPR
case|:
case|case
name|STATEMENT_LIST
case|:
comment|/* We don't yet have a way of dumping statements in a 	 human-readable format.  */
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|"({...})"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOP_EXPR
case|:
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|"while (1) { "
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_right_brace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_EXPR
case|:
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|"if ("
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|") break; "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BASELINK
case|:
name|dump_expr
argument_list|(
name|get_first_fn
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
break|break;
case|case
name|EMPTY_CLASS_EXPR
case|:
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_DEPENDENT_EXPR
case|:
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' does not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|pp_unsupported_tree
argument_list|(
name|cxx_pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* fall through to ERROR_MARK...  */
case|case
name|ERROR_MARK
case|:
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<expression error>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_op
parameter_list|(
specifier|const
name|char
modifier|*
name|opstring
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|opstring
condition|)
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|opstring
argument_list|)
expr_stmt|;
else|else
name|pp_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"<unknown operator>"
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_unary_op
parameter_list|(
specifier|const
name|char
modifier|*
name|opstring
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|pp_cxx_left_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
name|opstring
argument_list|)
expr_stmt|;
name|dump_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|TFF_EXPR_IN_PARENS
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TFF_EXPR_IN_PARENS
condition|)
name|pp_cxx_right_paren
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reinit_cxx_pp
parameter_list|(
name|void
parameter_list|)
block|{
name|pp_clear_output_area
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
name|pp_indentation
argument_list|(
name|cxx_pp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|cxx_pp
argument_list|)
operator|=
name|false
expr_stmt|;
name|cxx_pp
operator|->
name|enclosing_scope
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exported interface to stringifying types, exprs and decls under TFF_*    control.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|type_as_string
parameter_list|(
name|tree
name|typ
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|dump_type
argument_list|(
name|typ
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|expr_as_string
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|dump_expr
argument_list|(
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|decl_as_string
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the three forms of printable names for cxx_printable_name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|lang_decl_name
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|>=
literal|2
condition|)
return|return
name|decl_as_string
argument_list|(
name|decl
argument_list|,
name|TFF_DECL_SPECIFIERS
argument_list|)
return|;
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|1
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|dump_type
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|dump_function_name
argument_list|(
name|decl
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
else|else
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the location of a tree passed to %+ formats.  */
end_comment

begin_function
specifier|static
name|location_t
name|location_of
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|t
operator|=
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Now the interfaces from error et al to dump_type et al. Each takes an    on/off VERBOSE flag and supply the appropriate TFF_ flags to a dump_    function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|decl_to_string
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|flags
operator|=
name|TFF_CLASS_KEY_OR_ENUM
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_DECL_SPECIFIERS
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator||=
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_RETURN_TYPE
expr_stmt|;
name|flags
operator||=
name|TFF_TEMPLATE_HEADER
expr_stmt|;
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|expr_to_string
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|dump_expr
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fndecl_to_string
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|TFF_EXCEPTION_SPECIFICATION
operator||
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_TEMPLATE_HEADER
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_FUNCTION_DEFAULT_ARGUMENTS
expr_stmt|;
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|fndecl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|code_to_string
parameter_list|(
name|enum
name|tree_code
name|c
parameter_list|)
block|{
return|return
name|tree_code_name
index|[
name|c
index|]
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|language_to_string
parameter_list|(
name|enum
name|languages
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|lang_c
case|:
return|return
literal|"C"
return|;
case|case
name|lang_cplusplus
case|:
return|return
literal|"C++"
return|;
case|case
name|lang_java
case|:
return|return
literal|"Java"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the proper printed version of a parameter to a C++ function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parm_to_string
parameter_list|(
name|int
name|p
parameter_list|)
block|{
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
name|pp_string
argument_list|(
name|cxx_pp
argument_list|,
literal|"'this'"
argument_list|)
expr_stmt|;
else|else
name|pp_decimal_int
argument_list|(
name|cxx_pp
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|op_to_string
parameter_list|(
name|enum
name|tree_code
name|p
parameter_list|)
block|{
name|tree
name|id
init|=
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|p
index|]
operator|.
name|identifier
decl_stmt|;
return|return
name|id
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
else|:
literal|"<unknown>"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_to_string
parameter_list|(
name|tree
name|typ
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_CLASS_KEY_OR_ENUM
expr_stmt|;
name|flags
operator||=
name|TFF_TEMPLATE_HEADER
expr_stmt|;
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|dump_type
argument_list|(
name|typ
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|assop_to_string
parameter_list|(
name|enum
name|tree_code
name|p
parameter_list|)
block|{
name|tree
name|id
init|=
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|p
index|]
operator|.
name|identifier
decl_stmt|;
return|return
name|id
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
else|:
literal|"{unknown}"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|args_to_string
parameter_list|(
name|tree
name|p
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|flags
operator||=
name|TFF_CLASS_KEY_OR_ENUM
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL_TREE
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|type_as_string
argument_list|(
name|p
argument_list|,
name|flags
argument_list|)
return|;
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|==
name|null_node
condition|)
name|pp_cxx_identifier
argument_list|(
name|cxx_pp
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
else|else
name|dump_type
argument_list|(
name|error_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
condition|)
name|pp_separate_with_comma
argument_list|(
name|cxx_pp
argument_list|)
expr_stmt|;
block|}
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cv_to_string
parameter_list|(
name|tree
name|p
parameter_list|,
name|int
name|v
parameter_list|)
block|{
name|reinit_cxx_pp
argument_list|()
expr_stmt|;
name|pp_base
argument_list|(
name|cxx_pp
argument_list|)
operator|->
name|padding
operator|=
name|v
condition|?
name|pp_before
else|:
name|pp_none
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|cxx_pp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text
argument_list|(
name|cxx_pp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Langhook for print_error_function.  */
end_comment

begin_function
name|void
name|cxx_print_error_function
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|lhd_print_error_function
argument_list|(
name|context
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|pp_base_set_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|maybe_print_instantiation_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cp_diagnostic_starter
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
name|diagnostic_report_current_module
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|cp_print_error_function
argument_list|(
name|context
argument_list|,
name|diagnostic
argument_list|)
expr_stmt|;
name|maybe_print_instantiation_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pp_base_set_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|,
name|diagnostic_build_prefix
argument_list|(
name|diagnostic
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cp_diagnostic_finalizer
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|pp_base_destroy_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print current function onto BUFFER, in the process of reporting    a diagnostic message.  Called from cp_diagnostic_starter.  */
end_comment

begin_function
specifier|static
name|void
name|cp_print_error_function
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
if|if
condition|(
name|diagnostic_last_function_changed
argument_list|(
name|context
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|old_prefix
init|=
name|context
operator|->
name|printer
operator|->
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
init|=
name|LOCATION_FILE
argument_list|(
name|diagnostic
operator|->
name|location
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_prefix
init|=
name|file
condition|?
name|file_name_as_prefix
argument_list|(
name|file
argument_list|)
else|:
name|NULL
decl_stmt|;
name|pp_base_set_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|,
name|new_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
name|pp_base_string
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"At global scope:"
argument_list|)
expr_stmt|;
else|else
name|pp_printf
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"In %s %qs:"
argument_list|,
name|function_category
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|cxx_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|pp_base_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|diagnostic_set_last_function
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pp_base_destroy_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|context
operator|->
name|printer
operator|->
name|prefix
operator|=
name|old_prefix
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns a description of FUNCTION using standard terminology.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|function_category
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"static member function"
return|;
elseif|else
if|if
condition|(
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"copy constructor"
return|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"constructor"
return|;
elseif|else
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|"destructor"
return|;
else|else
return|return
literal|"member function"
return|;
block|}
else|else
return|return
literal|"function"
return|;
block|}
end_function

begin_comment
comment|/* Report the full context of a current template instantiation,    onto BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|print_instantiation_full_context
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|tree
name|p
init|=
name|current_instantiation
argument_list|()
decl_stmt|;
name|location_t
name|location
init|=
name|input_location
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|!=
name|TINST_DECL
argument_list|(
name|p
argument_list|)
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
comment|/* We can get here during the processing of some synthesized 	   method.  Then, TINST_DECL (p) will be the function that's causing 	   the synthesis.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|TINST_DECL
argument_list|(
name|p
argument_list|)
condition|)
comment|/* Avoid redundancy with the "In function" line.  */
empty_stmt|;
else|else
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"%s: In instantiation of %qs:\n"
argument_list|,
name|LOCATION_FILE
argument_list|(
name|location
argument_list|)
argument_list|,
name|decl_as_string
argument_list|(
name|TINST_DECL
argument_list|(
name|p
argument_list|)
argument_list|,
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_RETURN_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|location
operator|=
name|TINST_LOCATION
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|print_instantiation_partial_context
argument_list|(
name|context
argument_list|,
name|p
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as above but less verbose.  */
end_comment

begin_function
specifier|static
name|void
name|print_instantiation_partial_context
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|tree
name|t
parameter_list|,
name|location_t
name|loc
parameter_list|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
for|for
control|(
init|;
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|xloc
operator|=
name|expand_location
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
break|break;
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"%s:%d:   instantiated from %qs\n"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|,
name|decl_as_string
argument_list|(
name|TINST_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
name|TFF_DECL_SPECIFIERS
operator||
name|TFF_RETURN_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|=
name|TINST_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"%s:%d:   instantiated from here"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
name|pp_base_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from cp_thing to print the template context for an error.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_print_instantiation_context
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|problematic_instantiation_changed
argument_list|()
operator|||
name|current_instantiation
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|record_last_problematic_instantiation
argument_list|()
expr_stmt|;
name|print_instantiation_full_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report the bare minimum context of a template instantiation.  */
end_comment

begin_function
name|void
name|print_instantiation_context
parameter_list|(
name|void
parameter_list|)
block|{
name|print_instantiation_partial_context
argument_list|(
name|global_dc
argument_list|,
name|current_instantiation
argument_list|()
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
name|diagnostic_flush_buffer
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from output_format -- during diagnostic message processing --    to handle C++ specific format specifier with the following meanings:    %A   function argument-list.    %C	tree code.    %D   declaration.    %E   expression.    %F   function declaration.    %L	language as used in extern "lang".    %O	binary operator.    %P   function parameter whose position is indicated by an integer.    %Q	assignment operator.    %T   type.    %V   cv-qualifier.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_printer
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|,
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|int
name|precision
parameter_list|,
name|bool
name|wide
parameter_list|,
name|bool
name|set_locus
parameter_list|,
name|bool
name|verbose
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|tree
name|t
init|=
name|NULL
decl_stmt|;
define|#
directive|define
name|next_tree
value|(t = va_arg (*text->args_ptr, tree))
define|#
directive|define
name|next_tcode
value|va_arg (*text->args_ptr, enum tree_code)
define|#
directive|define
name|next_lang
value|va_arg (*text->args_ptr, enum languages)
define|#
directive|define
name|next_int
value|va_arg (*text->args_ptr, int)
if|if
condition|(
name|precision
operator|!=
literal|0
operator|||
name|wide
condition|)
return|return
name|false
return|;
if|if
condition|(
name|text
operator|->
name|locus
operator|==
name|NULL
condition|)
name|set_locus
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
operator|*
name|spec
condition|)
block|{
case|case
literal|'A'
case|:
name|result
operator|=
name|args_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|result
operator|=
name|code_to_string
argument_list|(
name|next_tcode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
block|{
name|tree
name|temp
init|=
name|next_tree
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|temp
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|temp
operator|=
name|DECL_DEBUG_EXPR
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|result
operator|=
name|expr_to_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|result
operator|=
name|decl_to_string
argument_list|(
name|temp
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
name|result
operator|=
name|expr_to_string
argument_list|(
name|next_tree
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|result
operator|=
name|fndecl_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|result
operator|=
name|language_to_string
argument_list|(
name|next_lang
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|result
operator|=
name|op_to_string
argument_list|(
name|next_tcode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|result
operator|=
name|parm_to_string
argument_list|(
name|next_int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|result
operator|=
name|assop_to_string
argument_list|(
name|next_tcode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|result
operator|=
name|type_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|result
operator|=
name|cv_to_string
argument_list|(
name|next_tree
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
name|pp_base_string
argument_list|(
name|pp
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_locus
operator|&&
name|t
operator|!=
name|NULL
condition|)
operator|*
name|text
operator|->
name|locus
operator|=
name|location_of
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
undef|#
directive|undef
name|next_tree
undef|#
directive|undef
name|next_tcode
undef|#
directive|undef
name|next_lang
undef|#
directive|undef
name|next_int
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Callback from cpp_error for PFILE to print diagnostics arising from    interpreting strings.  The diagnostic is of type LEVEL; MSG is the    translated message and AP the arguments.  */
end_comment

begin_function
name|void
name|cp_cpp_error
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
modifier|*
name|ap
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|diagnostic_t
name|dlevel
decl_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|CPP_DL_WARNING
case|:
case|case
name|CPP_DL_WARNING_SYSHDR
case|:
name|dlevel
operator|=
name|DK_WARNING
expr_stmt|;
break|break;
case|case
name|CPP_DL_PEDWARN
case|:
name|dlevel
operator|=
name|pedantic_error_kind
argument_list|()
expr_stmt|;
break|break;
case|case
name|CPP_DL_ERROR
case|:
name|dlevel
operator|=
name|DK_ERROR
expr_stmt|;
break|break;
case|case
name|CPP_DL_ICE
case|:
name|dlevel
operator|=
name|DK_ICE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|diagnostic_set_info_translated
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|,
name|input_location
argument_list|,
name|dlevel
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

