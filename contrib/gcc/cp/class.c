begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to building classes and their related objects.    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002  Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* The number of nested classes being processed.  If we are not in the    scope of any class, this is zero.  */
end_comment

begin_decl_stmt
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In order to deal with nested classes, we keep a stack of classes.    The topmost entry is the innermost class, and is the entry at index    CURRENT_CLASS_DEPTH  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|class_stack_node
block|{
comment|/* The name of the class.  */
name|tree
name|name
decl_stmt|;
comment|/* The _TYPE node for the class.  */
name|tree
name|type
decl_stmt|;
comment|/* The access specifier pending for new declarations in the scope of      this class.  */
name|tree
name|access
decl_stmt|;
comment|/* If were defining TYPE, the names used in this class.  */
name|splay_tree
name|names_used
decl_stmt|;
block|}
typedef|*
name|class_stack_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|vtbl_init_data_s
block|{
comment|/* The base for which we're building initializers.  */
name|tree
name|binfo
decl_stmt|;
comment|/* The type of the most-derived type.  */
name|tree
name|derived
decl_stmt|;
comment|/* The binfo for the dynamic type. This will be TYPE_BINFO (derived),      unless ctor_vtbl_p is true.  */
name|tree
name|rtti_binfo
decl_stmt|;
comment|/* The negative-index vtable initializers built up so far.  These      are in order from least negative index to most negative index.  */
name|tree
name|inits
decl_stmt|;
comment|/* The last (i.e., most negative) entry in INITS.  */
name|tree
modifier|*
name|last_init
decl_stmt|;
comment|/* The binfo for the virtual base for which we're building      vcall offset initializers.  */
name|tree
name|vbase
decl_stmt|;
comment|/* The functions in vbase for which we have already provided vcall      offsets.  */
name|varray_type
name|fns
decl_stmt|;
comment|/* The vtable index of the next vcall or vbase offset.  */
name|tree
name|index
decl_stmt|;
comment|/* Nonzero if we are building the initializer for the primary      vtable.  */
name|int
name|primary_vtbl_p
decl_stmt|;
comment|/* Nonzero if we are building the initializer for a construction      vtable.  */
name|int
name|ctor_vtbl_p
decl_stmt|;
block|}
name|vtbl_init_data
typedef|;
end_typedef

begin_comment
comment|/* The type of a function passed to walk_subobject_offsets.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*subobject_offset_fn
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|splay_tree
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* The stack itself.  This is an dynamically resized array.  The    number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_class_stack_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|class_stack_node_t
name|current_class_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of all local classes present in this translation unit, in    declaration order.  */
end_comment

begin_decl_stmt
name|varray_type
name|local_classes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vfield_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_anon
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtable_entry
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vtable_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_basefndecls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|build_primary_vtable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|build_secondary_vtable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_vtbls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_vtable_entry
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_virtual_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|delete_duplicate_fields_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_duplicate_fields
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_bits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alter_access
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_using_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strictly_overrides
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_for_override
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_modify_vtables
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|modify_all_vtables
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|determine_primary_base
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_methods
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_warn_about_overly_private_class
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|field_decl_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|tree
operator|*
operator|,
specifier|const
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|method_name_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|tree
operator|*
operator|,
specifier|const
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_implicitly_declared_members
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fixed_type_or_null
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|resolve_address_of_overloaded_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtable_entry_ref
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtbl_ref_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtbl_initializer
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_fields
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_fields_to_vec
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_bitfield_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_field_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_field_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|build_base_field
name|PARAMS
argument_list|(
operator|(
name|record_layout_info
operator|,
name|tree
operator|,
name|int
operator|*
operator|,
name|splay_tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|build_base_fields
name|PARAMS
argument_list|(
operator|(
name|record_layout_info
operator|,
name|int
operator|*
operator|,
name|splay_tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_methods
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_zero_width_bit_fields
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_bases
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_bases_and_members
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|create_vtable_ptr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|layout_class_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_pending_inline
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_inline_methods
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_primary_base
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|propagate_binfo_offsets
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|layout_virtual_bases
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|splay_tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_set_offset_for_unshared_vbases
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_vbase_offset_vtbl_entries
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|vtbl_init_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|vtbl_init_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|vtbl_init_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_vcall_offset_vtbl_entries
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|vtbl_init_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|layout_vtable_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_find_final_overrider
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|find_final_overrider
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|make_new_vtable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_indent_hierarchy
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_class_hierarchy_r
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_class_hierarchy
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_array
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_vtable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_vtt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_vtable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_array
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|layout_nonempty_base_or_field
name|PARAMS
argument_list|(
operator|(
name|record_layout_info
operator|,
name|tree
operator|,
name|tree
operator|,
name|splay_tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|end_of_class
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|layout_empty_base
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|splay_tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|accumulate_vtbl_inits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_accumulate_vtbl_inits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_vindex
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_rtti_vtbl_entries
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|vtbl_init_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_vcall_and_vbase_vtbl_entries
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|vtbl_init_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|force_canonical_binfo_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|force_canonical_binfo
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_unshared_virtual_bases
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_primary_bases
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|mark_primary_virtual_base
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clone_constructors_and_destructors
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_clone
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_vtable_entry_for_fn
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_virtuals
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_ctor_vtbl_group
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_vtt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|binfo_ctor_vtable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|build_vtt_inits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_build_secondary_vptr_vtt_inits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_ctor_vtable_bases_queue_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_fixup_binfo_vtbls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_original_base
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_get_primary_binfo
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|record_subobject_offset
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|splay_tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_subobject_offset
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|splay_tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|walk_subobject_offsets
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|subobject_offset_fn
operator|,
name|tree
operator|,
name|splay_tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_subobject_offsets
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|splay_tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|layout_conflict_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|splay_tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|splay_tree_compare_integer_csts
name|PARAMS
argument_list|(
operator|(
name|splay_tree_key
name|k1
operator|,
name|splay_tree_key
name|k2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_about_ambiguous_direct_bases
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|type_requires_array_cookie
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros for dfs walking during vtt construction. See    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits    and dfs_fixup_binfo_vtbls.  */
end_comment

begin_define
define|#
directive|define
name|VTT_TOP_LEVEL_P
parameter_list|(
name|NODE
parameter_list|)
value|TREE_UNSIGNED (NODE)
end_define

begin_define
define|#
directive|define
name|VTT_MARKED_BINFO_P
parameter_list|(
name|NODE
parameter_list|)
value|TREE_USED (NODE)
end_define

begin_comment
comment|/* Variables shared between class.c and call.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|n_vtables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_searches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_elems
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_convert_harshness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_compute_conversion_costs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_build_method_call
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_inner_fields_searched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert to or from a base subobject.  EXPR is an expression of type    `A' or `A*', an expression of type `B' or `B*' is returned.  To    convert A to a base B, CODE is PLUS_EXPR and BINFO is the binfo for    the B base instance within A.  To convert base A to derived B, CODE    is MINUS_EXPR and BINFO is the binfo for the A instance within B.    In this latter case, A must not be a morally virtual base of B.    NONNULL is true if EXPR is known to be non-NULL (this is only    needed when EXPR is of pointer type).  CV qualifiers are preserved    from EXPR.  */
end_comment

begin_function
name|tree
name|build_base_path
parameter_list|(
name|code
parameter_list|,
name|expr
parameter_list|,
name|binfo
parameter_list|,
name|nonnull
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
block|{
name|tree
name|v_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|d_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|probe
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|target_type
decl_stmt|;
name|tree
name|null_test
init|=
name|NULL
decl_stmt|;
name|tree
name|ptr_target_type
decl_stmt|;
name|int
name|fixed_type_p
decl_stmt|;
name|int
name|want_pointer
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
operator|||
name|binfo
operator|==
name|error_mark_node
operator|||
operator|!
name|binfo
condition|)
return|return
name|error_mark_node
return|;
for|for
control|(
name|probe
operator|=
name|binfo
init|;
name|probe
condition|;
name|probe
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
name|d_binfo
operator|=
name|probe
expr_stmt|;
if|if
condition|(
operator|!
name|v_binfo
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|probe
argument_list|)
condition|)
name|v_binfo
operator|=
name|probe
expr_stmt|;
block|}
name|probe
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_pointer
condition|)
name|probe
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|probe
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|probe
argument_list|)
else|:
name|code
operator|==
name|PLUS_EXPR
condition|?
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|d_binfo
argument_list|)
argument_list|,
name|probe
argument_list|)
else|:
name|false
argument_list|,
literal|20010723
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|v_binfo
condition|)
block|{
name|error
argument_list|(
literal|"cannot convert from base `%T' to derived type `%T' via virtual base `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|d_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|v_binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fixed_type_p
operator|=
name|resolves_to_fixed_type_p
argument_list|(
name|expr
argument_list|,
operator|&
name|nonnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixed_type_p
operator|<
literal|0
condition|)
comment|/* Virtual base layout is not fixed, even in ctors and dtors. */
name|fixed_type_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_type_p
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|want_pointer
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nonnull
condition|)
name|null_test
operator|=
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_binfo
operator|&&
operator|!
name|fixed_type_p
condition|)
block|{
comment|/* Going via virtual base V_BINFO.  We need the static offset          from V_BINFO to BINFO, and the dynamic offset from D_BINFO to          V_BINFO.  That offset is an entry in D_BINFO's vtable.  */
name|tree
name|v_offset
init|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|v_binfo
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|v_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|d_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|v_offset
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|v_offset
argument_list|)
argument_list|,
name|v_offset
argument_list|,
name|BINFO_VPTR_FIELD
argument_list|(
name|v_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|v_offset
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|ptrdiff_type_node
argument_list|)
argument_list|,
name|v_offset
argument_list|)
expr_stmt|;
name|v_offset
operator|=
name|build_indirect_ref
argument_list|(
name|v_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|size_diffop
argument_list|(
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|v_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|v_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|v_offset
expr_stmt|;
block|}
name|target_type
operator|=
name|code
operator|==
name|PLUS_EXPR
condition|?
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
else|:
name|BINFO_TYPE
argument_list|(
name|d_binfo
argument_list|)
expr_stmt|;
name|target_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|target_type
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_target_type
operator|=
name|build_pointer_type
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_pointer
condition|)
name|target_type
operator|=
name|ptr_target_type
expr_stmt|;
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|ptr_target_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|expr
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|ptr_target_type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|null_test
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|want_pointer
condition|)
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|null_test
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|target_type
argument_list|,
name|null_test
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|target_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Virtual function things.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable_entry_ref
parameter_list|(
name|array_ref
parameter_list|,
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
name|array_ref
decl_stmt|,
name|instance
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|tree
name|i
decl_stmt|,
name|i2
decl_stmt|,
name|vtable
decl_stmt|,
name|first_fn
decl_stmt|,
name|basetype
decl_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|vtable
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|first_fn
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|i
operator|=
name|fold
argument_list|(
name|build_array_ref
argument_list|(
name|first_fn
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|fold
argument_list|(
name|build_c_cast
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i2
operator|=
name|fold
argument_list|(
name|build_array_ref
argument_list|(
name|vtable
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i2
operator|=
name|fold
argument_list|(
name|build_c_cast
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|i2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|fold
argument_list|(
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|i
argument_list|,
name|i2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|build
argument_list|(
name|VTABLE_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|array_ref
argument_list|)
argument_list|,
name|array_ref
argument_list|,
name|vtable
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields the    vtable element corresponding to INDEX.  There are many special    cases for INSTANCE which we take care of here, mainly to avoid    creating extra tree nodes when we don't have to.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtbl_ref_1
parameter_list|(
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|tree
name|vtbl
decl_stmt|,
name|aref
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|current_class_ref
condition|)
name|vtbl
operator|=
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Try to figure out what a reference refers to, and 	     access its virtual function table directly.  */
name|tree
name|ref
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|instance
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|instance
operator|=
name|init
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
block|{
name|vtbl
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* Knowing the dynamic type of INSTANCE we can easily obtain 	     the correct vtable entry.  We resolve this back to be in 	     terms of the primary vtable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vtbl
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|idx
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|,
name|idx
argument_list|,
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|vtbl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|vtbl
operator|=
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_function
name|tree
name|build_vtbl_ref
parameter_list|(
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|tree
name|aref
init|=
name|build_vtbl_ref_1
argument_list|(
name|instance
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_vtable_gc
condition|)
name|aref
operator|=
name|build_vtable_entry_ref
argument_list|(
name|aref
argument_list|,
name|instance
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields a    function pointer corresponding to vtable element INDEX.  */
end_comment

begin_function
name|tree
name|build_vfn_ref
parameter_list|(
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|tree
name|aref
init|=
name|build_vtbl_ref_1
argument_list|(
name|instance
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|/* When using function descriptors, the address of the      vtable entry is treated as a function pointer.  */
if|if
condition|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|)
name|aref
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|aref
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|aref
argument_list|,
comment|/*noconvert=*/
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_gc
condition|)
name|aref
operator|=
name|build_vtable_entry_ref
argument_list|(
name|aref
argument_list|,
name|instance
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the virtual function table (as an IDENTIFIER_NODE)    for the given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|mangle_vtbl_for_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an IDENTIFIER_NODE for the name of the virtual table table    for TYPE.  */
end_comment

begin_function
name|tree
name|get_vtt_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|mangle_vtt_for_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a VAR_DECL for a primary or secondary vtable for CLASS_TYPE.    (For a secondary vtable for B-in-D, CLASS_TYPE should be D, not B.)    Use NAME for the name of the vtable, and VTABLE_TYPE for its type.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|class_type
parameter_list|,
name|name
parameter_list|,
name|vtable_type
parameter_list|)
name|tree
name|class_type
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|vtable_type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|vtable_type
argument_list|)
expr_stmt|;
comment|/* vtable names are already mangled; give them their DECL_ASSEMBLER_NAME      now to avoid confusion in mangle_decl.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|class_type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|import_export_vtable
argument_list|(
name|decl
argument_list|,
name|class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Get the VAR_DECL of the vtable for TYPE. TYPE need not be polymorphic,    or even complete.  If this does not exist, create it.  If COMPLETE is    non-zero, then complete the definition of it -- that will render it    impossible to actually build the vtable, but is useful to get at those    which are known to exist in the runtime.  */
end_comment

begin_function
name|tree
name|get_vtable_decl
parameter_list|(
name|type
parameter_list|,
name|complete
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|complete
decl_stmt|;
block|{
name|tree
name|name
init|=
name|get_vtable_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|20000118
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
name|decl
operator|=
name|build_vtable
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|decl
argument_list|,
literal|20000517
argument_list|)
expr_stmt|;
comment|/* At one time the vtable info was grabbed 2 words at a time.  This      fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|complete
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns a copy of the BINFO_VIRTUALS list in BINFO.  The    BV_VCALL_INDEX for each entry is cleared.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_virtuals
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|copies
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|copies
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|copies
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|BV_VCALL_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BV_USE_VCALL_INDEX_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|copies
return|;
block|}
end_function

begin_comment
comment|/* Build the primary virtual function table for TYPE.  If BINFO is    non-NULL, build the vtable starting with the initial approximation    that it is the same as the one which is the head of the association    list.  Returns a non-zero value if a new vtable is actually    created.  */
end_comment

begin_function
specifier|static
name|int
name|build_primary_vtable
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|decl
operator|=
name|get_vtable_decl
argument_list|(
name|type
argument_list|,
comment|/*complete=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|,
name|type
argument_list|)
condition|)
comment|/* We have already created a vtable for this base, so there's 	   no need to do it again.  */
return|return
literal|0
return|;
name|virtuals
operator|=
name|copy_virtuals
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
argument_list|,
literal|20000118
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the association list for this type, based      on our first approximation.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Give BINFO a new virtual function table which is initialized    with a skeleton-copy of its original initialization.  The only    entry that changes is the `delta' entry, so we can really    share a lot of structure.     FOR_TYPE is the most derived type which caused this table to    be needed.     Returns non-zero if we haven't met BINFO before.     The order in which vtables are built (by calling this function) for    an object must remain the same, otherwise a binary incompatibility    can result.  */
end_comment

begin_function
specifier|static
name|int
name|build_secondary_vtable
parameter_list|(
name|binfo
parameter_list|,
name|for_type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|for_type
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|binfo
operator|==
name|CANONICAL_BINFO
argument_list|(
name|binfo
argument_list|,
name|for_type
argument_list|)
argument_list|,
literal|20010605
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|,
name|for_type
argument_list|)
condition|)
comment|/* We already created a vtable for this base.  There's no need to        do it again.  */
return|return
literal|0
return|;
comment|/* Remember that we've created a vtable for this BINFO, so that we      don't try to do so again.  */
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|,
name|for_type
argument_list|)
expr_stmt|;
comment|/* Make fresh virtual list, so we can smash it later.  */
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|copy_virtuals
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Secondary vtables are laid out as part of the same structure as      the primary vtable.  */
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create a new vtable for BINFO which is the hierarchy dominated by    T. Return non-zero if we actually created a new vtable.  */
end_comment

begin_function
specifier|static
name|int
name|make_new_vtable
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
comment|/* In this case, it is *type*'s vtable we are modifying.  We start        with the approximation that its vtable is that of the        immediate base class.  */
comment|/* ??? This actually passes TYPE_BINFO (t), not the primary base binfo,        since we've updated DECL_CONTEXT (TYPE_VFIELD (t)) by now.  */
return|return
name|build_primary_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
return|;
else|else
comment|/* This is our very own copy of `basetype' to play with.  Later,        we will fill in all the virtual functions that override the        virtual functions in these base classes which are not defined        by the current type.  */
return|return
name|build_secondary_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make *VIRTUALS, an entry on the BINFO_VIRTUALS list for BINFO    (which is in the hierarchy dominated by T) list FNDECL as its    BV_FN.  DELTA is the required constant adjustment from the `this'    pointer where the vtable entry appears to the `this' required when    the function is actually called.  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fndecl
parameter_list|,
name|delta
parameter_list|,
name|virtuals
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|delta
decl_stmt|;
name|tree
modifier|*
name|virtuals
decl_stmt|;
block|{
name|tree
name|v
decl_stmt|;
name|v
operator|=
operator|*
name|virtuals
expr_stmt|;
if|if
condition|(
name|fndecl
operator|!=
name|BV_FN
argument_list|(
name|v
argument_list|)
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|delta
argument_list|,
name|BV_DELTA
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|base_fndecl
decl_stmt|;
comment|/* We need a new vtable for BINFO.  */
if|if
condition|(
name|make_new_vtable
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|)
condition|)
block|{
comment|/* If we really did make a new vtable, we also made a copy 	     of the BINFO_VIRTUALS list.  Now, we have to find the 	     corresponding entry in that list.  */
operator|*
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|BV_FN
argument_list|(
operator|*
name|virtuals
argument_list|)
operator|!=
name|BV_FN
argument_list|(
name|v
argument_list|)
condition|)
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
name|v
operator|=
operator|*
name|virtuals
expr_stmt|;
block|}
name|base_fndecl
operator|=
name|BV_FN
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BV_DELTA
argument_list|(
name|v
argument_list|)
operator|=
name|delta
expr_stmt|;
name|BV_VCALL_INDEX
argument_list|(
name|v
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BV_FN
argument_list|(
name|v
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Now assign virtual dispatch information, if unset.  We can 	 dispatch this through any overridden base function.  	 FIXME this can choose a secondary vtable if the primary is not 	 also lexically first, leading to useless conversions. 	 In the V3 ABI, there's no reason for DECL_VIRTUAL_CONTEXT to 	 ever be different from DECL_CONTEXT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set DECL_VINDEX for DECL.  VINDEX_P is the number of virtual    functions present in the vtable so far.  */
end_comment

begin_function
specifier|static
name|void
name|set_vindex
parameter_list|(
name|decl
parameter_list|,
name|vfuns_p
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
modifier|*
name|vfuns_p
decl_stmt|;
block|{
name|int
name|vindex
decl_stmt|;
name|vindex
operator|=
operator|*
name|vfuns_p
expr_stmt|;
operator|*
name|vfuns_p
operator|+=
operator|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|?
name|TARGET_VTABLE_USES_DESCRIPTORS
else|:
literal|1
operator|)
expr_stmt|;
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|build_shared_int_cst
argument_list|(
name|vindex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a virtual function to all the appropriate vtables for the class    T.  DECL_VINDEX(X) should be error_mark_node, if we want to    allocate a new slot in our table.  If it is error_mark_node, we    know that no other function from another vtable is overridden by X.    VFUNS_P keeps track of how many virtuals there are in our    main vtable for the type, and we build upon the NEW_VIRTUALS list    and return it.  */
end_comment

begin_function
specifier|static
name|void
name|add_virtual_function
parameter_list|(
name|new_virtuals_p
parameter_list|,
name|overridden_virtuals_p
parameter_list|,
name|vfuns_p
parameter_list|,
name|fndecl
parameter_list|,
name|t
parameter_list|)
name|tree
modifier|*
name|new_virtuals_p
decl_stmt|;
name|tree
modifier|*
name|overridden_virtuals_p
decl_stmt|;
name|int
modifier|*
name|vfuns_p
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Structure type.  */
block|{
name|tree
name|new_virtual
decl_stmt|;
comment|/* If this function doesn't override anything from a base class, we      can just assign it a new DECL_VINDEX now.  Otherwise, if it does      override something, we keep it around and assign its DECL_VINDEX      later, in modify_all_vtables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* We've already dealt with this function.  */
return|return;
name|new_virtual
operator|=
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
expr_stmt|;
name|BV_FN
argument_list|(
name|new_virtual
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|BV_DELTA
argument_list|(
name|new_virtual
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
comment|/* FNDECL is a new virtual function; it doesn't override any 	 virtual function in a base class.  */
comment|/* We remember that this was the base sub-object for rtti.  */
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Now assign virtual dispatch information.  */
name|set_vindex
argument_list|(
name|fndecl
argument_list|,
name|vfuns_p
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Save the state we've computed on the NEW_VIRTUALS list.  */
name|TREE_CHAIN
argument_list|(
name|new_virtual
argument_list|)
operator|=
operator|*
name|new_virtuals_p
expr_stmt|;
operator|*
name|new_virtuals_p
operator|=
name|new_virtual
expr_stmt|;
block|}
else|else
block|{
comment|/* FNDECL overrides a function from a base class.  */
name|TREE_CHAIN
argument_list|(
name|new_virtual
argument_list|)
operator|=
operator|*
name|overridden_virtuals_p
expr_stmt|;
operator|*
name|overridden_virtuals_p
operator|=
name|new_virtual
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add method METHOD to class TYPE.  If ERROR_P is true, we are adding    the method after the class has already been defined because a    declaration for it was seen.  (Even though that is erroneous, we    add the method for improved error recovery.)  */
end_comment

begin_function
name|void
name|add_method
parameter_list|(
name|type
parameter_list|,
name|method
parameter_list|,
name|error_p
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|method
decl_stmt|;
name|int
name|error_p
decl_stmt|;
block|{
name|int
name|using
init|=
operator|(
name|DECL_CONTEXT
argument_list|(
name|method
argument_list|)
operator|!=
name|type
operator|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Make a new method vector.  We start with 8 entries.  We must        allocate at least two (for constructors and destructors), and        we're going to end up with an assignment operator at some point        as well.                We could use a TREE_LIST for now, and convert it to a TREE_VEC        in finish_struct, but we would probably waste more memory        making the links in the list than we would by over-allocating        the size of the vector here.  Furthermore, we would complicate        all the code that expects this to be a vector.  */
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* Constructors and destructors go in special slots.  */
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|method
argument_list|)
condition|)
name|slot
operator|=
name|CLASSTYPE_CONSTRUCTOR_SLOT
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|method
argument_list|)
condition|)
name|slot
operator|=
name|CLASSTYPE_DESTRUCTOR_SLOT
expr_stmt|;
else|else
block|{
comment|/* See if we already have an entry with this name.  */
for|for
control|(
name|slot
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|method
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|slot
operator|==
name|len
condition|)
block|{
comment|/* We need a bigger method vector.  */
name|int
name|new_len
decl_stmt|;
name|tree
name|new_vec
decl_stmt|;
comment|/* In the non-error case, we are processing a class 	     definition.  Double the size of the vector to give room 	     for new methods.  */
if|if
condition|(
operator|!
name|error_p
condition|)
name|new_len
operator|=
literal|2
operator|*
name|len
expr_stmt|;
comment|/* In the error case, the vector is already complete.  We 	     don't expect many errors, and the rest of the front-end 	     will get confused if there are empty slots in the vector.  */
else|else
name|new_len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|new_vec
operator|=
name|make_tree_vec
argument_list|(
name|new_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|new_len
expr_stmt|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|new_vec
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
condition|)
block|{
comment|/* Type conversion operators have to come before ordinary 	     methods; add_conversions depends on this to speed up 	     looking for conversion operators.  So, if necessary, we 	     slide some of the vector elements up.  In theory, this 	     makes this algorithm O(N^2) but we don't expect many 	     conversion operators.  */
for|for
control|(
name|slot
operator|=
literal|2
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
comment|/* There are no more entries in the vector, so we 		   can insert the new conversion operator here.  */
break|break;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
comment|/* We can insert the new function right at the 		   SLOTth position.  */
break|break;
block|}
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
condition|)
comment|/* There is nothing in the Ith slot, so we can avoid 	       moving anything.  */
empty_stmt|;
else|else
block|{
comment|/* We know the last slot in the vector is empty 		 because we know that at this point there's room 		 for a new function.  */
name|memmove
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
operator|+
literal|1
argument_list|)
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|,
operator|(
name|len
operator|-
name|slot
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|template_class_depth
argument_list|(
name|type
argument_list|)
condition|)
comment|/* TYPE is a template class.  Don't issue any errors now; wait        until instantiation time to complain.  */
empty_stmt|;
else|else
block|{
name|tree
name|fns
decl_stmt|;
comment|/* Check to see if we've already got this method.  */
for|for
control|(
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|method
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
comment|/* [over.load] Member function declarations with the 		 same name and the same parameter types cannot be 		 overloaded if any of them is a static member 		 function declaration.  	         [namespace.udecl] When a using-declaration brings names 		 from a base class into a derived class scope, member 		 functions in the derived class override and/or hide member 		 functions with the same name and parameter types in a base 		 class (rather than conflicting).  */
if|if
condition|(
operator|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|!=
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|method
argument_list|)
operator|)
operator|||
name|using
condition|)
block|{
name|tree
name|parms1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parms2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|same
init|=
literal|1
decl_stmt|;
comment|/* Compare the quals on the 'this' parm.  Don't compare 		     the whole types, as used functions are treated as 		     coming from the using class in overload resolution.  */
if|if
condition|(
name|using
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms2
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|same
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parms1
operator|=
name|TREE_CHAIN
argument_list|(
name|parms1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|method
argument_list|)
condition|)
name|parms2
operator|=
name|TREE_CHAIN
argument_list|(
name|parms2
argument_list|)
expr_stmt|;
if|if
condition|(
name|same
operator|&&
name|compparms
argument_list|(
name|parms1
argument_list|,
name|parms2
argument_list|)
condition|)
block|{
if|if
condition|(
name|using
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|==
name|type
condition|)
comment|/* Defer to the local function.  */
return|return;
else|else
name|error
argument_list|(
literal|"`%#D' and `%#D' cannot be overloaded"
argument_list|,
name|fn
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|decls_match
argument_list|(
name|fn
argument_list|,
name|method
argument_list|)
condition|)
continue|continue;
comment|/* There has already been a declaration of this method 	     or member template.  */
name|cp_error_at
argument_list|(
literal|"`%D' has already been declared in `%T'"
argument_list|,
name|method
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* We don't call duplicate_decls here to merge the 	     declarations because that will confuse things if the 	     methods have inline definitions.  In particular, we 	     will crash while processing the definitions.  */
return|return;
block|}
block|}
comment|/* Actually insert the new method.  */
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|=
name|build_overload
argument_list|(
name|method
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the new binding.  */
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|method
argument_list|)
condition|)
name|push_class_level_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|method
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutines of finish_struct.  */
end_comment

begin_comment
comment|/* Look through the list of fields for this struct, deleting    duplicates as we go.  This must be recursive to handle    anonymous unions.     FIELD is the field which may not appear anywhere in FIELDS.    FIELD_PTR, if non-null, is the starting point at which    chained deletions may take place.    The value returned is the first acceptable entry found    in FIELDS.     Note that anonymous fields which are not of UNION_TYPE are    not duplicates, they are just anonymous fields.  This happens    when we have unnamed bitfields, for example.  */
end_comment

begin_function
specifier|static
name|tree
name|delete_duplicate_fields_1
parameter_list|(
name|field
parameter_list|,
name|fields
parameter_list|)
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|tree
name|prev
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
name|fields
return|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|fields
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|fields
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|prev
operator|=
name|x
operator|,
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|field
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|USING_DECL
condition|)
comment|/* A using declaration is allowed to appear more than 	       once.  We'll prune these from the field list later, and 	       handle_using_decl will complain about invalid multiple 	       uses.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate enum value `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as enum and non-enum)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARES_TYPE_P
argument_list|(
name|field
argument_list|)
operator|&&
name|DECL_DECLARES_TYPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|cp_error_at
argument_list|(
literal|"duplicate nested type `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARES_TYPE_P
argument_list|(
name|field
argument_list|)
operator|||
name|DECL_DECLARES_TYPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Hide tag decls.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
continue|continue;
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as type and non-type)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error_at
argument_list|(
literal|"duplicate member `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|fields
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_duplicate_fields
parameter_list|(
name|fields
parameter_list|)
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the access of FDECL to ACCESS in T.  Return 1 if change was    legit, otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|alter_access
parameter_list|(
name|t
parameter_list|,
name|fdecl
parameter_list|,
name|access
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fdecl
decl_stmt|;
name|tree
name|access
decl_stmt|;
block|{
name|tree
name|elem
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|fdecl
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DISCRIMINATOR_P
argument_list|(
name|fdecl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|elem
operator|=
name|purpose_member
argument_list|(
name|t
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
operator|!=
name|access
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"conflicting access specifications for method `%D', ignored"
argument_list|,
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"conflicting access specifications for field `%s', ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* They're changing the access to the same thing they changed 	     it to before.  That's OK.  */
empty_stmt|;
block|}
block|}
else|else
block|{
name|enforce_access
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|access
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the USING_DECL, which is a member of T.  */
end_comment

begin_function
specifier|static
name|void
name|handle_using_decl
parameter_list|(
name|using_decl
parameter_list|,
name|t
parameter_list|)
name|tree
name|using_decl
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|ctype
init|=
name|DECL_INITIAL
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|access
init|=
name|TREE_PRIVATE
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_private_node
else|:
name|TREE_PROTECTED
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_protected_node
else|:
name|access_public_node
decl_stmt|;
name|tree
name|fdecl
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|flist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|old_value
decl_stmt|;
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|ctype
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
return|return;
if|if
condition|(
name|name
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|||
name|name
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' names constructor"
argument_list|,
name|using_decl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|name
operator|==
name|constructor_name
argument_list|(
name|t
argument_list|)
operator|||
name|name
operator|==
name|constructor_name_full
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' invalid in `%T'"
argument_list|,
name|using_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|fdecl
operator|=
name|lookup_member
argument_list|(
name|binfo
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"no members matching `%D' in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fdecl
argument_list|)
condition|)
comment|/* Ignore base type this came from. */
name|fdecl
operator|=
name|TREE_VALUE
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
name|old_value
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_value
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old_value
argument_list|)
condition|)
name|old_value
operator|=
name|OVL_CURRENT
argument_list|(
name|old_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|old_value
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|old_value
argument_list|)
operator|==
name|t
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|old_value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fdecl
argument_list|)
condition|)
name|flist
operator|=
name|fdecl
expr_stmt|;
if|if
condition|(
operator|!
name|old_value
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old_value
argument_list|)
condition|)
block|{
if|if
condition|(
name|flist
condition|)
comment|/* It's OK to use functions from a base when there are functions with 	   the same name already present in the current class.  */
empty_stmt|;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"`%D' invalid in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local method `%#D' with same name"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|old_value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|old_value
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' invalid in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local member `%#D' with same name"
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make type T see field decl FDECL with access ACCESS.*/
if|if
condition|(
name|flist
condition|)
for|for
control|(
init|;
name|flist
condition|;
name|flist
operator|=
name|OVL_NEXT
argument_list|(
name|flist
argument_list|)
control|)
block|{
name|add_method
argument_list|(
name|t
argument_list|,
name|OVL_CURRENT
argument_list|(
name|flist
argument_list|)
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|alter_access
argument_list|(
name|t
argument_list|,
name|OVL_CURRENT
argument_list|(
name|flist
argument_list|)
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
else|else
name|alter_access
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Run through the base clases of T, updating    CANT_HAVE_DEFAULT_CTOR_P, CANT_HAVE_CONST_CTOR_P, and    NO_CONST_ASN_REF_P.  Also set flag bits in T based on properties of    the bases.  */
end_comment

begin_function
specifier|static
name|void
name|check_bases
parameter_list|(
name|t
parameter_list|,
name|cant_have_default_ctor_p
parameter_list|,
name|cant_have_const_ctor_p
parameter_list|,
name|no_const_asn_ref_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|cant_have_default_ctor_p
decl_stmt|;
name|int
modifier|*
name|cant_have_const_ctor_p
decl_stmt|;
name|int
modifier|*
name|no_const_asn_ref_p
decl_stmt|;
block|{
name|int
name|n_baseclasses
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|seen_non_virtual_nearly_empty_base_p
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
name|binfos
operator|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|seen_non_virtual_nearly_empty_base_p
operator|=
literal|0
expr_stmt|;
comment|/* An aggregate cannot have baseclasses.  */
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|n_baseclasses
operator|!=
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
comment|/* Figure out what base we're looking at.  */
name|base_binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* If the type of basetype is incomplete, then we already 	 complained about that fact (and we should have fixed it up as 	 well).  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* The base type is of incomplete type.  It is 	     probably best to pretend that it does not 	     exist.  */
if|if
condition|(
name|i
operator|==
name|n_baseclasses
operator|-
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|n_baseclasses
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|+
literal|1
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Effective C++ rule 14.  We only need to check TYPE_POLYMORPHIC_P 	 here because the case of virtual functions but non-virtual 	 dtor is handled in finish_struct_1.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|!
name|TYPE_POLYMORPHIC_P
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|warning
argument_list|(
literal|"base class `%#T' has a non-virtual destructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
comment|/* If the base class doesn't have copy constructors or 	 assignment operators that take const references, then the 	 derived class cannot have such a member automatically 	 generated.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
operator|*
name|cant_have_const_ctor_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
condition|)
operator|*
name|no_const_asn_ref_p
operator|=
literal|1
expr_stmt|;
comment|/* Similarly, if the base class doesn't have a default 	 constructor, then the derived class won't have an 	 automatically generated default constructor.  */
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
operator|*
name|cant_have_default_ctor_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"base `%T' with only non-default constructor in class without a constructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
comment|/* A virtual base does not effect nearly emptiness. */
empty_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|seen_non_virtual_nearly_empty_base_p
condition|)
comment|/* And if there is more than one nearly empty base, then the 	       derived class is not nearly empty either.  */
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
comment|/* Remember we've seen one. */
name|seen_non_virtual_nearly_empty_base_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_empty_class
argument_list|(
name|basetype
argument_list|)
condition|)
comment|/* If the base class is not empty or nearly empty, then this 	   class cannot be nearly empty.  */
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* A lot of properties from the bases also apply to the derived 	 class.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_POLYMORPHIC_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Binfo FROM is within a virtual hierarchy which is being reseated to    TO. Move primary information from FROM to TO, and recursively traverse    into FROM's bases. The hierarchy is dominated by TYPE.  MAPPINGS is an    assoc list of binfos that have already been reseated.  */
end_comment

begin_function
specifier|static
name|void
name|force_canonical_binfo_r
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|type
parameter_list|,
name|mappings
parameter_list|)
name|tree
name|to
decl_stmt|;
name|tree
name|from
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|mappings
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|BINFO_N_BASETYPES
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|to
operator|!=
name|from
argument_list|,
literal|20010905
argument_list|)
expr_stmt|;
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|to
argument_list|)
operator|=
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|from
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BINFO_UNSHARED_MARKED
argument_list|(
name|to
argument_list|)
operator|=
name|BINFO_UNSHARED_MARKED
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|BINFO_UNSHARED_MARKED
argument_list|(
name|from
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|to
argument_list|)
operator|=
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|from
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|tree
name|primary
init|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|tree
name|assoc
decl_stmt|;
comment|/* We might have just moved the primary base too, see if it's on our          mappings.  */
name|assoc
operator|=
name|purpose_member
argument_list|(
name|primary
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
condition|)
name|primary
operator|=
name|TREE_VALUE
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|to
argument_list|)
operator|=
name|primary
expr_stmt|;
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|from
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
literal|20010104
argument_list|)
expr_stmt|;
name|mappings
operator|=
name|tree_cons
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|from_primary
init|=
name|get_primary_binfo
argument_list|(
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|from_primary
argument_list|)
operator|==
name|from
condition|)
name|force_canonical_binfo
argument_list|(
name|get_primary_binfo
argument_list|(
name|to
argument_list|)
argument_list|,
name|from_primary
argument_list|,
name|type
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|from_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|to_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|from_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|from_binfo
argument_list|)
operator|&&
name|purpose_member
argument_list|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|from_binfo
argument_list|)
argument_list|,
name|mappings
argument_list|)
condition|)
comment|/* This base is a primary of some binfo we have already 	       reseated. We must reseat this one too.  */
name|force_canonical_binfo
argument_list|(
name|to_binfo
argument_list|,
name|from_binfo
argument_list|,
name|type
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
block|}
else|else
name|force_canonical_binfo_r
argument_list|(
name|to_binfo
argument_list|,
name|from_binfo
argument_list|,
name|type
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FROM is the canonical binfo for a virtual base. It is being reseated to    make TO the canonical binfo, within the hierarchy dominated by TYPE.    MAPPINGS is an assoc list of binfos that have already been reseated.    Adjust any non-virtual bases within FROM, and also move any virtual bases    which are canonical.  This complication arises because selecting primary    bases walks in inheritance graph order, but we don't share binfos for    virtual bases, hence we can fill in the primaries for a virtual base,    and then discover that a later base requires the virtual as its    primary.  */
end_comment

begin_function
specifier|static
name|void
name|force_canonical_binfo
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|type
parameter_list|,
name|mappings
parameter_list|)
name|tree
name|to
decl_stmt|;
name|tree
name|from
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|mappings
decl_stmt|;
block|{
name|tree
name|assoc
init|=
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|assoc
argument_list|)
operator|!=
name|to
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|assoc
argument_list|)
operator|=
name|to
expr_stmt|;
name|force_canonical_binfo_r
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|type
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make BASE_BINFO the a primary virtual base within the hierarchy    dominated by TYPE. Returns BASE_BINFO, if it is not already one, NULL    otherwise (because something else has already made it primary).  */
end_comment

begin_function
specifier|static
name|tree
name|mark_primary_virtual_base
parameter_list|(
name|base_binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|base_binfo
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|shared_binfo
init|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|shared_binfo
argument_list|)
condition|)
block|{
comment|/* It's already allocated in the hierarchy. BINFO won't have a          primary base in this hierarchy, even though the complete object          BINFO is for, would do.  */
return|return
name|NULL_TREE
return|;
block|}
comment|/* We need to make sure that the assoc list      CLASSTYPE_VBASECLASSES of TYPE, indicates this particular      primary BINFO for the virtual base, as this is the one      that'll really exist.  */
if|if
condition|(
name|base_binfo
operator|!=
name|shared_binfo
condition|)
name|force_canonical_binfo
argument_list|(
name|base_binfo
argument_list|,
name|shared_binfo
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|base_binfo
return|;
block|}
end_function

begin_comment
comment|/* If BINFO is an unmarked virtual binfo for a class with a primary virtual    base, then BINFO has no primary base in this graph.  Called from    mark_primary_bases.  DATA is the most derived type. */
end_comment

begin_function
specifier|static
name|tree
name|dfs_unshared_virtual_bases
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|BINFO_UNSHARED_MARKED
argument_list|(
name|binfo
argument_list|)
operator|&&
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This morally virtual base has a primary base when it          is a complete object. We need to locate the shared instance          of this binfo in the type dominated by T. We duplicate the          primary base information from there to here.  */
name|tree
name|vbase
decl_stmt|;
name|tree
name|unshared_base
decl_stmt|;
for|for
control|(
name|vbase
operator|=
name|binfo
init|;
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|;
name|vbase
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
continue|continue;
name|unshared_base
operator|=
name|get_original_base
argument_list|(
name|binfo
argument_list|,
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|unshared_base
operator|!=
name|binfo
argument_list|,
literal|20010612
argument_list|)
expr_stmt|;
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|=
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|unshared_base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|=
name|binfo
expr_stmt|;
block|}
if|if
condition|(
name|binfo
operator|!=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
comment|/* The vtable fields will have been copied when duplicating the        base binfos. That information is bogus, make sure we don't try        and use it. */
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If this is a virtual primary base, make sure its offset matches      that which it is primary for. */
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
operator|==
name|binfo
condition|)
block|{
name|tree
name|delta
init|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|delta
argument_list|)
condition|)
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|delta
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|BINFO_UNSHARED_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set BINFO_PRIMARY_BASE_OF for all binfos in the hierarchy    dominated by TYPE that are primary bases.  */
end_comment

begin_function
specifier|static
name|void
name|mark_primary_bases
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
comment|/* Walk the bases in inheritance graph order.  */
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
comment|/* Not a dynamic base. */
continue|continue;
name|base_binfo
operator|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|base_binfo
operator|=
name|mark_primary_virtual_base
argument_list|(
name|base_binfo
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
condition|)
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
else|else
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_UNSHARED_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* There could remain unshared morally virtual bases which were not      visited in the inheritance graph walk. These bases will have lost      their virtual primary base (should they have one). We must now      find them. Also we must fix up the BINFO_OFFSETs of primary      virtual bases. We could not do that as we went along, as they      were originally copied from the bases we inherited from by      unshare_base_binfos. That may have decided differently about      where a virtual primary base went.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unshared_virtual_bases
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the BINFO the primary base of T.  */
end_comment

begin_function
specifier|static
name|void
name|set_primary_base
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|,
name|vfuns_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|int
modifier|*
name|vfuns_p
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|;
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_RTTI
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
operator|*
name|vfuns_p
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the primary class for T.  */
end_comment

begin_function
specifier|static
name|void
name|determine_primary_base
parameter_list|(
name|t
parameter_list|,
name|vfuns_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|vfuns_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|tree
name|type_binfo
decl_stmt|;
comment|/* If there are no baseclasses, there is certainly no primary base.  */
if|if
condition|(
name|n_baseclasses
operator|==
literal|0
condition|)
return|return;
name|type_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|type_binfo
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* Even a virtual baseclass can contain our RTTI 	     information.  But, we prefer a non-virtual polymorphic 	     baseclass.  */
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_RTTI
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* We prefer a non-virtual base, although a virtual one will 	     do.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|set_primary_base
argument_list|(
name|t
argument_list|,
name|base_binfo
argument_list|,
name|vfuns_p
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|copy_list
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|vfields
decl_stmt|;
comment|/* Only add unique vfields, and flatten them out as we go.  */
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Find the indirect primary bases - those virtual bases which are primary      bases of something else in this hierarchy.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|vbase_binfo
init|=
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
comment|/* See if this virtual base is an indirect primary base.  To be so,          it must be a primary base within the hierarchy of one of our          direct bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
name|tree
name|base_vbase
init|=
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|base_vbase
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_vbase
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|vbase_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|vbase_binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we've discovered that this virtual base is an indirect 	     primary base, then we can move on to the next virtual 	     base.  */
if|if
condition|(
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|vbase_binfo
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* A "nearly-empty" virtual base class can be the primary base      class, if no non-virtual polymorphic base can be found.  */
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* If not NULL, this is the best primary base candidate we have          found so far.  */
name|tree
name|candidate
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
comment|/* Loop over the baseclasses.  */
for|for
control|(
name|base_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
init|;
name|base_binfo
condition|;
name|base_binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* If this is not an indirect primary base, then it's 		 definitely our primary base.  */
if|if
condition|(
operator|!
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|candidate
operator|=
name|base_binfo
expr_stmt|;
break|break;
block|}
comment|/* If this is an indirect primary base, it still could be 	         our primary base -- unless we later find there's another 	         nearly-empty virtual base that isn't an indirect 	         primary base.  */
if|if
condition|(
operator|!
name|candidate
condition|)
name|candidate
operator|=
name|base_binfo
expr_stmt|;
block|}
block|}
comment|/* If we've got a primary base, use it.  */
if|if
condition|(
name|candidate
condition|)
block|{
name|set_primary_base
argument_list|(
name|t
argument_list|,
name|candidate
argument_list|,
name|vfuns_p
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|copy_list
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|candidate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark the primary base classes at this point.  */
name|mark_primary_bases
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set memoizing fields and bits of T (and its variants) for later    use.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Fix up variants (if any).  */
name|tree
name|variants
init|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
comment|/* These fields are in the _TYPE part of the node, not in 	 the TYPE_LANG_SPECIFIC component, so they are not shared.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_POLYMORPHIC_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Copy whatever these are holding today.  */
name|TYPE_MIN_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* For a class w/o baseclasses, `finish_struct' has set        CLASS_TYPE_ABSTRACT_VIRTUALS correctly (by        definition). Similarly for a class whose base classes do not        have vtables. When neither of these is true, we might have        removed abstract virtuals (by providing a definition), added        some (by declaring new ones), or redeclared ones from a base        class. We need to recalculate what's really an abstract virtual        at this point (by looking in the vtables).  */
name|get_pure_virtuals
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
block|{
comment|/* Notice whether this class has type conversion functions defined.  */
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this type has a copy constructor, force its mode to be BLKmode, and      force its TREE_ADDRESSABLE bit to be nonzero.  This will cause it to      be passed by invisible reference and prevent it from being returned in      a register.       Also do this if the class has BLKmode but can still be returned in      registers, since function_cannot_inline_p won't let us inline      functions returning such a type.  This affects the HP-PA.  */
if|if
condition|(
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|tree
name|variants
decl_stmt|;
name|DECL_MODE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
for|for
control|(
name|variants
operator|=
name|t
init|;
name|variants
condition|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
control|)
block|{
name|TYPE_MODE
argument_list|(
name|variants
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|variants
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Issue warnings about T having private constructors, but no friends,    and so forth.       HAS_NONPRIVATE_METHOD is nonzero if T has any non-private methods or    static members.  HAS_NONPRIVATE_STATIC_FN is nonzero if T has any    non-private static member functions.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_warn_about_overly_private_class
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|has_member_fn
init|=
literal|0
decl_stmt|;
name|int
name|has_nonprivate_method
init|=
literal|0
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|warn_ctor_dtor_privacy
comment|/* If the class has friends, those entities might create and 	 access instances, so we should not warn.  */
operator|||
operator|(
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
comment|/* We will have warned when the template was declared; there's 	 no need to warn on every instantiation.  */
operator|||
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
comment|/* There's no reason to even consider warning about this         class.  */
return|return;
comment|/* We only issue one warning, if more than one applies, because      otherwise, on code like:       class A {        // Oops - forgot `public:'        A();        A(const A&);        ~A();      };       we warn several times about essentially the same problem.  */
comment|/* Check to see if all (non-constructor, non-destructor) member      functions are private.  (Since there are no friends or      non-private statics, we can't ever call any of the private member      functions.)  */
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
comment|/* We're not interested in compiler-generated methods; they don't        provide any way to call private members.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* A non-private static member function is just like a 		 friend; it can create and invoke private member 		 functions, and be accessed without a class 		 instance.  */
return|return;
name|has_nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|has_member_fn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_nonprivate_method
operator|&&
name|has_member_fn
condition|)
block|{
comment|/* There are no non-private methods, and there's at least one 	 private member function that isn't a constructor or 	 destructor.  (If all the private members are 	 constructors/destructors we want to use the code below that 	 issues error messages specifically referring to 	 constructors/destructors.)  */
name|int
name|i
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_PROTECTED
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|has_nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|has_nonprivate_method
condition|)
block|{
name|warning
argument_list|(
literal|"all member functions in class `%T' are private"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Even if some of the member functions are non-private, the class      won't be useful for much if all the constructors or destructors      are private: such an object can never be created or destroyed.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|dtor
init|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|dtor
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%#T' only defines a private destructor and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|nonprivate_ctor
init|=
literal|0
decl_stmt|;
comment|/* If a non-template class does not define a copy 	 constructor, one is defined for it, enabling it to avoid 	 this warning.  For a template class, this does not 	 happen, and so we would normally get a warning on:  	   template<class T> class C { private: C(); };   	   	 To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  All 	 complete non-template or fully instantiated classes have this 	 flag set.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|fn
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|ctor
init|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
comment|/* Ideally, we wouldn't count copy constructors (or, in 	       fact, any constructor that takes an argument of the 	       class type as a parameter) because such things cannot 	       be used to construct an instance of the class unless 	       you already have one.  But, for now at least, we're 	       more generous.  */
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|ctor
argument_list|)
condition|)
block|{
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nonprivate_ctor
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"`%#T' only defines private constructors and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Function to help qsort sort FIELD_DECLs by name order.  */
end_comment

begin_function
specifier|static
name|int
name|field_decl_cmp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|tree
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
condition|)
comment|/* A nontype is "greater" than a type.  */
return|return
name|DECL_DECLARES_TYPE_P
argument_list|(
operator|*
name|y
argument_list|)
operator|-
name|DECL_DECLARES_TYPE_P
argument_list|(
operator|*
name|x
argument_list|)
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|<
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */
end_comment

begin_function
specifier|static
name|int
name|method_name_cmp
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
specifier|const
name|tree
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|*
name|m1
operator|==
name|NULL_TREE
operator|&&
operator|*
name|m2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|m1
operator|==
name|NULL_TREE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|m2
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|m1
argument_list|)
argument_list|)
operator|<
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|m2
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Warn about duplicate methods in fn_fields.  Also compact method    lists so that lookup can be made faster.     Data Structure: List of method lists.  The outer list is a    TREE_LIST, whose TREE_PURPOSE field is the field name and the    TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN    links the entire list of methods for TYPE_METHODS.  Friends are    chained in the same way as member functions (? TREE_CHAIN or    DECL_CHAIN), but they live in the TREE_TYPE field of the outer    list.  That allows them to be quickly deleted, and requires no    extra storage.     Sort methods that are not special (i.e., constructors, destructors,    and type conversion operators) so that we can find them faster in    search.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_methods
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|fn_fields
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Clear these for safety; perhaps some parsing error could set 	 these incorrectly.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|method_vec
operator|!=
name|NULL_TREE
argument_list|,
literal|19991215
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* First fill in entry 0 with the constructors, entry 1 with destructors,      and the next few with type conversion operators (if any).  */
for|for
control|(
name|fn_fields
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn_fields
condition|;
name|fn_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
control|)
comment|/* Clear out this flag.  */
name|DECL_IN_AGGR_P
argument_list|(
name|fn_fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|t
argument_list|)
condition|)
comment|/* We thought there was a destructor, but there wasn't.  Some        parse errors cause this anomalous situation.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Issue warnings about private constructors and such.  If there are      no methods, then some public defaults are generated.  */
name|maybe_warn_about_overly_private_class
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Now sort the methods.  */
while|while
condition|(
name|len
operator|>
literal|2
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|len
operator|--
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
name|len
expr_stmt|;
comment|/* The type conversion ops have to live at the front of the vec, so we      can't sort them.  */
for|for
control|(
name|slot
operator|=
literal|2
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|len
operator|-
name|slot
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|,
name|len
operator|-
name|slot
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|method_name_cmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit error when a duplicate definition of a type is seen.  Patch up.  */
end_comment

begin_function
name|void
name|duplicate_tag_error
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous definition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pretend we haven't defined this type.  */
comment|/* All of the component_decl's were TREE_CHAINed together in the parser.      finish_struct_methods walks these chains and assembles all methods with      the same base name into DECL_CHAINs. Now we don't need the parser chains      anymore, so we unravel them.  */
comment|/* This used to be in finish_struct, but it turns out that the      TREE_CHAIN is used by dbxout_type_methods and perhaps some other      things...  */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|unchain
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|unchain
operator|!=
name|NULL_TREE
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|OVL_CURRENT
argument_list|(
name|unchain
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|unchain
operator|=
name|OVL_NEXT
argument_list|(
name|unchain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_only
init|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_unknown
init|=
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|template_info
init|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|use_template
init|=
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|TYPE_REDEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|=
name|template_info
expr_stmt|;
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
operator|=
name|use_template
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Clear TYPE_LANG_FLAGS -- those in TYPE_LANG_SPECIFIC are cleared above.  */
name|TYPE_LANG_FLAG_0
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_FLAG_1
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_FLAG_2
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_FLAG_3
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_FLAG_4
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_FLAG_5
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_FLAG_6
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* But not this one.  */
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make BINFO's vtable have N entries, including RTTI entries,    vbase and vcall offsets, etc.  Set its type and call the backend    to lay it out.  */
end_comment

begin_function
specifier|static
name|void
name|layout_vtable_decl
parameter_list|(
name|binfo
parameter_list|,
name|n
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|tree
name|atype
decl_stmt|;
name|tree
name|vtable
decl_stmt|;
name|atype
operator|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|n
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
comment|/* We may have to grow the vtable.  */
name|vtable
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|,
name|atype
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
operator|=
name|atype
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|vtable
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|vtable
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_decl
argument_list|(
name|vtable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* At one time the vtable info was grabbed 2 words at a time.  This 	 fails on Sparc unless you have 8-byte alignment.  */
name|DECL_ALIGN
argument_list|(
name|vtable
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|vtable
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True iff FNDECL and BASE_FNDECL (both non-static member functions)    have the same signature.  */
end_comment

begin_function
name|int
name|same_signature_p
parameter_list|(
name|fndecl
parameter_list|,
name|base_fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|base_fndecl
decl_stmt|;
block|{
comment|/* One destructor overrides another if they are the same kind of      destructor.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|base_fndecl
argument_list|)
operator|&&
name|DECL_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|special_function_p
argument_list|(
name|base_fndecl
argument_list|)
operator|==
name|special_function_p
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* But a non-destructor never overrides a destructor, nor vice      versa, nor do different kinds of destructors override      one-another.  For example, a complete object destructor does not      override a deleting destructor.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|base_fndecl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|base_fndecl
argument_list|)
condition|)
block|{
name|tree
name|types
decl_stmt|,
name|base_types
decl_stmt|;
name|types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|base_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_types
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|base_types
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|find_final_overrider_data_s
block|{
comment|/* The function for which we are trying to find a final overrider.  */
name|tree
name|fn
decl_stmt|;
comment|/* The base class in which the function was declared.  */
name|tree
name|declaring_base
decl_stmt|;
comment|/* The most derived class in the hierarchy.  */
name|tree
name|most_derived_type
decl_stmt|;
comment|/* The final overriding function.  */
name|tree
name|overriding_fn
decl_stmt|;
comment|/* The functions that we thought might be final overriders, but      aren't.  */
name|tree
name|candidates
decl_stmt|;
comment|/* The BINFO for the class in which the final overriding function      appears.  */
name|tree
name|overriding_base
decl_stmt|;
block|}
name|find_final_overrider_data
typedef|;
end_typedef

begin_comment
comment|/* Called from find_final_overrider via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_find_final_overrider
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|find_final_overrider_data
modifier|*
name|ffod
init|=
operator|(
name|find_final_overrider_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|ffod
operator|->
name|declaring_base
argument_list|)
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|ffod
operator|->
name|declaring_base
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|tree
name|method
decl_stmt|;
comment|/* We haven't found an overrider yet.  */
name|method
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We've found a path to the declaring base.  Walk down the path 	 looking for an overrider for FN.  */
for|for
control|(
name|path
operator|=
name|reverse_path
argument_list|(
name|binfo
argument_list|)
init|;
name|path
condition|;
name|path
operator|=
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
control|)
block|{
name|method
operator|=
name|look_for_overrides_here
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|,
name|ffod
operator|->
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
break|break;
block|}
comment|/* If we found an overrider, record the overriding function, and 	 the base from which it came.  */
if|if
condition|(
name|path
condition|)
block|{
name|tree
name|base
decl_stmt|;
comment|/* Assume the path is non-virtual.  See if there are any 	     virtual bases from (but not including) the overrider up 	     to and including the base where the function is 	     defined. */
for|for
control|(
name|base
operator|=
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
init|;
name|base
condition|;
name|base
operator|=
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
control|)
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|ffod
operator|->
name|declaring_base
expr_stmt|;
break|break;
block|}
comment|/* If we didn't already have an overrider, or any 	     candidates, then this function is the best candidate so 	     far.  */
if|if
condition|(
operator|!
name|ffod
operator|->
name|overriding_fn
operator|&&
operator|!
name|ffod
operator|->
name|candidates
condition|)
block|{
name|ffod
operator|->
name|overriding_fn
operator|=
name|method
expr_stmt|;
name|ffod
operator|->
name|overriding_base
operator|=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffod
operator|->
name|overriding_fn
condition|)
block|{
comment|/* We had a best overrider; let's see how this compares.  */
if|if
condition|(
name|ffod
operator|->
name|overriding_fn
operator|==
name|method
operator|&&
operator|(
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|ffod
operator|->
name|overriding_base
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* We found the same overrider we already have, and in the 		   same place; it's still the best.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|ffod
operator|->
name|overriding_fn
argument_list|,
name|method
argument_list|)
condition|)
comment|/* The old function overrides this function; it's still the 		   best.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|method
argument_list|,
name|ffod
operator|->
name|overriding_fn
argument_list|)
condition|)
block|{
comment|/* The new function overrides the old; it's now the 		     best.  */
name|ffod
operator|->
name|overriding_fn
operator|=
name|method
expr_stmt|;
name|ffod
operator|->
name|overriding_base
operator|=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ambiguous.  */
name|ffod
operator|->
name|candidates
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffod
operator|->
name|overriding_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|!=
name|ffod
operator|->
name|overriding_fn
condition|)
name|ffod
operator|->
name|candidates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|method
argument_list|,
name|ffod
operator|->
name|candidates
argument_list|)
expr_stmt|;
name|ffod
operator|->
name|overriding_fn
operator|=
name|NULL_TREE
expr_stmt|;
name|ffod
operator|->
name|overriding_base
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We had a list of ambiguous overrides; let's see how this 		 new one compares.  */
name|tree
name|candidates
decl_stmt|;
name|bool
name|incomparable
init|=
name|false
decl_stmt|;
comment|/* If there were previous candidates, and this function 		 overrides all of them, then it is the new best 		 candidate.  */
for|for
control|(
name|candidates
operator|=
name|ffod
operator|->
name|candidates
init|;
name|candidates
condition|;
name|candidates
operator|=
name|TREE_CHAIN
argument_list|(
name|candidates
argument_list|)
control|)
block|{
comment|/* If the candidate overrides the METHOD, then we 		     needn't worry about it any further.  */
if|if
condition|(
name|strictly_overrides
argument_list|(
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|,
name|method
argument_list|)
condition|)
block|{
name|method
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
comment|/* If the METHOD doesn't override the candidate, 		     then it is incomporable.  */
if|if
condition|(
operator|!
name|strictly_overrides
argument_list|(
name|method
argument_list|,
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|)
condition|)
name|incomparable
operator|=
name|true
expr_stmt|;
block|}
comment|/* If METHOD overrode all the candidates, then it is the 		 new best candidate.  */
if|if
condition|(
operator|!
name|candidates
operator|&&
operator|!
name|incomparable
condition|)
block|{
name|ffod
operator|->
name|overriding_fn
operator|=
name|method
expr_stmt|;
name|ffod
operator|->
name|overriding_base
operator|=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|ffod
operator|->
name|candidates
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If METHOD didn't override all the candidates, then it 		 is another candidate.  */
elseif|else
if|if
condition|(
name|method
operator|&&
name|incomparable
condition|)
name|ffod
operator|->
name|candidates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|method
argument_list|,
name|ffod
operator|->
name|candidates
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns a TREE_LIST whose TREE_PURPOSE is the final overrider for    FN and whose TREE_VALUE is the binfo for the base where the    overriding occurs.  BINFO (in the hierarchy dominated by T) is the    base object in which FN is declared.  */
end_comment

begin_function
specifier|static
name|tree
name|find_final_overrider
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fn
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|fn
decl_stmt|;
block|{
name|find_final_overrider_data
name|ffod
decl_stmt|;
comment|/* Getting this right is a little tricky.  This is legal:         struct S { virtual void f (); };        struct T { virtual void f (); };        struct U : public S, public T { };       even though calling `f' in `U' is ambiguous.  But,          struct R { virtual void f(); };        struct S : virtual public R { virtual void f (); };        struct T : virtual public R { virtual void f (); };        struct U : public S, public T { };       is not -- there's no way to decide whether to put `S::f' or      `T::f' in the vtable for `R'.              The solution is to look at all paths to BINFO.  If we find      different overriders along any two, then there is a problem.  */
name|ffod
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|ffod
operator|.
name|declaring_base
operator|=
name|binfo
expr_stmt|;
name|ffod
operator|.
name|most_derived_type
operator|=
name|t
expr_stmt|;
name|ffod
operator|.
name|overriding_fn
operator|=
name|NULL_TREE
expr_stmt|;
name|ffod
operator|.
name|overriding_base
operator|=
name|NULL_TREE
expr_stmt|;
name|ffod
operator|.
name|candidates
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|dfs_find_final_overrider
argument_list|,
name|NULL
argument_list|,
operator|&
name|ffod
argument_list|)
expr_stmt|;
comment|/* If there was no winner, issue an error message.  */
if|if
condition|(
operator|!
name|ffod
operator|.
name|overriding_fn
condition|)
block|{
name|error
argument_list|(
literal|"no unique final overrider for `%D' in `%T'"
argument_list|,
name|fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_tree_list
argument_list|(
name|ffod
operator|.
name|overriding_fn
argument_list|,
name|ffod
operator|.
name|overriding_base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the function from the BINFO_VIRTUALS entry in T which matches    the signature of FUNCTION_DECL FN, or NULL_TREE if none.  In other words,    the function that the slot in T's primary vtable points to.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|get_matching_virtual
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|get_matching_virtual
parameter_list|(
name|t
parameter_list|,
name|fn
parameter_list|)
name|tree
name|t
decl_stmt|,
name|fn
decl_stmt|;
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|same_signature_p
argument_list|(
name|BV_FN
argument_list|(
name|f
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|BV_FN
argument_list|(
name|f
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Update an entry in the vtable for BINFO, which is in the hierarchy    dominated by T.  FN has been overriden in BINFO; VIRTUALS points to the    corresponding position in the BINFO_VIRTUALS list.  */
end_comment

begin_function
specifier|static
name|void
name|update_vtable_entry_for_fn
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fn
parameter_list|,
name|virtuals
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
modifier|*
name|virtuals
decl_stmt|;
block|{
name|tree
name|b
decl_stmt|;
name|tree
name|overrider
decl_stmt|;
name|tree
name|delta
decl_stmt|;
name|tree
name|virtual_base
decl_stmt|;
name|tree
name|first_defn
decl_stmt|;
name|bool
name|lost
init|=
name|false
decl_stmt|;
comment|/* Find the nearest primary base (possibly binfo itself) which defines      this function; this is the class the caller will convert to when      calling FN through BINFO.  */
for|for
control|(
name|b
operator|=
name|binfo
init|;
condition|;
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
name|look_for_overrides_here
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
break|break;
comment|/* The nearest definition is from a lost primary.  */
if|if
condition|(
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|b
argument_list|)
condition|)
name|lost
operator|=
name|true
expr_stmt|;
block|}
name|first_defn
operator|=
name|b
expr_stmt|;
comment|/* Find the final overrider.  */
name|overrider
operator|=
name|find_final_overrider
argument_list|(
name|t
argument_list|,
name|b
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|overrider
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Assume that we will produce a thunk that convert all the way to      the final overrider, and not to an intermediate virtual base.  */
name|virtual_base
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* See if we can convert to an intermediate virtual base first, and then      use the vcall offset located there to finish the conversion.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
block|{
comment|/* If we find the final overrider, then we can stop 	 walking.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|overrider
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* If we find a virtual base, and we haven't yet found the 	 overrider, then there is a virtual base between the 	 declaring base (first_defn) and the final overrider.  */
if|if
condition|(
operator|!
name|virtual_base
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
condition|)
name|virtual_base
operator|=
name|b
expr_stmt|;
block|}
comment|/* Compute the constant adjustment to the `this' pointer.  The      `this' pointer, when this function is called, will point at BINFO      (or one of its primary bases, which are at the same offset).  */
if|if
condition|(
name|virtual_base
condition|)
comment|/* The `this' pointer needs to be adjusted from the declaration to        the nearest virtual base.  */
name|delta
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|virtual_base
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|first_defn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lost
condition|)
comment|/* If the nearest definition is in a lost primary, we don't need an        entry in our vtable.  Except possibly in a constructor vtable,        if we happen to get our primary back.  In that case, the offset        will be zero, as it will be a primary base.  */
name|delta
operator|=
name|size_zero_node
expr_stmt|;
else|else
block|{
comment|/* The `this' pointer needs to be adjusted from pointing to 	 BINFO to pointing at the base where the final overrider 	 appears.  */
name|delta
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|TREE_VALUE
argument_list|(
name|overrider
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|delta
argument_list|)
condition|)
block|{
comment|/* We'll need a thunk.  But if we have a (perhaps formerly) 	     primary virtual base, we have a vcall slot for this function, 	     so we can use it rather than create a non-virtual thunk.  */
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|first_defn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
control|)
block|{
name|tree
name|f
init|=
name|get_matching_virtual
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
comment|/* b doesn't have this function; no suitable vbase.  */
break|break;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* Found one; we can treat ourselves as a virtual base.  */
name|virtual_base
operator|=
name|binfo
expr_stmt|;
name|delta
operator|=
name|size_zero_node
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|modify_vtable_entry
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|overrider
argument_list|)
argument_list|,
name|delta
argument_list|,
name|virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_base
condition|)
name|BV_USE_VCALL_INDEX_P
argument_list|(
operator|*
name|virtuals
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from modify_all_vtables via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_modify_vtables
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
comment|/* There's no need to modify the vtable for a non-virtual          primary base; we're not going to use that vtable anyhow. 	 We do still need to do this for virtual primary bases, as they 	 could become non-primary in a construction vtable.  */
operator|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|)
comment|/* Similarly, a base without a vtable needs no modification.  */
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|tree
name|old_virtuals
decl_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|data
expr_stmt|;
name|make_new_vtable
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Now, go through each of the virtual functions in the virtual 	 function table for BINFO.  Find the final overrider, and 	 update the BINFO_VIRTUALS list appropriately.  */
for|for
control|(
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|,
name|old_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
init|;
name|virtuals
condition|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
operator|,
name|old_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|old_virtuals
argument_list|)
control|)
name|update_vtable_entry_for_fn
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|BV_FN
argument_list|(
name|old_virtuals
argument_list|)
argument_list|,
operator|&
name|virtuals
argument_list|)
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Update all of the primary and secondary vtables for T.  Create new    vtables as required, and initialize their RTTI information.  Each    of the functions in OVERRIDDEN_VIRTUALS overrides a virtual    function from a base class; find and modify the appropriate entries    to point to the overriding functions.  Returns a list, in    declaration order, of the functions that are overridden in this    class, but do not appear in the primary base class vtable, and    which should therefore be appended to the end of the vtable for T.  */
end_comment

begin_function
specifier|static
name|tree
name|modify_all_vtables
parameter_list|(
name|t
parameter_list|,
name|vfuns_p
parameter_list|,
name|overridden_virtuals
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|vfuns_p
decl_stmt|;
name|tree
name|overridden_virtuals
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|fnsp
decl_stmt|;
comment|/* Update all of the vtables.  */
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_modify_vtables
argument_list|,
name|dfs_unmarked_real_bases_queue_p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|dfs_marked_real_bases_queue_p
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Include overriding functions for secondary vtables in our primary      vtable.  */
for|for
control|(
name|fnsp
operator|=
operator|&
name|overridden_virtuals
init|;
operator|*
name|fnsp
condition|;
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|fnsp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|||
operator|!
name|value_member
argument_list|(
name|fn
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Set the vtable index.  */
name|set_vindex
argument_list|(
name|fn
argument_list|,
name|vfuns_p
argument_list|)
expr_stmt|;
comment|/* We don't need to convert to a base class when calling 	     this function.  */
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* We don't need to adjust the `this' pointer when 	     calling this function.  */
name|BV_DELTA
argument_list|(
operator|*
name|fnsp
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|BV_VCALL_INDEX
argument_list|(
operator|*
name|fnsp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* This is an overridden function not already in our 	     vtable.  Keep it.  */
name|fnsp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|fnsp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We've already got an entry for this function.  Skip it.  */
operator|*
name|fnsp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|fnsp
argument_list|)
expr_stmt|;
block|}
return|return
name|overridden_virtuals
return|;
block|}
end_function

begin_comment
comment|/* Here, we already know that they match in every respect.    All we have to check is where they had their declarations.     Return non-zero iff FNDECL1 is declared in a class which has a    proper base class containing FNDECL2.  We don't care about    ambiguity or accessibility.  */
end_comment

begin_function
specifier|static
name|int
name|strictly_overrides
parameter_list|(
name|fndecl1
parameter_list|,
name|fndecl2
parameter_list|)
name|tree
name|fndecl1
decl_stmt|,
name|fndecl2
decl_stmt|;
block|{
name|base_kind
name|kind
decl_stmt|;
return|return
operator|(
name|lookup_base
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl1
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fndecl2
argument_list|)
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
operator|&
name|kind
argument_list|)
operator|&&
name|kind
operator|!=
name|bk_same_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the base virtual function declarations in T that have the    indicated NAME.  */
end_comment

begin_function
specifier|static
name|tree
name|get_basefndecls
parameter_list|(
name|name
parameter_list|,
name|t
parameter_list|)
name|tree
name|name
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|methods
decl_stmt|;
name|tree
name|base_fndecls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|methods
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|methods
condition|;
name|methods
operator|=
name|TREE_CHAIN
argument_list|(
name|methods
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|methods
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|methods
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_NAME
argument_list|(
name|methods
argument_list|)
operator|==
name|name
condition|)
name|base_fndecls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|methods
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_fndecls
condition|)
return|return
name|base_fndecls
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
return|return
name|base_fndecls
return|;
block|}
end_function

begin_comment
comment|/* If this declaration supersedes the declaration of    a method declared virtual in the base class, then    mark this field as being virtual as well.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_override
parameter_list|(
name|decl
parameter_list|,
name|ctype
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|ctype
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* In [temp.mem] we have:           A specialization of a member function template does not          override a virtual function from a base class.  */
return|return;
if|if
condition|(
operator|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|look_for_overrides
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Set DECL_VINDEX to a value that is neither an 	 INTEGER_CST nor the error_mark_node so that 	 add_virtual_function will realize this is an 	 overriding function.  */
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn about hidden virtual functions that are not overridden in t.    We know that constructors and destructors don't apply.  */
end_comment

begin_function
name|void
name|warn_hidden
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|n_methods
init|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We go through each separately named virtual function.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|n_methods
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|fns
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|base_fndecls
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* All functions in this slot in the CLASSTYPE_METHOD_VEC will 	 have the same name.  Figure out what name that is.  */
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There are no possibly hidden functions yet.  */
name|base_fndecls
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Iterate through all of the base classes looking for possibly 	 hidden functions.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no functions to hide, continue. */
if|if
condition|(
operator|!
name|base_fndecls
condition|)
continue|continue;
comment|/* Remove any overridden functions. */
for|for
control|(
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|prev
init|=
operator|&
name|base_fndecls
decl_stmt|;
while|while
condition|(
operator|*
name|prev
condition|)
comment|/* If the method from the base class has the same 		   signature as the method from the derived class, it 		   has been overridden.  */
if|if
condition|(
name|same_signature_p
argument_list|(
name|fndecl
argument_list|,
name|TREE_VALUE
argument_list|(
operator|*
name|prev
argument_list|)
argument_list|)
condition|)
operator|*
name|prev
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
else|else
name|prev
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now give a warning for all base functions without overriders, 	 as they are hidden.  */
while|while
condition|(
name|base_fndecls
condition|)
block|{
comment|/* Here we know it is a hider, and no overrider exists.  */
name|cp_warning_at
argument_list|(
literal|"`%D' was hidden"
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  by `%D'"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check for things that are invalid.  There are probably plenty of other    things we should check for also.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_anon
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|elt
init|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
comment|/* We're generally only interested in entities the user 		 declared, but we also find nested classes by noticing 		 the TYPE_DECL that we create implicitly.  You're 		 allowed to put one anonymous union inside another, 		 though, so we explicitly tolerate that.  We use 		 TYPE_ANONYMOUS_P rather than ANON_AGGR_TYPE_P so that 		 we also allow unnamed types used for defining fields.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|elt
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|elt
argument_list|)
operator|||
name|TYPE_ANONYMOUS_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|elt
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|t
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"ISO C++ forbids member `%D' with same name as enclosing class"
argument_list|,
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"`%#D' invalid; an anonymous union can only have non-static data members"
argument_list|,
name|elt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|elt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"private member `%#D' in anonymous union"
argument_list|,
name|elt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|elt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"protected member `%#D' in anonymous union"
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create default constructors, assignment operators, and so forth for    the type indicated by T, if they are needed.    CANT_HAVE_DEFAULT_CTOR, CANT_HAVE_CONST_CTOR, and    CANT_HAVE_CONST_ASSIGNMENT are nonzero if, for whatever reason, the    class cannot have a default constructor, copy constructor taking a    const reference argument, or an assignment operator taking a const    reference, respectively.  If a virtual destructor is created, its    DECL is returned; otherwise the return value is NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|add_implicitly_declared_members
parameter_list|(
name|t
parameter_list|,
name|cant_have_default_ctor
parameter_list|,
name|cant_have_const_cctor
parameter_list|,
name|cant_have_const_assignment
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|cant_have_default_ctor
decl_stmt|;
name|int
name|cant_have_const_cctor
decl_stmt|;
name|int
name|cant_have_const_assignment
decl_stmt|;
block|{
name|tree
name|default_fn
decl_stmt|;
name|tree
name|implicit_fns
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|virtual_dtor
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|f
decl_stmt|;
operator|++
name|adding_implicit_members
expr_stmt|;
comment|/* Destructor.  */
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_destructor
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
literal|0
argument_list|)
expr_stmt|;
name|check_for_override
argument_list|(
name|default_fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we couldn't make it work, then pretend we didn't need it.  */
if|if
condition|(
name|default_fn
operator|==
name|void_type_node
condition|)
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|default_fn
argument_list|)
condition|)
name|virtual_dtor
operator|=
name|default_fn
expr_stmt|;
block|}
block|}
else|else
comment|/* Any non-implicit destructor is non-trivial.  */
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Default constructor.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|cant_have_default_ctor
condition|)
block|{
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_constructor
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Copy constructor.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* ARM 12.18: You get either X(X&) or X(const X&), but 	 not both.  --Chip  */
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_copy_constructor
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
operator|!
name|cant_have_const_cctor
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Assignment operator.  */
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_assignment_operator
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
operator|!
name|cant_have_const_assignment
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Now, hook all of the new functions on to TYPE_METHODS,      and add them to the CLASSTYPE_METHOD_VEC.  */
for|for
control|(
name|f
operator|=
operator|&
name|implicit_fns
init|;
operator|*
name|f
condition|;
name|f
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|f
argument_list|)
control|)
name|add_method
argument_list|(
name|t
argument_list|,
operator|*
name|f
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
operator|*
name|f
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
operator|--
name|adding_implicit_members
expr_stmt|;
return|return
name|virtual_dtor
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of finish_struct_1.  Recursively count the number of fields    in TYPE, including anonymous union members.  */
end_comment

begin_function
specifier|static
name|int
name|count_fields
parameter_list|(
name|fields
parameter_list|)
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|int
name|n_fields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|n_fields
operator|+=
name|count_fields
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|n_fields
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|n_fields
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of finish_struct_1.  Recursively add all the fields in the    TREE_LIST FIELDS to the TREE_VEC FIELD_VEC, starting at offset IDX.  */
end_comment

begin_function
specifier|static
name|int
name|add_fields_to_vec
parameter_list|(
name|fields
parameter_list|,
name|field_vec
parameter_list|,
name|idx
parameter_list|)
name|tree
name|fields
decl_stmt|,
name|field_vec
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|idx
operator|=
name|add_fields_to_vec
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|field_vec
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|TREE_VEC_ELT
argument_list|(
name|field_vec
argument_list|,
name|idx
operator|++
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* FIELD is a bit-field.  We are finishing the processing for its    enclosing type.  Issue any appropriate messages and set appropriate    flags.  */
end_comment

begin_function
specifier|static
name|void
name|check_bitfield_decl
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|w
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%#D' with non-integral type"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|w
operator|=
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */
name|STRIP_NOPS
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* detect invalid field size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|w
operator|=
name|DECL_INITIAL
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|w
operator|=
name|decl_constant_value
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%D' width not an integer constant"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|w
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"negative width in bit-field `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|w
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"zero width for bit-field `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|w
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
name|cp_warning_at
argument_list|(
literal|"width of `%D' exceeds its type"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|w
argument_list|,
name|min_precision
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|||
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|w
argument_list|,
name|min_precision
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|cp_warning_at
argument_list|(
literal|"`%D' is too small to hold all values of `%#T'"
argument_list|,
name|field
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the bit-field width indicator so that the rest of the      compiler does not treat that value as an initializer.  */
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|error_mark_node
condition|)
block|{
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|w
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator||=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLEAR_DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator||=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FIELD is a non bit-field.  We are finishing the processing for its    enclosing type T.  Issue any appropriate messages and set appropriate    flags.  */
end_comment

begin_function
specifier|static
name|void
name|check_field_decl
parameter_list|(
name|field
parameter_list|,
name|t
parameter_list|,
name|cant_have_const_ctor
parameter_list|,
name|cant_have_default_ctor
parameter_list|,
name|no_const_asn_ref
parameter_list|,
name|any_default_members
parameter_list|)
name|tree
name|field
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|cant_have_const_ctor
decl_stmt|;
name|int
modifier|*
name|cant_have_default_ctor
decl_stmt|;
name|int
modifier|*
name|no_const_asn_ref
decl_stmt|;
name|int
modifier|*
name|any_default_members
decl_stmt|;
block|{
name|tree
name|type
init|=
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
comment|/* An anonymous union cannot contain any fields which would change      the settings of CANT_HAVE_CONST_CTOR and friends.  */
if|if
condition|(
name|ANON_UNION_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* And, we don't set TYPE_HAS_CONST_INIT_REF, etc., for anonymous      structs.  So, we recurse through their fields here.  */
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
name|check_field_decl
argument_list|(
name|fields
argument_list|,
name|t
argument_list|,
name|cant_have_const_ctor
argument_list|,
name|cant_have_default_ctor
argument_list|,
name|no_const_asn_ref
argument_list|,
name|any_default_members
argument_list|)
expr_stmt|;
block|}
comment|/* Check members with class type for constructors, destructors,      etc.  */
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Never let anything with uninheritable virtuals 	 make it through without complaint.  */
name|abstract_virtuals_error
argument_list|(
name|field
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with constructor not allowed in union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with destructor not allowed in union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with copy assignment operator not allowed in union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* `build_class_init_list' does not recognize 	 non-FIELD_DECLs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|any_default_members
operator|!=
literal|0
condition|)
name|cp_error_at
argument_list|(
literal|"multiple fields in union `%T' initialized"
argument_list|)
expr_stmt|;
operator|*
name|any_default_members
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Non-bit-fields are aligned for their type, except packed fields      which require only BITS_PER_UNIT alignment.  */
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
argument_list|,
operator|(
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|?
name|BITS_PER_UNIT
else|:
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator||=
name|TYPE_USER_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the data members (both static and non-static), class-scoped    typedefs, etc., appearing in the declaration of T.  Issue    appropriate diagnostics.  Sets ACCESS_DECLS to a list (in    declaration order) of access declarations; each TREE_VALUE in this    list is a USING_DECL.     In addition, set the following flags:       EMPTY_P        The class is empty, i.e., contains no non-static data members.       CANT_HAVE_DEFAULT_CTOR_P        This class cannot have an implicitly generated default        constructor.       CANT_HAVE_CONST_CTOR_P        This class cannot have an implicitly generated copy constructor        taking a const reference.       CANT_HAVE_CONST_ASN_REF        This class cannot have an implicitly generated assignment        operator taking a const reference.     All of these flags should be initialized before calling this    function.     Returns a pointer to the end of the TYPE_FIELDs chain; additional    fields can be added by adding to this chain.  */
end_comment

begin_function
specifier|static
name|void
name|check_field_decls
parameter_list|(
name|t
parameter_list|,
name|access_decls
parameter_list|,
name|empty_p
parameter_list|,
name|cant_have_default_ctor_p
parameter_list|,
name|cant_have_const_ctor_p
parameter_list|,
name|no_const_asn_ref_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
modifier|*
name|access_decls
decl_stmt|;
name|int
modifier|*
name|empty_p
decl_stmt|;
name|int
modifier|*
name|cant_have_default_ctor_p
decl_stmt|;
name|int
modifier|*
name|cant_have_const_ctor_p
decl_stmt|;
name|int
modifier|*
name|no_const_asn_ref_p
decl_stmt|;
block|{
name|tree
modifier|*
name|field
decl_stmt|;
name|tree
modifier|*
name|next
decl_stmt|;
name|int
name|has_pointers
decl_stmt|;
name|int
name|any_default_members
decl_stmt|;
comment|/* First, delete any duplicate fields.  */
name|delete_duplicate_fields
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assume there are no access declarations.  */
operator|*
name|access_decls
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Assume this class has no pointer members.  */
name|has_pointers
operator|=
literal|0
expr_stmt|;
comment|/* Assume none of the members of this class have default      initializations.  */
name|any_default_members
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|field
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
operator|*
name|field
condition|;
name|field
operator|=
name|next
control|)
block|{
name|tree
name|x
init|=
operator|*
name|field
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
operator||=
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
comment|/* We don't treat zero-width bitfields as making a class 	       non-empty.  */
empty_stmt|;
else|else
block|{
comment|/* The class is non-empty.  */
operator|*
name|empty_p
operator|=
literal|0
expr_stmt|;
comment|/* The class is not even nearly empty.  */
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
condition|)
block|{
comment|/* Prune the access declaration from the list of fields.  */
operator|*
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Save the access declarations for our caller.  */
operator|*
name|access_decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
operator|*
name|access_decls
argument_list|)
expr_stmt|;
comment|/* Since we've reset *FIELD there's no reason to skip to the 	     next field.  */
name|next
operator|=
name|field
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
continue|continue;
comment|/* If we've gotten this far, it's a data member, possibly static, 	 or an enumerator.  */
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* ``A local class cannot have static data members.'' ARM 9.4 */
if|if
condition|(
name|current_function_decl
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"field `%D' in local class cannot be static"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Perform error checking that did not get done in 	 grokdeclarator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared function type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared method type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared offset type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* When this goes into scope, it will be a non-local reference.  */
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* Unions cannot have static members.  */
name|cp_error_at
argument_list|(
literal|"field `%D' declared static in union"
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now it can only be a FIELD_DECL.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
condition|)
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is of reference type, check if it needs an init. 	 Also do a little ANSI jig if necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
operator|*
name|cant_have_default_ctor_p
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static reference `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|has_pointers
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|x
argument_list|)
operator|||
name|TYPE_HAS_MUTABLE_P
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_HAS_MUTABLE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pod_type_p
argument_list|(
name|type
argument_list|)
condition|)
comment|/* DR 148 now allows pointers to members (which are POD themselves),            to be allowed in POD structs.  */
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
operator|*
name|cant_have_default_ctor_p
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static const member `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* A field that is pseudo-const makes the structure likewise.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator||=
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator||=
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Core issue 80: A nonstatic data member is required to have a 	 different name from the class iff the class has a 	 user-defined constructor.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"field `%#D' with same name as class"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* We set DECL_C_BIT_FIELD in grokbitfield. 	 If the type and width are valid, we'll also set DECL_BIT_FIELD.  */
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
condition|)
name|check_bitfield_decl
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|check_field_decl
argument_list|(
name|x
argument_list|,
name|t
argument_list|,
name|cant_have_const_ctor_p
argument_list|,
name|cant_have_default_ctor_p
argument_list|,
name|no_const_asn_ref_p
argument_list|,
operator|&
name|any_default_members
argument_list|)
expr_stmt|;
block|}
comment|/* Effective C++ rule 11.  */
if|if
condition|(
name|has_pointers
operator|&&
name|warn_ecpp
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%#T' has pointer data members"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"  but does not override `%T(const %T&)'"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|warning
argument_list|(
literal|"  or `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|warning
argument_list|(
literal|"  but does not override `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Check anonymous struct/anonymous union fields.  */
name|finish_struct_anon
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* We've built up the list of access declarations in reverse order.      Fix that now.  */
operator|*
name|access_decls
operator|=
name|nreverse
argument_list|(
operator|*
name|access_decls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TYPE is an empty class type, records its OFFSET in the table of    OFFSETS.  */
end_comment

begin_function
specifier|static
name|int
name|record_subobject_offset
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|offsets
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
block|{
name|splay_tree_node
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|is_empty_class
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record the location of this empty object in OFFSETS.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|offsets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|splay_tree_insert
argument_list|(
name|offsets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|offset
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|NULL_TREE
argument_list|)
expr_stmt|;
name|n
operator|->
name|value
operator|=
operator|(
operator|(
name|splay_tree_value
operator|)
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if TYPE is an empty class type and there is    already an entry in OFFSETS for the same TYPE as the same OFFSET.  */
end_comment

begin_function
specifier|static
name|int
name|check_subobject_offset
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|offsets
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|is_empty_class
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record the location of this empty object in OFFSETS.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|offsets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Walk through all the subobjects of TYPE (located at OFFSET).  Call    F for every subobject, passing it the type, offset, and table of    OFFSETS.  If VBASES_P is non-zero, then even virtual non-primary    bases should be traversed; otherwise, they are ignored.       If MAX_OFFSET is non-NULL, then subobjects with an offset greater    than MAX_OFFSET will not be walked.     If F returns a non-zero value, the traversal ceases, and that value    is returned.  Otherwise, returns zero.  */
end_comment

begin_function
specifier|static
name|int
name|walk_subobject_offsets
parameter_list|(
name|type
parameter_list|,
name|f
parameter_list|,
name|offset
parameter_list|,
name|offsets
parameter_list|,
name|max_offset
parameter_list|,
name|vbases_p
parameter_list|)
name|tree
name|type
decl_stmt|;
name|subobject_offset_fn
name|f
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
name|tree
name|max_offset
decl_stmt|;
name|int
name|vbases_p
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
comment|/* If this OFFSET is bigger than the MAX_OFFSET, then we should      stop.  */
if|if
condition|(
name|max_offset
operator|&&
name|INT_CST_LT
argument_list|(
name|max_offset
argument_list|,
name|offset
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|field
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Record the location of TYPE.  */
name|r
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
comment|/* Iterate through the direct base classes of TYPE.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vbases_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
continue|continue;
name|r
operator|=
name|walk_subobject_offsets
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|f
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
name|vbases_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
comment|/* Iterate through the fields of TYPE.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|r
operator|=
name|walk_subobject_offsets
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|f
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
comment|/*vbases_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|index
decl_stmt|;
comment|/* Step through each of the elements in the array.  */
for|for
control|(
name|index
operator|=
name|size_zero_node
init|;
name|INT_CST_LT
argument_list|(
name|index
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
condition|;
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|index
argument_list|,
name|size_one_node
argument_list|)
control|)
block|{
name|r
operator|=
name|walk_subobject_offsets
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|f
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
comment|/*vbases_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this new OFFSET is bigger than the MAX_OFFSET, then 	     there's no point in iterating through the remaining 	     elements of the array.  */
if|if
condition|(
name|max_offset
operator|&&
name|INT_CST_LT
argument_list|(
name|max_offset
argument_list|,
name|offset
argument_list|)
condition|)
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record all of the empty subobjects of TYPE (located at OFFSET) in    OFFSETS.  If VBASES_P is non-zero, virtual bases of TYPE are    examined.  */
end_comment

begin_function
specifier|static
name|void
name|record_subobject_offsets
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|offsets
parameter_list|,
name|vbases_p
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
name|int
name|vbases_p
decl_stmt|;
block|{
name|walk_subobject_offsets
argument_list|(
name|type
argument_list|,
name|record_subobject_offset
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
comment|/*max_offset=*/
name|NULL_TREE
argument_list|,
name|vbases_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if any of the empty subobjects of TYPE (located at    OFFSET) conflict with entries in OFFSETS.  If VBASES_P is non-zero,    virtual bases of TYPE are examined.  */
end_comment

begin_function
specifier|static
name|int
name|layout_conflict_p
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|offsets
parameter_list|,
name|vbases_p
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
name|int
name|vbases_p
decl_stmt|;
block|{
name|splay_tree_node
name|max_node
decl_stmt|;
comment|/* Get the node in OFFSETS that indicates the maximum offset where      an empty subobject is located.  */
name|max_node
operator|=
name|splay_tree_max
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
comment|/* If there aren't any empty subobjects, then there's no point in      performing this check.  */
if|if
condition|(
operator|!
name|max_node
condition|)
return|return
literal|0
return|;
return|return
name|walk_subobject_offsets
argument_list|(
name|type
argument_list|,
name|check_subobject_offset
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
call|(
name|tree
call|)
argument_list|(
name|max_node
operator|->
name|key
argument_list|)
argument_list|,
name|vbases_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is a FIELD_DECL corresponding either to a base subobject of a    non-static data member of the type indicated by RLI.  BINFO is the    binfo corresponding to the base subobject, OFFSETS maps offsets to    types already located at those offsets.  T is the most derived    type.  This function determines the position of the DECL.  */
end_comment

begin_function
specifier|static
name|void
name|layout_nonempty_base_or_field
parameter_list|(
name|rli
parameter_list|,
name|decl
parameter_list|,
name|binfo
parameter_list|,
name|offsets
parameter_list|,
name|t
parameter_list|)
name|record_layout_info
name|rli
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|offset
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* If we are laying out a base class, rather than a field, then      DECL_ARTIFICIAL will be set on the FIELD_DECL.  */
name|int
name|field_p
init|=
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Try to place the field.  It may take more than one try if we have      a hard time placing the field without putting two objects of the      same type at the same address.  */
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|record_layout_info_s
name|old_rli
init|=
operator|*
name|rli
decl_stmt|;
comment|/* Place this field.  */
name|place_field
argument_list|(
name|rli
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|offset
operator|=
name|byte_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We have to check to see whether or not there is already 	 something of the same type at the offset we're about to use. 	 For example: 	  	 struct S {}; 	 struct T : public S { int i; }; 	 struct U : public S, public T {}; 	  	 Here, we put S at offset zero in U.  Then, we can't put T at 	 offset zero -- its S component would be at the same address 	 as the S we already allocated.  So, we have to skip ahead. 	 Since all data members, including those whose type is an 	 empty class, have non-zero size, any overlap can happen only 	 with a direct or indirect base-class -- it can't happen with 	 a data member.  */
if|if
condition|(
name|layout_conflict_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
name|field_p
argument_list|)
condition|)
block|{
comment|/* Strip off the size allocated to this field.  That puts us 	     at the first place we could have put the field with 	     proper alignment.  */
operator|*
name|rli
operator|=
name|old_rli
expr_stmt|;
comment|/* Bump up by the alignment required for the type.  */
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|bitsize_int
argument_list|(
name|binfo
condition|?
name|CLASSTYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* There was no conflict.  We're done laying out this field.  */
break|break;
block|}
comment|/* Now that we know where it will be placed, update its      BINFO_OFFSET.  */
if|if
condition|(
name|binfo
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|offset
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Layout the empty base BINFO.  EOC indicates the byte currently just    past the end of the class, and should be correctly aligned for a    class of the type indicated by BINFO; OFFSETS gives the offsets of    the empty bases allocated so far. T is the most derived    type.  Return non-zero iff we added it at the end. */
end_comment

begin_function
specifier|static
name|bool
name|layout_empty_base
parameter_list|(
name|binfo
parameter_list|,
name|eoc
parameter_list|,
name|offsets
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|eoc
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|alignment
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|bool
name|atend
init|=
name|false
decl_stmt|;
comment|/* This routine should only be used for empty classes.  */
name|my_friendly_assert
argument_list|(
name|is_empty_class
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|20000321
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|ssize_int
argument_list|(
name|CLASSTYPE_ALIGN_UNIT
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is an empty base class.  We first try to put it at offset      zero.  */
if|if
condition|(
name|layout_conflict_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|offsets
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
condition|)
block|{
comment|/* That didn't work.  Now, we move forward from the next 	 available spot in the class.  */
name|atend
operator|=
name|true
expr_stmt|;
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|eoc
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|layout_conflict_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|offsets
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
condition|)
comment|/* We finally found a spot where there's no overlap.  */
break|break;
comment|/* There's overlap here, too.  Bump along to the next spot.  */
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|alignment
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|atend
return|;
block|}
end_function

begin_comment
comment|/* Build a FIELD_DECL for the base given by BINFO in the class    indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.    *BASE_ALIGN is a running maximum of the alignments of any base    class.  OFFSETS gives the location of empty base subobjects.  T is    the most derived type.  Return non-zero if the new object cannot be    nearly-empty. */
end_comment

begin_function
specifier|static
name|bool
name|build_base_field
parameter_list|(
name|rli
parameter_list|,
name|binfo
parameter_list|,
name|empty_p
parameter_list|,
name|offsets
parameter_list|,
name|t
parameter_list|)
name|record_layout_info
name|rli
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|int
modifier|*
name|empty_p
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|bool
name|atend
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
comment|/* This error is now reported in xref_tag, thus giving better        location information.  */
return|return
name|atend
return|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|rli
operator|->
name|t
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_SIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_SIZE_UNIT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_USER_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The containing class is non-empty because it has a non-empty 	 base class.  */
operator|*
name|empty_p
operator|=
literal|0
expr_stmt|;
comment|/* Try to place the field.  It may take more than one try if we 	 have a hard time placing the field without putting two 	 objects of the same type at the same address.  */
name|layout_nonempty_base_or_field
argument_list|(
name|rli
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|,
name|offsets
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|eoc
decl_stmt|;
comment|/* On some platforms (ARM), even empty classes will not be 	 byte-aligned.  */
name|eoc
operator|=
name|tree_low_cst
argument_list|(
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|eoc
operator|=
name|CEIL
argument_list|(
name|eoc
argument_list|,
name|DECL_ALIGN_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|*
name|DECL_ALIGN_UNIT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|atend
operator||=
name|layout_empty_base
argument_list|(
name|binfo
argument_list|,
name|size_int
argument_list|(
name|eoc
argument_list|)
argument_list|,
name|offsets
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Record the offsets of BINFO and its base subobjects.  */
name|record_subobject_offsets
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|offsets
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|atend
return|;
block|}
end_function

begin_comment
comment|/* Layout all of the non-virtual base classes.  Record empty    subobjects in OFFSETS.  T is the most derived type.  Return    non-zero if the type cannot be nearly empty.  */
end_comment

begin_function
specifier|static
name|bool
name|build_base_fields
parameter_list|(
name|rli
parameter_list|,
name|empty_p
parameter_list|,
name|offsets
parameter_list|,
name|t
parameter_list|)
name|record_layout_info
name|rli
decl_stmt|;
name|int
modifier|*
name|empty_p
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
comment|/* Chain to hold all the new FIELD_DECLs which stand in for base class      subobjects.  */
name|tree
name|rec
init|=
name|rli
operator|->
name|t
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|rec
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|atend
init|=
literal|0
decl_stmt|;
comment|/* The primary base class is always allocated first.  */
if|if
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|rec
argument_list|)
condition|)
name|build_base_field
argument_list|(
name|rli
argument_list|,
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|rec
argument_list|)
argument_list|,
name|empty_p
argument_list|,
name|offsets
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Now allocate the rest of the bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|rec
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The primary base was already allocated above, so we don't 	 need to allocate it again here.  */
if|if
condition|(
name|base_binfo
operator|==
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|rec
argument_list|)
condition|)
continue|continue;
comment|/* A primary virtual base class is allocated just like any other 	 base class, but a non-primary virtual base is allocated 	 later, in layout_virtual_bases.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|atend
operator||=
name|build_base_field
argument_list|(
name|rli
argument_list|,
name|base_binfo
argument_list|,
name|empty_p
argument_list|,
name|offsets
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|atend
return|;
block|}
end_function

begin_comment
comment|/* Go through the TYPE_METHODS of T issuing any appropriate    diagnostics, figuring out which methods override which other    methods, and so forth.  */
end_comment

begin_function
specifier|static
name|void
name|check_methods
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If this was an evil function, don't keep it in class.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|x
argument_list|)
operator|&&
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|check_for_override
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"initializer specified for non-virtual method `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* The name of the field is the original field name 	 Save this in auxiliary field for later overloading.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* FN is a constructor or destructor.  Clone the declaration to create    a specialized in-charge or not-in-charge version, as indicated by    NAME.  */
end_comment

begin_function
specifier|static
name|tree
name|build_clone
parameter_list|(
name|fn
parameter_list|,
name|name
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|tree
name|clone
decl_stmt|;
comment|/* Copy the function.  */
name|clone
operator|=
name|copy_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Remember where this function came from.  */
name|DECL_CLONED_FUNCTION
argument_list|(
name|clone
argument_list|)
operator|=
name|fn
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|clone
argument_list|)
operator|=
name|fn
expr_stmt|;
comment|/* Reset the function name.  */
name|DECL_NAME
argument_list|(
name|clone
argument_list|)
operator|=
name|name
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|clone
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* There's no pending inline data for this function.  */
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|clone
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* And it hasn't yet been deferred.  */
name|DECL_DEFERRED_FN
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The base-class destructor is not virtual.  */
if|if
condition|(
name|name
operator|==
name|base_dtor_identifier
condition|)
block|{
name|DECL_VIRTUAL_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|clone
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
name|DECL_VINDEX
argument_list|(
name|clone
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If there was an in-charge parameter, drop it from the function      type.  */
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|exceptions
decl_stmt|;
name|exceptions
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the `this' parameter.  */
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* Skip the in-charge parameter.  */
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* And the VTT parm, in a complete [cd]tor.  */
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_NEEDS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* If this is subobject constructor or destructor, add the vtt 	 parameter.  */
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceptions
condition|)
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|,
name|exceptions
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the function parameters.  But, DECL_ARGUMENTS on a TEMPLATE_DECL      aren't function parameters; those are the template parameters.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|clone
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
operator|=
name|copy_list
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the in-charge parameter.  */
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* And the VTT parm, in a complete [cd]tor.  */
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NEEDS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|parms
argument_list|)
operator|=
name|clone
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create the RTL for this function.  */
name|SET_DECL_RTL
argument_list|(
name|clone
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|clone
argument_list|,
name|NULL
argument_list|,
comment|/*top_level=*/
literal|1
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
comment|/* Make it easy to find the CLONE given the FN.  */
name|TREE_CHAIN
argument_list|(
name|clone
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
operator|=
name|clone
expr_stmt|;
comment|/* If this is a template, handle the DECL_TEMPLATE_RESULT as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|clone
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|result
decl_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|clone
argument_list|)
operator|=
name|build_clone
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
operator|=
name|copy_node
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|result
argument_list|)
operator|=
name|clone
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DEFERRED_FN
argument_list|(
name|fn
argument_list|)
condition|)
name|defer_fn
argument_list|(
name|clone
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
end_function

begin_comment
comment|/* Produce declarations for all appropriate clones of FN.  If    UPDATE_METHOD_VEC_P is non-zero, the clones are added to the    CLASTYPE_METHOD_VEC as well.  */
end_comment

begin_function
name|void
name|clone_function_decl
parameter_list|(
name|fn
parameter_list|,
name|update_method_vec_p
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|int
name|update_method_vec_p
decl_stmt|;
block|{
name|tree
name|clone
decl_stmt|;
comment|/* Avoid inappropriate cloning.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_CLONED_FUNCTION
argument_list|(
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* For each constructor, we need two variants: an in-charge version 	 and a not-in-charge version.  */
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|complete_ctor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|base_ctor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|20000411
argument_list|)
expr_stmt|;
comment|/* For each destructor, we need three variants: an in-charge 	 version, a not-in-charge version, and an in-charge deleting 	 version.  We clone the deleting version first because that 	 means it will go second on the TYPE_METHODS list -- and that 	 corresponds to the correct layout order in the virtual 	 function table.             For a non-virtual destructor, we do not build a deleting 	 destructor.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|deleting_dtor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|complete_dtor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|base_dtor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Note that this is an abstract function that is never emitted.  */
name|DECL_ABSTRACT
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is an in charge constructor, which is being defined. This will    have had an in class declaration, from whence clones were    declared. An out-of-class definition can specify additional default    arguments. As it is the clones that are involved in overload    resolution, we must propagate the information from the DECL to its    clones. */
end_comment

begin_function
name|void
name|adjust_clone_args
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|clone
decl_stmt|;
for|for
control|(
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
init|;
name|clone
operator|&&
name|DECL_CLONED_FUNCTION
argument_list|(
name|clone
argument_list|)
condition|;
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|clone
argument_list|)
control|)
block|{
name|tree
name|orig_clone_parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|orig_decl_parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|decl_parms
decl_stmt|,
name|clone_parms
decl_stmt|;
name|clone_parms
operator|=
name|orig_clone_parms
expr_stmt|;
comment|/* Skip the 'this' parameter. */
name|orig_clone_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_clone_parms
argument_list|)
expr_stmt|;
name|orig_decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_decl_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
name|orig_decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_decl_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
name|orig_decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_decl_parms
argument_list|)
expr_stmt|;
name|clone_parms
operator|=
name|orig_clone_parms
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|clone_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|decl_parms
operator|=
name|orig_decl_parms
init|;
name|decl_parms
condition|;
name|decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_parms
argument_list|)
operator|,
name|clone_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parms
argument_list|)
control|)
block|{
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_parms
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|clone_parms
argument_list|)
argument_list|)
argument_list|,
literal|20010424
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|decl_parms
argument_list|)
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|clone_parms
argument_list|)
condition|)
block|{
comment|/* A default parameter has been added. Adjust the 		 clone's parameters. */
name|tree
name|exceptions
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|clone_parms
operator|=
name|orig_decl_parms
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|clone_parms
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|orig_clone_parms
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|orig_clone_parms
argument_list|)
argument_list|,
name|clone_parms
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|clone_parms
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|orig_clone_parms
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|,
name|clone_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceptions
condition|)
name|type
operator|=
name|build_exception_variant
argument_list|(
name|type
argument_list|,
name|exceptions
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
operator|=
name|type
expr_stmt|;
name|clone_parms
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
name|my_friendly_assert
argument_list|(
operator|!
name|clone_parms
argument_list|,
literal|20010424
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For each of the constructors and destructors in T, create an    in-charge and not-in-charge variant.  */
end_comment

begin_function
specifier|static
name|void
name|clone_constructors_and_destructors
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|fns
decl_stmt|;
comment|/* If for some reason we don't have a CLASSTYPE_METHOD_VEC, we bail      out now.  */
if|if
condition|(
operator|!
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
return|return;
for|for
control|(
name|fns
operator|=
name|CLASSTYPE_CONSTRUCTORS
argument_list|(
name|t
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
name|clone_function_decl
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|,
comment|/*update_method_vec_p=*/
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|t
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
name|clone_function_decl
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|,
comment|/*update_method_vec_p=*/
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all zero-width bit-fields from T.  */
end_comment

begin_function
specifier|static
name|void
name|remove_zero_width_bit_fields
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
modifier|*
name|fieldsp
decl_stmt|;
name|fieldsp
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|fieldsp
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|fieldsp
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
operator|*
name|fieldsp
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
operator|*
name|fieldsp
argument_list|)
condition|)
operator|*
name|fieldsp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldsp
argument_list|)
expr_stmt|;
else|else
name|fieldsp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldsp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns TRUE iff we need a cookie when dynamically allocating an    array whose elements have the indicated class TYPE.  */
end_comment

begin_function
specifier|static
name|bool
name|type_requires_array_cookie
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fns
decl_stmt|;
name|bool
name|has_two_argument_delete_p
init|=
name|false
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|,
literal|20010712
argument_list|)
expr_stmt|;
comment|/* If there's a non-trivial destructor, we need a cookie.  In order      to iterate through the array calling the destructor for each      element, we'll have to know how many elements there are.  */
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If the usual deallocation function is a two-argument whose second      argument is of type `size_t', then we have to pass the size of      the array to the deallocation function, so we will need to store      a cookie.  */
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|ansi_opname
argument_list|(
name|VEC_DELETE_EXPR
argument_list|)
argument_list|,
comment|/*protect=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are no `operator []' members, or the lookup is      ambiguous, then we don't need a cookie.  */
if|if
condition|(
operator|!
name|fns
operator|||
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* Loop through all of the functions.  */
for|for
control|(
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|second_parm
decl_stmt|;
comment|/* Select the current function.  */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
comment|/* See if this function is a one-argument delete function.  If 	 it is, then it will be the usual deallocation function.  */
name|second_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_parm
operator|==
name|void_list_node
condition|)
return|return
name|false
return|;
comment|/* Otherwise, if we have a two-argument function and the second 	 argument is `size_t', it will be the usual deallocation 	 function -- unless there is one-argument function, too.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|second_parm
argument_list|)
operator|==
name|void_list_node
operator|&&
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|second_parm
argument_list|)
argument_list|,
name|sizetype
argument_list|)
condition|)
name|has_two_argument_delete_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|has_two_argument_delete_p
return|;
block|}
end_function

begin_comment
comment|/* Check the validity of the bases and members declared in T.  Add any    implicitly-generated functions (like copy-constructors and    assignment operators).  Compute various flag bits (like    CLASSTYPE_NON_POD_T) for T.  This routine works purely at the C++    level: i.e., independently of the ABI in use.  */
end_comment

begin_function
specifier|static
name|void
name|check_bases_and_members
parameter_list|(
name|t
parameter_list|,
name|empty_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|empty_p
decl_stmt|;
block|{
comment|/* Nonzero if we are not allowed to generate a default constructor      for this case.  */
name|int
name|cant_have_default_ctor
decl_stmt|;
comment|/* Nonzero if the implicitly generated copy constructor should take      a non-const reference argument.  */
name|int
name|cant_have_const_ctor
decl_stmt|;
comment|/* Nonzero if the the implicitly generated assignment operator      should take a non-const reference argument.  */
name|int
name|no_const_asn_ref
decl_stmt|;
name|tree
name|access_decls
decl_stmt|;
comment|/* By default, we use const reference arguments and generate default      constructors.  */
name|cant_have_default_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_const_ctor
operator|=
literal|0
expr_stmt|;
name|no_const_asn_ref
operator|=
literal|0
expr_stmt|;
comment|/* Assume that the class is nearly empty; we'll clear this flag if      it turns out not to be nearly empty.  */
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Check all the base-classes. */
name|check_bases
argument_list|(
name|t
argument_list|,
operator|&
name|cant_have_default_ctor
argument_list|,
operator|&
name|cant_have_const_ctor
argument_list|,
operator|&
name|no_const_asn_ref
argument_list|)
expr_stmt|;
comment|/* Check all the data member declarations.  */
name|check_field_decls
argument_list|(
name|t
argument_list|,
operator|&
name|access_decls
argument_list|,
name|empty_p
argument_list|,
operator|&
name|cant_have_default_ctor
argument_list|,
operator|&
name|cant_have_const_ctor
argument_list|,
operator|&
name|no_const_asn_ref
argument_list|)
expr_stmt|;
comment|/* Check all the method declarations.  */
name|check_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* A nearly-empty class has to be vptr-containing; a nearly empty      class contains just a vptr.  */
if|if
condition|(
operator|!
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do some bookkeeping that will guide the generation of implicitly      declared member functions.  */
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|TYPE_HAS_REAL_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Synthesize any needed methods.  Note that methods will be synthesized      for anonymous unions; grok_x_components undoes that.  */
name|add_implicitly_declared_members
argument_list|(
name|t
argument_list|,
name|cant_have_default_ctor
argument_list|,
name|cant_have_const_ctor
argument_list|,
name|no_const_asn_ref
argument_list|)
expr_stmt|;
comment|/* Create the in-charge and not-in-charge variants of constructors      and destructors.  */
name|clone_constructors_and_destructors
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Process the using-declarations.  */
for|for
control|(
init|;
name|access_decls
condition|;
name|access_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|access_decls
argument_list|)
control|)
name|handle_using_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|access_decls
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Build and sort the CLASSTYPE_METHOD_VEC.  */
name|finish_struct_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not we will need a cookie when dynamically      allocating an array of this type.  */
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|vec_new_uses_cookie
operator|=
name|type_requires_array_cookie
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If T needs a pointer to its virtual function table, set TYPE_VFIELD    accordingly.  If a new vfield was created (because T doesn't have a    primary base class), then the newly created field is returned.  It    is not added to the TYPE_FIELDS list; it is the caller's    responsibility to do that.  */
end_comment

begin_function
specifier|static
name|tree
name|create_vtable_ptr
parameter_list|(
name|t
parameter_list|,
name|empty_p
parameter_list|,
name|vfuns_p
parameter_list|,
name|new_virtuals_p
parameter_list|,
name|overridden_virtuals_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|empty_p
decl_stmt|;
name|int
modifier|*
name|vfuns_p
decl_stmt|;
name|tree
modifier|*
name|new_virtuals_p
decl_stmt|;
name|tree
modifier|*
name|overridden_virtuals_p
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
comment|/* Loop over the virtual functions, adding them to our various      vtables.  */
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|add_virtual_function
argument_list|(
name|new_virtuals_p
argument_list|,
name|overridden_virtuals_p
argument_list|,
name|vfuns_p
argument_list|,
name|fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we couldn't find an appropriate base class, create a new field      here.  Even if there weren't any new virtual functions, we might need a      new virtual function table if we're supposed to include vptrs in      all classes that need them.  */
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
operator|*
name|vfuns_p
operator|||
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
comment|/* We build this decl with vtbl_ptr_type_node, which is a 	 `vtable_entry_type*'.  It might seem more precise to use 	 `vtable_entry_type (*)[N]' where N is the number of firtual 	 functions.  However, that would require the vtable pointer in 	 base classes to have a different type than the vtable pointer 	 in derived classes.  We could make that happen, but that 	 still wouldn't solve all the problems.  In particular, the 	 type-based alias analysis code would decide that assignments 	 to the base class vtable pointer can't alias assignments to 	 the derived class vtable pointer, since they have different 	 types.  Thus, in an derived class destructor, where the base 	 class constructor was inlined, we could generate bad code for 	 setting up the vtable pointer.             Therefore, we use one type for all vtable pointers.  We still 	 use a type-correct type; it's just doesn't indicate the array 	 bounds.  That's better than using `void*' or some such; it's 	 cleaner, and it let's the alias analysis code know that these 	 stores cannot alias stores to void*!  */
name|tree
name|field
decl_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|,
name|get_identifier
argument_list|(
name|VFIELD_BASE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|field
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|field
expr_stmt|;
comment|/* This class is non-empty.  */
operator|*
name|empty_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
comment|/* If there were any baseclasses, they can't possibly be at 	   offset zero any more, because that's where the vtable 	   pointer is.  So, converting to a base class is going to 	   take work.  */
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|field
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fixup the inline function given by INFO now that the class is    complete.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_pending_inline
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
decl_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|fn
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fixup the inline methods and friends in TYPE now that TYPE is    complete.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_inline_methods
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|method
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|&&
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Do inline member functions.  */
for|for
control|(
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
name|fixup_pending_inline
argument_list|(
name|method
argument_list|)
expr_stmt|;
comment|/* Do friends.  */
for|for
control|(
name|method
operator|=
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|type
argument_list|)
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
name|fixup_pending_inline
argument_list|(
name|TREE_VALUE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add OFFSET to all base types of BINFO which is a base in the    hierarchy dominated by T.     OFFSET, which is a type offset, is number of bytes.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_binfo_offsets
parameter_list|(
name|binfo
parameter_list|,
name|offset
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|primary_binfo
decl_stmt|;
comment|/* Update BINFO's offset.  */
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the primary base class.  */
name|primary_binfo
operator|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Scan all of the bases, pushing the BINFO_OFFSET adjust      downwards.  */
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
comment|/* On the first time through the loop, do the primary base. 	 Because the primary base need not be an immediate base, we 	 must handle the primary base specially.  */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|primary_binfo
condition|)
continue|continue;
name|base_binfo
operator|=
name|primary_binfo
expr_stmt|;
block|}
else|else
block|{
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Don't do the primary base twice.  */
if|if
condition|(
name|base_binfo
operator|==
name|primary_binfo
condition|)
continue|continue;
block|}
comment|/* Skip virtual bases that aren't our canonical primary base.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|base_binfo
argument_list|)
operator|!=
name|binfo
operator|||
name|base_binfo
operator|!=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|t
argument_list|)
operator|)
condition|)
continue|continue;
name|propagate_binfo_offsets
argument_list|(
name|base_binfo
argument_list|,
name|offset
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called via dfs_walk from layout_virtual bases.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_set_offset_for_unshared_vbases
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
comment|/* If this is a virtual base, make sure it has the same offset as      the shared copy.  If it's a primary base, then we know it's      correct.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|vbase
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbase
operator|!=
name|binfo
condition|)
block|{
name|offset
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|offset
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set BINFO_OFFSET for all of the virtual bases for T.  Update    TYPE_ALIGN and TYPE_SIZE for T.  OFFSETS gives the location of    empty subobjects of T.  */
end_comment

begin_function
specifier|static
name|void
name|layout_virtual_bases
parameter_list|(
name|t
parameter_list|,
name|offsets
parameter_list|)
name|tree
name|t
decl_stmt|;
name|splay_tree
name|offsets
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|dsize
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|eoc
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
comment|/* Packed structures don't need to have minimum size.  */
if|if
condition|(
operator|!
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|,
name|STRUCTURE_SIZE_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DSIZE is the size of the class without the virtual bases.  */
name|dsize
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make every class have alignment of at least one.  */
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Go through the virtual bases, allocating space for each virtual      base that is not already a primary base class.  These are      allocated in inheritance graph order.  */
for|for
control|(
name|vbases
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|vbase
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbases
argument_list|)
condition|)
continue|continue;
name|vbase
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|vbase
argument_list|)
condition|)
block|{
comment|/* This virtual base is not a primary base of any class in the 	     hierarchy, so we have to add space for it.  */
name|tree
name|basetype
decl_stmt|;
name|unsigned
name|int
name|desired_align
decl_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
expr_stmt|;
name|desired_align
operator|=
name|CLASSTYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
comment|/* Add padding so that we can put the virtual base class at an 	     appropriately aligned offset.  */
name|dsize
operator|=
name|CEIL
argument_list|(
name|dsize
argument_list|,
name|desired_align
argument_list|)
operator|*
name|desired_align
expr_stmt|;
comment|/* We try to squish empty virtual bases in just like 	     ordinary empty bases.  */
if|if
condition|(
name|is_empty_class
argument_list|(
name|basetype
argument_list|)
condition|)
name|layout_empty_base
argument_list|(
name|vbase
argument_list|,
name|size_int
argument_list|(
name|CEIL
argument_list|(
name|dsize
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
name|offsets
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|offset
decl_stmt|;
name|offset
operator|=
name|ssize_int
argument_list|(
name|CEIL
argument_list|(
name|dsize
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_diffop
argument_list|(
name|offset
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vbase
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And compute the offset of the virtual base.  */
name|propagate_binfo_offsets
argument_list|(
name|vbase
argument_list|,
name|offset
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Every virtual baseclass takes a least a UNIT, so that 		 we can take it's address and get something different 		 for each base.  */
name|dsize
operator|+=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|tree_low_cst
argument_list|(
name|CLASSTYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Keep track of the offsets assigned to this virtual base.  */
name|record_subobject_offsets
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|offsets
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, go through the TYPE_BINFO hierarchy, setting the      BINFO_OFFSETs correctly for all non-primary copies of the virtual      bases and their direct and indirect bases.  The ambiguity checks      in lookup_base depend on the BINFO_OFFSETs being set      correctly.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|dfs_set_offset_for_unshared_vbases
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we had empty base classes that protruded beyond the end of the      class, we didn't update DSIZE above; we were hoping to overlay      multiple such bases at the same location.  */
name|eoc
operator|=
name|end_of_class
argument_list|(
name|t
argument_list|,
comment|/*include_virtuals_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|eoc
operator|*
name|BITS_PER_UNIT
operator|>
name|dsize
condition|)
name|dsize
operator|=
name|eoc
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Now, make sure that the total size of the type is a multiple of      its alignment.  */
name|dsize
operator|=
name|CEIL
argument_list|(
name|dsize
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|*
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|dsize
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for ambiguous virtual bases.  */
if|if
condition|(
name|extra_warnings
condition|)
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lookup_base
argument_list|(
name|t
argument_list|,
name|basetype
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
condition|)
name|warning
argument_list|(
literal|"virtual base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the offset of the byte just past the end of the base class    with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero, then    only non-virtual bases are included.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|end_of_class
parameter_list|(
name|t
parameter_list|,
name|include_virtuals_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|include_virtuals_p
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|end_of_base
decl_stmt|;
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|include_virtuals_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|is_empty_class
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
comment|/* An empty class has zero CLASSTYPE_SIZE_UNIT, but we need to 	   allocate some space for it. It cannot have virtual bases, 	   so TYPE_SIZE_UNIT is fine.  */
name|size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|CLASSTYPE_SIZE_UNIT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|end_of_base
operator|=
name|tree_low_cst
argument_list|(
name|offset
argument_list|,
comment|/*pos=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_of_base
operator|>
name|result
condition|)
name|result
operator|=
name|end_of_base
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Warn about direct bases of T that are inaccessible because they are    ambiguous.  For example:       struct S {};      struct T : public S {};      struct U : public S, public T {};     Here, `(S*) new U' is not allowed because there are two `S'    subobjects of U.  */
end_comment

begin_function
specifier|static
name|void
name|warn_about_ambiguous_direct_bases
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lookup_base
argument_list|(
name|t
argument_list|,
name|basetype
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
condition|)
name|warning
argument_list|(
literal|"direct base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two INTEGER_CSTs K1 and K2.  */
end_comment

begin_function
specifier|static
name|int
name|splay_tree_compare_integer_csts
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|)
name|splay_tree_key
name|k1
decl_stmt|;
name|splay_tree_key
name|k2
decl_stmt|;
block|{
return|return
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|k1
argument_list|,
operator|(
name|tree
operator|)
name|k2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate    BINFO_OFFSETs for all of the base-classes.  Position the vtable    pointer.  */
end_comment

begin_function
specifier|static
name|void
name|layout_class_type
parameter_list|(
name|t
parameter_list|,
name|empty_p
parameter_list|,
name|vfuns_p
parameter_list|,
name|new_virtuals_p
parameter_list|,
name|overridden_virtuals_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|empty_p
decl_stmt|;
name|int
modifier|*
name|vfuns_p
decl_stmt|;
name|tree
modifier|*
name|new_virtuals_p
decl_stmt|;
name|tree
modifier|*
name|overridden_virtuals_p
decl_stmt|;
block|{
name|tree
name|non_static_data_members
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|vptr
decl_stmt|;
name|record_layout_info
name|rli
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|eoc
decl_stmt|;
comment|/* Maps offsets (represented as INTEGER_CSTs) to a TREE_LIST of      types that appear at that offset.  */
name|splay_tree
name|empty_base_offsets
decl_stmt|;
comment|/* Keep track of the first non-static data member.  */
name|non_static_data_members
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Start laying out the record.  */
name|rli
operator|=
name|start_record_layout
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If possible, we reuse the virtual function table pointer from one      of our base classes.  */
name|determine_primary_base
argument_list|(
name|t
argument_list|,
name|vfuns_p
argument_list|)
expr_stmt|;
comment|/* Create a pointer to our virtual function table.  */
name|vptr
operator|=
name|create_vtable_ptr
argument_list|(
name|t
argument_list|,
name|empty_p
argument_list|,
name|vfuns_p
argument_list|,
name|new_virtuals_p
argument_list|,
name|overridden_virtuals_p
argument_list|)
expr_stmt|;
comment|/* The vptr is always the first thing in the class.  */
if|if
condition|(
name|vptr
condition|)
block|{
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|vptr
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|place_field
argument_list|(
name|rli
argument_list|,
name|vptr
argument_list|)
expr_stmt|;
block|}
comment|/* Build FIELD_DECLs for all of the non-virtual base-types.  */
name|empty_base_offsets
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_integer_csts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_base_fields
argument_list|(
name|rli
argument_list|,
name|empty_p
argument_list|,
name|empty_base_offsets
argument_list|,
name|t
argument_list|)
condition|)
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Layout the non-static data members.  */
for|for
control|(
name|field
operator|=
name|non_static_data_members
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|padding
decl_stmt|;
comment|/* We still pass things that aren't non-static data members to 	 the back-end, in case it wants to do something with them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|place_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* If this field is a bit-field whose width is greater than its 	 type, then there are some special rules for allocating 	 it.  */
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
name|INT_CST_LT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|integer_type_kind
name|itk
decl_stmt|;
name|tree
name|integer_type
decl_stmt|;
comment|/* We must allocate the bits as if suitably aligned for the 	     longest integer type that fits in this many bits.  type 	     of the field.  Then, we are supposed to use the left over 	     bits as additional padding.  */
for|for
control|(
name|itk
operator|=
name|itk_char
init|;
name|itk
operator|!=
name|itk_none
condition|;
operator|++
name|itk
control|)
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|integer_types
index|[
name|itk
index|]
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* ITK now indicates a type that is too large for the 	     field.  We have to back up by one to find the largest 	     type that fits.  */
name|integer_type
operator|=
name|integer_types
index|[
name|itk
operator|-
literal|1
index|]
expr_stmt|;
name|padding
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|integer_type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|integer_type
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|integer_type
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|integer_type
argument_list|)
expr_stmt|;
block|}
else|else
name|padding
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_nonempty_base_or_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
name|empty_base_offsets
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we needed additional padding after this field, add it 	 now.  */
if|if
condition|(
name|padding
condition|)
block|{
name|tree
name|padding_field
decl_stmt|;
name|padding_field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|padding_field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|padding_field
argument_list|)
operator|=
name|padding
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|padding_field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|padding_field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_nonempty_base_or_field
argument_list|(
name|rli
argument_list|,
name|padding_field
argument_list|,
name|NULL_TREE
argument_list|,
name|empty_base_offsets
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* It might be the case that we grew the class to allocate a      zero-sized base class.  That won't be reflected in RLI, yet,      because we are willing to overlay multiple bases at the same      offset.  However, now we need to make sure that RLI is big enough      to reflect the entire class.  */
name|eoc
operator|=
name|end_of_class
argument_list|(
name|t
argument_list|,
comment|/*include_virtuals_p=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
argument_list|,
name|eoc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rli
operator|->
name|offset
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|rli
operator|->
name|offset
argument_list|,
name|size_int
argument_list|(
name|eoc
argument_list|)
argument_list|)
expr_stmt|;
name|rli
operator|->
name|bitpos
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
comment|/* We make all structures have at least one element, so that they      have non-zero size.  The class may be empty even if it has      basetypes.  Therefore, we add the fake field after all the other      fields; if there are already FIELD_DECLs on the list, their      offsets will not be disturbed.  */
if|if
condition|(
operator|!
name|eoc
operator|&&
operator|*
name|empty_p
condition|)
block|{
name|tree
name|padding
decl_stmt|;
name|padding
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|place_field
argument_list|(
name|rli
argument_list|,
name|padding
argument_list|)
expr_stmt|;
block|}
comment|/* Let the back-end lay out the type. Note that at this point we      have only included non-virtual base-classes; we will lay out the      virtual base classes later.  So, the TYPE_SIZE/TYPE_ALIGN after      this call are not necessarily correct; they are just the size and      alignment when no virtual base clases are used.  */
name|finish_record_layout
argument_list|(
name|rli
argument_list|)
expr_stmt|;
comment|/* Delete all zero-width bit-fields from the list of fields.  Now      that the type is laid out they are no longer important.  */
name|remove_zero_width_bit_fields
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Remember the size and alignment of the class before adding      the virtual bases.  */
if|if
condition|(
operator|*
name|empty_p
condition|)
block|{
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|CLASSTYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
block|}
else|else
block|{
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_DECL for this type to contain the right      value for DECL_OFFSET, so that we can use it as part      of a COMPONENT_REF for multiple inheritance.  */
name|layout_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now fix up any virtual base class types that we left lying      around.  We must get these done before we try to lay out the      virtual function table.  As a side-effect, this will remove the      base subobject fields.  */
name|layout_virtual_bases
argument_list|(
name|t
argument_list|,
name|empty_base_offsets
argument_list|)
expr_stmt|;
comment|/* Warn about direct bases that can't be talked about due to      ambiguity.  */
name|warn_about_ambiguous_direct_bases
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|empty_base_offsets
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration    (or C++ class declaration).     For C++, we must handle the building of derived classes.    Also, C++ allows static class members.  The way that this is    handled is to keep the field name where it is (as the DECL_NAME    of the field), and place the overloaded decl in the bit position    of the field.  layout_record and layout_union will know about this.     More C++ hair: inline functions have text in their    DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into    meaningful tree structure.  After the struct has been laid out, set    things up so that this can happen.     And still more: virtual functions.  In the case of single inheritance,    when a new virtual function is seen which redefines a virtual function    from the base class, the new virtual function is placed into    the virtual function table at exactly the same address that    it had in the base class.  When this is extended to multiple    inheritance, the same thing happens, except that multiple virtual    function tables must be maintained.  The first virtual function    table is treated in exactly the same way as in the case of single    inheritance.  Additional virtual function tables have different    DELTAs, which tell how to adjust `this' to point to the right thing.     ATTRIBUTES is the set of decl attributes to be applied, if any.  */
end_comment

begin_function
name|void
name|finish_struct_1
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|int
name|vfuns
decl_stmt|;
comment|/* The NEW_VIRTUALS is a TREE_LIST.  The TREE_VALUE of each node is      a FUNCTION_DECL.  Each of these functions is a virtual function      declared in T that does not override any virtual function from a      base class.  */
name|tree
name|new_virtuals
init|=
name|NULL_TREE
decl_stmt|;
comment|/* The OVERRIDDEN_VIRTUALS list is like the NEW_VIRTUALS list,      except that each declaration here overrides the declaration from      a base class.  */
name|tree
name|overridden_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|n_fields
init|=
literal|0
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|int
name|empty
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|popclass
argument_list|()
expr_stmt|;
return|return;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|vfuns
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|fixup_inline_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Do end-of-class semantic processing: checking the validity of the      bases and members and add implicitly generated methods.  */
name|check_bases_and_members
argument_list|(
name|t
argument_list|,
operator|&
name|empty
argument_list|)
expr_stmt|;
comment|/* Layout the class itself.  */
name|layout_class_type
argument_list|(
name|t
argument_list|,
operator|&
name|empty
argument_list|,
operator|&
name|vfuns
argument_list|,
operator|&
name|new_virtuals
argument_list|,
operator|&
name|overridden_virtuals
argument_list|)
expr_stmt|;
comment|/* Make sure that we get our own copy of the vfield FIELD_DECL.  */
name|vfield
operator|=
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfield
operator|&&
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|primary
init|=
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|primary
argument_list|)
argument_list|)
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
comment|/* The vtable better be at the start. */
name|my_friendly_assert
argument_list|(
name|integer_zerop
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|integer_zerop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|primary
argument_list|)
argument_list|)
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
name|vfield
operator|=
name|copy_decl
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
block|}
else|else
name|my_friendly_assert
argument_list|(
operator|!
name|vfield
operator|||
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|==
name|t
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
name|overridden_virtuals
operator|=
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
operator|&
name|vfuns
argument_list|,
name|nreverse
argument_list|(
name|overridden_virtuals
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we created a new vtbl pointer for this class, add it to the      list.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If necessary, create the primary vtable for this class.  */
if|if
condition|(
name|new_virtuals
operator|||
name|overridden_virtuals
operator|||
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|new_virtuals
operator|=
name|nreverse
argument_list|(
name|new_virtuals
argument_list|)
expr_stmt|;
comment|/* We must enter these virtuals into the table.  */
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|build_primary_vtable
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
comment|/* Here we know enough to change the type of our virtual 	   function table, but we will wait until later this function.  */
name|build_primary_vtable
argument_list|(
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If this type has basetypes with constructors, then those 	 constructors might clobber the virtual function table.  But 	 they don't if the derived class shares the exact vtable of the base 	 class.  */
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we didn't need a new vtable, see if we should copy one from      the base.  */
elseif|else
if|if
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* If this class uses a different vtable than its primary base 	 then when we will need to initialize our vptr after the base 	 class constructor runs.  */
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|!=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
condition|)
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|DECL_VIRTUAL_P
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|20000116
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|20000116
argument_list|)
expr_stmt|;
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|=
name|vfuns
expr_stmt|;
comment|/* Entries for virtual functions defined in the primary base are 	 followed by entries for new functions unique to this class.  */
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|new_virtuals
argument_list|)
expr_stmt|;
comment|/* Finally, add entries for functions that override virtuals 	 from non-primary bases.  */
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|overridden_virtuals
argument_list|)
expr_stmt|;
block|}
name|finish_struct_bits
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Complete the rtl for any static member objects of the type we're      working on.  */
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|t
condition|)
name|DECL_MODE
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Done with FIELDS...now decide whether to sort these for      faster lookups later.       The C front-end only does this when n_fields> 15.  We use      a smaller number because most searches fail (succeeding      ultimately as the search bores through the inheritance      hierarchy), and we want this failure to occur quickly.  */
name|n_fields
operator|=
name|count_fields
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_fields
operator|>
literal|7
condition|)
block|{
name|tree
name|field_vec
init|=
name|make_tree_vec
argument_list|(
name|n_fields
argument_list|)
decl_stmt|;
name|add_fields_to_vec
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|field_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|field_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n_fields
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|field_decl_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|field_vec
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
comment|/* Mark the fact that constructor for T 	     could affect anybody inheriting from T 	     who wants to initialize vtables for VFIELDS's type.  */
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make the rtl for any new vtables we have created, and unmark      the base types we marked.  */
name|finish_vtbls
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Build the VTT for T.  */
name|build_vtt
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_nonvdtor
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|warning
argument_list|(
literal|"`%#T' has virtual functions but non-virtual destructor"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|hack_incomplete_structures
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_overloaded_virtual
condition|)
name|warn_hidden
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|maybe_suppress_debug_info
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_class_hierarchy
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
operator|!
name|LOCAL_CLASS_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When T was built up, the member declarations were added in reverse    order.  Rearrange them to declaration order.  */
end_comment

begin_function
name|void
name|unreverse_member_declarations
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|next
decl_stmt|;
name|tree
name|prev
decl_stmt|;
name|tree
name|x
decl_stmt|;
comment|/* The TYPE_FIELDS, TYPE_METHODS, and CLASSTYPE_TAGS are all in      reverse order.  Put them in declaration order now.  */
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in      reverse order, so we can't just use nreverse.  */
name|prev
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
condition|;
name|x
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|t
decl_stmt|,
name|attributes
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|saved_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|saved_lineno
init|=
name|lineno
decl_stmt|;
comment|/* Now that we've got all the field declarations, reverse everything      as necessary.  */
name|unreverse_member_declarations
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
operator|&
name|t
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
comment|/* Nadger the current location so that diagnostics point to the start of      the struct, not the end.  */
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|finish_struct_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
block|}
else|else
name|finish_struct_1
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|saved_filename
expr_stmt|;
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
name|popclass
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to finish struct, but kicked out due to previous parse errors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|add_stmt
argument_list|(
name|build_min
argument_list|(
name|TAG_DEFN
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the dynamic type of INSTANCE, if known.    Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  *NONNULL should be initialized    before this function is called.  */
end_comment

begin_function
specifier|static
name|tree
name|fixed_type_or_null
parameter_list|(
name|instance
parameter_list|,
name|nonnull
parameter_list|,
name|cdtorp
parameter_list|)
name|tree
name|instance
decl_stmt|;
name|int
modifier|*
name|nonnull
decl_stmt|;
name|int
modifier|*
name|cdtorp
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|SAVE_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
return|return
name|NULL_TREE
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Propagate nonnull.  */
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
return|;
block|}
comment|/* fall through...  */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|==
name|current_class_ptr
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
comment|/* if we're in a ctor or dtor, we know our type. */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cdtorp
condition|)
operator|*
name|cdtorp
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Reference variables should be references to objects.  */
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the dynamic type of INSTANCE is known, and    equivalent to the static type.  We also handle the case where    INSTANCE is really a pointer. Return negative if this is a    ctor/dtor. There the dynamic type is known, but this might not be    the most derived base of the original object, and hence virtual    bases may not be layed out according to this type.     Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  *NONNULL should be initialized    before this function is called.  */
end_comment

begin_function
name|int
name|resolves_to_fixed_type_p
parameter_list|(
name|instance
parameter_list|,
name|nonnull
parameter_list|)
name|tree
name|instance
decl_stmt|;
name|int
modifier|*
name|nonnull
decl_stmt|;
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
name|int
name|cdtorp
init|=
literal|0
decl_stmt|;
name|tree
name|fixed
init|=
name|fixed_type_or_null
argument_list|(
name|instance
argument_list|,
name|nonnull
argument_list|,
operator|&
name|cdtorp
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixed
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|t
argument_list|,
name|fixed
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|cdtorp
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_class_processing
parameter_list|()
block|{
name|current_class_depth
operator|=
literal|0
expr_stmt|;
name|current_class_stack_size
operator|=
literal|10
expr_stmt|;
name|current_class_stack
operator|=
operator|(
name|class_stack_node_t
operator|)
name|xmalloc
argument_list|(
name|current_class_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|class_stack_node
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|local_classes
argument_list|,
literal|8
argument_list|,
literal|"local_classes"
argument_list|)
expr_stmt|;
name|ggc_add_tree_varray_root
argument_list|(
operator|&
name|local_classes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|access_default_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_public_node
operator|=
name|build_int_2
argument_list|(
name|ak_public
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_protected_node
operator|=
name|build_int_2
argument_list|(
name|ak_protected
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_private_node
operator|=
name|build_int_2
argument_list|(
name|ak_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_default_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_public_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|4
operator||
name|ak_public
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_protected_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|4
operator||
name|ak_protected
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_private_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|4
operator||
name|ak_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PUBLIC
index|]
operator|=
name|access_public_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PRIVATE
index|]
operator|=
name|access_private_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PROTECTED
index|]
operator|=
name|access_protected_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current scope to NAME. CODE tells us if this is a    STRUCT, UNION, or ENUM environment.     NAME may end up being NULL_TREE if this is an anonymous or    late-bound struct (as in "struct { ... } foo;")  */
end_comment

begin_comment
comment|/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE to    appropriate values, found by looking up the type definition of    NAME (as a CODE).     If MODIFY is 1, we set IDENTIFIER_CLASS_VALUE's of names    which can be seen locally to the class.  They are shadowed by    any subsequent local declaration (including parameter names).     If MODIFY is 2, we set IDENTIFIER_CLASS_VALUE's of names    which have static meaning (i.e., static members, static    member functions, enum declarations, etc).     If MODIFY is 3, we set IDENTIFIER_CLASS_VALUE of names    which can be seen locally to the class (as in 1), but    know that we are doing this for declaration purposes    (i.e. friend foo::bar (int)).     So that we may avoid calls to lookup_name, we cache the _TYPE    nodes of local TYPE_DECLs in the TREE_TYPE field of the name.     For multiple inheritance, we perform a two-pass depth-first search    of the type lattice.  The first pass performs a pre-order search,    marking types after the type has had its fields installed in    the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely    unmarks the marked types.  If a field or member function name    appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of    that name becomes `error_mark_node'.  */
end_comment

begin_function
name|void
name|pushclass
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure there is enough room for the new entry on the stack.  */
if|if
condition|(
name|current_class_depth
operator|+
literal|1
operator|>=
name|current_class_stack_size
condition|)
block|{
name|current_class_stack_size
operator|*=
literal|2
expr_stmt|;
name|current_class_stack
operator|=
operator|(
name|class_stack_node_t
operator|)
name|xrealloc
argument_list|(
name|current_class_stack
argument_list|,
name|current_class_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|class_stack_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert a new entry on the class stack.  */
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|name
operator|=
name|current_class_name
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|type
operator|=
name|current_class_type
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|access
operator|=
name|current_access_specifier
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
operator|=
literal|0
expr_stmt|;
name|current_class_depth
operator|++
expr_stmt|;
comment|/* Now set up the new type.  */
name|current_class_name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|current_class_name
operator|=
name|DECL_NAME
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
name|current_class_type
operator|=
name|type
expr_stmt|;
comment|/* By default, things in classes are private, while things in      structures or unions are public.  */
name|current_access_specifier
operator|=
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|type
argument_list|)
condition|?
name|access_private_node
else|:
name|access_public_node
operator|)
expr_stmt|;
if|if
condition|(
name|previous_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|type
operator|!=
name|previous_class_type
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|previous_class_type
argument_list|)
operator|)
operator|&&
name|current_class_depth
operator|==
literal|1
condition|)
block|{
comment|/* Forcibly remove any old class remnants.  */
name|invalidate_class_lookup_cache
argument_list|()
expr_stmt|;
block|}
comment|/* If we're about to enter a nested class, clear      IDENTIFIER_CLASS_VALUE for the enclosing classes.  */
if|if
condition|(
name|modify
operator|&&
name|current_class_depth
operator|>
literal|1
condition|)
name|clear_identifier_class_values
argument_list|()
expr_stmt|;
name|pushlevel_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|modify
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|previous_class_type
operator|||
name|current_class_depth
operator|>
literal|1
condition|)
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|item
decl_stmt|;
comment|/* We are re-entering the same class we just left, so we 	     don't have to search the whole inheritance matrix to find 	     all the decls to bind again.  Instead, we install the 	     cached class_shadowed list, and walk through it binding 	     names and setting up IDENTIFIER_TYPE_VALUEs.  */
name|set_class_shadows
argument_list|(
name|previous_class_values
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|previous_class_values
init|;
name|item
condition|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_PURPOSE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|push_class_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|id
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unuse_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|storetags
argument_list|(
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* When we exit a toplevel class scope, we save the    IDENTIFIER_CLASS_VALUEs so that we can restore them quickly if we    reenter the class.  Here, we've entered some other class, so we    must invalidate our cache.  */
end_comment

begin_function
name|void
name|invalidate_class_lookup_cache
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
comment|/* The IDENTIFIER_CLASS_VALUEs are no longer valid.  */
for|for
control|(
name|t
operator|=
name|previous_class_values
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|previous_class_values
operator|=
name|NULL_TREE
expr_stmt|;
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current class scope. If we were in a class scope    previously, that is the one popped to.  */
end_comment

begin_function
name|void
name|popclass
parameter_list|()
block|{
name|poplevel_class
argument_list|()
expr_stmt|;
comment|/* Since poplevel_class does the popping of class decls nowadays,      this really only frees the obstack used for these decls.  */
name|pop_class_decls
argument_list|()
expr_stmt|;
name|current_class_depth
operator|--
expr_stmt|;
name|current_class_name
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|name
expr_stmt|;
name|current_class_type
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|type
expr_stmt|;
name|current_access_specifier
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|access
expr_stmt|;
if|if
condition|(
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
condition|)
name|splay_tree_delete
argument_list|(
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if current_class_type is either T or a nested type of T.    We start looking from 1 because entry 0 is from global scope, and has    no type.  */
end_comment

begin_function
name|int
name|currently_open_class
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|current_class_type
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|current_class_depth
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
operator|==
name|t
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If either current_class_type or one of its enclosing classes are derived    from T, return the appropriate type.  Used to determine how we found    something via unqualified lookup.  */
end_comment

begin_function
name|tree
name|currently_open_derived_class
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|current_class_type
argument_list|)
condition|)
return|return
name|current_class_type
return|;
for|for
control|(
name|i
operator|=
name|current_class_depth
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
argument_list|)
condition|)
return|return
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* When entering a class scope, all enclosing class scopes' names with    static meaning (static variables, static functions, types and enumerators)    have to be visible.  This recursive function calls pushclass for all    enclosing class contexts until global or a local scope is reached.    TYPE is the enclosed class and MODIFY is equivalent with the pushclass    formal of the same name.  */
end_comment

begin_function
name|void
name|push_nested_class
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
comment|/* A namespace might be passed in error cases, like A::B:C.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
return|return;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undoes a push_nested_class call.  MODIFY is passed on to popclass.  */
end_comment

begin_function
name|void
name|pop_nested_class
parameter_list|()
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|popclass
argument_list|()
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the number of extern "LANG" blocks we are nested within.  */
end_comment

begin_function
name|int
name|current_lang_depth
parameter_list|()
block|{
return|return
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|current_lang_base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_LANG_NAME to appropriate value    so that behavior of name-mangling machinery is correct.  */
end_comment

begin_function
name|void
name|push_lang_context
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|VARRAY_PUSH_TREE
argument_list|(
name|current_lang_base
argument_list|,
name|current_lang_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_java
condition|)
block|{
name|current_lang_name
operator|=
name|name
expr_stmt|;
comment|/* DECL_IGNORED_P is initially set for these types, to avoid clutter. 	 (See record_builtin_java_type in decl.c.)  However, that causes 	 incorrect debug entries if these types are actually used. 	 So we re-enable debug output after extern "Java". */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_byte_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_short_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_int_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_long_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_float_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_double_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_char_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_boolean_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
block|{
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"language string `\"%s\"' not recognized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current language scope.  */
end_comment

begin_function
name|void
name|pop_lang_context
parameter_list|()
block|{
name|current_lang_name
operator|=
name|VARRAY_TOP_TREE
argument_list|(
name|current_lang_base
argument_list|)
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|current_lang_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Type instantiation routines.  */
end_comment

begin_comment
comment|/* Given an OVERLOAD and a TARGET_TYPE, return the function that    matches the TARGET_TYPE.  If there is no satisfactory match, return    error_mark_node, and issue an error message if COMPLAIN is    non-zero.  Permit pointers to member function if PTRMEM is non-zero.    If TEMPLATE_ONLY, the name of the overloaded function    was a template-id, and EXPLICIT_TARGS are the explicitly provided    template arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_address_of_overloaded_function
parameter_list|(
name|target_type
parameter_list|,
name|overload
parameter_list|,
name|complain
parameter_list|,
name|ptrmem
parameter_list|,
name|template_only
parameter_list|,
name|explicit_targs
parameter_list|)
name|tree
name|target_type
decl_stmt|;
name|tree
name|overload
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|int
name|ptrmem
decl_stmt|;
name|int
name|template_only
decl_stmt|;
name|tree
name|explicit_targs
decl_stmt|;
block|{
comment|/* Here's what the standard says:              [over.over]         If the name is a function template, template argument deduction        is done, and if the argument deduction succeeds, the deduced        arguments are used to generate a single template function, which        is added to the set of overloaded functions considered.         Non-member functions and static member functions match targets of        type "pointer-to-function" or "reference-to-function."  Nonstatic        member functions match targets of type "pointer-to-member        function;" the function type of the pointer to member is used to        select the member function from the set of overloaded member        functions.  If a nonstatic member function is selected, the        reference to the overloaded function name is required to have the        form of a pointer to member as described in 5.3.1.         If more than one function is selected, any template functions in        the set are eliminated if the set also contains a non-template        function, and any given template function is eliminated if the        set contains a second template function that is more specialized        than the first according to the partial ordering rules 14.5.5.2.        After such eliminations, if any, there shall remain exactly one        selected function.  */
name|int
name|is_ptrmem
init|=
literal|0
decl_stmt|;
name|int
name|is_reference
init|=
literal|0
decl_stmt|;
comment|/* We store the matches in a TREE_LIST rooted here.  The functions      are the TREE_PURPOSE, not the TREE_VALUE, in this list, for easy      interoperability with most_specialized_instantiation.  */
name|tree
name|matches
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* By the time we get here, we should be seeing only real      pointer-to-member types, not the internal POINTER_TYPE to      METHOD_TYPE representation.  */
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|overload
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|overload
operator|=
name|TREE_OPERAND
argument_list|(
name|overload
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check that the TARGET_TYPE is reasonable.  */
if|if
condition|(
name|TYPE_PTRFN_P
argument_list|(
name|target_type
argument_list|)
condition|)
comment|/* This is OK.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|target_type
argument_list|)
condition|)
comment|/* This is OK, too.  */
name|is_ptrmem
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* This is OK, too.  This comes from a conversion to reference 	 type.  */
name|target_type
operator|=
name|build_reference_type
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|is_reference
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"\ cannot resolve overloaded function `%D' based on conversion to type `%T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If we can find a non-template function that matches, we can just      use it.  There's no point in generating template instantiations      if we're just going to throw them out anyhow.  But, of course, we      can only do this when we don't *need* a template function.  */
if|if
condition|(
operator|!
name|template_only
condition|)
block|{
name|tree
name|fns
decl_stmt|;
for|for
control|(
name|fns
operator|=
name|overload
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_CHAIN
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_FUNCTION
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* We're not looking for templates just yet.  */
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|!=
name|is_ptrmem
condition|)
comment|/* We're looking for a non-static member, and this isn't 	       one, or vice versa.  */
continue|continue;
comment|/* See if there's a match.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|fntype
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_reference
condition|)
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_convert_arg
argument_list|(
name|target_type
argument_list|,
name|fntype
argument_list|,
name|fn
argument_list|)
condition|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|matches
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, if we've already got a match (or matches), there's no need      to proceed to the template functions.  But, if we don't have a      match we need to look at them, too.  */
if|if
condition|(
operator|!
name|matches
condition|)
block|{
name|tree
name|target_fn_type
decl_stmt|;
name|tree
name|target_arg_types
decl_stmt|;
name|tree
name|target_ret_type
decl_stmt|;
name|tree
name|fns
decl_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|target_fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|target_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|target_fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|target_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|target_fn_type
argument_list|)
expr_stmt|;
name|target_ret_type
operator|=
name|TREE_TYPE
argument_list|(
name|target_fn_type
argument_list|)
expr_stmt|;
comment|/* Never do unification on the 'this' parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_fn_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|target_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|target_arg_types
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|overload
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_CHAIN
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_FUNCTION
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|instantiation
decl_stmt|;
name|tree
name|instantiation_type
decl_stmt|;
name|tree
name|targs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* We're only looking for templates.  */
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|!=
name|is_ptrmem
condition|)
comment|/* We're not looking for a non-static member, and this is 	       one, or vice versa.  */
continue|continue;
comment|/* Try to do argument deduction.  */
name|targs
operator|=
name|make_tree_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_type_unification
argument_list|(
name|fn
argument_list|,
name|explicit_targs
argument_list|,
name|targs
argument_list|,
name|target_arg_types
argument_list|,
name|target_ret_type
argument_list|,
name|DEDUCE_EXACT
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Argument deduction failed.  */
continue|continue;
comment|/* Instantiate the template.  */
name|instantiation
operator|=
name|instantiate_template
argument_list|(
name|fn
argument_list|,
name|targs
argument_list|)
expr_stmt|;
if|if
condition|(
name|instantiation
operator|==
name|error_mark_node
condition|)
comment|/* Instantiation failed.  */
continue|continue;
comment|/* See if there's a match.  */
name|instantiation_type
operator|=
name|TREE_TYPE
argument_list|(
name|instantiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|instantiation_type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|instantiation_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_reference
condition|)
name|instantiation_type
operator|=
name|build_pointer_type
argument_list|(
name|instantiation_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_convert_arg
argument_list|(
name|target_type
argument_list|,
name|instantiation_type
argument_list|,
name|instantiation
argument_list|)
condition|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|instantiation
argument_list|,
name|fn
argument_list|,
name|matches
argument_list|)
expr_stmt|;
block|}
comment|/* Now, remove all but the most specialized of the matches.  */
if|if
condition|(
name|matches
condition|)
block|{
name|tree
name|match
init|=
name|most_specialized_instantiation
argument_list|(
name|matches
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|!=
name|error_mark_node
condition|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|match
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we should have exactly one function in MATCHES.  */
if|if
condition|(
name|matches
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* There were *no* matches.  */
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"no matches converting function `%D' to type `%#T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* print_candidates expects a chain with the functions in              TREE_VALUE slots, so we cons one up here (we're losing anyway,              so why be clever?).  */
for|for
control|(
init|;
name|overload
condition|;
name|overload
operator|=
name|OVL_NEXT
argument_list|(
name|overload
argument_list|)
control|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|OVL_CURRENT
argument_list|(
name|overload
argument_list|)
argument_list|,
name|matches
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|matches
argument_list|)
condition|)
block|{
comment|/* There were too many matches.  */
if|if
condition|(
name|complain
condition|)
block|{
name|tree
name|match
decl_stmt|;
name|error
argument_list|(
literal|"converting overloaded function `%D' to type `%#T' is ambiguous"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* Since print_candidates expects the functions in the 	     TREE_VALUE slot, we flip them here.  */
for|for
control|(
name|match
operator|=
name|matches
init|;
name|match
condition|;
name|match
operator|=
name|TREE_CHAIN
argument_list|(
name|match
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|match
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* Good, exactly one match.  Now, convert it to the correct type.  */
name|fn
operator|=
name|TREE_PURPOSE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|ptrmem
operator|&&
operator|!
name|flag_ms_extensions
condition|)
block|{
specifier|static
name|int
name|explained
decl_stmt|;
if|if
condition|(
operator|!
name|complain
condition|)
return|return
name|error_mark_node
return|;
name|pedwarn
argument_list|(
literal|"assuming pointer to member `%D'"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|pedwarn
argument_list|(
literal|"(a pointer to member can only be formed with `&%E')"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRFN_P
argument_list|(
name|target_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|target_type
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
comment|/* The target must be a REFERENCE_TYPE.  Above, build_unary_op 	 will mark the function as addressed, but here we must do it 	 explicitly.  */
name|mark_addressable
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function will instantiate the type of the expression given in    RHS to match the type of LHSTYPE.  If errors exist, then return    error_mark_node. FLAGS is a bit mask.  If ITF_COMPLAIN is set, then    we complain on errors.  If we are not complaining, never modify rhs,    as overload resolution wants to try many possible instantiations, in    the hope that at least one will work.        For non-recursive calls, LHSTYPE should be a function, pointer to    function, or a pointer to member function.  */
end_comment

begin_function
name|tree
name|instantiate_type
parameter_list|(
name|lhstype
parameter_list|,
name|rhs
parameter_list|,
name|flags
parameter_list|)
name|tree
name|lhstype
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|instantiate_type_flags
name|flags
decl_stmt|;
block|{
name|int
name|complain
init|=
operator|(
name|flags
operator|&
name|itf_complain
operator|)
decl_stmt|;
name|int
name|strict
init|=
operator|(
name|flags
operator|&
name|itf_no_attributes
operator|)
condition|?
name|COMPARE_NO_ATTRIBUTES
else|:
name|COMPARE_STRICT
decl_stmt|;
name|int
name|allow_ptrmem
init|=
name|flags
operator|&
name|itf_ptrmem_ok
decl_stmt|;
name|flags
operator|&=
operator|~
name|itf_ptrmem_ok
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
operator|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
return|return
name|rhs
return|;
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"argument of type `%T' does not match `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We don't overwrite rhs if it is an overloaded function.      Copying it would destroy the tree link.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|rhs
operator|=
name|copy_node
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* This should really only be used when attempting to distinguish      what sort of a pointer to function we have.  For now, any      arithmetic operation which is not supported on pointers      is rejected as an error.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TYPE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|BUFFER_REF
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|new_rhs
decl_stmt|;
name|new_rhs
operator|=
name|instantiate_type
argument_list|(
name|build_pointer_type
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|new_rhs
expr_stmt|;
return|return
name|rhs
return|;
block|}
case|case
name|NOP_EXPR
case|:
name|rhs
operator|=
name|copy_node
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|OFFSET_REF
case|:
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|flags
operator||
name|allow_ptrmem
argument_list|)
return|;
comment|/* This can happen if we are forming a pointer-to-member for a 	 member template.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|fns
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|resolve_address_of_overloaded_function
argument_list|(
name|lhstype
argument_list|,
name|fns
argument_list|,
name|complain
argument_list|,
name|allow_ptrmem
argument_list|,
comment|/*template_only=*/
literal|1
argument_list|,
name|args
argument_list|)
return|;
block|}
case|case
name|OVERLOAD
case|:
return|return
name|resolve_address_of_overloaded_function
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|,
name|allow_ptrmem
argument_list|,
comment|/*template_only=*/
literal|0
argument_list|,
comment|/*explicit_targs=*/
name|NULL_TREE
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
comment|/* Now we should have a baselink. */
name|my_friendly_assert
argument_list|(
name|BASELINK_P
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|990412
argument_list|)
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* This is too hard for now.  */
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid operation on uninstantiated type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MODIFY_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ADDR_EXPR
case|:
block|{
if|if
condition|(
name|PTRMEM_OK_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|flags
operator||=
name|itf_ptrmem_ok
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
case|case
name|ENTRY_VALUE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the virtual function pointer field    (as an IDENTIFIER_NODE) for the given TYPE.  Note that    this may have to look back through base types to find the    ultimate field name.  (For single inheritance, these could    all be the same name.  Who knows for multiple inheritance).  */
end_comment

begin_function
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VFIELD_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VFIELD_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_class_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert_harshness = %d\n"
argument_list|,
name|n_convert_harshness
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compute_conversion_costs = %d\n"
argument_list|,
name|n_compute_conversion_costs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"build_method_call = %d (inner = %d)\n"
argument_list|,
name|n_build_method_call
argument_list|,
name|n_inner_fields_searched
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_vtables
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtables = %d; vtable searches = %d\n"
argument_list|,
name|n_vtables
argument_list|,
name|n_vtable_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable entries = %d; vtable elems = %d\n"
argument_list|,
name|n_vtable_entries
argument_list|,
name|n_vtable_elems
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Build a dummy reference to ourselves so Derived::Base (and A::A) works,    according to [class]:                                           The class-name is also inserted    into  the scope of the class itself.  For purposes of access checking,    the inserted class name is treated as if it were a public member name.  */
end_comment

begin_function
name|void
name|build_self_reference
parameter_list|()
block|{
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|saved_cas
decl_stmt|;
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|value
operator|=
name|push_template_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|saved_cas
operator|=
name|current_access_specifier
expr_stmt|;
name|current_access_specifier
operator|=
name|access_public_node
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|current_access_specifier
operator|=
name|saved_cas
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE contains only padding bytes.  */
end_comment

begin_function
name|int
name|is_empty_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|integer_zerop
argument_list|(
name|CLASSTYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the enclosing class of the given NODE.  NODE can be a *_DECL or    a *_TYPE node.  NODE can also be a local class.  */
end_comment

begin_function
name|tree
name|get_enclosing_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|node
init|=
name|type
decl_stmt|;
while|while
condition|(
name|node
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|node
operator|=
name|DECL_CONTEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|node
operator|!=
name|type
condition|)
return|return
name|node
return|;
name|node
operator|=
name|TYPE_CONTEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TYPE or one of its enclosing classes is derived from BASE.  */
end_comment

begin_function
name|int
name|is_base_of_enclosing_class
parameter_list|(
name|base
parameter_list|,
name|type
parameter_list|)
name|tree
name|base
decl_stmt|,
name|type
decl_stmt|;
block|{
while|while
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|lookup_base
argument_list|(
name|type
argument_list|,
name|base
argument_list|,
name|ba_any
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|1
return|;
name|type
operator|=
name|get_enclosing_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Note that NAME was looked up while the current class was being    defined and that the result of that lookup was DECL.  */
end_comment

begin_function
name|void
name|maybe_note_name_used_in_class
parameter_list|(
name|name
parameter_list|,
name|decl
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|splay_tree
name|names_used
decl_stmt|;
comment|/* If we're not defining a class, there's nothing to do.  */
if|if
condition|(
operator|!
name|current_class_type
operator|||
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
return|return;
comment|/* If there's already a binding for this NAME, then we don't have      anything to worry about.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
condition|)
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|names_used
operator|=
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|names_used
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that NAME was declared (as DECL) in the current class.  Check    to see that the declaration is legal.  */
end_comment

begin_function
name|void
name|note_name_declared_in_class
parameter_list|(
name|name
parameter_list|,
name|decl
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|splay_tree
name|names_used
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Look to see if we ever used this name.  */
name|names_used
operator|=
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
expr_stmt|;
if|if
condition|(
operator|!
name|names_used
condition|)
return|return;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|names_used
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* [basic.scope.class] 	  	 A name N used in a class S shall refer to the same declaration 	 in its context and when re-evaluated in the completed scope of 	 S.  */
name|error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"changes meaning of `%D' from `%+#D'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the VAR_DECL for the complete vtable associated with BINFO.    Secondary vtables are merged with primary vtables; this function    will return the VAR_DECL for the primary vtable.  */
end_comment

begin_function
name|tree
name|get_vtbl_decl_for_binfo
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|,
literal|2000403
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|20000403
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Called from get_primary_binfo via dfs_walk.  DATA is a TREE_LIST    who's TREE_PURPOSE is the TYPE of the required primary base and    who's TREE_VALUE is a list of candidate binfos that we fill in. */
end_comment

begin_function
specifier|static
name|tree
name|dfs_get_primary_binfo
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|cons
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|tree
name|primary_base
init|=
name|TREE_PURPOSE
argument_list|(
name|cons
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|primary_base
argument_list|)
condition|)
comment|/* This is the right type of binfo, but it might be an unshared        instance, and the shared instance is later in the dfs walk.  We        must keep looking.  */
name|TREE_VALUE
argument_list|(
name|cons
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|binfo
argument_list|,
name|TREE_VALUE
argument_list|(
name|cons
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns the unshared binfo for the primary base of BINFO.  Note    that in a complex hierarchy the resulting BINFO may not actually    *be* primary.  In particular if the resulting BINFO is a virtual    base, and it occurs elsewhere in the hierarchy, then this    occurrence may not actually be a primary base in the complete    object.  Check BINFO_PRIMARY_P to be sure.  */
end_comment

begin_function
name|tree
name|get_primary_binfo
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|primary_base
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|primary_base
operator|=
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|primary_base
condition|)
return|return
name|NULL_TREE
return|;
comment|/* A non-virtual primary base is always a direct base, and easy to      find.  */
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|primary_base
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Scan the direct basetypes until we find a base with the same 	 type as the primary base.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|primary_base
argument_list|)
argument_list|)
condition|)
return|return
name|base_binfo
return|;
block|}
comment|/* We should always find the primary base.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* For a primary virtual base, we have to scan the entire hierarchy      rooted at BINFO; the virtual base could be an indirect virtual      base.  There could be more than one instance of the primary base      in the hierarchy, and if one is the canonical binfo we want that      one.  If it exists, it should be the first one we find, but as a      consistency check we find them all and make sure.  */
name|virtuals
operator|=
name|build_tree_list
argument_list|(
name|BINFO_TYPE
argument_list|(
name|primary_base
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_get_primary_binfo
argument_list|,
name|NULL
argument_list|,
name|virtuals
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
comment|/* We must have found at least one instance.  */
name|my_friendly_assert
argument_list|(
name|virtuals
argument_list|,
literal|20010612
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
condition|)
block|{
comment|/* We found more than one instance of the base. We must make          sure that, if one is the canonical one, it is the first one          we found. As the chain is in reverse dfs order, that means          the last on the list.  */
name|tree
name|complete_binfo
decl_stmt|;
name|tree
name|canonical
decl_stmt|;
for|for
control|(
name|complete_binfo
operator|=
name|binfo
init|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|complete_binfo
argument_list|)
condition|;
name|complete_binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|complete_binfo
argument_list|)
control|)
continue|continue;
name|canonical
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|primary_base
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|complete_binfo
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|virtuals
condition|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
control|)
block|{
name|result
operator|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
operator|==
name|result
condition|)
block|{
comment|/* This is the unshared instance. Make sure it was the 		 first one found.  */
name|my_friendly_assert
argument_list|(
operator|!
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
argument_list|,
literal|20010612
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|result
operator|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* If INDENTED_P is zero, indent to INDENT. Return non-zero. */
end_comment

begin_function
specifier|static
name|int
name|maybe_indent_hierarchy
parameter_list|(
name|stream
parameter_list|,
name|indent
parameter_list|,
name|indented_p
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|indent
decl_stmt|;
name|int
name|indented_p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|indented_p
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%*s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dump the offsets of all the bases rooted at BINFO (in the hierarchy    dominated by T) to stderr.  INDENT should be zero when called from    the top level; it is incremented recursively.  */
end_comment

begin_function
specifier|static
name|void
name|dump_class_hierarchy_r
parameter_list|(
name|stream
parameter_list|,
name|flags
parameter_list|,
name|t
parameter_list|,
name|binfo
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|indented
init|=
literal|0
decl_stmt|;
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s (0x%lx) "
argument_list|,
name|type_as_string
argument_list|(
name|binfo
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|binfo
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_empty_class
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" empty"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" nearly-empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|canonical
init|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" virtual"
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
operator|==
name|binfo
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" canonical"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" non-canonical"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|indented
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" primary-for %s (0x%lx)"
argument_list|,
name|type_as_string
argument_list|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" lost-primary"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indented
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|int
name|indented
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" subvttidx=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vptridx=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_VPTR_FIELD
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vbaseoffset=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_VPTR_FIELD
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vptr=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indented
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
name|dump_class_hierarchy_r
argument_list|(
name|stream
argument_list|,
name|flags
argument_list|,
name|t
argument_list|,
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the BINFO hierarchy for T.  */
end_comment

begin_function
specifier|static
name|void
name|dump_class_hierarchy
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_class
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Class %s\n"
argument_list|,
name|type_as_string
argument_list|(
name|t
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"   size=%lu align=%lu\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|dump_class_hierarchy_r
argument_list|(
name|stream
argument_list|,
name|flags
argument_list|,
name|t
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_array
parameter_list|(
name|stream
parameter_list|,
name|decl
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|inits
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|HOST_WIDE_INT
name|elt
decl_stmt|;
name|tree
name|size
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|elt
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s:"
argument_list|,
name|decl_as_string
argument_list|(
name|decl
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s entries"
argument_list|,
name|expr_as_string
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|size_one_node
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
operator|,
name|inits
operator|=
name|TREE_OPERAND
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
init|;
name|inits
condition|;
name|ix
operator|++
operator|,
name|inits
operator|=
name|TREE_CHAIN
argument_list|(
name|inits
argument_list|)
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-4ld  %s\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ix
operator|*
name|elt
argument_list|)
argument_list|,
name|expr_as_string
argument_list|(
name|TREE_VALUE
argument_list|(
name|inits
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_vtable
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|,
name|vtable
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|vtable
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_class
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|int
name|ctor_vtbl_p
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|!=
name|binfo
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s for %s"
argument_list|,
name|ctor_vtbl_p
condition|?
literal|"Construction vtable"
else|:
literal|"Vtable"
argument_list|,
name|type_as_string
argument_list|(
name|binfo
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctor_vtbl_p
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" (0x%lx instance)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|binfo
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" in %s"
argument_list|,
name|type_as_string
argument_list|(
name|t
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_array
argument_list|(
name|stream
argument_list|,
name|vtable
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dump_end
argument_list|(
name|TDI_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_vtt
parameter_list|(
name|t
parameter_list|,
name|vtt
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|vtt
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_class
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"VTT for %s\n"
argument_list|,
name|type_as_string
argument_list|(
name|t
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|dump_array
argument_list|(
name|stream
argument_list|,
name|vtt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dump_end
argument_list|(
name|TDI_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Virtual function table initialization.  */
end_comment

begin_comment
comment|/* Create all the necessary vtables for T and its base classes.  */
end_comment

begin_function
specifier|static
name|void
name|finish_vtbls
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|list
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We lay out the primary and secondary vtables in one contiguous      vtable.  The primary vtable is first, followed by the non-virtual      secondary vtables in inheritance graph order.  */
name|list
operator|=
name|build_tree_list
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|accumulate_vtbl_inits
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Then come the virtual bases, also in inheritance graph order.  */
for|for
control|(
name|vbase
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
name|tree
name|real_base
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|)
continue|continue;
comment|/* Although we walk in inheritance order, that might not get the          canonical base.  */
name|real_base
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|accumulate_vtbl_inits
argument_list|(
name|real_base
argument_list|,
name|real_base
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in BINFO_VPTR_FIELD in the immediate binfos for our virtual      base classes, for the benefit of the debugging backends.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base
init|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|vbase
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|BINFO_VPTR_FIELD
argument_list|(
name|base
argument_list|)
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|vbase
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
condition|)
name|initialize_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the vtable for BINFO with the INITS.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_vtable
parameter_list|(
name|binfo
parameter_list|,
name|inits
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|inits
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|layout_vtable_decl
argument_list|(
name|binfo
argument_list|,
name|list_length
argument_list|(
name|inits
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|initialize_array
argument_list|(
name|decl
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|dump_vtable
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|binfo
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize DECL (a declaration for a namespace-scope array) with    the INITS.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_array
parameter_list|(
name|decl
parameter_list|,
name|inits
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|inits
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the VTT (virtual table table) for T.    A class requires a VTT if it has virtual bases.        This holds    1 - primary virtual pointer for complete object T    2 - secondary VTTs for each direct non-virtual base of T which requires a        VTT    3 - secondary virtual pointers for each direct or indirect base of T which        has virtual bases or is reachable via a virtual path from T.    4 - secondary VTTs for each direct or indirect virtual base of T.        Secondary VTTs look like complete object VTTs without part 4.  */
end_comment

begin_function
specifier|static
name|void
name|build_vtt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|inits
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|vtt
decl_stmt|;
name|tree
name|index
decl_stmt|;
comment|/* Build up the initializers for the VTT.  */
name|inits
operator|=
name|NULL_TREE
expr_stmt|;
name|index
operator|=
name|size_zero_node
expr_stmt|;
name|build_vtt_inits
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
operator|&
name|inits
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
comment|/* If we didn't need a VTT, we're done.  */
if|if
condition|(
operator|!
name|inits
condition|)
return|return;
comment|/* Figure out the type of the VTT.  */
name|type
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|list_length
argument_list|(
name|inits
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|const_ptr_type_node
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Now, build the VTT object itself.  */
name|vtt
operator|=
name|build_vtable
argument_list|(
name|t
argument_list|,
name|get_vtt_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|vtt
argument_list|)
expr_stmt|;
name|initialize_array
argument_list|(
name|vtt
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|dump_vtt
argument_list|(
name|t
argument_list|,
name|vtt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The type corresponding to BASE_BINFO is a base of the type of BINFO, but    from within some hierarchy which is inherited from the type of BINFO.    Return BASE_BINFO's equivalent binfo from the hierarchy dominated by    BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|get_original_base
parameter_list|(
name|base_binfo
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|base_binfo
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|derived
decl_stmt|;
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|binfo
return|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
return|return
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
return|;
name|derived
operator|=
name|get_original_base
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|BINFO_N_BASETYPES
argument_list|(
name|derived
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* When building a secondary VTT, BINFO_VTABLE is set to a TREE_LIST with    PURPOSE the RTTI_BINFO, VALUE the real vtable pointer for this binfo,    and CHAIN the vtable pointer for this binfo after construction is    complete.  VALUE can also be another BINFO, in which case we recurse. */
end_comment

begin_function
specifier|static
name|tree
name|binfo_ctor_vtable
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|vt
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|vt
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vt
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|vt
operator|=
name|TREE_VALUE
argument_list|(
name|vt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vt
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|binfo
operator|=
name|vt
expr_stmt|;
else|else
break|break;
block|}
return|return
name|vt
return|;
block|}
end_function

begin_comment
comment|/* Recursively build the VTT-initializer for BINFO (which is in the    hierarchy dominated by T).  INITS points to the end of the initializer    list to date.  INDEX is the VTT index where the next element will be    replaced.  Iff BINFO is the binfo for T, this is the top level VTT (i.e.    not a subvtt for some base of T).  When that is so, we emit the sub-VTTs    for virtual bases of T. When it is not so, we build the constructor    vtables for the BINFO-in-T variant.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|build_vtt_inits
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|,
name|inits
parameter_list|,
name|index
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
modifier|*
name|inits
decl_stmt|;
name|tree
modifier|*
name|index
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|b
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|secondary_vptrs
decl_stmt|;
name|int
name|top_level_p
init|=
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
comment|/* We only need VTTs for subobjects with virtual bases.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|inits
return|;
comment|/* We need to use a construction vtable if this is not the primary      VTT.  */
if|if
condition|(
operator|!
name|top_level_p
condition|)
block|{
name|build_ctor_vtbl_group
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Record the offset in the VTT where this sub-VTT can be found.  */
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
operator|=
operator|*
name|index
expr_stmt|;
block|}
comment|/* Add the address of the primary vtable for the complete object.  */
name|init
operator|=
name|binfo_ctor_vtable
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
operator|*
name|inits
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|inits
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|inits
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_level_p
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|20010129
argument_list|)
expr_stmt|;
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
operator|=
operator|*
name|index
expr_stmt|;
block|}
operator|*
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|index
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recursively add the secondary VTTs for non-virtual bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|b
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
condition|)
name|inits
operator|=
name|build_vtt_inits
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|,
name|t
argument_list|,
name|inits
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Add secondary virtual pointers for all subobjects of BINFO with      either virtual bases or reachable along a virtual path, except      subobjects that are non-virtual primary bases.  */
name|secondary_vptrs
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
operator|*
name|index
expr_stmt|;
name|VTT_TOP_LEVEL_P
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
name|top_level_p
expr_stmt|;
name|VTT_MARKED_BINFO_P
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
name|dfs_build_secondary_vptr_vtt_inits
argument_list|,
name|NULL
argument_list|,
name|dfs_ctor_vtable_bases_queue_p
argument_list|,
name|secondary_vptrs
argument_list|)
expr_stmt|;
name|VTT_MARKED_BINFO_P
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|dfs_ctor_vtable_bases_queue_p
argument_list|,
name|secondary_vptrs
argument_list|)
expr_stmt|;
operator|*
name|index
operator|=
name|TREE_TYPE
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
comment|/* The secondary vptrs come back in reverse order.  After we reverse      them, and add the INITS, the last init will be the first element      of the chain.  */
name|secondary_vptrs
operator|=
name|TREE_VALUE
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|secondary_vptrs
condition|)
block|{
operator|*
name|inits
operator|=
name|nreverse
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
name|inits
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|*
name|inits
operator|==
name|NULL_TREE
argument_list|,
literal|20000517
argument_list|)
expr_stmt|;
block|}
comment|/* Add the secondary VTTs for virtual bases.  */
if|if
condition|(
name|top_level_p
condition|)
for|for
control|(
name|b
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|TREE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
block|{
name|tree
name|vbase
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
name|vbase
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build_vtt_inits
argument_list|(
name|vbase
argument_list|,
name|t
argument_list|,
name|inits
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|top_level_p
condition|)
block|{
name|tree
name|data
init|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|VTT_TOP_LEVEL_P
argument_list|(
name|data
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VTT_MARKED_BINFO_P
argument_list|(
name|data
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_fixup_binfo_vtbls
argument_list|,
name|dfs_ctor_vtable_bases_queue_p
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|inits
return|;
block|}
end_function

begin_comment
comment|/* Called from build_vtt_inits via dfs_walk.  BINFO is the binfo    for the base in most derived. DATA is a TREE_LIST who's    TREE_CHAIN is the type of the base being    constructed whilst this secondary vptr is live.  The TREE_UNSIGNED    flag of DATA indicates that this is a constructor vtable.  The    TREE_TOP_LEVEL flag indicates that this is the primary VTT.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_build_secondary_vptr_vtt_inits
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|l
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|int
name|top_level_p
decl_stmt|;
name|l
operator|=
operator|(
name|tree
operator|)
name|data
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|top_level_p
operator|=
name|VTT_TOP_LEVEL_P
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* We don't care about bases that don't have vtables.  */
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We're only interested in proper subobjects of T.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We're not interested in non-virtual primary bases.  */
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If BINFO has virtual bases or is reachable via a virtual path      from T, it'll have a secondary vptr.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|!
name|binfo_via_virtual
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Record the index where this secondary vptr can be found.  */
name|index
operator|=
name|TREE_TYPE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_level_p
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|20010129
argument_list|)
expr_stmt|;
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
operator|=
name|index
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|l
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|index
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the initializer for the secondary vptr itself.  */
if|if
condition|(
name|top_level_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
comment|/* It's a primary virtual base, and this is not the construction          vtable. Find the base this is primary of in the inheritance graph,          and use that base's vtable now. */
while|while
condition|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|binfo_ctor_vtable
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* dfs_walk_real predicate for building vtables. DATA is a TREE_LIST,    VTT_MARKED_BINFO_P indicates whether marked or unmarked bases    should be walked.  TREE_PURPOSE is the TREE_TYPE that dominates the    hierarchy.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_ctor_vtable_bases_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* Get the shared version.  */
name|binfo
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
name|VTT_MARKED_BINFO_P
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Called from build_vtt_inits via dfs_walk. After building constructor    vtables and generating the sub-vtt from them, we need to restore the    BINFO_VTABLES that were scribbled on.  DATA is a TREE_LIST whose    TREE_VALUE is the TREE_TYPE of the base whose sub vtt was generated.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_fixup_binfo_vtbls
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* We don't care about bases that don't have vtables.  */
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we scribbled the construction vtable vptr into BINFO, clear it      out now.  */
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|TREE_PURPOSE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
operator|)
condition|)
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build the construction vtable group for BINFO which is in the    hierarchy dominated by T.  */
end_comment

begin_function
specifier|static
name|void
name|build_ctor_vtbl_group
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|list
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|vtbl
decl_stmt|;
name|tree
name|inits
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
comment|/* See if we've already created this construction vtable group.  */
name|id
operator|=
name|mangle_ctor_vtbl_for_type
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
condition|)
return|return;
name|my_friendly_assert
argument_list|(
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|,
literal|20010124
argument_list|)
expr_stmt|;
comment|/* Build a version of VTBL (with the wrong type) for use in      constructing the addresses of secondary vtables in the      construction vtable group.  */
name|vtbl
operator|=
name|build_vtable
argument_list|(
name|t
argument_list|,
name|id
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|list
operator|=
name|build_tree_list
argument_list|(
name|vtbl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|accumulate_vtbl_inits
argument_list|(
name|binfo
argument_list|,
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|binfo
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Add the vtables for each of our virtual bases using the vbase in T      binfo.  */
for|for
control|(
name|vbase
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
name|tree
name|b
decl_stmt|;
name|tree
name|orig_base
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|)
continue|continue;
name|b
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|orig_base
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|accumulate_vtbl_inits
argument_list|(
name|b
argument_list|,
name|orig_base
argument_list|,
name|binfo
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|inits
operator|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* Figure out the type of the construction vtable.  */
name|type
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|list_length
argument_list|(
name|inits
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Initialize the construction vtable.  */
name|pushdecl_top_level
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|initialize_array
argument_list|(
name|vtbl
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|dump_vtable
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the vtbl initializers for BINFO (and its bases other than    non-virtual primaries) to the list of INITS.  BINFO is in the    hierarchy dominated by T.  RTTI_BINFO is the binfo within T of    the constructor the vtbl inits should be accumulated for. (If this    is the complete object vtbl then RTTI_BINFO will be TYPE_BINFO (T).)    ORIG_BINFO is the binfo for this object within BINFO_TYPE (RTTI_BINFO).    BINFO is the active base equivalent of ORIG_BINFO in the inheritance    graph of T. Both BINFO and ORIG_BINFO will have the same BINFO_TYPE,    but are not necessarily the same in terms of layout.  */
end_comment

begin_function
specifier|static
name|void
name|accumulate_vtbl_inits
parameter_list|(
name|binfo
parameter_list|,
name|orig_binfo
parameter_list|,
name|rtti_binfo
parameter_list|,
name|t
parameter_list|,
name|inits
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|orig_binfo
decl_stmt|;
name|tree
name|rtti_binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|inits
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|ctor_vtbl_p
init|=
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|orig_binfo
argument_list|)
argument_list|)
argument_list|,
literal|20000517
argument_list|)
expr_stmt|;
comment|/* If it doesn't have a vptr, we don't do anything. */
if|if
condition|(
operator|!
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If we're building a construction vtable, we're not interested in      subobjects that don't require construction vtables.  */
if|if
condition|(
name|ctor_vtbl_p
operator|&&
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|!
name|binfo_via_virtual
argument_list|(
name|orig_binfo
argument_list|,
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Build the initializers for the BINFO-in-T vtable.  */
name|TREE_VALUE
argument_list|(
name|inits
argument_list|)
operator|=
name|chainon
argument_list|(
name|TREE_VALUE
argument_list|(
name|inits
argument_list|)
argument_list|,
name|dfs_accumulate_vtbl_inits
argument_list|(
name|binfo
argument_list|,
name|orig_binfo
argument_list|,
name|rtti_binfo
argument_list|,
name|t
argument_list|,
name|inits
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk the BINFO and its bases.  We walk in preorder so that as we      initialize each vtable we can figure out at what offset the      secondary vtable lies from the primary vtable.  We can't use      dfs_walk here because we need to iterate through bases of BINFO      and RTTI_BINFO simultaneously.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Skip virtual bases.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|accumulate_vtbl_inits
argument_list|(
name|base_binfo
argument_list|,
name|BINFO_BASETYPE
argument_list|(
name|orig_binfo
argument_list|,
name|i
argument_list|)
argument_list|,
name|rtti_binfo
argument_list|,
name|t
argument_list|,
name|inits
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from accumulate_vtbl_inits.  Returns the initializers for    the BINFO vtable.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accumulate_vtbl_inits
parameter_list|(
name|binfo
parameter_list|,
name|orig_binfo
parameter_list|,
name|rtti_binfo
parameter_list|,
name|t
parameter_list|,
name|l
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|orig_binfo
decl_stmt|;
name|tree
name|rtti_binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|l
decl_stmt|;
block|{
name|tree
name|inits
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vtbl
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|ctor_vtbl_p
init|=
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctor_vtbl_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|orig_binfo
argument_list|)
operator|&&
name|BINFO_PRIMARY_P
argument_list|(
name|orig_binfo
argument_list|)
condition|)
block|{
comment|/* In the hierarchy of BINFO_TYPE (RTTI_BINFO), this is a 	 primary virtual base.  If it is not the same primary in 	 the hierarchy of T, we'll need to generate a ctor vtable 	 for it, to place at its location in T.  If it is the same 	 primary, we still need a VTT entry for the vtable, but it 	 should point to the ctor vtable for the base it is a 	 primary for within the sub-hierarchy of RTTI_BINFO. 	       	 There are three possible cases: 	       	 1) We are in the same place. 	 2) We are a primary base within a lost primary virtual base of 	 RTTI_BINFO. 	 3) We are primary to something not a base of RTTI_BINFO.  */
name|tree
name|b
init|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|;
comment|/* First, look through the bases we are primary to for RTTI_BINFO 	 or a virtual base.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|b
argument_list|)
control|)
block|{
name|last
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
operator|||
name|b
operator|==
name|rtti_binfo
condition|)
break|break;
block|}
comment|/* If we run out of primary links, keep looking down our 	 inheritance chain; we might be an indirect primary.  */
if|if
condition|(
name|b
operator|==
name|NULL_TREE
condition|)
for|for
control|(
name|b
operator|=
name|last
init|;
name|b
condition|;
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
operator|||
name|b
operator|==
name|rtti_binfo
condition|)
break|break;
comment|/* If we found RTTI_BINFO, this is case 1.  If we found a virtual 	 base B and it is a base of RTTI_BINFO, this is case 2.  In 	 either case, we share our vtable with LAST, i.e. the 	 derived-most base within B of which we are a primary.  */
if|if
condition|(
name|b
operator|==
name|rtti_binfo
operator|||
operator|(
name|b
operator|&&
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* Just set our BINFO_VTABLE to point to LAST, as we may not have 	   set LAST's BINFO_VTABLE yet.  We'll extract the actual vptr in 	   binfo_ctor_vtable after everything's been set up.  */
name|vtbl
operator|=
name|last
expr_stmt|;
comment|/* Otherwise, this is case 3 and we get our own.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|orig_binfo
argument_list|,
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|)
condition|)
return|return
name|inits
return|;
if|if
condition|(
operator|!
name|vtbl
condition|)
block|{
name|tree
name|index
decl_stmt|;
name|int
name|non_fn_entries
decl_stmt|;
comment|/* Compute the initializer for this vtable.  */
name|inits
operator|=
name|build_vtbl_initializer
argument_list|(
name|binfo
argument_list|,
name|orig_binfo
argument_list|,
name|t
argument_list|,
name|rtti_binfo
argument_list|,
operator|&
name|non_fn_entries
argument_list|)
expr_stmt|;
comment|/* Figure out the position to which the VPTR should point.  */
name|vtbl
operator|=
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtbl_ptr_type_node
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_int
argument_list|(
name|non_fn_entries
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|list_length
argument_list|(
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|vtbl
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ctor_vtbl_p
condition|)
comment|/* For a construction vtable, we can't overwrite BINFO_VTABLE.        So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will        straighten this out.  */
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|rtti_binfo
argument_list|,
name|vtbl
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|inits
operator|=
name|NULL_TREE
expr_stmt|;
else|else
comment|/* For an ordinary vtable, set BINFO_VTABLE.  */
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|vtbl
expr_stmt|;
return|return
name|inits
return|;
block|}
end_function

begin_comment
comment|/* Construct the initializer for BINFO's virtual function table.  BINFO    is part of the hierarchy dominated by T.  If we're building a    construction vtable, the ORIG_BINFO is the binfo we should use to    find the actual function pointers to put in the vtable - but they    can be overridden on the path to most-derived in the graph that    ORIG_BINFO belongs.  Otherwise,    ORIG_BINFO should be the same as BINFO.  The RTTI_BINFO is the    BINFO that should be indicated by the RTTI information in the    vtable; it will be a base class of T, rather than T itself, if we    are building a construction vtable.     The value returned is a TREE_LIST suitable for wrapping in a    CONSTRUCTOR to use as the DECL_INITIAL for a vtable.  If    NON_FN_ENTRIES_P is not NULL, *NON_FN_ENTRIES_P is set to the    number of non-function entries in the vtable.       It might seem that this function should never be called with a    BINFO for which BINFO_PRIMARY_P holds, the vtable for such a    base is always subsumed by a derived class vtable.  However, when    we are building construction vtables, we do build vtables for    primary bases; we need these while the primary base is being    constructed.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtbl_initializer
parameter_list|(
name|binfo
parameter_list|,
name|orig_binfo
parameter_list|,
name|t
parameter_list|,
name|rtti_binfo
parameter_list|,
name|non_fn_entries_p
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|orig_binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|rtti_binfo
decl_stmt|;
name|int
modifier|*
name|non_fn_entries_p
decl_stmt|;
block|{
name|tree
name|v
decl_stmt|,
name|b
decl_stmt|;
name|tree
name|vfun_inits
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
name|vtbl_init_data
name|vid
decl_stmt|;
comment|/* Initialize VID.  */
name|memset
argument_list|(
operator|&
name|vid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vid
argument_list|)
argument_list|)
expr_stmt|;
name|vid
operator|.
name|binfo
operator|=
name|binfo
expr_stmt|;
name|vid
operator|.
name|derived
operator|=
name|t
expr_stmt|;
name|vid
operator|.
name|rtti_binfo
operator|=
name|rtti_binfo
expr_stmt|;
name|vid
operator|.
name|last_init
operator|=
operator|&
name|vid
operator|.
name|inits
expr_stmt|;
name|vid
operator|.
name|primary_vtbl_p
operator|=
operator|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|vid
operator|.
name|ctor_vtbl_p
operator|=
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* The first vbase or vcall offset is at index -3 in the vtable.  */
name|vid
operator|.
name|index
operator|=
name|ssize_int
argument_list|(
operator|-
literal|3
argument_list|)
expr_stmt|;
comment|/* Add entries to the vtable for RTTI.  */
name|build_rtti_vtbl_entries
argument_list|(
name|binfo
argument_list|,
operator|&
name|vid
argument_list|)
expr_stmt|;
comment|/* Create an array for keeping track of the functions we've      processed.  When we see multiple functions with the same      signature, we share the vcall offsets.  */
name|VARRAY_TREE_INIT
argument_list|(
name|vid
operator|.
name|fns
argument_list|,
literal|32
argument_list|,
literal|"fns"
argument_list|)
expr_stmt|;
comment|/* Add the vcall and vbase offset entries.  */
name|build_vcall_and_vbase_vtbl_entries
argument_list|(
name|binfo
argument_list|,
operator|&
name|vid
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|VARRAY_FREE
argument_list|(
name|vid
operator|.
name|fns
argument_list|)
expr_stmt|;
comment|/* Clear BINFO_VTABLE_PATH_MARKED; it's set by      build_vbase_offset_vtbl_entries.  */
for|for
control|(
name|vbase
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_fn_entries_p
condition|)
operator|*
name|non_fn_entries_p
operator|=
name|list_length
argument_list|(
name|vid
operator|.
name|inits
argument_list|)
expr_stmt|;
comment|/* Go through all the ordinary virtual functions, building up      initializers.  */
name|vfun_inits
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|v
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|orig_binfo
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|vcall_index
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
name|fn
operator|=
name|BV_FN
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* If the only definition of this function signature along our 	 primary base chain is from a lost primary, this vtable slot will 	 never be used, so just zero it out.  This is important to avoid 	 requiring extra thunks which cannot be generated with the function.  	 We first check this in update_vtable_entry_for_fn, so we handle 	 restored primary bases properly; we also need to do it here so we 	 zero out unused slots in ctor vtables, rather than filling themff 	 with erroneous values (though harmless, apart from relocation 	 costs).  */
for|for
control|(
name|b
operator|=
name|binfo
init|;
condition|;
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
control|)
block|{
comment|/* We found a defn before a lost primary; go ahead as normal.  */
if|if
condition|(
name|look_for_overrides_here
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
break|break;
comment|/* The nearest definition is from a lost primary; clear the 	     slot.  */
if|if
condition|(
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|init
operator|=
name|size_zero_node
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|init
condition|)
block|{
comment|/* Pull the offset for `this', and the function to call, out of 	     the list.  */
name|delta
operator|=
name|BV_DELTA
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|BV_USE_VCALL_INDEX_P
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|vcall_index
operator|=
name|BV_VCALL_INDEX
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|vcall_index
operator|!=
name|NULL_TREE
argument_list|,
literal|20000621
argument_list|)
expr_stmt|;
block|}
else|else
name|vcall_index
operator|=
name|NULL_TREE
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|delta
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
literal|19990727
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|19990727
argument_list|)
expr_stmt|;
comment|/* You can't call an abstract virtual function; it's abstract. 	     So, we replace these functions with __pure_virtual.  */
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|abort_fndecl
expr_stmt|;
comment|/* Take the address of the function, considering it to be of an 	     appropriate generic type.  */
name|pfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* The address of a function can't change.  */
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Enter it in the vtable.  */
name|init
operator|=
name|build_vtable_entry
argument_list|(
name|delta
argument_list|,
name|vcall_index
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
comment|/* And add it to the chain of initializers.  */
if|if
condition|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|size_zero_node
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|;
operator|++
name|i
control|)
name|vfun_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|vfun_inits
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|fdesc
init|=
name|build
argument_list|(
name|FDESC_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|fdesc
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfun_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fdesc
argument_list|,
name|vfun_inits
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|vfun_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|vfun_inits
argument_list|)
expr_stmt|;
block|}
comment|/* The initializers for virtual functions were built up in reverse      order; straighten them out now.  */
name|vfun_inits
operator|=
name|nreverse
argument_list|(
name|vfun_inits
argument_list|)
expr_stmt|;
comment|/* The negative offset initializers are also in reverse order.  */
name|vid
operator|.
name|inits
operator|=
name|nreverse
argument_list|(
name|vid
operator|.
name|inits
argument_list|)
expr_stmt|;
comment|/* Chain the two together.  */
return|return
name|chainon
argument_list|(
name|vid
operator|.
name|inits
argument_list|,
name|vfun_inits
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Adds to vid->inits the initializers for the vbase and vcall    offsets in BINFO, which is in the hierarchy dominated by T.  */
end_comment

begin_function
specifier|static
name|void
name|build_vcall_and_vbase_vtbl_entries
parameter_list|(
name|binfo
parameter_list|,
name|vid
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|vtbl_init_data
modifier|*
name|vid
decl_stmt|;
block|{
name|tree
name|b
decl_stmt|;
comment|/* If this is a derived class, we must first create entries      corresponding to the primary base class.  */
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|build_vcall_and_vbase_vtbl_entries
argument_list|(
name|b
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Add the vbase entries for this base.  */
name|build_vbase_offset_vtbl_entries
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Add the vcall entries for this base.  */
name|build_vcall_offset_vtbl_entries
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the initializers for the vbase offset entries in the vtable    for BINFO (which is part of the class hierarchy dominated by T), in    reverse order.  VBASE_OFFSET_INDEX gives the vtable index    where the next vbase offset will go.  */
end_comment

begin_function
specifier|static
name|void
name|build_vbase_offset_vtbl_entries
parameter_list|(
name|binfo
parameter_list|,
name|vid
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|vtbl_init_data
modifier|*
name|vid
decl_stmt|;
block|{
name|tree
name|vbase
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|non_primary_binfo
decl_stmt|;
comment|/* If there are no virtual baseclasses, then there is nothing to      do.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return;
name|t
operator|=
name|vid
operator|->
name|derived
expr_stmt|;
comment|/* We might be a primary base class.  Go up the inheritance hierarchy      until we find the most derived class of which we are a primary base:      it is the offset of that which we need to use.  */
name|non_primary_binfo
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
name|tree
name|b
decl_stmt|;
comment|/* If we have reached a virtual base, then it must be a primary 	 base (possibly multi-level) of vid->binfo, or we wouldn't 	 have called build_vcall_and_vbase_vtbl_entries for it.  But it 	 might be a lost primary, so just skip down to vid->binfo.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
name|non_primary_binfo
operator|=
name|vid
operator|->
name|binfo
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
operator|!=
name|non_primary_binfo
condition|)
break|break;
name|non_primary_binfo
operator|=
name|b
expr_stmt|;
block|}
comment|/* Go through the virtual bases, adding the offsets.  */
for|for
control|(
name|vbase
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
name|tree
name|b
decl_stmt|;
name|tree
name|delta
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|)
continue|continue;
comment|/* Find the instance of this virtual base in the complete 	 object.  */
name|b
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we've already got an offset for this virtual base, we 	 don't need another one.  */
if|if
condition|(
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Figure out where we can find this vbase offset.  */
name|delta
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|vid
operator|->
name|index
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vid
operator|->
name|primary_vtbl_p
condition|)
name|BINFO_VPTR_FIELD
argument_list|(
name|b
argument_list|)
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|binfo
operator|!=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|orig_vbase
decl_stmt|;
comment|/* Find the instance of this virtual base in the type of BINFO.  */
name|orig_vbase
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The vbase offset had better be the same.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|delta
argument_list|,
name|BINFO_VPTR_FIELD
argument_list|(
name|orig_vbase
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* The next vbase will come at a more negative offset.  */
name|vid
operator|->
name|index
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|vid
operator|->
name|index
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The initializer is the delta from BINFO to this virtual base. 	 The vbase offsets go in reverse inheritance-graph order, and 	 we are walking in inheritance graph order so these end up in 	 the right order.  */
name|delta
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|b
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|non_primary_binfo
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|delta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adds the initializers for the vcall offset entries in the vtable    for BINFO (which is part of the class hierarchy dominated by VID->DERIVED)    to VID->INITS.  */
end_comment

begin_function
specifier|static
name|void
name|build_vcall_offset_vtbl_entries
parameter_list|(
name|binfo
parameter_list|,
name|vid
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|vtbl_init_data
modifier|*
name|vid
decl_stmt|;
block|{
comment|/* We only need these entries if this base is a virtual base.  */
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return;
comment|/* We need a vcall offset for each of the virtual functions in this      vtable.  For example:         class A { virtual void f (); };        class B1 : virtual public A { virtual void f (); };        class B2 : virtual public A { virtual void f (); };        class C: public B1, public B2 { virtual void f (); };       A C object has a primary base of B1, which has a primary base of A.  A      C also has a secondary base of B2, which no longer has a primary base      of A.  So the B2-in-C construction vtable needs a secondary vtable for      A, which will adjust the A* to a B2* to call f.  We have no way of      knowing what (or even whether) this offset will be when we define B2,      so we store this "vcall offset" in the A sub-vtable and look it up in      a "virtual thunk" for B2::f.       We need entries for all the functions in our primary vtable and      in our non-virtual bases' secondary vtables.  */
name|vid
operator|->
name|vbase
operator|=
name|binfo
expr_stmt|;
comment|/* Now, walk through the non-virtual bases, adding vcall offsets.  */
name|add_vcall_offset_vtbl_entries_r
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build vcall offsets, starting with those for BINFO.  */
end_comment

begin_function
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_r
parameter_list|(
name|binfo
parameter_list|,
name|vid
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|vtbl_init_data
modifier|*
name|vid
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|primary_binfo
decl_stmt|;
comment|/* Don't walk into virtual bases -- except, of course, for the      virtual base for which we are building vcall offsets.  Any      primary virtual base will have already had its offsets generated      through the recursion in build_vcall_and_vbase_vtbl_entries.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|vid
operator|->
name|vbase
operator|!=
name|binfo
condition|)
return|return;
comment|/* If BINFO has a primary base, process it first.  */
name|primary_binfo
operator|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary_binfo
condition|)
name|add_vcall_offset_vtbl_entries_r
argument_list|(
name|primary_binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Add BINFO itself to the list.  */
name|add_vcall_offset_vtbl_entries_1
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Scan the non-primary bases of BINFO.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
operator|!=
name|primary_binfo
condition|)
name|add_vcall_offset_vtbl_entries_r
argument_list|(
name|base_binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from build_vcall_offset_vtbl_entries_r.  */
end_comment

begin_function
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_1
parameter_list|(
name|binfo
parameter_list|,
name|vid
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|vtbl_init_data
modifier|*
name|vid
decl_stmt|;
block|{
name|tree
name|derived_virtuals
decl_stmt|;
name|tree
name|base_virtuals
decl_stmt|;
name|tree
name|orig_virtuals
decl_stmt|;
name|tree
name|binfo_inits
decl_stmt|;
comment|/* If BINFO is a primary base, the most derived class which has BINFO as      a primary base; otherwise, just BINFO.  */
name|tree
name|non_primary_binfo
decl_stmt|;
name|binfo_inits
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We might be a primary base class.  Go up the inheritance hierarchy      until we find the most derived class of which we are a primary base:      it is the BINFO_VIRTUALS there that we need to consider.  */
name|non_primary_binfo
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
name|tree
name|b
decl_stmt|;
comment|/* If we have reached a virtual base, then it must be vid->vbase, 	 because we ignore other virtual bases in 	 add_vcall_offset_vtbl_entries_r.  In turn, it must be a primary 	 base (possibly multi-level) of vid->binfo, or we wouldn't 	 have called build_vcall_and_vbase_vtbl_entries for it.  But it 	 might be a lost primary, so just skip down to vid->binfo.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|non_primary_binfo
operator|!=
name|vid
operator|->
name|vbase
condition|)
name|abort
argument_list|()
expr_stmt|;
name|non_primary_binfo
operator|=
name|vid
operator|->
name|binfo
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
operator|!=
name|non_primary_binfo
condition|)
break|break;
name|non_primary_binfo
operator|=
name|b
expr_stmt|;
block|}
if|if
condition|(
name|vid
operator|->
name|ctor_vtbl_p
condition|)
comment|/* For a ctor vtable we need the equivalent binfo within the hierarchy        where rtti_binfo is the most derived type.  */
name|non_primary_binfo
operator|=
name|get_original_base
argument_list|(
name|non_primary_binfo
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vid
operator|->
name|rtti_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make entries for the rest of the virtuals.  */
for|for
control|(
name|base_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|,
name|derived_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|non_primary_binfo
argument_list|)
operator|,
name|orig_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
init|;
name|base_virtuals
condition|;
name|base_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|base_virtuals
argument_list|)
operator|,
name|derived_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|derived_virtuals
argument_list|)
operator|,
name|orig_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_virtuals
argument_list|)
control|)
block|{
name|tree
name|orig_fn
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|vcall_offset
decl_stmt|;
comment|/* Find the declaration that originally caused this function to 	 be present in BINFO_TYPE (binfo).  */
name|orig_fn
operator|=
name|BV_FN
argument_list|(
name|orig_virtuals
argument_list|)
expr_stmt|;
comment|/* When processing BINFO, we only want to generate vcall slots for 	 function slots introduced in BINFO.  So don't try to generate 	 one if the function isn't even defined in BINFO.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|orig_fn
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Find the overriding function.  */
name|fn
operator|=
name|BV_FN
argument_list|(
name|derived_virtuals
argument_list|)
expr_stmt|;
comment|/* If there is already an entry for a function with the same 	 signature as FN, then we do not need a second vcall offset. 	 Check the list of functions already present in the derived 	 class vtable.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|vid
operator|->
name|fns
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|derived_entry
decl_stmt|;
name|derived_entry
operator|=
name|VARRAY_TREE
argument_list|(
name|vid
operator|->
name|fns
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_signature_p
argument_list|(
name|BV_FN
argument_list|(
name|derived_entry
argument_list|)
argument_list|,
name|fn
argument_list|)
comment|/* We only use one vcall offset for virtual destructors, 		 even though there are two virtual table entries.  */
operator|||
operator|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|BV_FN
argument_list|(
name|derived_entry
argument_list|)
argument_list|)
operator|&&
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|vid
operator|->
name|ctor_vtbl_p
condition|)
name|BV_VCALL_INDEX
argument_list|(
name|derived_virtuals
argument_list|)
operator|=
name|BV_VCALL_INDEX
argument_list|(
name|derived_entry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|!=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|vid
operator|->
name|fns
argument_list|)
condition|)
continue|continue;
comment|/* The FN comes from BASE.  So, we must calculate the adjustment from 	 vid->vbase to BASE.  We can just look for BASE in the complete 	 object because we are converting from a virtual base, so if there 	 were multiple copies, there would not be a unique final overrider 	 and vid->derived would be ill-formed.  */
name|base
operator|=
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|base_binfo
operator|=
name|lookup_base
argument_list|(
name|vid
operator|->
name|derived
argument_list|,
name|base
argument_list|,
name|ba_any
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Compute the vcall offset.  */
comment|/* As mentioned above, the vbase we're working on is a primary base of 	 vid->binfo.  But it might be a lost primary, so its BINFO_OFFSET          might be wrong, so we just use the BINFO_OFFSET from vid->binfo.  */
name|vcall_offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|vid
operator|->
name|binfo
argument_list|)
expr_stmt|;
name|vcall_offset
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|vcall_offset
argument_list|)
expr_stmt|;
name|vcall_offset
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|vcall_offset
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|vcall_offset
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
comment|/* Keep track of the vtable index where this vcall offset can be 	 found.  For a construction vtable, we already made this 	 annotation when we built the original vtable.  */
if|if
condition|(
operator|!
name|vid
operator|->
name|ctor_vtbl_p
condition|)
name|BV_VCALL_INDEX
argument_list|(
name|derived_virtuals
argument_list|)
operator|=
name|vid
operator|->
name|index
expr_stmt|;
comment|/* The next vcall offset will be found at a more negative 	 offset.  */
name|vid
operator|->
name|index
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|vid
operator|->
name|index
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep track of this function.  */
name|VARRAY_PUSH_TREE
argument_list|(
name|vid
operator|->
name|fns
argument_list|,
name|derived_virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return vtbl initializers for the RTTI entries coresponding to the    BINFO's vtable.  The RTTI entries should indicate the object given    by VID->rtti_binfo.  */
end_comment

begin_function
specifier|static
name|void
name|build_rtti_vtbl_entries
parameter_list|(
name|binfo
parameter_list|,
name|vid
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|vtbl_init_data
modifier|*
name|vid
decl_stmt|;
block|{
name|tree
name|b
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|t
operator|=
name|BINFO_TYPE
argument_list|(
name|vid
operator|->
name|rtti_binfo
argument_list|)
expr_stmt|;
comment|/* To find the complete object, we will first convert to our most      primary base, and then add the offset in the vtbl to that value.  */
name|b
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|)
operator|&&
operator|!
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|tree
name|primary_base
decl_stmt|;
name|primary_base
operator|=
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|primary_base
argument_list|)
operator|==
name|b
argument_list|,
literal|20010127
argument_list|)
expr_stmt|;
name|b
operator|=
name|primary_base
expr_stmt|;
block|}
name|offset
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|vid
operator|->
name|rtti_binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The second entry is the address of the typeinfo object.  */
if|if
condition|(
name|flag_rtti
condition|)
name|decl
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_tinfo_decl
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Convert the declaration to a type that can be stored in the      vtable.  */
name|init
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
comment|/* Add the offset-to-top entry.  It comes earlier in the vtable that      the the typeinfo entry.  Convert the offset to look like a      function pointer, so that we can put it in the vtable.  */
name|init
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build an entry in the virtual function table.  DELTA is the offset    for the `this' pointer.  VCALL_INDEX is the vtable index containing    the vcall offset; NULL_TREE if none.  ENTRY is the virtual function    table entry itself.  It's TREE_TYPE must be VFUNC_PTR_TYPE_NODE,    but it may not actually be a virtual function table pointer.  (For    example, it might be the address of the RTTI object, under the new    ABI.)  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable_entry
parameter_list|(
name|delta
parameter_list|,
name|vcall_index
parameter_list|,
name|entry
parameter_list|)
name|tree
name|delta
decl_stmt|;
name|tree
name|vcall_index
decl_stmt|;
name|tree
name|entry
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|integer_zerop
argument_list|(
name|delta
argument_list|)
operator|||
name|vcall_index
operator|!=
name|NULL_TREE
operator|)
operator|&&
name|fn
operator|!=
name|abort_fndecl
condition|)
block|{
name|entry
operator|=
name|make_thunk
argument_list|(
name|entry
argument_list|,
name|delta
argument_list|,
name|vcall_index
argument_list|)
expr_stmt|;
name|entry
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|entry
return|;
block|}
end_function

end_unit

