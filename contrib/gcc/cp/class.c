begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to building classes and their related objects.    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005      Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_comment
comment|/* The number of nested classes being processed.  If we are not in the    scope of any class, this is zero.  */
end_comment

begin_decl_stmt
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In order to deal with nested classes, we keep a stack of classes.    The topmost entry is the innermost class, and is the entry at index    CURRENT_CLASS_DEPTH  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|class_stack_node
block|{
comment|/* The name of the class.  */
name|tree
name|name
decl_stmt|;
comment|/* The _TYPE node for the class.  */
name|tree
name|type
decl_stmt|;
comment|/* The access specifier pending for new declarations in the scope of      this class.  */
name|tree
name|access
decl_stmt|;
comment|/* If were defining TYPE, the names used in this class.  */
name|splay_tree
name|names_used
decl_stmt|;
block|}
typedef|*
name|class_stack_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|vtbl_init_data_s
block|{
comment|/* The base for which we're building initializers.  */
name|tree
name|binfo
decl_stmt|;
comment|/* The type of the most-derived type.  */
name|tree
name|derived
decl_stmt|;
comment|/* The binfo for the dynamic type. This will be TYPE_BINFO (derived),      unless ctor_vtbl_p is true.  */
name|tree
name|rtti_binfo
decl_stmt|;
comment|/* The negative-index vtable initializers built up so far.  These      are in order from least negative index to most negative index.  */
name|tree
name|inits
decl_stmt|;
comment|/* The last (i.e., most negative) entry in INITS.  */
name|tree
modifier|*
name|last_init
decl_stmt|;
comment|/* The binfo for the virtual base for which we're building      vcall offset initializers.  */
name|tree
name|vbase
decl_stmt|;
comment|/* The functions in vbase for which we have already provided vcall      offsets.  */
name|varray_type
name|fns
decl_stmt|;
comment|/* The vtable index of the next vcall or vbase offset.  */
name|tree
name|index
decl_stmt|;
comment|/* Nonzero if we are building the initializer for the primary      vtable.  */
name|int
name|primary_vtbl_p
decl_stmt|;
comment|/* Nonzero if we are building the initializer for a construction      vtable.  */
name|int
name|ctor_vtbl_p
decl_stmt|;
comment|/* True when adding vcall offset entries to the vtable.  False when      merely computing the indices.  */
name|bool
name|generate_vcall_entries
decl_stmt|;
block|}
name|vtbl_init_data
typedef|;
end_typedef

begin_comment
comment|/* The type of a function passed to walk_subobject_offsets.  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|subobject_offset_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* The stack itself.  This is a dynamically resized array.  The    number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_class_stack_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|class_stack_node_t
name|current_class_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of all local classes present in this translation unit, in    declaration order.  */
end_comment

begin_decl_stmt
name|varray_type
name|local_classes
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_struct_anon
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_basefndecls
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|build_primary_vtable
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|build_secondary_vtable
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_vtbls
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alter_access
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_using_decl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_for_override
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_modify_vtables
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|modify_all_vtables
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|determine_primary_base
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_struct_methods
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_warn_about_overly_private_class
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|method_name_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resort_method_name_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_implicitly_declared_members
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fixed_type_or_null
parameter_list|(
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|resolve_address_of_overloaded_function
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|bool
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_vtbl_ref_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_vtbl_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_fields
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_fields_to_record_type
parameter_list|(
name|tree
parameter_list|,
name|struct
name|sorted_fields_type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_bitfield_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_field_decl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_field_decls
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
modifier|*
name|build_base_field
parameter_list|(
name|record_layout_info
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_base_fields
parameter_list|(
name|record_layout_info
parameter_list|,
name|splay_tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_methods
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_zero_width_bit_fields
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_bases
parameter_list|(
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_bases_and_members
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|create_vtable_ptr
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|include_empty_classes
parameter_list|(
name|record_layout_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_class_type
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_pending_inline
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_inline_methods
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_primary_base
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_binfo_offsets
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_virtual_bases
parameter_list|(
name|record_layout_info
parameter_list|,
name|splay_tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_vbase_offset_vtbl_entries
parameter_list|(
name|tree
parameter_list|,
name|vtbl_init_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_r
parameter_list|(
name|tree
parameter_list|,
name|vtbl_init_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_1
parameter_list|(
name|tree
parameter_list|,
name|vtbl_init_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_vcall_offset_vtbl_entries
parameter_list|(
name|tree
parameter_list|,
name|vtbl_init_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_vcall_offset
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|vtbl_init_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_vtable_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_find_final_overrider
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_find_final_overrider_post
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_find_final_overrider_q
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_final_overrider
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|make_new_vtable
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|maybe_indent_hierarchy
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dump_class_hierarchy_r
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_class_hierarchy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_class_hierarchy_1
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_array
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_vtable
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_vtt
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_vtable
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_array
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_nonempty_base_or_field
parameter_list|(
name|record_layout_info
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|end_of_class
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|layout_empty_base
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|accumulate_vtbl_inits
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_accumulate_vtbl_inits
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_rtti_vtbl_entries
parameter_list|(
name|tree
parameter_list|,
name|vtbl_init_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_vcall_and_vbase_vtbl_entries
parameter_list|(
name|tree
parameter_list|,
name|vtbl_init_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_primary_bases
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clone_constructors_and_destructors
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_clone
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_vtable_entry_for_fn
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_virtuals
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_ctor_vtbl_group
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_vtt
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|binfo_ctor_vtable
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
modifier|*
name|build_vtt_inits
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_build_secondary_vptr_vtt_inits
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_ctor_vtable_bases_queue_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_fixup_binfo_vtbls
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|record_subobject_offset
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_subobject_offset
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|walk_subobject_offsets
parameter_list|(
name|tree
parameter_list|,
name|subobject_offset_fn
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_subobject_offsets
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|layout_conflict_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|splay_tree_compare_integer_csts
parameter_list|(
name|splay_tree_key
name|k1
parameter_list|,
name|splay_tree_key
name|k2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_about_ambiguous_bases
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|type_requires_array_cookie
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|contains_empty_class_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|base_derived_from
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|empty_base_at_nonzero_offset_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|splay_tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|end_of_base
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_vcall_index
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Macros for dfs walking during vtt construction. See    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits    and dfs_fixup_binfo_vtbls.  */
end_comment

begin_define
define|#
directive|define
name|VTT_TOP_LEVEL_P
parameter_list|(
name|NODE
parameter_list|)
value|TREE_UNSIGNED (NODE)
end_define

begin_define
define|#
directive|define
name|VTT_MARKED_BINFO_P
parameter_list|(
name|NODE
parameter_list|)
value|TREE_USED (NODE)
end_define

begin_comment
comment|/* Variables shared between class.c and call.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|n_vtables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_searches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_elems
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_convert_harshness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_compute_conversion_costs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_inner_fields_searched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert to or from a base subobject.  EXPR is an expression of type    `A' or `A*', an expression of type `B' or `B*' is returned.  To    convert A to a base B, CODE is PLUS_EXPR and BINFO is the binfo for    the B base instance within A.  To convert base A to derived B, CODE    is MINUS_EXPR and BINFO is the binfo for the A instance within B.    In this latter case, A must not be a morally virtual base of B.    NONNULL is true if EXPR is known to be non-NULL (this is only    needed when EXPR is of pointer type).  CV qualifiers are preserved    from EXPR.  */
end_comment

begin_function
name|tree
name|build_base_path
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|int
name|nonnull
parameter_list|)
block|{
name|tree
name|v_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|d_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|probe
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|target_type
decl_stmt|;
name|tree
name|null_test
init|=
name|NULL
decl_stmt|;
name|tree
name|ptr_target_type
decl_stmt|;
name|int
name|fixed_type_p
decl_stmt|;
name|int
name|want_pointer
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
operator|||
name|binfo
operator|==
name|error_mark_node
operator|||
operator|!
name|binfo
condition|)
return|return
name|error_mark_node
return|;
for|for
control|(
name|probe
operator|=
name|binfo
init|;
name|probe
condition|;
name|probe
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
name|d_binfo
operator|=
name|probe
expr_stmt|;
if|if
condition|(
operator|!
name|v_binfo
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|probe
argument_list|)
condition|)
name|v_binfo
operator|=
name|probe
expr_stmt|;
block|}
name|probe
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_pointer
condition|)
name|probe
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|probe
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|probe
argument_list|)
else|:
name|code
operator|==
name|PLUS_EXPR
condition|?
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|d_binfo
argument_list|)
argument_list|,
name|probe
argument_list|)
else|:
name|false
argument_list|,
literal|20010723
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|v_binfo
condition|)
block|{
name|error
argument_list|(
literal|"cannot convert from base `%T' to derived type `%T' via virtual base `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|d_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|v_binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|want_pointer
condition|)
comment|/* This must happen before the call to save_expr.  */
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixed_type_p
operator|=
name|resolves_to_fixed_type_p
argument_list|(
name|expr
argument_list|,
operator|&
name|nonnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixed_type_p
operator|<=
literal|0
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_pointer
operator|&&
operator|!
name|nonnull
condition|)
name|null_test
operator|=
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_binfo
operator|&&
name|fixed_type_p
operator|<=
literal|0
condition|)
block|{
comment|/* Going via virtual base V_BINFO.  We need the static offset          from V_BINFO to BINFO, and the dynamic offset from D_BINFO to          V_BINFO.  That offset is an entry in D_BINFO's vtable.  */
name|tree
name|v_offset
decl_stmt|;
if|if
condition|(
name|fixed_type_p
operator|<
literal|0
operator|&&
name|in_base_initializer
condition|)
block|{
comment|/* In a base member initializer, we cannot rely on 	     the vtable being set up. We have to use the vtt_parm.  */
name|tree
name|derived
init|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|v_binfo
argument_list|)
decl_stmt|;
name|v_offset
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_vtt_parm
argument_list|)
argument_list|,
name|current_vtt_parm
argument_list|,
name|BINFO_VPTR_INDEX
argument_list|(
name|derived
argument_list|)
argument_list|)
expr_stmt|;
name|v_offset
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|derived
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|v_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|v_offset
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|v_offset
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|v_offset
argument_list|)
argument_list|,
name|v_offset
argument_list|,
name|BINFO_VPTR_FIELD
argument_list|(
name|v_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|v_offset
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|ptrdiff_type_node
argument_list|)
argument_list|,
name|v_offset
argument_list|)
expr_stmt|;
name|v_offset
operator|=
name|build_indirect_ref
argument_list|(
name|v_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|=
name|convert_to_integer
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|size_diffop
argument_list|(
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|v_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|v_offset
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|v_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixed_type_p
operator|<
literal|0
condition|)
comment|/* Negative fixed_type_p means this is a constructor or destructor; 	   virtual base layout is fixed in in-charge [cd]tors, but not in 	   base [cd]tors.  */
name|offset
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|v_offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|v_offset
expr_stmt|;
block|}
name|target_type
operator|=
name|code
operator|==
name|PLUS_EXPR
condition|?
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
else|:
name|BINFO_TYPE
argument_list|(
name|d_binfo
argument_list|)
expr_stmt|;
name|target_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|target_type
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_target_type
operator|=
name|build_pointer_type
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_pointer
condition|)
name|target_type
operator|=
name|ptr_target_type
expr_stmt|;
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|ptr_target_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|expr
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|ptr_target_type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|null_test
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|want_pointer
condition|)
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|null_test
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|target_type
argument_list|,
name|null_test
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|target_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Convert OBJECT to the base TYPE.  If CHECK_ACCESS is true, an error    message is emitted if TYPE is inaccessible.  OBJECT is assumed to    be non-NULL.  */
end_comment

begin_function
name|tree
name|convert_to_base
parameter_list|(
name|tree
name|object
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|check_access
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|,
name|type
argument_list|,
name|check_access
condition|?
name|ba_check
else|:
name|ba_ignore
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
operator|||
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|object
argument_list|,
name|binfo
argument_list|,
comment|/*nonnull=*/
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* EXPR is an expression with class type.  BASE is a base class (a    BINFO) of that class type.  Returns EXPR, converted to the BASE    type.  This function assumes that EXPR is the most derived class;    therefore virtual bases can be found at their static offsets.  */
end_comment

begin_function
name|tree
name|convert_to_base_statically
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|base
parameter_list|)
block|{
name|tree
name|expr_type
decl_stmt|;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|expr_type
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|pointer_type
decl_stmt|;
name|pointer_type
operator|=
name|build_pointer_type
argument_list|(
name|expr_type
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
comment|/*noconvert=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|pointer_type
argument_list|,
name|expr
argument_list|,
name|build_nop
argument_list|(
name|pointer_type
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_nop
argument_list|(
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields the    vtable element corresponding to INDEX.  There are many special    cases for INSTANCE which we take care of here, mainly to avoid    creating extra tree nodes when we don't have to.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtbl_ref_1
parameter_list|(
name|tree
name|instance
parameter_list|,
name|tree
name|idx
parameter_list|)
block|{
name|tree
name|aref
decl_stmt|;
name|tree
name|vtbl
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Try to figure out what a reference refers to, and      access its virtual function table directly.  */
name|int
name|cdtorp
init|=
literal|0
decl_stmt|;
name|tree
name|fixed_type
init|=
name|fixed_type_or_null
argument_list|(
name|instance
argument_list|,
name|NULL
argument_list|,
operator|&
name|cdtorp
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixed_type
operator|&&
operator|!
name|cdtorp
condition|)
block|{
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|fixed_type
argument_list|,
name|basetype
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
name|vtbl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vtbl
condition|)
name|vtbl
operator|=
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_function
name|tree
name|build_vtbl_ref
parameter_list|(
name|tree
name|instance
parameter_list|,
name|tree
name|idx
parameter_list|)
block|{
name|tree
name|aref
init|=
name|build_vtbl_ref_1
argument_list|(
name|instance
argument_list|,
name|idx
argument_list|)
decl_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields a    function pointer corresponding to vtable element INDEX.  */
end_comment

begin_function
name|tree
name|build_vfn_ref
parameter_list|(
name|tree
name|instance
parameter_list|,
name|tree
name|idx
parameter_list|)
block|{
name|tree
name|aref
init|=
name|build_vtbl_ref_1
argument_list|(
name|instance
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|/* When using function descriptors, the address of the      vtable entry is treated as a function pointer.  */
if|if
condition|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|)
name|aref
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|aref
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|aref
argument_list|,
comment|/*noconvert=*/
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the virtual function table (as an IDENTIFIER_NODE)    for the given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|mangle_vtbl_for_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an IDENTIFIER_NODE for the name of the virtual table table    for TYPE.  */
end_comment

begin_function
name|tree
name|get_vtt_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|mangle_vtt_for_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a VAR_DECL for a primary or secondary vtable for CLASS_TYPE.    (For a secondary vtable for B-in-D, CLASS_TYPE should be D, not B.)    Use NAME for the name of the vtable, and VTABLE_TYPE for its type.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|tree
name|class_type
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|vtable_type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|vtable_type
argument_list|)
expr_stmt|;
comment|/* vtable names are already mangled; give them their DECL_ASSEMBLER_NAME      now to avoid confusion in mangle_decl.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|class_type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TARGET_VTABLE_ENTRY_ALIGN
expr_stmt|;
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* At one time the vtable info was grabbed 2 words at a time.  This      fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|import_export_vtable
argument_list|(
name|decl
argument_list|,
name|class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Get the VAR_DECL of the vtable for TYPE. TYPE need not be polymorphic,    or even complete.  If this does not exist, create it.  If COMPLETE is    nonzero, then complete the definition of it -- that will render it    impossible to actually build the vtable, but is useful to get at those    which are known to exist in the runtime.  */
end_comment

begin_function
name|tree
name|get_vtable_decl
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|complete
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_VTABLES
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|CLASSTYPE_VTABLES
argument_list|(
name|type
argument_list|)
return|;
name|decl
operator|=
name|build_vtable
argument_list|(
name|type
argument_list|,
name|get_vtable_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLES
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|complete
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns a copy of the BINFO_VIRTUALS list in BINFO.  The    BV_VCALL_INDEX for each entry is cleared.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_virtuals
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|copies
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|copies
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|copies
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|BV_VCALL_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|copies
return|;
block|}
end_function

begin_comment
comment|/* Build the primary virtual function table for TYPE.  If BINFO is    non-NULL, build the vtable starting with the initial approximation    that it is the same as the one which is the head of the association    list.  Returns a nonzero value if a new vtable is actually    created.  */
end_comment

begin_function
specifier|static
name|int
name|build_primary_vtable
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|decl
operator|=
name|get_vtable_decl
argument_list|(
name|type
argument_list|,
comment|/*complete=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* We have already created a vtable for this base, so there's 	   no need to do it again.  */
return|return
literal|0
return|;
name|virtuals
operator|=
name|copy_virtuals
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|vtbl_type_node
argument_list|,
literal|20000118
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the association list for this type, based      on our first approximation.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Give BINFO a new virtual function table which is initialized    with a skeleton-copy of its original initialization.  The only    entry that changes is the `delta' entry, so we can really    share a lot of structure.     FOR_TYPE is the most derived type which caused this table to    be needed.     Returns nonzero if we haven't met BINFO before.     The order in which vtables are built (by calling this function) for    an object must remain the same, otherwise a binary incompatibility    can result.  */
end_comment

begin_function
specifier|static
name|int
name|build_secondary_vtable
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* We already created a vtable for this base.  There's no need to        do it again.  */
return|return
literal|0
return|;
comment|/* Remember that we've created a vtable for this BINFO, so that we      don't try to do so again.  */
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Make fresh virtual list, so we can smash it later.  */
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|copy_virtuals
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Secondary vtables are laid out as part of the same structure as      the primary vtable.  */
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create a new vtable for BINFO which is the hierarchy dominated by    T. Return nonzero if we actually created a new vtable.  */
end_comment

begin_function
specifier|static
name|int
name|make_new_vtable
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
comment|/* In this case, it is *type*'s vtable we are modifying.  We start        with the approximation that its vtable is that of the        immediate base class.  */
comment|/* ??? This actually passes TYPE_BINFO (t), not the primary base binfo,        since we've updated DECL_CONTEXT (TYPE_VFIELD (t)) by now.  */
return|return
name|build_primary_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
return|;
else|else
comment|/* This is our very own copy of `basetype' to play with.  Later,        we will fill in all the virtual functions that override the        virtual functions in these base classes which are not defined        by the current type.  */
return|return
name|build_secondary_vtable
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make *VIRTUALS, an entry on the BINFO_VIRTUALS list for BINFO    (which is in the hierarchy dominated by T) list FNDECL as its    BV_FN.  DELTA is the required constant adjustment from the `this'    pointer where the vtable entry appears to the `this' required when    the function is actually called.  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|tree
name|fndecl
parameter_list|,
name|tree
name|delta
parameter_list|,
name|tree
modifier|*
name|virtuals
parameter_list|)
block|{
name|tree
name|v
decl_stmt|;
name|v
operator|=
operator|*
name|virtuals
expr_stmt|;
if|if
condition|(
name|fndecl
operator|!=
name|BV_FN
argument_list|(
name|v
argument_list|)
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|delta
argument_list|,
name|BV_DELTA
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We need a new vtable for BINFO.  */
if|if
condition|(
name|make_new_vtable
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|)
condition|)
block|{
comment|/* If we really did make a new vtable, we also made a copy 	     of the BINFO_VIRTUALS list.  Now, we have to find the 	     corresponding entry in that list.  */
operator|*
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|BV_FN
argument_list|(
operator|*
name|virtuals
argument_list|)
operator|!=
name|BV_FN
argument_list|(
name|v
argument_list|)
condition|)
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
name|v
operator|=
operator|*
name|virtuals
expr_stmt|;
block|}
name|BV_DELTA
argument_list|(
name|v
argument_list|)
operator|=
name|delta
expr_stmt|;
name|BV_VCALL_INDEX
argument_list|(
name|v
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BV_FN
argument_list|(
name|v
argument_list|)
operator|=
name|fndecl
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add method METHOD to class TYPE.  If ERROR_P is true, we are adding    the method after the class has already been defined because a    declaration for it was seen.  (Even though that is erroneous, we    add the method for improved error recovery.)  */
end_comment

begin_function
name|void
name|add_method
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|method
parameter_list|,
name|int
name|error_p
parameter_list|)
block|{
name|int
name|using
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|int
name|template_conv_p
decl_stmt|;
if|if
condition|(
name|method
operator|==
name|error_mark_node
condition|)
return|return;
name|using
operator|=
operator|(
name|DECL_CONTEXT
argument_list|(
name|method
argument_list|)
operator|!=
name|type
operator|)
expr_stmt|;
name|template_conv_p
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|DECL_TEMPLATE_CONV_FN_P
argument_list|(
name|method
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Make a new method vector.  We start with 8 entries.  We must        allocate at least two (for constructors and destructors), and        we're going to end up with an assignment operator at some point        as well.                We could use a TREE_LIST for now, and convert it to a TREE_VEC        in finish_struct, but we would probably waste more memory        making the links in the list than we would by over-allocating        the size of the vector here.  Furthermore, we would complicate        all the code that expects this to be a vector.  */
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* Constructors and destructors go in special slots.  */
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|method
argument_list|)
condition|)
name|slot
operator|=
name|CLASSTYPE_CONSTRUCTOR_SLOT
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|slot
operator|=
name|CLASSTYPE_DESTRUCTOR_SLOT
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
name|DECL_ARTIFICIAL
argument_list|(
name|method
argument_list|)
condition|?
literal|"Java class '%T' cannot have an implicit non-trivial destructor"
else|:
literal|"Java class '%T' cannot have a destructor"
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|have_template_convs_p
init|=
literal|0
decl_stmt|;
comment|/* See if we already have an entry with this name.  */
for|for
control|(
name|slot
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
block|{
name|tree
name|m
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
break|break;
name|m
operator|=
name|OVL_CURRENT
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_conv_p
condition|)
block|{
name|have_template_convs_p
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|m
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|DECL_TEMPLATE_CONV_FN_P
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
comment|/* If we need to move things up, see if there's 		 space.  */
if|if
condition|(
operator|!
name|have_template_convs_p
condition|)
block|{
name|slot
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
condition|)
name|slot
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|m
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|method
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|slot
operator|==
name|len
condition|)
block|{
comment|/* We need a bigger method vector.  */
name|int
name|new_len
decl_stmt|;
name|tree
name|new_vec
decl_stmt|;
comment|/* In the non-error case, we are processing a class 	     definition.  Double the size of the vector to give room 	     for new methods.  */
if|if
condition|(
operator|!
name|error_p
condition|)
name|new_len
operator|=
literal|2
operator|*
name|len
expr_stmt|;
comment|/* In the error case, the vector is already complete.  We 	     don't expect many errors, and the rest of the front-end 	     will get confused if there are empty slots in the vector.  */
else|else
name|new_len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|new_vec
operator|=
name|make_tree_vec
argument_list|(
name|new_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|new_len
expr_stmt|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|new_vec
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
condition|)
block|{
comment|/* Type conversion operators have to come before ordinary 	     methods; add_conversions depends on this to speed up 	     looking for conversion operators.  So, if necessary, we 	     slide some of the vector elements up.  In theory, this 	     makes this algorithm O(N^2) but we don't expect many 	     conversion operators.  */
if|if
condition|(
name|template_conv_p
condition|)
name|slot
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
expr_stmt|;
else|else
for|for
control|(
name|slot
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
comment|/* There are no more entries in the vector, so we 		     can insert the new conversion operator here.  */
break|break;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
comment|/* We can insert the new function right at the 		     SLOTth position.  */
break|break;
block|}
if|if
condition|(
name|template_conv_p
operator|&&
name|have_template_convs_p
condition|)
comment|/*OK*/
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
condition|)
comment|/* There is nothing in the Ith slot, so we can avoid 	       moving anything.  */
empty_stmt|;
else|else
block|{
comment|/* We know the last slot in the vector is empty 		 because we know that at this point there's room 		 for a new function.  */
name|memmove
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
operator|+
literal|1
argument_list|)
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|,
operator|(
name|len
operator|-
name|slot
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* TYPE is a template class.  Don't issue any errors now; wait        until instantiation time to complain.  */
empty_stmt|;
else|else
block|{
name|tree
name|fns
decl_stmt|;
comment|/* Check to see if we've already got this method.  */
for|for
control|(
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|parms1
decl_stmt|;
name|tree
name|parms2
decl_stmt|;
name|bool
name|same
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|method
argument_list|)
condition|)
continue|continue;
comment|/* [over.load] Member function declarations with the 	     same name and the same parameter types cannot be 	     overloaded if any of them is a static member 	     function declaration.  	     [namespace.udecl] When a using-declaration brings names 	     from a base class into a derived class scope, member 	     functions in the derived class override and/or hide member 	     functions with the same name and parameter types in a base 	     class (rather than conflicting).  */
name|parms1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|parms2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compare the quals on the 'this' parm.  Don't compare 	     the whole types, as used functions are treated as 	     coming from the using class in overload resolution.  */
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms2
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|same
operator|=
literal|0
expr_stmt|;
comment|/* For templates, the template parms must be identical.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|method
argument_list|)
argument_list|)
condition|)
name|same
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parms1
operator|=
name|TREE_CHAIN
argument_list|(
name|parms1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|method
argument_list|)
condition|)
name|parms2
operator|=
name|TREE_CHAIN
argument_list|(
name|parms2
argument_list|)
expr_stmt|;
if|if
condition|(
name|same
operator|&&
name|compparms
argument_list|(
name|parms1
argument_list|,
name|parms2
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|fn
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|using
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|==
name|type
condition|)
comment|/* Defer to the local function.  */
return|return;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"`%#D' and `%#D' cannot be overloaded"
argument_list|,
name|method
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* We don't call duplicate_decls here to merge 		     the declarations because that will confuse 		     things if the methods have inline 		     definitions.  In particular, we will crash 		     while processing the definitions.  */
return|return;
block|}
block|}
block|}
block|}
comment|/* Actually insert the new method.  */
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|=
name|build_overload
argument_list|(
name|method
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the new binding.  */
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|method
argument_list|)
condition|)
name|push_class_level_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|method
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutines of finish_struct.  */
end_comment

begin_comment
comment|/* Change the access of FDECL to ACCESS in T.  Return 1 if change was    legit, otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|alter_access
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|fdecl
parameter_list|,
name|tree
name|access
parameter_list|)
block|{
name|tree
name|elem
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|fdecl
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_DISCRIMINATOR_P
argument_list|(
name|fdecl
argument_list|)
argument_list|,
literal|20030624
argument_list|)
expr_stmt|;
name|elem
operator|=
name|purpose_member
argument_list|(
name|t
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
operator|!=
name|access
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"conflicting access specifications for method `%D', ignored"
argument_list|,
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"conflicting access specifications for field `%s', ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* They're changing the access to the same thing they changed 	     it to before.  That's OK.  */
empty_stmt|;
block|}
block|}
else|else
block|{
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|access
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the USING_DECL, which is a member of T.  */
end_comment

begin_function
specifier|static
name|void
name|handle_using_decl
parameter_list|(
name|tree
name|using_decl
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|ctype
init|=
name|DECL_INITIAL
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|access
init|=
name|TREE_PRIVATE
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_private_node
else|:
name|TREE_PROTECTED
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_protected_node
else|:
name|access_public_node
decl_stmt|;
name|tree
name|fdecl
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|flist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|old_value
decl_stmt|;
if|if
condition|(
name|ctype
operator|==
name|error_mark_node
condition|)
return|return;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|t
argument_list|,
name|ctype
argument_list|,
name|ba_any
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
name|location_t
name|saved_loc
init|=
name|input_location
decl_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|using_decl
argument_list|)
expr_stmt|;
name|error_not_base_type
argument_list|(
name|ctype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|saved_loc
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|constructor_name_p
argument_list|(
name|name
argument_list|,
name|ctype
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' names constructor"
argument_list|,
name|using_decl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|constructor_name_p
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' invalid in `%T'"
argument_list|,
name|using_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|fdecl
operator|=
name|lookup_member
argument_list|(
name|binfo
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"no members matching `%D' in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fdecl
argument_list|)
condition|)
comment|/* Ignore base type this came from.  */
name|fdecl
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
name|old_value
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_value
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old_value
argument_list|)
condition|)
name|old_value
operator|=
name|OVL_CURRENT
argument_list|(
name|old_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|old_value
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|old_value
argument_list|)
operator|==
name|t
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|old_value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fdecl
argument_list|)
condition|)
name|flist
operator|=
name|fdecl
expr_stmt|;
if|if
condition|(
operator|!
name|old_value
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old_value
argument_list|)
condition|)
block|{
if|if
condition|(
name|flist
condition|)
comment|/* It's OK to use functions from a base when there are functions with 	   the same name already present in the current class.  */
empty_stmt|;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"`%D' invalid in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local method `%#D' with same name"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|old_value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|old_value
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' invalid in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local member `%#D' with same name"
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make type T see field decl FDECL with access ACCESS.  */
if|if
condition|(
name|flist
condition|)
for|for
control|(
init|;
name|flist
condition|;
name|flist
operator|=
name|OVL_NEXT
argument_list|(
name|flist
argument_list|)
control|)
block|{
name|add_method
argument_list|(
name|t
argument_list|,
name|OVL_CURRENT
argument_list|(
name|flist
argument_list|)
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|alter_access
argument_list|(
name|t
argument_list|,
name|OVL_CURRENT
argument_list|(
name|flist
argument_list|)
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
else|else
name|alter_access
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Run through the base clases of T, updating    CANT_HAVE_DEFAULT_CTOR_P, CANT_HAVE_CONST_CTOR_P, and    NO_CONST_ASN_REF_P.  Also set flag bits in T based on properties of    the bases.  */
end_comment

begin_function
specifier|static
name|void
name|check_bases
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
modifier|*
name|cant_have_default_ctor_p
parameter_list|,
name|int
modifier|*
name|cant_have_const_ctor_p
parameter_list|,
name|int
modifier|*
name|no_const_asn_ref_p
parameter_list|)
block|{
name|int
name|n_baseclasses
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|seen_non_virtual_nearly_empty_base_p
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
name|binfos
operator|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|seen_non_virtual_nearly_empty_base_p
operator|=
literal|0
expr_stmt|;
comment|/* An aggregate cannot have baseclasses.  */
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|n_baseclasses
operator|!=
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
comment|/* Figure out what base we're looking at.  */
name|base_binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* If the type of basetype is incomplete, then we already 	 complained about that fact (and we should have fixed it up as 	 well).  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* The base type is of incomplete type.  It is 	     probably best to pretend that it does not 	     exist.  */
if|if
condition|(
name|i
operator|==
name|n_baseclasses
operator|-
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|n_baseclasses
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|+
literal|1
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Effective C++ rule 14.  We only need to check TYPE_POLYMORPHIC_P 	 here because the case of virtual functions but non-virtual 	 dtor is handled in finish_struct_1.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|!
name|TYPE_POLYMORPHIC_P
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|warning
argument_list|(
literal|"base class `%#T' has a non-virtual destructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
comment|/* If the base class doesn't have copy constructors or 	 assignment operators that take const references, then the 	 derived class cannot have such a member automatically 	 generated.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
operator|*
name|cant_have_const_ctor_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
condition|)
operator|*
name|no_const_asn_ref_p
operator|=
literal|1
expr_stmt|;
comment|/* Similarly, if the base class doesn't have a default 	 constructor, then the derived class won't have an 	 automatically generated default constructor.  */
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
operator|*
name|cant_have_default_ctor_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"base `%T' with only non-default constructor in class without a constructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
comment|/* A virtual base does not effect nearly emptiness.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|seen_non_virtual_nearly_empty_base_p
condition|)
comment|/* And if there is more than one nearly empty base, then the 	       derived class is not nearly empty either.  */
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
comment|/* Remember we've seen one.  */
name|seen_non_virtual_nearly_empty_base_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_empty_class
argument_list|(
name|basetype
argument_list|)
condition|)
comment|/* If the base class is not empty or nearly empty, then this 	   class cannot be nearly empty.  */
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* A lot of properties from the bases also apply to the derived 	 class.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_POLYMORPHIC_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|t
argument_list|)
operator||=
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set BINFO_PRIMARY_BASE_OF for all binfos in the hierarchy    dominated by TYPE that are primary bases.  */
end_comment

begin_function
specifier|static
name|void
name|mark_primary_bases
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
comment|/* Walk the bases in inheritance graph order.  */
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
name|tree
name|base_binfo
init|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|base_binfo
condition|)
comment|/* Not a dynamic base.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
comment|/* A virtual binfo might have been copied from within   	     another hierarchy. As we're about to use it as a primary   	     base, make sure the offsets match.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|tree
name|delta
init|=
name|size_diffop
argument_list|(
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|propagate_binfo_offsets
argument_list|(
name|base_binfo
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make the BINFO the primary base of T.  */
end_comment

begin_function
specifier|static
name|void
name|set_primary_base
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|basetype
decl_stmt|;
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the primary class for T.  */
end_comment

begin_function
specifier|static
name|void
name|determine_primary_base
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|tree
name|type_binfo
decl_stmt|;
comment|/* If there are no baseclasses, there is certainly no primary base.  */
if|if
condition|(
name|n_baseclasses
operator|==
literal|0
condition|)
return|return;
name|type_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|type_binfo
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* We prefer a non-virtual base, although a virtual one will 	     do.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|set_primary_base
argument_list|(
name|t
argument_list|,
name|base_binfo
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|copy_list
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|vfields
decl_stmt|;
comment|/* Only add unique vfields, and flatten them out as we go.  */
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Find the indirect primary bases - those virtual bases which are primary      bases of something else in this hierarchy.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|vbase_binfo
init|=
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
comment|/* See if this virtual base is an indirect primary base.  To be so,          it must be a primary base within the hierarchy of one of our          direct bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
name|tree
name|base_vbase
init|=
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|base_vbase
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_vbase
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|vbase_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|vbase_binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we've discovered that this virtual base is an indirect 	     primary base, then we can move on to the next virtual 	     base.  */
if|if
condition|(
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|vbase_binfo
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* A "nearly-empty" virtual base class can be the primary base      class, if no non-virtual polymorphic base can be found.  */
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* If not NULL, this is the best primary base candidate we have          found so far.  */
name|tree
name|candidate
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
comment|/* Loop over the baseclasses.  */
for|for
control|(
name|base_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
init|;
name|base_binfo
condition|;
name|base_binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* If this is not an indirect primary base, then it's 		 definitely our primary base.  */
if|if
condition|(
operator|!
name|BINFO_INDIRECT_PRIMARY_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|candidate
operator|=
name|base_binfo
expr_stmt|;
break|break;
block|}
comment|/* If this is an indirect primary base, it still could be 	         our primary base -- unless we later find there's another 	         nearly-empty virtual base that isn't an indirect 	         primary base.  */
if|if
condition|(
operator|!
name|candidate
condition|)
name|candidate
operator|=
name|base_binfo
expr_stmt|;
block|}
block|}
comment|/* If we've got a primary base, use it.  */
if|if
condition|(
name|candidate
condition|)
block|{
name|set_primary_base
argument_list|(
name|t
argument_list|,
name|candidate
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|copy_list
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|candidate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark the primary base classes at this point.  */
name|mark_primary_bases
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set memoizing fields and bits of T (and its variants) for later    use.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Fix up variants (if any).  */
name|tree
name|variants
init|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
comment|/* These fields are in the _TYPE part of the node, not in 	 the TYPE_LANG_SPECIFIC component, so they are not shared.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_POLYMORPHIC_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Copy whatever these are holding today.  */
name|TYPE_MIN_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* For a class w/o baseclasses, `finish_struct' has set        CLASS_TYPE_ABSTRACT_VIRTUALS correctly (by        definition). Similarly for a class whose base classes do not        have vtables. When neither of these is true, we might have        removed abstract virtuals (by providing a definition), added        some (by declaring new ones), or redeclared ones from a base        class. We need to recalculate what's really an abstract virtual        at this point (by looking in the vtables).  */
name|get_pure_virtuals
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
block|{
comment|/* Notice whether this class has type conversion functions defined.  */
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this type has a copy constructor or a destructor, force its mode to      be BLKmode, and force its TREE_ADDRESSABLE bit to be nonzero.  This      will cause it to be passed by invisible reference and prevent it from      being returned in a register.  */
if|if
condition|(
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|variants
decl_stmt|;
name|DECL_MODE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
for|for
control|(
name|variants
operator|=
name|t
init|;
name|variants
condition|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
control|)
block|{
name|TYPE_MODE
argument_list|(
name|variants
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|variants
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Issue warnings about T having private constructors, but no friends,    and so forth.       HAS_NONPRIVATE_METHOD is nonzero if T has any non-private methods or    static members.  HAS_NONPRIVATE_STATIC_FN is nonzero if T has any    non-private static member functions.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_warn_about_overly_private_class
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|has_member_fn
init|=
literal|0
decl_stmt|;
name|int
name|has_nonprivate_method
init|=
literal|0
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|warn_ctor_dtor_privacy
comment|/* If the class has friends, those entities might create and 	 access instances, so we should not warn.  */
operator|||
operator|(
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
comment|/* We will have warned when the template was declared; there's 	 no need to warn on every instantiation.  */
operator|||
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
comment|/* There's no reason to even consider warning about this         class.  */
return|return;
comment|/* We only issue one warning, if more than one applies, because      otherwise, on code like:       class A {        // Oops - forgot `public:'        A();        A(const A&);        ~A();      };       we warn several times about essentially the same problem.  */
comment|/* Check to see if all (non-constructor, non-destructor) member      functions are private.  (Since there are no friends or      non-private statics, we can't ever call any of the private member      functions.)  */
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
comment|/* We're not interested in compiler-generated methods; they don't        provide any way to call private members.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* A non-private static member function is just like a 		 friend; it can create and invoke private member 		 functions, and be accessed without a class 		 instance.  */
return|return;
name|has_nonprivate_method
operator|=
literal|1
expr_stmt|;
comment|/* Keep searching for a static member function.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|has_member_fn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_nonprivate_method
operator|&&
name|has_member_fn
condition|)
block|{
comment|/* There are no non-private methods, and there's at least one 	 private member function that isn't a constructor or 	 destructor.  (If all the private members are 	 constructors/destructors we want to use the code below that 	 issues error messages specifically referring to 	 constructors/destructors.)  */
name|int
name|i
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BINFO_BASEACCESS
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
operator|!=
name|access_private_node
condition|)
block|{
name|has_nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|has_nonprivate_method
condition|)
block|{
name|warning
argument_list|(
literal|"all member functions in class `%T' are private"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Even if some of the member functions are non-private, the class      won't be useful for much if all the constructors or destructors      are private: such an object can never be created or destroyed.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_PRIVATE
argument_list|(
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%#T' only defines a private destructor and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|nonprivate_ctor
init|=
literal|0
decl_stmt|;
comment|/* If a non-template class does not define a copy 	 constructor, one is defined for it, enabling it to avoid 	 this warning.  For a template class, this does not 	 happen, and so we would normally get a warning on:  	   template<class T> class C { private: C(); };   	   	 To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  All 	 complete non-template or fully instantiated classes have this 	 flag set.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|fn
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|ctor
init|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
comment|/* Ideally, we wouldn't count copy constructors (or, in 	       fact, any constructor that takes an argument of the 	       class type as a parameter) because such things cannot 	       be used to construct an instance of the class unless 	       you already have one.  But, for now at least, we're 	       more generous.  */
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|ctor
argument_list|)
condition|)
block|{
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nonprivate_ctor
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"`%#T' only defines private constructors and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|gt_pointer_operator
name|new_value
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
block|}
name|resort_data
struct|;
end_struct

begin_comment
comment|/* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */
end_comment

begin_function
specifier|static
name|int
name|method_name_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|m1_p
parameter_list|,
specifier|const
name|void
modifier|*
name|m2_p
parameter_list|)
block|{
specifier|const
name|tree
modifier|*
specifier|const
name|m1
init|=
name|m1_p
decl_stmt|;
specifier|const
name|tree
modifier|*
specifier|const
name|m2
init|=
name|m2_p
decl_stmt|;
if|if
condition|(
operator|*
name|m1
operator|==
name|NULL_TREE
operator|&&
operator|*
name|m2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|m1
operator|==
name|NULL_TREE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|m2
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|m1
argument_list|)
argument_list|)
operator|<
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|m2
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine compares two fields like method_name_cmp but using the    pointer operator in resort_field_decl_data.  */
end_comment

begin_function
specifier|static
name|int
name|resort_method_name_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|m1_p
parameter_list|,
specifier|const
name|void
modifier|*
name|m2_p
parameter_list|)
block|{
specifier|const
name|tree
modifier|*
specifier|const
name|m1
init|=
name|m1_p
decl_stmt|;
specifier|const
name|tree
modifier|*
specifier|const
name|m2
init|=
name|m2_p
decl_stmt|;
if|if
condition|(
operator|*
name|m1
operator|==
name|NULL_TREE
operator|&&
operator|*
name|m2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|m1
operator|==
name|NULL_TREE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|m2
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
block|{
name|tree
name|d1
init|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|m1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|m2
argument_list|)
argument_list|)
decl_stmt|;
name|resort_data
operator|.
name|new_value
argument_list|(
operator|&
name|d1
argument_list|,
name|resort_data
operator|.
name|cookie
argument_list|)
expr_stmt|;
name|resort_data
operator|.
name|new_value
argument_list|(
operator|&
name|d2
argument_list|,
name|resort_data
operator|.
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|<
name|d2
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Resort TYPE_METHOD_VEC because pointers have been reordered.  */
end_comment

begin_function
name|void
name|resort_type_method_vec
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|orig_obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|gt_pointer_operator
name|new_value
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|tree
name|method_vec
init|=
name|obj
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
name|int
name|slot
decl_stmt|;
comment|/* The type conversion ops have to live at the front of the vec, so we      can't sort them.  */
for|for
control|(
name|slot
operator|=
literal|2
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|len
operator|-
name|slot
operator|>
literal|1
condition|)
block|{
name|resort_data
operator|.
name|new_value
operator|=
name|new_value
expr_stmt|;
name|resort_data
operator|.
name|cookie
operator|=
name|cookie
expr_stmt|;
name|qsort
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|,
name|len
operator|-
name|slot
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|resort_method_name_cmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn about duplicate methods in fn_fields.  Also compact method    lists so that lookup can be made faster.     Data Structure: List of method lists.  The outer list is a    TREE_LIST, whose TREE_PURPOSE field is the field name and the    TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN    links the entire list of methods for TYPE_METHODS.  Friends are    chained in the same way as member functions (? TREE_CHAIN or    DECL_CHAIN), but they live in the TREE_TYPE field of the outer    list.  That allows them to be quickly deleted, and requires no    extra storage.     Sort methods that are not special (i.e., constructors, destructors,    and type conversion operators) so that we can find them faster in    search.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_methods
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|fn_fields
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Clear these for safety; perhaps some parsing error could set 	 these incorrectly.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|method_vec
operator|!=
name|NULL_TREE
argument_list|,
literal|19991215
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* First fill in entry 0 with the constructors, entry 1 with destructors,      and the next few with type conversion operators (if any).  */
for|for
control|(
name|fn_fields
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn_fields
condition|;
name|fn_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
control|)
comment|/* Clear out this flag.  */
name|DECL_IN_AGGR_P
argument_list|(
name|fn_fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|t
argument_list|)
condition|)
comment|/* We thought there was a destructor, but there wasn't.  Some        parse errors cause this anomalous situation.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Issue warnings about private constructors and such.  If there are      no methods, then some public defaults are generated.  */
name|maybe_warn_about_overly_private_class
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Now sort the methods.  */
while|while
condition|(
name|len
operator|>
literal|2
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|len
operator|--
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
name|len
expr_stmt|;
comment|/* The type conversion ops have to live at the front of the vec, so we      can't sort them.  */
for|for
control|(
name|slot
operator|=
literal|2
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|len
operator|-
name|slot
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|,
name|len
operator|-
name|slot
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|method_name_cmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make BINFO's vtable have N entries, including RTTI entries,    vbase and vcall offsets, etc.  Set its type and call the backend    to lay it out.  */
end_comment

begin_function
specifier|static
name|void
name|layout_vtable_decl
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|tree
name|atype
decl_stmt|;
name|tree
name|vtable
decl_stmt|;
name|atype
operator|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|n
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
comment|/* We may have to grow the vtable.  */
name|vtable
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|,
name|atype
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
operator|=
name|atype
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|vtable
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|vtable
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_decl
argument_list|(
name|vtable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True iff FNDECL and BASE_FNDECL (both non-static member functions)    have the same signature.  */
end_comment

begin_function
name|int
name|same_signature_p
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|base_fndecl
parameter_list|)
block|{
comment|/* One destructor overrides another if they are the same kind of      destructor.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|base_fndecl
argument_list|)
operator|&&
name|DECL_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|special_function_p
argument_list|(
name|base_fndecl
argument_list|)
operator|==
name|special_function_p
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* But a non-destructor never overrides a destructor, nor vice      versa, nor do different kinds of destructors override      one-another.  For example, a complete object destructor does not      override a deleting destructor.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|base_fndecl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|base_fndecl
argument_list|)
operator|||
operator|(
name|DECL_CONV_FN_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_CONV_FN_P
argument_list|(
name|base_fndecl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_CONV_FN_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|DECL_CONV_FN_TYPE
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|types
decl_stmt|,
name|base_types
decl_stmt|;
name|types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|base_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_types
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|base_types
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if DERIVED is a binfo containing the binfo BASE as a    subobject.  */
end_comment

begin_function
specifier|static
name|bool
name|base_derived_from
parameter_list|(
name|tree
name|derived
parameter_list|,
name|tree
name|base
parameter_list|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|base
init|;
name|probe
condition|;
name|probe
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
if|if
condition|(
name|probe
operator|==
name|derived
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|probe
argument_list|)
condition|)
comment|/* If we meet a virtual base, we can't follow the inheritance 	   any more.  See if the complete type of DERIVED contains 	   such a virtual base.  */
return|return
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|probe
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|derived
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|count_depth_data
block|{
comment|/* The depth of the current subobject, with "1" as the depth of the      most derived object in the hierarchy.  */
name|size_t
name|depth
decl_stmt|;
comment|/* The maximum depth found so far.  */
name|size_t
name|max_depth
decl_stmt|;
block|}
name|count_depth_data
typedef|;
end_typedef

begin_comment
comment|/* Called from find_final_overrider via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_depth_post
parameter_list|(
name|tree
name|binfo
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|count_depth_data
modifier|*
name|cd
init|=
operator|(
name|count_depth_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|depth
operator|>
name|cd
operator|->
name|max_depth
condition|)
name|cd
operator|->
name|max_depth
operator|=
name|cd
operator|->
name|depth
expr_stmt|;
name|cd
operator|->
name|depth
operator|--
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called from find_final_overrider via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_depth_q
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|i
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|count_depth_data
modifier|*
name|cd
init|=
operator|(
name|count_depth_data
operator|*
operator|)
name|data
decl_stmt|;
name|cd
operator|->
name|depth
operator|++
expr_stmt|;
return|return
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|find_final_overrider_data_s
block|{
comment|/* The function for which we are trying to find a final overrider.  */
name|tree
name|fn
decl_stmt|;
comment|/* The base class in which the function was declared.  */
name|tree
name|declaring_base
decl_stmt|;
comment|/* The most derived class in the hierarchy.  */
name|tree
name|most_derived_type
decl_stmt|;
comment|/* The candidate overriders.  */
name|tree
name|candidates
decl_stmt|;
comment|/* Each entry in this array is the next-most-derived class for a      virtual base class along the current path.  */
name|tree
modifier|*
name|vpath_list
decl_stmt|;
comment|/* A pointer one past the top of the VPATH_LIST.  */
name|tree
modifier|*
name|vpath
decl_stmt|;
block|}
name|find_final_overrider_data
typedef|;
end_typedef

begin_comment
comment|/* Add the overrider along the current path to FFOD->CANDIDATES.    Returns true if an overrider was found; false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|dfs_find_final_overrider_1
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
modifier|*
name|vpath
parameter_list|,
name|find_final_overrider_data
modifier|*
name|ffod
parameter_list|)
block|{
name|tree
name|method
decl_stmt|;
comment|/* If BINFO is not the most derived type, try a more derived class.      A definition there will overrider a definition here.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|ffod
operator|->
name|most_derived_type
argument_list|)
condition|)
block|{
name|tree
name|derived
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|derived
operator|=
operator|*
operator|--
name|vpath
expr_stmt|;
else|else
name|derived
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfs_find_final_overrider_1
argument_list|(
name|derived
argument_list|,
name|vpath
argument_list|,
name|ffod
argument_list|)
condition|)
return|return
name|true
return|;
block|}
name|method
operator|=
name|look_for_overrides_here
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|ffod
operator|->
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
block|{
name|tree
modifier|*
name|candidate
init|=
operator|&
name|ffod
operator|->
name|candidates
decl_stmt|;
comment|/* Remove any candidates overridden by this new function.  */
while|while
condition|(
operator|*
name|candidate
condition|)
block|{
comment|/* If *CANDIDATE overrides METHOD, then METHOD 	     cannot override anything else on the list.  */
if|if
condition|(
name|base_derived_from
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|candidate
argument_list|)
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If METHOD overrides *CANDIDATE, remove *CANDIDATE.  */
if|if
condition|(
name|base_derived_from
argument_list|(
name|binfo
argument_list|,
name|TREE_VALUE
argument_list|(
operator|*
name|candidate
argument_list|)
argument_list|)
condition|)
operator|*
name|candidate
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|candidate
argument_list|)
expr_stmt|;
else|else
name|candidate
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|candidate
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new function.  */
name|ffod
operator|->
name|candidates
operator|=
name|tree_cons
argument_list|(
name|method
argument_list|,
name|binfo
argument_list|,
name|ffod
operator|->
name|candidates
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Called from find_final_overrider via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_find_final_overrider
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|find_final_overrider_data
modifier|*
name|ffod
init|=
operator|(
name|find_final_overrider_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|ffod
operator|->
name|declaring_base
condition|)
name|dfs_find_final_overrider_1
argument_list|(
name|binfo
argument_list|,
name|ffod
operator|->
name|vpath
argument_list|,
name|ffod
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|dfs_find_final_overrider_q
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|find_final_overrider_data
modifier|*
name|ffod
init|=
operator|(
name|find_final_overrider_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
operator|*
name|ffod
operator|->
name|vpath
operator|++
operator|=
name|derived
expr_stmt|;
return|return
name|binfo
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|dfs_find_final_overrider_post
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|find_final_overrider_data
modifier|*
name|ffod
init|=
operator|(
name|find_final_overrider_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|ffod
operator|->
name|vpath
operator|--
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns a TREE_LIST whose TREE_PURPOSE is the final overrider for    FN and whose TREE_VALUE is the binfo for the base where the    overriding occurs.  BINFO (in the hierarchy dominated by the binfo    DERIVED) is the base object in which FN is declared.  */
end_comment

begin_function
specifier|static
name|tree
name|find_final_overrider
parameter_list|(
name|tree
name|derived
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|find_final_overrider_data
name|ffod
decl_stmt|;
name|count_depth_data
name|cd
decl_stmt|;
comment|/* Getting this right is a little tricky.  This is valid:         struct S { virtual void f (); };        struct T { virtual void f (); };        struct U : public S, public T { };       even though calling `f' in `U' is ambiguous.  But,          struct R { virtual void f(); };        struct S : virtual public R { virtual void f (); };        struct T : virtual public R { virtual void f (); };        struct U : public S, public T { };       is not -- there's no way to decide whether to put `S::f' or      `T::f' in the vtable for `R'.              The solution is to look at all paths to BINFO.  If we find      different overriders along any two, then there is a problem.  */
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|THUNK_TARGET
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Determine the depth of the hierarchy.  */
name|cd
operator|.
name|depth
operator|=
literal|0
expr_stmt|;
name|cd
operator|.
name|max_depth
operator|=
literal|0
expr_stmt|;
name|dfs_walk
argument_list|(
name|derived
argument_list|,
name|dfs_depth_post
argument_list|,
name|dfs_depth_q
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
name|ffod
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|ffod
operator|.
name|declaring_base
operator|=
name|binfo
expr_stmt|;
name|ffod
operator|.
name|most_derived_type
operator|=
name|BINFO_TYPE
argument_list|(
name|derived
argument_list|)
expr_stmt|;
name|ffod
operator|.
name|candidates
operator|=
name|NULL_TREE
expr_stmt|;
name|ffod
operator|.
name|vpath_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xcalloc
argument_list|(
name|cd
operator|.
name|max_depth
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|ffod
operator|.
name|vpath
operator|=
name|ffod
operator|.
name|vpath_list
expr_stmt|;
name|dfs_walk_real
argument_list|(
name|derived
argument_list|,
name|dfs_find_final_overrider
argument_list|,
name|dfs_find_final_overrider_post
argument_list|,
name|dfs_find_final_overrider_q
argument_list|,
operator|&
name|ffod
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ffod
operator|.
name|vpath_list
argument_list|)
expr_stmt|;
comment|/* If there was no winner, issue an error message.  */
if|if
condition|(
operator|!
name|ffod
operator|.
name|candidates
operator|||
name|TREE_CHAIN
argument_list|(
name|ffod
operator|.
name|candidates
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no unique final overrider for `%D' in `%T'"
argument_list|,
name|fn
argument_list|,
name|BINFO_TYPE
argument_list|(
name|derived
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|ffod
operator|.
name|candidates
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the vcall offset for FN when TYPE is used as a    virtual base.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vcall_index
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|CLASSTYPE_VCALL_INDICES
argument_list|(
name|type
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
operator|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_DESTRUCTOR_P
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|)
operator|||
name|same_signature_p
argument_list|(
name|fn
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* There should always be an appropriate index.  */
name|my_friendly_assert
argument_list|(
name|v
argument_list|,
literal|20021103
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update an entry in the vtable for BINFO, which is in the hierarchy    dominated by T.  FN has been overridden in BINFO; VIRTUALS points to the    corresponding position in the BINFO_VIRTUALS list.  */
end_comment

begin_function
specifier|static
name|void
name|update_vtable_entry_for_fn
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|tree
name|fn
parameter_list|,
name|tree
modifier|*
name|virtuals
parameter_list|,
name|unsigned
name|ix
parameter_list|)
block|{
name|tree
name|b
decl_stmt|;
name|tree
name|overrider
decl_stmt|;
name|tree
name|delta
decl_stmt|;
name|tree
name|virtual_base
decl_stmt|;
name|tree
name|first_defn
decl_stmt|;
name|tree
name|overrider_fn
decl_stmt|,
name|overrider_target
decl_stmt|;
name|tree
name|target_fn
init|=
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
condition|?
name|THUNK_TARGET
argument_list|(
name|fn
argument_list|)
else|:
name|fn
decl_stmt|;
name|tree
name|over_return
decl_stmt|,
name|base_return
decl_stmt|;
name|bool
name|lost
init|=
name|false
decl_stmt|;
comment|/* Find the nearest primary base (possibly binfo itself) which defines      this function; this is the class the caller will convert to when      calling FN through BINFO.  */
for|for
control|(
name|b
operator|=
name|binfo
init|;
condition|;
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
control|)
block|{
name|my_friendly_assert
argument_list|(
name|b
argument_list|,
literal|20021227
argument_list|)
expr_stmt|;
if|if
condition|(
name|look_for_overrides_here
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|target_fn
argument_list|)
condition|)
break|break;
comment|/* The nearest definition is from a lost primary.  */
if|if
condition|(
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|b
argument_list|)
condition|)
name|lost
operator|=
name|true
expr_stmt|;
block|}
name|first_defn
operator|=
name|b
expr_stmt|;
comment|/* Find the final overrider.  */
name|overrider
operator|=
name|find_final_overrider
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|b
argument_list|,
name|target_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|overrider
operator|==
name|error_mark_node
condition|)
return|return;
name|overrider_target
operator|=
name|overrider_fn
operator|=
name|TREE_PURPOSE
argument_list|(
name|overrider
argument_list|)
expr_stmt|;
comment|/* Check for adjusting covariant return types.  */
name|over_return
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|overrider_target
argument_list|)
argument_list|)
expr_stmt|;
name|base_return
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target_fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|over_return
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|over_return
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|base_return
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|over_return
argument_list|)
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_return
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If FN is a covariant thunk, we must figure out the adjustment          to the final base FN was converting to. As OVERRIDER_TARGET might          also be converting to the return type of FN, we have to          combine the two conversions here.  */
name|tree
name|fixed_offset
decl_stmt|,
name|virtual_offset
decl_stmt|;
name|over_return
operator|=
name|TREE_TYPE
argument_list|(
name|over_return
argument_list|)
expr_stmt|;
name|base_return
operator|=
name|TREE_TYPE
argument_list|(
name|base_return
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_RESULT_THUNK_P
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|20031211
argument_list|)
expr_stmt|;
name|fixed_offset
operator|=
name|ssize_int
argument_list|(
name|THUNK_FIXED_OFFSET
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|virtual_offset
operator|=
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
name|fixed_offset
operator|=
name|virtual_offset
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|virtual_offset
condition|)
comment|/* Find the equivalent binfo within the return type of the 	   overriding function. We will want the vbase offset from 	   there.  */
name|virtual_offset
operator|=
name|TREE_VALUE
argument_list|(
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|virtual_offset
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|over_return
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|over_return
argument_list|,
name|base_return
argument_list|)
condition|)
block|{
comment|/* There was no existing virtual thunk (which takes 	     precedence).  So find the binfo of the base function's 	     return type within the overriding function's return type. 	     We cannot call lookup base here, because we're inside a 	     dfs_walk, and will therefore clobber the BINFO_MARKED 	     flags.  Fortunately we know the covariancy is valid (it 	     has already been checked), so we can just iterate along 	     the binfos, which have been chained in inheritance graph 	     order.  Of course it is lame that we have to repeat the 	     search here anyway -- we should really be caching pieces 	     of the vtable and avoiding this repeated work.  */
name|tree
name|thunk_binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
comment|/* Find the base binfo within the overriding function's 	     return type.  We will always find a thunk_binfo, except 	     when the covariancy is invalid (which we will have 	     already diagnosed).  */
for|for
control|(
name|base_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|base_return
argument_list|)
operator|,
name|thunk_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|over_return
argument_list|)
init|;
name|thunk_binfo
condition|;
name|thunk_binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|thunk_binfo
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|thunk_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* See if virtual inheritance is involved.  */
for|for
control|(
name|virtual_offset
operator|=
name|thunk_binfo
init|;
name|virtual_offset
condition|;
name|virtual_offset
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|virtual_offset
argument_list|)
control|)
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|virtual_offset
argument_list|)
condition|)
break|break;
if|if
condition|(
name|virtual_offset
operator|||
operator|(
name|thunk_binfo
operator|&&
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|thunk_binfo
argument_list|)
operator|)
condition|)
block|{
name|tree
name|offset
init|=
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|thunk_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|virtual_offset
condition|)
block|{
comment|/* We convert via virtual base.  Adjust the fixed 		     offset to be from there.  */
name|offset
operator|=
name|size_diffop
argument_list|(
name|offset
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|virtual_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixed_offset
condition|)
comment|/* There was an existing fixed offset, this must be 		   from the base just converted to, and the base the 		   FN was thunking to.  */
name|fixed_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|fixed_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|fixed_offset
operator|=
name|offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixed_offset
operator|||
name|virtual_offset
condition|)
comment|/* Replace the overriding function with a covariant thunk.  We 	   will emit the overriding function in its own slot as 	   well.  */
name|overrider_fn
operator|=
name|make_thunk
argument_list|(
name|overrider_target
argument_list|,
comment|/*this_adjusting=*/
literal|0
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|20021231
argument_list|)
expr_stmt|;
comment|/* Assume that we will produce a thunk that convert all the way to      the final overrider, and not to an intermediate virtual base.  */
name|virtual_base
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* See if we can convert to an intermediate virtual base first, and then      use the vcall offset located there to finish the conversion.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
block|{
comment|/* If we find the final overrider, then we can stop 	 walking.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|overrider
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* If we find a virtual base, and we haven't yet found the 	 overrider, then there is a virtual base between the 	 declaring base (first_defn) and the final overrider.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|virtual_base
operator|=
name|b
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|overrider_fn
operator|!=
name|overrider_target
operator|&&
operator|!
name|virtual_base
condition|)
block|{
comment|/* The ABI specifies that a covariant thunk includes a mangling    	 for a this pointer adjustment.  This-adjusting thunks that    	 override a function from a virtual base have a vcall    	 adjustment.  When the virtual base in question is a primary    	 virtual base, we know the adjustments are zero, (and in the    	 non-covariant case, we would not use the thunk).    	 Unfortunately we didn't notice this could happen, when    	 designing the ABI and so never mandated that such a covariant    	 thunk should be emitted.  Because we must use the ABI mandated    	 name, we must continue searching from the binfo where we    	 found the most recent definition of the function, towards the    	 primary binfo which first introduced the function into the    	 vtable.  If that enters a virtual base, we must use a vcall    	 this-adjusting thunk.  Bleah! */
name|tree
name|probe
init|=
name|first_defn
decl_stmt|;
while|while
condition|(
operator|(
name|probe
operator|=
name|get_primary_binfo
argument_list|(
name|probe
argument_list|)
operator|)
operator|&&
operator|(
name|unsigned
operator|)
name|list_length
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|probe
argument_list|)
argument_list|)
operator|>
name|ix
condition|)
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|probe
argument_list|)
condition|)
name|virtual_base
operator|=
name|probe
expr_stmt|;
if|if
condition|(
name|virtual_base
condition|)
comment|/* Even if we find a virtual base, the correct delta is 	   between the overrider and the binfo we're building a vtable 	   for.  */
goto|goto
name|virtual_covariant
goto|;
block|}
comment|/* Compute the constant adjustment to the `this' pointer.  The      `this' pointer, when this function is called, will point at BINFO      (or one of its primary bases, which are at the same offset).  */
if|if
condition|(
name|virtual_base
condition|)
comment|/* The `this' pointer needs to be adjusted from the declaration to        the nearest virtual base.  */
name|delta
operator|=
name|size_diffop
argument_list|(
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|virtual_base
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|first_defn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lost
condition|)
comment|/* If the nearest definition is in a lost primary, we don't need an        entry in our vtable.  Except possibly in a constructor vtable,        if we happen to get our primary back.  In that case, the offset        will be zero, as it will be a primary base.  */
name|delta
operator|=
name|size_zero_node
expr_stmt|;
else|else
comment|/* The `this' pointer needs to be adjusted from pointing to        BINFO to pointing at the base where the final overrider        appears.  */
name|virtual_covariant
label|:
name|delta
operator|=
name|size_diffop
argument_list|(
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|TREE_VALUE
argument_list|(
name|overrider
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modify_vtable_entry
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|overrider_fn
argument_list|,
name|delta
argument_list|,
name|virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_base
condition|)
name|BV_VCALL_INDEX
argument_list|(
operator|*
name|virtuals
argument_list|)
operator|=
name|get_vcall_index
argument_list|(
name|overrider_target
argument_list|,
name|BINFO_TYPE
argument_list|(
name|virtual_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from modify_all_vtables via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_modify_vtables
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
comment|/* There's no need to modify the vtable for a non-virtual          primary base; we're not going to use that vtable anyhow. 	 We do still need to do this for virtual primary bases, as they 	 could become non-primary in a construction vtable.  */
operator|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|)
comment|/* Similarly, a base without a vtable needs no modification.  */
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|tree
name|old_virtuals
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|make_new_vtable
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Now, go through each of the virtual functions in the virtual 	 function table for BINFO.  Find the final overrider, and 	 update the BINFO_VIRTUALS list appropriately.  */
for|for
control|(
name|ix
operator|=
literal|0
operator|,
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|,
name|old_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
init|;
name|virtuals
condition|;
name|ix
operator|++
operator|,
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
operator|,
name|old_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|old_virtuals
argument_list|)
control|)
name|update_vtable_entry_for_fn
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|BV_FN
argument_list|(
name|old_virtuals
argument_list|)
argument_list|,
operator|&
name|virtuals
argument_list|,
name|ix
argument_list|)
expr_stmt|;
block|}
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Update all of the primary and secondary vtables for T.  Create new    vtables as required, and initialize their RTTI information.  Each    of the functions in VIRTUALS is declared in T and may override a    virtual function from a base class; find and modify the appropriate    entries to point to the overriding functions.  Returns a list, in    declaration order, of the virtual functions that are declared in T,    but do not appear in the primary base class vtable, and which    should therefore be appended to the end of the vtable for T.  */
end_comment

begin_function
specifier|static
name|tree
name|modify_all_vtables
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|virtuals
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|fnsp
decl_stmt|;
comment|/* Update all of the vtables.  */
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_modify_vtables
argument_list|,
name|unmarkedp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Add virtual functions not already in our primary vtable. These      will be both those introduced by this class, and those overridden      from secondary bases.  It does not include virtuals merely      inherited from secondary bases.  */
for|for
control|(
name|fnsp
operator|=
operator|&
name|virtuals
init|;
operator|*
name|fnsp
condition|;
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|fnsp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value_member
argument_list|(
name|fn
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|||
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
comment|/* We don't need to adjust the `this' pointer when 	     calling this function.  */
name|BV_DELTA
argument_list|(
operator|*
name|fnsp
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|BV_VCALL_INDEX
argument_list|(
operator|*
name|fnsp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* This is a function not already in our vtable.  Keep it.  */
name|fnsp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|fnsp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We've already got an entry for this function.  Skip it.  */
operator|*
name|fnsp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|fnsp
argument_list|)
expr_stmt|;
block|}
return|return
name|virtuals
return|;
block|}
end_function

begin_comment
comment|/* Get the base virtual function declarations in T that have the    indicated NAME.  */
end_comment

begin_function
specifier|static
name|tree
name|get_basefndecls
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|methods
decl_stmt|;
name|tree
name|base_fndecls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find virtual functions in T with the indicated NAME.  */
name|i
operator|=
name|lookup_fnfields_1
argument_list|(
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
for|for
control|(
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
init|;
name|methods
condition|;
name|methods
operator|=
name|OVL_NEXT
argument_list|(
name|methods
argument_list|)
control|)
block|{
name|tree
name|method
init|=
name|OVL_CURRENT
argument_list|(
name|methods
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|method
argument_list|)
condition|)
name|base_fndecls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|method
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base_fndecls
condition|)
return|return
name|base_fndecls
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
return|return
name|base_fndecls
return|;
block|}
end_function

begin_comment
comment|/* If this declaration supersedes the declaration of    a method declared virtual in the base class, then    mark this field as being virtual as well.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_override
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|ctype
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* In [temp.mem] we have:           A specialization of a member function template does not          override a virtual function from a base class.  */
return|return;
if|if
condition|(
operator|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|look_for_overrides
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Set DECL_VINDEX to a value that is neither an INTEGER_CST nor        the error_mark_node so that we know it is an overriding        function.  */
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn about hidden virtual functions that are not overridden in t.    We know that constructors and destructors don't apply.  */
end_comment

begin_function
name|void
name|warn_hidden
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|n_methods
init|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We go through each separately named virtual function.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|n_methods
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|fns
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|base_fndecls
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* All functions in this slot in the CLASSTYPE_METHOD_VEC will 	 have the same name.  Figure out what name that is.  */
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There are no possibly hidden functions yet.  */
name|base_fndecls
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Iterate through all of the base classes looking for possibly 	 hidden functions.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no functions to hide, continue.  */
if|if
condition|(
operator|!
name|base_fndecls
condition|)
continue|continue;
comment|/* Remove any overridden functions.  */
for|for
control|(
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|prev
init|=
operator|&
name|base_fndecls
decl_stmt|;
while|while
condition|(
operator|*
name|prev
condition|)
comment|/* If the method from the base class has the same 		   signature as the method from the derived class, it 		   has been overridden.  */
if|if
condition|(
name|same_signature_p
argument_list|(
name|fndecl
argument_list|,
name|TREE_VALUE
argument_list|(
operator|*
name|prev
argument_list|)
argument_list|)
condition|)
operator|*
name|prev
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
else|else
name|prev
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now give a warning for all base functions without overriders, 	 as they are hidden.  */
while|while
condition|(
name|base_fndecls
condition|)
block|{
comment|/* Here we know it is a hider, and no overrider exists.  */
name|cp_warning_at
argument_list|(
literal|"`%D' was hidden"
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  by `%D'"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check for things that are invalid.  There are probably plenty of other    things we should check for also.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_anon
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|elt
init|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
comment|/* We're generally only interested in entities the user 		 declared, but we also find nested classes by noticing 		 the TYPE_DECL that we create implicitly.  You're 		 allowed to put one anonymous union inside another, 		 though, so we explicitly tolerate that.  We use 		 TYPE_ANONYMOUS_P rather than ANON_AGGR_TYPE_P so that 		 we also allow unnamed types used for defining fields.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|elt
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|elt
argument_list|)
operator|||
name|TYPE_ANONYMOUS_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"`%#D' invalid; an anonymous union can only have non-static data members"
argument_list|,
name|elt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|elt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"private member `%#D' in anonymous union"
argument_list|,
name|elt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|elt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"protected member `%#D' in anonymous union"
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add T to CLASSTYPE_DECL_LIST of current_class_type which    will be used later during class template instantiation.    When FRIEND_P is zero, T can be a static member data (VAR_DECL),    a non-static member data (FIELD_DECL), a member function    (FUNCTION_DECL), a nested type (RECORD_TYPE, ENUM_TYPE),     a typedef (TYPE_DECL) or a member class template (TEMPLATE_DECL)    When FRIEND_P is nonzero, T is either a friend class    (RECORD_TYPE, TEMPLATE_DECL) or a friend function    (FUNCTION_DECL, TEMPLATE_DECL).  */
end_comment

begin_function
name|void
name|maybe_add_class_template_decl_list
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|friend_p
parameter_list|)
block|{
comment|/* Save some memory by not creating TREE_LIST if TYPE is not template.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_DECL_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|friend_p
condition|?
name|NULL_TREE
else|:
name|type
argument_list|,
name|t
argument_list|,
name|CLASSTYPE_DECL_LIST
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create default constructors, assignment operators, and so forth for    the type indicated by T, if they are needed.    CANT_HAVE_DEFAULT_CTOR, CANT_HAVE_CONST_CTOR, and    CANT_HAVE_CONST_ASSIGNMENT are nonzero if, for whatever reason, the    class cannot have a default constructor, copy constructor taking a    const reference argument, or an assignment operator taking a const    reference, respectively.  If a virtual destructor is created, its    DECL is returned; otherwise the return value is NULL_TREE.  */
end_comment

begin_function
specifier|static
name|void
name|add_implicitly_declared_members
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|cant_have_default_ctor
parameter_list|,
name|int
name|cant_have_const_cctor
parameter_list|,
name|int
name|cant_have_const_assignment
parameter_list|)
block|{
name|tree
name|default_fn
decl_stmt|;
name|tree
name|implicit_fns
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|virtual_dtor
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|f
decl_stmt|;
operator|++
name|adding_implicit_members
expr_stmt|;
comment|/* Destructor.  */
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_destructor
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
literal|0
argument_list|)
expr_stmt|;
name|check_for_override
argument_list|(
name|default_fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we couldn't make it work, then pretend we didn't need it.  */
if|if
condition|(
name|default_fn
operator|==
name|void_type_node
condition|)
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|default_fn
argument_list|)
condition|)
name|virtual_dtor
operator|=
name|default_fn
expr_stmt|;
block|}
block|}
else|else
comment|/* Any non-implicit destructor is non-trivial.  */
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Default constructor.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|cant_have_default_ctor
condition|)
block|{
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_constructor
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Copy constructor.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* ARM 12.18: You get either X(X&) or X(const X&), but 	 not both.  --Chip  */
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_copy_constructor
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
operator|!
name|cant_have_const_cctor
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Assignment operator.  */
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk_assignment_operator
argument_list|,
name|t
argument_list|,
comment|/*const_p=*/
operator|!
name|cant_have_const_assignment
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Now, hook all of the new functions on to TYPE_METHODS,      and add them to the CLASSTYPE_METHOD_VEC.  */
for|for
control|(
name|f
operator|=
operator|&
name|implicit_fns
init|;
operator|*
name|f
condition|;
name|f
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|f
argument_list|)
control|)
block|{
name|add_method
argument_list|(
name|t
argument_list|,
operator|*
name|f
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
operator|*
name|f
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
comment|/* G++ 3.2 put the implicit destructor at the *beginning* of the        list, which cause the destructor to be emitted in an incorrect        location in the vtable.  */
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
argument_list|,
name|implicit_fns
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|warn_abi
operator|&&
name|virtual_dtor
condition|)
name|warning
argument_list|(
literal|"vtable layout for class `%T' may not be ABI-compliant "
literal|"and may change in a future version of GCC due to implicit "
literal|"virtual destructor"
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|f
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
block|}
operator|--
name|adding_implicit_members
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of finish_struct_1.  Recursively count the number of fields    in TYPE, including anonymous union members.  */
end_comment

begin_function
specifier|static
name|int
name|count_fields
parameter_list|(
name|tree
name|fields
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
name|int
name|n_fields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|n_fields
operator|+=
name|count_fields
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|n_fields
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|n_fields
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of finish_struct_1.  Recursively add all the fields in the    TREE_LIST FIELDS to the SORTED_FIELDS_TYPE elts, starting at offset IDX.  */
end_comment

begin_function
specifier|static
name|int
name|add_fields_to_record_type
parameter_list|(
name|tree
name|fields
parameter_list|,
name|struct
name|sorted_fields_type
modifier|*
name|field_vec
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|idx
operator|=
name|add_fields_to_record_type
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|field_vec
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|field_vec
operator|->
name|elts
index|[
name|idx
operator|++
index|]
operator|=
name|x
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* FIELD is a bit-field.  We are finishing the processing for its    enclosing type.  Issue any appropriate messages and set appropriate    flags.  */
end_comment

begin_function
specifier|static
name|void
name|check_bitfield_decl
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|w
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%#D' with non-integral type"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|w
operator|=
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */
name|STRIP_NOPS
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* detect invalid field size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|w
operator|=
name|DECL_INITIAL
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|w
operator|=
name|decl_constant_value
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%D' width not an integer constant"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|w
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"negative width in bit-field `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|w
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"zero width for bit-field `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|w
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|w
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
name|cp_warning_at
argument_list|(
literal|"width of `%D' exceeds its type"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|w
argument_list|,
name|min_precision
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|||
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|w
argument_list|,
name|min_precision
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|cp_warning_at
argument_list|(
literal|"`%D' is too small to hold all values of `%#T'"
argument_list|,
name|field
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the bit-field width indicator so that the rest of the      compiler does not treat that value as an initializer.  */
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|error_mark_node
condition|)
block|{
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLEAR_DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FIELD is a non bit-field.  We are finishing the processing for its    enclosing type T.  Issue any appropriate messages and set appropriate    flags.  */
end_comment

begin_function
specifier|static
name|void
name|check_field_decl
parameter_list|(
name|tree
name|field
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
modifier|*
name|cant_have_const_ctor
parameter_list|,
name|int
modifier|*
name|cant_have_default_ctor
parameter_list|,
name|int
modifier|*
name|no_const_asn_ref
parameter_list|,
name|int
modifier|*
name|any_default_members
parameter_list|)
block|{
name|tree
name|type
init|=
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
comment|/* An anonymous union cannot contain any fields which would change      the settings of CANT_HAVE_CONST_CTOR and friends.  */
if|if
condition|(
name|ANON_UNION_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* And, we don't set TYPE_HAS_CONST_INIT_REF, etc., for anonymous      structs.  So, we recurse through their fields here.  */
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
name|check_field_decl
argument_list|(
name|fields
argument_list|,
name|t
argument_list|,
name|cant_have_const_ctor
argument_list|,
name|cant_have_default_ctor
argument_list|,
name|no_const_asn_ref
argument_list|,
name|any_default_members
argument_list|)
expr_stmt|;
block|}
comment|/* Check members with class type for constructors, destructors,      etc.  */
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Never let anything with uninheritable virtuals 	 make it through without complaint.  */
name|abstract_virtuals_error
argument_list|(
name|field
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with constructor not allowed in union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with destructor not allowed in union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with copy assignment operator not allowed in union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* `build_class_init_list' does not recognize 	 non-FIELD_DECLs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|any_default_members
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"multiple fields in union `%T' initialized"
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|any_default_members
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check the data members (both static and non-static), class-scoped    typedefs, etc., appearing in the declaration of T.  Issue    appropriate diagnostics.  Sets ACCESS_DECLS to a list (in    declaration order) of access declarations; each TREE_VALUE in this    list is a USING_DECL.     In addition, set the following flags:       EMPTY_P        The class is empty, i.e., contains no non-static data members.       CANT_HAVE_DEFAULT_CTOR_P        This class cannot have an implicitly generated default        constructor.       CANT_HAVE_CONST_CTOR_P        This class cannot have an implicitly generated copy constructor        taking a const reference.       CANT_HAVE_CONST_ASN_REF        This class cannot have an implicitly generated assignment        operator taking a const reference.     All of these flags should be initialized before calling this    function.     Returns a pointer to the end of the TYPE_FIELDs chain; additional    fields can be added by adding to this chain.  */
end_comment

begin_function
specifier|static
name|void
name|check_field_decls
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|access_decls
parameter_list|,
name|int
modifier|*
name|cant_have_default_ctor_p
parameter_list|,
name|int
modifier|*
name|cant_have_const_ctor_p
parameter_list|,
name|int
modifier|*
name|no_const_asn_ref_p
parameter_list|)
block|{
name|tree
modifier|*
name|field
decl_stmt|;
name|tree
modifier|*
name|next
decl_stmt|;
name|int
name|has_pointers
decl_stmt|;
name|int
name|any_default_members
decl_stmt|;
comment|/* Assume there are no access declarations.  */
operator|*
name|access_decls
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Assume this class has no pointer members.  */
name|has_pointers
operator|=
literal|0
expr_stmt|;
comment|/* Assume none of the members of this class have default      initializations.  */
name|any_default_members
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|field
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
operator|*
name|field
condition|;
name|field
operator|=
name|next
control|)
block|{
name|tree
name|x
init|=
operator|*
name|field
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|next
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pod_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_PACKED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"ignoring packed attribute on unpacked non-POD field `%#D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
comment|/* We don't treat zero-width bitfields as making a class 	       non-empty.  */
empty_stmt|;
else|else
block|{
name|tree
name|element_type
decl_stmt|;
comment|/* The class is non-empty.  */
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The class is not even nearly empty.  */
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If one of the data members contains an empty class, 		 so does T.  */
name|element_type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|element_type
argument_list|)
operator|&&
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|element_type
argument_list|)
condition|)
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
condition|)
block|{
comment|/* Prune the access declaration from the list of fields.  */
operator|*
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Save the access declarations for our caller.  */
operator|*
name|access_decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
operator|*
name|access_decls
argument_list|)
expr_stmt|;
comment|/* Since we've reset *FIELD there's no reason to skip to the 	     next field.  */
name|next
operator|=
name|field
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
continue|continue;
comment|/* If we've gotten this far, it's a data member, possibly static, 	 or an enumerator.  */
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* When this goes into scope, it will be a non-local reference.  */
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* [class.union]  	     If a union contains a static data member, or a member of 	     reference type, the program is ill-formed. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' may not be static because it is a member of a union"
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' may not have reference type `%T' because it is a member of a union"
argument_list|,
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* ``A local class cannot have static data members.'' ARM 9.4 */
if|if
condition|(
name|current_function_decl
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"field `%D' in local class cannot be static"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Perform error checking that did not get done in 	 grokdeclarator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared function type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared method type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
continue|continue;
comment|/* Now it can only be a FIELD_DECL.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
condition|)
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is of reference type, check if it needs an init. 	 Also do a little ANSI jig if necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|SET_CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
operator|*
name|cant_have_default_ctor_p
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static reference `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
condition|)
name|has_pointers
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|type
argument_list|)
condition|)
name|SET_CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|type
argument_list|)
condition|)
name|SET_CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|x
argument_list|)
operator|||
name|TYPE_HAS_MUTABLE_P
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_HAS_MUTABLE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pod_type_p
argument_list|(
name|type
argument_list|)
condition|)
comment|/* DR 148 now allows pointers to members (which are POD themselves),            to be allowed in POD structs.  */
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|zero_init_p
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_NON_ZERO_INIT_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|SET_CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
operator|*
name|cant_have_default_ctor_p
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static const member `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* A field that is pseudo-const makes the structure likewise.  */
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator||=
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|,
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator||
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Core issue 80: A nonstatic data member is required to have a 	 different name from the class iff the class has a 	 user-defined constructor.  */
if|if
condition|(
name|constructor_name_p
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"field `%#D' with same name as class"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* We set DECL_C_BIT_FIELD in grokbitfield. 	 If the type and width are valid, we'll also set DECL_BIT_FIELD.  */
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
condition|)
name|check_bitfield_decl
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|check_field_decl
argument_list|(
name|x
argument_list|,
name|t
argument_list|,
name|cant_have_const_ctor_p
argument_list|,
name|cant_have_default_ctor_p
argument_list|,
name|no_const_asn_ref_p
argument_list|,
operator|&
name|any_default_members
argument_list|)
expr_stmt|;
block|}
comment|/* Effective C++ rule 11.  */
if|if
condition|(
name|has_pointers
operator|&&
name|warn_ecpp
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%#T' has pointer data members"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"  but does not override `%T(const %T&)'"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|warning
argument_list|(
literal|"  or `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|warning
argument_list|(
literal|"  but does not override `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Check anonymous struct/anonymous union fields.  */
name|finish_struct_anon
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* We've built up the list of access declarations in reverse order.      Fix that now.  */
operator|*
name|access_decls
operator|=
name|nreverse
argument_list|(
operator|*
name|access_decls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TYPE is an empty class type, records its OFFSET in the table of    OFFSETS.  */
end_comment

begin_function
specifier|static
name|int
name|record_subobject_offset
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|offset
parameter_list|,
name|splay_tree
name|offsets
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|is_empty_class
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record the location of this empty object in OFFSETS.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|offsets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|splay_tree_insert
argument_list|(
name|offsets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|offset
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|NULL_TREE
argument_list|)
expr_stmt|;
name|n
operator|->
name|value
operator|=
operator|(
operator|(
name|splay_tree_value
operator|)
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if TYPE is an empty class type and there is    already an entry in OFFSETS for the same TYPE as the same OFFSET.  */
end_comment

begin_function
specifier|static
name|int
name|check_subobject_offset
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|offset
parameter_list|,
name|splay_tree
name|offsets
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|is_empty_class
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record the location of this empty object in OFFSETS.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|offsets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Walk through all the subobjects of TYPE (located at OFFSET).  Call    F for every subobject, passing it the type, offset, and table of    OFFSETS.  If VBASES_P is one, then virtual non-primary bases should    be traversed.     If MAX_OFFSET is non-NULL, then subobjects with an offset greater    than MAX_OFFSET will not be walked.     If F returns a nonzero value, the traversal ceases, and that value    is returned.  Otherwise, returns zero.  */
end_comment

begin_function
specifier|static
name|int
name|walk_subobject_offsets
parameter_list|(
name|tree
name|type
parameter_list|,
name|subobject_offset_fn
name|f
parameter_list|,
name|tree
name|offset
parameter_list|,
name|splay_tree
name|offsets
parameter_list|,
name|tree
name|max_offset
parameter_list|,
name|int
name|vbases_p
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|tree
name|type_binfo
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If this OFFSET is bigger than the MAX_OFFSET, then we should      stop.  */
if|if
condition|(
name|max_offset
operator|&&
name|INT_CST_LT
argument_list|(
name|max_offset
argument_list|,
name|offset
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|type_binfo
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|field
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Avoid recursing into objects that are not interesting.  */
if|if
condition|(
operator|!
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record the location of TYPE.  */
name|r
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
comment|/* Iterate through the direct base classes of TYPE.  */
if|if
condition|(
operator|!
name|type_binfo
condition|)
name|type_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|type_binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo_offset
decl_stmt|;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|type_binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|vbases_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|binfo_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|orig_binfo
decl_stmt|;
comment|/* We cannot rely on BINFO_OFFSET being set for the base 		 class yet, but the offsets for direct non-virtual 		 bases can be calculated by going back to the TYPE.  */
name|orig_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|binfo_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|orig_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|walk_subobject_offsets
argument_list|(
name|binfo
argument_list|,
name|f
argument_list|,
name|binfo_offset
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
operator|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|?
comment|/*vbases_p=*/
literal|0
else|:
name|vbases_p
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|tree
name|vbase
decl_stmt|;
comment|/* Iterate through the virtual base classes of TYPE.  In G++ 	     3.2, we included virtual bases in the direct base class 	     loop above, which results in incorrect results; the 	     correct offsets for virtual bases are only known when 	     working with the most derived type.  */
if|if
condition|(
name|vbases_p
condition|)
for|for
control|(
name|vbase
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
name|binfo
operator|=
name|TREE_VALUE
argument_list|(
name|vbase
argument_list|)
expr_stmt|;
name|r
operator|=
name|walk_subobject_offsets
argument_list|(
name|binfo
argument_list|,
name|f
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
else|else
block|{
comment|/* We still have to walk the primary base, if it is 		 virtual.  (If it is non-virtual, then it was walked 		 above.)  */
name|vbase
operator|=
name|get_primary_binfo
argument_list|(
name|type_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbase
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
operator|&&
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|vbase
argument_list|)
operator|==
name|type_binfo
condition|)
block|{
name|r
operator|=
operator|(
name|walk_subobject_offsets
argument_list|(
name|vbase
argument_list|,
name|f
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
block|}
block|}
comment|/* Iterate through the fields of TYPE.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|tree
name|field_offset
decl_stmt|;
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|field_offset
operator|=
name|byte_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
comment|/* In G++ 3.2, DECL_FIELD_OFFSET was used.  */
name|field_offset
operator|=
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|r
operator|=
name|walk_subobject_offsets
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|f
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|field_offset
argument_list|)
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
comment|/*vbases_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|element_type
init|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|index
decl_stmt|;
comment|/* Avoid recursing into objects that are not interesting.  */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|element_type
argument_list|)
operator|||
operator|!
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|element_type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Step through each of the elements in the array.  */
for|for
control|(
name|index
operator|=
name|size_zero_node
init|;
comment|/* G++ 3.2 had an off-by-one error here.  */
operator|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|?
operator|!
name|INT_CST_LT
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
name|index
argument_list|)
else|:
name|INT_CST_LT
argument_list|(
name|index
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|)
condition|;
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|index
argument_list|,
name|size_one_node
argument_list|)
control|)
block|{
name|r
operator|=
name|walk_subobject_offsets
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|f
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
name|max_offset
argument_list|,
comment|/*vbases_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this new OFFSET is bigger than the MAX_OFFSET, then 	     there's no point in iterating through the remaining 	     elements of the array.  */
if|if
condition|(
name|max_offset
operator|&&
name|INT_CST_LT
argument_list|(
name|max_offset
argument_list|,
name|offset
argument_list|)
condition|)
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record all of the empty subobjects of TYPE (located at OFFSET) in    OFFSETS.  If VBASES_P is nonzero, virtual bases of TYPE are    examined.  */
end_comment

begin_function
specifier|static
name|void
name|record_subobject_offsets
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|offset
parameter_list|,
name|splay_tree
name|offsets
parameter_list|,
name|int
name|vbases_p
parameter_list|)
block|{
name|walk_subobject_offsets
argument_list|(
name|type
argument_list|,
name|record_subobject_offset
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
comment|/*max_offset=*/
name|NULL_TREE
argument_list|,
name|vbases_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if any of the empty subobjects of TYPE (located at    OFFSET) conflict with entries in OFFSETS.  If VBASES_P is nonzero,    virtual bases of TYPE are examined.  */
end_comment

begin_function
specifier|static
name|int
name|layout_conflict_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|offset
parameter_list|,
name|splay_tree
name|offsets
parameter_list|,
name|int
name|vbases_p
parameter_list|)
block|{
name|splay_tree_node
name|max_node
decl_stmt|;
comment|/* Get the node in OFFSETS that indicates the maximum offset where      an empty subobject is located.  */
name|max_node
operator|=
name|splay_tree_max
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
comment|/* If there aren't any empty subobjects, then there's no point in      performing this check.  */
if|if
condition|(
operator|!
name|max_node
condition|)
return|return
literal|0
return|;
return|return
name|walk_subobject_offsets
argument_list|(
name|type
argument_list|,
name|check_subobject_offset
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
call|(
name|tree
call|)
argument_list|(
name|max_node
operator|->
name|key
argument_list|)
argument_list|,
name|vbases_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is a FIELD_DECL corresponding either to a base subobject of a    non-static data member of the type indicated by RLI.  BINFO is the    binfo corresponding to the base subobject, OFFSETS maps offsets to    types already located at those offsets.  This function determines    the position of the DECL.  */
end_comment

begin_function
specifier|static
name|void
name|layout_nonempty_base_or_field
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|splay_tree
name|offsets
parameter_list|)
block|{
name|tree
name|offset
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|field_p
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
comment|/* For the purposes of determining layout conflicts, we want to 	 use the class type of BINFO; TREE_TYPE (DECL) will be the 	 CLASSTYPE_AS_BASE version, which does not contain entries for 	 zero-sized bases.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|field_p
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|field_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* Try to place the field.  It may take more than one try if we have      a hard time placing the field without putting two objects of the      same type at the same address.  */
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|record_layout_info_s
name|old_rli
init|=
operator|*
name|rli
decl_stmt|;
comment|/* Place this field.  */
name|place_field
argument_list|(
name|rli
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|offset
operator|=
name|byte_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We have to check to see whether or not there is already 	 something of the same type at the offset we're about to use. 	 For example, consider: 	  	   struct S {}; 	   struct T : public S { int i; }; 	   struct U : public S, public T {}; 	  	 Here, we put S at offset zero in U.  Then, we can't put T at 	 offset zero -- its S component would be at the same address 	 as the S we already allocated.  So, we have to skip ahead. 	 Since all data members, including those whose type is an 	 empty class, have nonzero size, any overlap can happen only 	 with a direct or indirect base-class -- it can't happen with 	 a data member.  */
comment|/* In a union, overlap is permitted; all members are placed at 	 offset zero.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
break|break;
comment|/* G++ 3.2 did not check for overlaps when placing a non-empty 	 virtual base.  */
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|binfo
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
break|break;
if|if
condition|(
name|layout_conflict_p
argument_list|(
name|field_p
condition|?
name|type
else|:
name|binfo
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|,
name|field_p
argument_list|)
condition|)
block|{
comment|/* Strip off the size allocated to this field.  That puts us 	     at the first place we could have put the field with 	     proper alignment.  */
operator|*
name|rli
operator|=
name|old_rli
expr_stmt|;
comment|/* Bump up by the alignment required for the type.  */
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|bitsize_int
argument_list|(
name|binfo
condition|?
name|CLASSTYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* There was no conflict.  We're done laying out this field.  */
break|break;
block|}
comment|/* Now that we know where it will be placed, update its      BINFO_OFFSET.  */
if|if
condition|(
name|binfo
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
comment|/* Indirect virtual bases may have a nonzero BINFO_OFFSET at        this point because their BINFO_OFFSET is copied from another        hierarchy.  Therefore, we may not need to add the entire        OFFSET.  */
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|size_diffop
argument_list|(
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|offset
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if TYPE is empty and OFFSET is nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|empty_base_at_nonzero_offset_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|offset
parameter_list|,
name|splay_tree
name|offsets
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|is_empty_class
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Layout the empty base BINFO.  EOC indicates the byte currently just    past the end of the class, and should be correctly aligned for a    class of the type indicated by BINFO; OFFSETS gives the offsets of    the empty bases allocated so far. T is the most derived    type.  Return nonzero iff we added it at the end.  */
end_comment

begin_function
specifier|static
name|bool
name|layout_empty_base
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|eoc
parameter_list|,
name|splay_tree
name|offsets
parameter_list|)
block|{
name|tree
name|alignment
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|bool
name|atend
init|=
name|false
decl_stmt|;
comment|/* This routine should only be used for empty classes.  */
name|my_friendly_assert
argument_list|(
name|is_empty_class
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|20000321
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|ssize_int
argument_list|(
name|CLASSTYPE_ALIGN_UNIT
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|size_diffop
argument_list|(
name|size_zero_node
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_abi
condition|)
name|warning
argument_list|(
literal|"offset of empty base `%T' may not be ABI-compliant and may"
literal|"change in a future version of GCC"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This is an empty base class.  We first try to put it at offset      zero.  */
if|if
condition|(
name|layout_conflict_p
argument_list|(
name|binfo
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|offsets
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
condition|)
block|{
comment|/* That didn't work.  Now, we move forward from the next 	 available spot in the class.  */
name|atend
operator|=
name|true
expr_stmt|;
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|eoc
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|layout_conflict_p
argument_list|(
name|binfo
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|offsets
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
condition|)
comment|/* We finally found a spot where there's no overlap.  */
break|break;
comment|/* There's overlap here, too.  Bump along to the next spot.  */
name|propagate_binfo_offsets
argument_list|(
name|binfo
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|atend
return|;
block|}
end_function

begin_comment
comment|/* Layout the the base given by BINFO in the class indicated by RLI.    *BASE_ALIGN is a running maximum of the alignments of    any base class.  OFFSETS gives the location of empty base    subobjects.  T is the most derived type.  Return nonzero if the new    object cannot be nearly-empty.  A new FIELD_DECL is inserted at    *NEXT_FIELD, unless BINFO is for an empty base class.       Returns the location at which the next field should be inserted.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|build_base_field
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|splay_tree
name|offsets
parameter_list|,
name|tree
modifier|*
name|next_field
parameter_list|)
block|{
name|tree
name|t
init|=
name|rli
operator|->
name|t
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
comment|/* This error is now reported in xref_tag, thus giving better        location information.  */
return|return
name|next_field
return|;
comment|/* Place the base class.  */
if|if
condition|(
operator|!
name|is_empty_class
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* The containing class is non-empty because it has a non-empty 	 base class.  */
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Create the FIELD_DECL.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|CLASSTYPE_AS_BASE
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_SIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_SIZE_UNIT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_USER_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Try to place the field.  It may take more than one try if we 	 have a hard time placing the field without putting two 	 objects of the same type at the same address.  */
name|layout_nonempty_base_or_field
argument_list|(
name|rli
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
comment|/* Add the new FIELD_DECL to the list of fields for T.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
operator|*
name|next_field
expr_stmt|;
operator|*
name|next_field
operator|=
name|decl
expr_stmt|;
name|next_field
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|eoc
decl_stmt|;
name|bool
name|atend
decl_stmt|;
comment|/* On some platforms (ARM), even empty classes will not be 	 byte-aligned.  */
name|eoc
operator|=
name|round_up
argument_list|(
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
argument_list|,
name|CLASSTYPE_ALIGN_UNIT
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|atend
operator|=
name|layout_empty_base
argument_list|(
name|binfo
argument_list|,
name|eoc
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
comment|/* A nearly-empty class "has no proper base class that is empty, 	 not morally virtual, and at an offset other than zero."  */
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|atend
condition|)
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The check above (used in G++ 3.2) is insufficient  because 	     an empty class placed at offset zero might itself have an 	     empty base at a nonzero offset.  */
elseif|else
if|if
condition|(
name|walk_subobject_offsets
argument_list|(
name|basetype
argument_list|,
name|empty_base_at_nonzero_offset_p
argument_list|,
name|size_zero_node
argument_list|,
comment|/*offsets=*/
name|NULL
argument_list|,
comment|/*max_offset=*/
name|NULL_TREE
argument_list|,
comment|/*vbases_p=*/
name|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_abi
condition|)
name|warning
argument_list|(
literal|"class `%T' will be considered nearly empty in a "
literal|"future version of GCC"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We do not create a FIELD_DECL for empty base classes because 	 it might overlap some other field.  We want to be able to 	 create CONSTRUCTORs for the class by iterating over the 	 FIELD_DECLs, and the back end does not handle overlapping 	 FIELD_DECLs.  */
comment|/* An empty virtual base causes a class to be non-empty 	 -- but in that case we do not need to clear CLASSTYPE_EMPTY_P 	 here because that was already done when the virtual table 	 pointer was created.  */
block|}
comment|/* Record the offsets of BINFO and its base subobjects.  */
name|record_subobject_offsets
argument_list|(
name|binfo
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|offsets
argument_list|,
comment|/*vbases_p=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|next_field
return|;
block|}
end_function

begin_comment
comment|/* Layout all of the non-virtual base classes.  Record empty    subobjects in OFFSETS.  T is the most derived type.  Return nonzero    if the type cannot be nearly empty.  The fields created    corresponding to the base classes will be inserted at    *NEXT_FIELD.  */
end_comment

begin_function
specifier|static
name|void
name|build_base_fields
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|splay_tree
name|offsets
parameter_list|,
name|tree
modifier|*
name|next_field
parameter_list|)
block|{
comment|/* Chain to hold all the new FIELD_DECLs which stand in for base class      subobjects.  */
name|tree
name|t
init|=
name|rli
operator|->
name|t
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The primary base class is always allocated first.  */
if|if
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|next_field
operator|=
name|build_base_field
argument_list|(
name|rli
argument_list|,
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|offsets
argument_list|,
name|next_field
argument_list|)
expr_stmt|;
comment|/* Now allocate the rest of the bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The primary base was already allocated above, so we don't 	 need to allocate it again here.  */
if|if
condition|(
name|base_binfo
operator|==
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
comment|/* Virtual bases are added at the end (a primary virtual base 	 will have already been added).  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|next_field
operator|=
name|build_base_field
argument_list|(
name|rli
argument_list|,
name|base_binfo
argument_list|,
name|offsets
argument_list|,
name|next_field
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Go through the TYPE_METHODS of T issuing any appropriate    diagnostics, figuring out which methods override which other    methods, and so forth.  */
end_comment

begin_function
specifier|static
name|void
name|check_methods
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
comment|/* If this was an evil function, don't keep it in class.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|x
argument_list|)
operator|&&
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|check_for_override
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"initializer specified for non-virtual method `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* The name of the field is the original field name 	 Save this in auxiliary field for later overloading.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* FN is a constructor or destructor.  Clone the declaration to create    a specialized in-charge or not-in-charge version, as indicated by    NAME.  */
end_comment

begin_function
specifier|static
name|tree
name|build_clone
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|parms
decl_stmt|;
name|tree
name|clone
decl_stmt|;
comment|/* Copy the function.  */
name|clone
operator|=
name|copy_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Remember where this function came from.  */
name|DECL_CLONED_FUNCTION
argument_list|(
name|clone
argument_list|)
operator|=
name|fn
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|clone
argument_list|)
operator|=
name|fn
expr_stmt|;
comment|/* Reset the function name.  */
name|DECL_NAME
argument_list|(
name|clone
argument_list|)
operator|=
name|name
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|clone
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* There's no pending inline data for this function.  */
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|clone
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* And it hasn't yet been deferred.  */
name|DECL_DEFERRED_FN
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The base-class destructor is not virtual.  */
if|if
condition|(
name|name
operator|==
name|base_dtor_identifier
condition|)
block|{
name|DECL_VIRTUAL_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|clone
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
name|DECL_VINDEX
argument_list|(
name|clone
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If there was an in-charge parameter, drop it from the function      type.  */
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|exceptions
decl_stmt|;
name|exceptions
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the `this' parameter.  */
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* Skip the in-charge parameter.  */
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* And the VTT parm, in a complete [cd]tor.  */
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_NEEDS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* If this is subobject constructor or destructor, add the vtt 	 parameter.  */
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
operator|=
name|build_method_type_directly
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceptions
condition|)
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|,
name|exceptions
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
operator|=
name|cp_build_type_attribute_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the function parameters.  But, DECL_ARGUMENTS on a TEMPLATE_DECL      aren't function parameters; those are the template parameters.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|clone
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
operator|=
name|copy_list
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the in-charge parameter.  */
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* And the VTT parm, in a complete [cd]tor.  */
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NEEDS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|parms
argument_list|)
operator|=
name|clone
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create the RTL for this function.  */
name|SET_DECL_RTL
argument_list|(
name|clone
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|clone
argument_list|,
name|NULL
argument_list|,
comment|/*top_level=*/
literal|1
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
comment|/* Make it easy to find the CLONE given the FN.  */
name|TREE_CHAIN
argument_list|(
name|clone
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
operator|=
name|clone
expr_stmt|;
comment|/* If this is a template, handle the DECL_TEMPLATE_RESULT as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|clone
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|result
decl_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|clone
argument_list|)
operator|=
name|build_clone
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
operator|=
name|copy_node
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|result
argument_list|)
operator|=
name|clone
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DEFERRED_FN
argument_list|(
name|fn
argument_list|)
condition|)
name|defer_fn
argument_list|(
name|clone
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
end_function

begin_comment
comment|/* Produce declarations for all appropriate clones of FN.  If    UPDATE_METHOD_VEC_P is nonzero, the clones are added to the    CLASTYPE_METHOD_VEC as well.  */
end_comment

begin_function
name|void
name|clone_function_decl
parameter_list|(
name|tree
name|fn
parameter_list|,
name|int
name|update_method_vec_p
parameter_list|)
block|{
name|tree
name|clone
decl_stmt|;
comment|/* Avoid inappropriate cloning.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_CLONED_FUNCTION
argument_list|(
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* For each constructor, we need two variants: an in-charge version 	 and a not-in-charge version.  */
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|complete_ctor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|base_ctor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|20000411
argument_list|)
expr_stmt|;
comment|/* For each destructor, we need three variants: an in-charge 	 version, a not-in-charge version, and an in-charge deleting 	 version.  We clone the deleting version first because that 	 means it will go second on the TYPE_METHODS list -- and that 	 corresponds to the correct layout order in the virtual 	 function table.             For a non-virtual destructor, we do not build a deleting 	 destructor.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|deleting_dtor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|complete_dtor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|clone
operator|=
name|build_clone
argument_list|(
name|fn
argument_list|,
name|base_dtor_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_method_vec_p
condition|)
name|add_method
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|clone
argument_list|)
argument_list|,
name|clone
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Note that this is an abstract function that is never emitted.  */
name|DECL_ABSTRACT
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is an in charge constructor, which is being defined. This will    have had an in class declaration, from whence clones were    declared. An out-of-class definition can specify additional default    arguments. As it is the clones that are involved in overload    resolution, we must propagate the information from the DECL to its    clones.  */
end_comment

begin_function
name|void
name|adjust_clone_args
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|clone
decl_stmt|;
for|for
control|(
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
init|;
name|clone
operator|&&
name|DECL_CLONED_FUNCTION
argument_list|(
name|clone
argument_list|)
condition|;
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|clone
argument_list|)
control|)
block|{
name|tree
name|orig_clone_parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|orig_decl_parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|decl_parms
decl_stmt|,
name|clone_parms
decl_stmt|;
name|clone_parms
operator|=
name|orig_clone_parms
expr_stmt|;
comment|/* Skip the 'this' parameter.  */
name|orig_clone_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_clone_parms
argument_list|)
expr_stmt|;
name|orig_decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_decl_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
name|orig_decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_decl_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
name|orig_decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_decl_parms
argument_list|)
expr_stmt|;
name|clone_parms
operator|=
name|orig_clone_parms
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|clone_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|decl_parms
operator|=
name|orig_decl_parms
init|;
name|decl_parms
condition|;
name|decl_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_parms
argument_list|)
operator|,
name|clone_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parms
argument_list|)
control|)
block|{
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_parms
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|clone_parms
argument_list|)
argument_list|)
argument_list|,
literal|20010424
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|decl_parms
argument_list|)
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|clone_parms
argument_list|)
condition|)
block|{
comment|/* A default parameter has been added. Adjust the 		 clone's parameters.  */
name|tree
name|exceptions
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|clone_parms
operator|=
name|orig_decl_parms
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|clone_parms
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|orig_clone_parms
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|orig_clone_parms
argument_list|)
argument_list|,
name|clone_parms
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|clone_parms
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|orig_clone_parms
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_method_type_directly
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
argument_list|)
argument_list|,
name|clone_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceptions
condition|)
name|type
operator|=
name|build_exception_variant
argument_list|(
name|type
argument_list|,
name|exceptions
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|clone
argument_list|)
operator|=
name|type
expr_stmt|;
name|clone_parms
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
name|my_friendly_assert
argument_list|(
operator|!
name|clone_parms
argument_list|,
literal|20010424
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For each of the constructors and destructors in T, create an    in-charge and not-in-charge variant.  */
end_comment

begin_function
specifier|static
name|void
name|clone_constructors_and_destructors
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
comment|/* If for some reason we don't have a CLASSTYPE_METHOD_VEC, we bail      out now.  */
if|if
condition|(
operator|!
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
return|return;
for|for
control|(
name|fns
operator|=
name|CLASSTYPE_CONSTRUCTORS
argument_list|(
name|t
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
name|clone_function_decl
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|,
comment|/*update_method_vec_p=*/
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|t
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
name|clone_function_decl
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|,
comment|/*update_method_vec_p=*/
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all zero-width bit-fields from T.  */
end_comment

begin_function
specifier|static
name|void
name|remove_zero_width_bit_fields
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
modifier|*
name|fieldsp
decl_stmt|;
name|fieldsp
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|fieldsp
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|fieldsp
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
operator|*
name|fieldsp
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
operator|*
name|fieldsp
argument_list|)
condition|)
operator|*
name|fieldsp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldsp
argument_list|)
expr_stmt|;
else|else
name|fieldsp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldsp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns TRUE iff we need a cookie when dynamically allocating an    array whose elements have the indicated class TYPE.  */
end_comment

begin_function
specifier|static
name|bool
name|type_requires_array_cookie
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
name|bool
name|has_two_argument_delete_p
init|=
name|false
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|,
literal|20010712
argument_list|)
expr_stmt|;
comment|/* If there's a non-trivial destructor, we need a cookie.  In order      to iterate through the array calling the destructor for each      element, we'll have to know how many elements there are.  */
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If the usual deallocation function is a two-argument whose second      argument is of type `size_t', then we have to pass the size of      the array to the deallocation function, so we will need to store      a cookie.  */
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|ansi_opname
argument_list|(
name|VEC_DELETE_EXPR
argument_list|)
argument_list|,
comment|/*protect=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are no `operator []' members, or the lookup is      ambiguous, then we don't need a cookie.  */
if|if
condition|(
operator|!
name|fns
operator|||
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* Loop through all of the functions.  */
for|for
control|(
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|second_parm
decl_stmt|;
comment|/* Select the current function.  */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
comment|/* See if this function is a one-argument delete function.  If 	 it is, then it will be the usual deallocation function.  */
name|second_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_parm
operator|==
name|void_list_node
condition|)
return|return
name|false
return|;
comment|/* Otherwise, if we have a two-argument function and the second 	 argument is `size_t', it will be the usual deallocation 	 function -- unless there is one-argument function, too.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|second_parm
argument_list|)
operator|==
name|void_list_node
operator|&&
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|second_parm
argument_list|)
argument_list|,
name|sizetype
argument_list|)
condition|)
name|has_two_argument_delete_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|has_two_argument_delete_p
return|;
block|}
end_function

begin_comment
comment|/* Check the validity of the bases and members declared in T.  Add any    implicitly-generated functions (like copy-constructors and    assignment operators).  Compute various flag bits (like    CLASSTYPE_NON_POD_T) for T.  This routine works purely at the C++    level: i.e., independently of the ABI in use.  */
end_comment

begin_function
specifier|static
name|void
name|check_bases_and_members
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* Nonzero if we are not allowed to generate a default constructor      for this case.  */
name|int
name|cant_have_default_ctor
decl_stmt|;
comment|/* Nonzero if the implicitly generated copy constructor should take      a non-const reference argument.  */
name|int
name|cant_have_const_ctor
decl_stmt|;
comment|/* Nonzero if the the implicitly generated assignment operator      should take a non-const reference argument.  */
name|int
name|no_const_asn_ref
decl_stmt|;
name|tree
name|access_decls
decl_stmt|;
comment|/* By default, we use const reference arguments and generate default      constructors.  */
name|cant_have_default_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_const_ctor
operator|=
literal|0
expr_stmt|;
name|no_const_asn_ref
operator|=
literal|0
expr_stmt|;
comment|/* Check all the base-classes.  */
name|check_bases
argument_list|(
name|t
argument_list|,
operator|&
name|cant_have_default_ctor
argument_list|,
operator|&
name|cant_have_const_ctor
argument_list|,
operator|&
name|no_const_asn_ref
argument_list|)
expr_stmt|;
comment|/* Check all the data member declarations.  */
name|check_field_decls
argument_list|(
name|t
argument_list|,
operator|&
name|access_decls
argument_list|,
operator|&
name|cant_have_default_ctor
argument_list|,
operator|&
name|cant_have_const_ctor
argument_list|,
operator|&
name|no_const_asn_ref
argument_list|)
expr_stmt|;
comment|/* Check all the method declarations.  */
name|check_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* A nearly-empty class has to be vptr-containing; a nearly empty      class contains just a vptr.  */
if|if
condition|(
operator|!
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do some bookkeeping that will guide the generation of implicitly      declared member functions.  */
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|TYPE_HAS_REAL_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Synthesize any needed methods.  Note that methods will be synthesized      for anonymous unions; grok_x_components undoes that.  */
name|add_implicitly_declared_members
argument_list|(
name|t
argument_list|,
name|cant_have_default_ctor
argument_list|,
name|cant_have_const_ctor
argument_list|,
name|no_const_asn_ref
argument_list|)
expr_stmt|;
comment|/* Create the in-charge and not-in-charge variants of constructors      and destructors.  */
name|clone_constructors_and_destructors
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Process the using-declarations.  */
for|for
control|(
init|;
name|access_decls
condition|;
name|access_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|access_decls
argument_list|)
control|)
name|handle_using_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|access_decls
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Build and sort the CLASSTYPE_METHOD_VEC.  */
name|finish_struct_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not we will need a cookie when dynamically      allocating an array of this type.  */
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|u
operator|.
name|c
operator|.
name|vec_new_uses_cookie
operator|=
name|type_requires_array_cookie
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If T needs a pointer to its virtual function table, set TYPE_VFIELD    accordingly.  If a new vfield was created (because T doesn't have a    primary base class), then the newly created field is returned.  It    is not added to the TYPE_FIELDS list; it is the caller's    responsibility to do that.  Accumulate declared virtual functions    on VIRTUALS_P.  */
end_comment

begin_function
specifier|static
name|tree
name|create_vtable_ptr
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|virtuals_p
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
comment|/* Collect the virtual functions declared in T.  */
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|tree
name|new_virtual
init|=
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
decl_stmt|;
name|BV_FN
argument_list|(
name|new_virtual
argument_list|)
operator|=
name|fn
expr_stmt|;
name|BV_DELTA
argument_list|(
name|new_virtual
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new_virtual
argument_list|)
operator|=
operator|*
name|virtuals_p
expr_stmt|;
operator|*
name|virtuals_p
operator|=
name|new_virtual
expr_stmt|;
block|}
comment|/* If we couldn't find an appropriate base class, create a new field      here.  Even if there weren't any new virtual functions, we might need a      new virtual function table if we're supposed to include vptrs in      all classes that need them.  */
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
operator|*
name|virtuals_p
operator|||
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
comment|/* We build this decl with vtbl_ptr_type_node, which is a 	 `vtable_entry_type*'.  It might seem more precise to use 	 `vtable_entry_type (*)[N]' where N is the number of firtual 	 functions.  However, that would require the vtable pointer in 	 base classes to have a different type than the vtable pointer 	 in derived classes.  We could make that happen, but that 	 still wouldn't solve all the problems.  In particular, the 	 type-based alias analysis code would decide that assignments 	 to the base class vtable pointer can't alias assignments to 	 the derived class vtable pointer, since they have different 	 types.  Thus, in a derived class destructor, where the base 	 class constructor was inlined, we could generate bad code for 	 setting up the vtable pointer.             Therefore, we use one type for all vtable pointers.  We still 	 use a type-correct type; it's just doesn't indicate the array 	 bounds.  That's better than using `void*' or some such; it's 	 cleaner, and it let's the alias analysis code know that these 	 stores cannot alias stores to void*!  */
name|tree
name|field
decl_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|,
name|get_identifier
argument_list|(
name|VFIELD_BASE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|field
argument_list|)
operator|=
name|t
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|field
expr_stmt|;
comment|/* This class is non-empty.  */
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
comment|/* If there were any baseclasses, they can't possibly be at 	   offset zero any more, because that's where the vtable 	   pointer is.  So, converting to a base class is going to 	   take work.  */
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|field
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fixup the inline function given by INFO now that the class is    complete.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_pending_inline
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
decl_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|fn
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fixup the inline methods and friends in TYPE now that TYPE is    complete.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_inline_methods
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|method
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|&&
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Do inline member functions.  */
for|for
control|(
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
name|fixup_pending_inline
argument_list|(
name|method
argument_list|)
expr_stmt|;
comment|/* Do friends.  */
for|for
control|(
name|method
operator|=
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|type
argument_list|)
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
name|fixup_pending_inline
argument_list|(
name|TREE_VALUE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add OFFSET to all base types of BINFO which is a base in the    hierarchy dominated by T.     OFFSET, which is a type offset, is number of bytes.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_binfo_offsets
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|offset
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|primary_binfo
decl_stmt|;
comment|/* Update BINFO's offset.  */
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the primary base class.  */
name|primary_binfo
operator|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Scan all of the bases, pushing the BINFO_OFFSET adjust      downwards.  */
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
comment|/* On the first time through the loop, do the primary base. 	 Because the primary base need not be an immediate base, we 	 must handle the primary base specially.  */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|primary_binfo
condition|)
continue|continue;
name|base_binfo
operator|=
name|primary_binfo
expr_stmt|;
block|}
else|else
block|{
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Don't do the primary base twice.  */
if|if
condition|(
name|base_binfo
operator|==
name|primary_binfo
condition|)
continue|continue;
block|}
comment|/* Skip virtual bases that aren't our canonical primary base.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|base_binfo
argument_list|)
operator|!=
name|binfo
condition|)
continue|continue;
name|propagate_binfo_offsets
argument_list|(
name|base_binfo
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set BINFO_OFFSET for all of the virtual bases for RLI->T.  Update    TYPE_ALIGN and TYPE_SIZE for T.  OFFSETS gives the location of    empty subobjects of T.  */
end_comment

begin_function
specifier|static
name|void
name|layout_virtual_bases
parameter_list|(
name|record_layout_info
name|rli
parameter_list|,
name|splay_tree
name|offsets
parameter_list|)
block|{
name|tree
name|vbase
decl_stmt|;
name|tree
name|t
init|=
name|rli
operator|->
name|t
decl_stmt|;
name|bool
name|first_vbase
init|=
name|true
decl_stmt|;
name|tree
modifier|*
name|next_field
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
block|{
comment|/* In G++ 3.2, we incorrectly rounded the size before laying out 	 the virtual bases.  */
name|finish_record_layout
argument_list|(
name|rli
argument_list|,
comment|/*free_p=*/
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
comment|/* Packed structures don't need to have minimum size.  */
if|if
condition|(
operator|!
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|STRUCTURE_SIZE_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rli
operator|->
name|offset
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|rli
operator|->
name|bitpos
operator|=
name|bitsize_zero_node
expr_stmt|;
name|rli
operator|->
name|record_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Find the last field.  The artificial fields created for virtual      bases will go after the last extant field to date.  */
name|next_field
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|next_field
condition|)
name|next_field
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|next_field
argument_list|)
expr_stmt|;
comment|/* Go through the virtual bases, allocating space for each virtual      base that is not already a primary base class.  These are      allocated in inheritance graph order.  */
for|for
control|(
name|vbase
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|vbase
argument_list|)
condition|)
block|{
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|vbase
argument_list|)
decl_stmt|;
comment|/* This virtual base is not a primary base of any class in the 	     hierarchy, so we have to add space for it.  */
name|next_field
operator|=
name|build_base_field
argument_list|(
name|rli
argument_list|,
name|vbase
argument_list|,
name|offsets
argument_list|,
name|next_field
argument_list|)
expr_stmt|;
comment|/* If the first virtual base might have been placed at a 	     lower address, had we started from CLASSTYPE_SIZE, rather 	     than TYPE_SIZE, issue a warning.  There can be both false 	     positives and false negatives from this warning in rare 	     cases; to deal with all the possibilities would probably 	     require performing both layout algorithms and comparing 	     the results which is not particularly tractable.  */
if|if
condition|(
name|warn_abi
operator|&&
name|first_vbase
operator|&&
operator|(
name|tree_int_cst_lt
argument_list|(
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|round_up
argument_list|(
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
name|CLASSTYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vbase
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"offset of virtual base `%T' is not ABI-compliant and may change in a future version of GCC"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|first_vbase
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns the offset of the byte just past the end of the base class    BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|end_of_base
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|size
decl_stmt|;
if|if
condition|(
name|is_empty_class
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
comment|/* An empty class has zero CLASSTYPE_SIZE_UNIT, but we need to        allocate some space for it. It cannot have virtual bases, so        TYPE_SIZE_UNIT is fine.  */
name|size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|CLASSTYPE_SIZE_UNIT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the offset of the byte just past the end of the base class    with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero, then    only non-virtual bases are included.  */
end_comment

begin_function
specifier|static
name|tree
name|end_of_class
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|include_virtuals_p
parameter_list|)
block|{
name|tree
name|result
init|=
name|size_zero_node
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|include_virtuals_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
operator|!=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
name|offset
operator|=
name|end_of_base
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_CST_LT_UNSIGNED
argument_list|(
name|result
argument_list|,
name|offset
argument_list|)
condition|)
name|result
operator|=
name|offset
expr_stmt|;
block|}
comment|/* G++ 3.2 did not check indirect virtual bases.  */
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|include_virtuals_p
condition|)
for|for
control|(
name|binfo
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
name|offset
operator|=
name|end_of_base
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_CST_LT_UNSIGNED
argument_list|(
name|result
argument_list|,
name|offset
argument_list|)
condition|)
name|result
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Warn about bases of T that are inaccessible because they are    ambiguous.  For example:       struct S {};      struct T : public S {};      struct U : public S, public T {};     Here, `(S*) new U' is not allowed because there are two `S'    subobjects of U.  */
end_comment

begin_function
specifier|static
name|void
name|warn_about_ambiguous_bases
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
comment|/* Check direct bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_base
argument_list|(
name|t
argument_list|,
name|basetype
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
condition|)
name|warning
argument_list|(
literal|"direct base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Check for ambiguous virtual bases.  */
if|if
condition|(
name|extra_warnings
condition|)
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_base
argument_list|(
name|t
argument_list|,
name|basetype
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
condition|)
name|warning
argument_list|(
literal|"virtual base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two INTEGER_CSTs K1 and K2.  */
end_comment

begin_function
specifier|static
name|int
name|splay_tree_compare_integer_csts
parameter_list|(
name|splay_tree_key
name|k1
parameter_list|,
name|splay_tree_key
name|k2
parameter_list|)
block|{
return|return
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|k1
argument_list|,
operator|(
name|tree
operator|)
name|k2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Increase the size indicated in RLI to account for empty classes    that are "off the end" of the class.  */
end_comment

begin_function
specifier|static
name|void
name|include_empty_classes
parameter_list|(
name|record_layout_info
name|rli
parameter_list|)
block|{
name|tree
name|eoc
decl_stmt|;
name|tree
name|rli_size
decl_stmt|;
comment|/* It might be the case that we grew the class to allocate a      zero-sized base class.  That won't be reflected in RLI, yet,      because we are willing to overlay multiple bases at the same      offset.  However, now we need to make sure that RLI is big enough      to reflect the entire class.  */
name|eoc
operator|=
name|end_of_class
argument_list|(
name|rli
operator|->
name|t
argument_list|,
name|CLASSTYPE_AS_BASE
argument_list|(
name|rli
operator|->
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|rli_size
operator|=
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rli_size
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|INT_CST_LT_UNSIGNED
argument_list|(
name|rli_size
argument_list|,
name|eoc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
comment|/* In version 1 of the ABI, the size of a class that ends with 	   a bitfield was not rounded up to a whole multiple of a 	   byte.  Because rli_size_unit_so_far returns only the number 	   of fully allocated bytes, any extra bits were not included 	   in the size.  */
name|rli
operator|->
name|bitpos
operator|=
name|round_down
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
comment|/* The size should have been rounded to a whole byte.  */
name|my_friendly_assert
argument_list|(
name|tree_int_cst_equal
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|round_down
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
literal|20030903
argument_list|)
expr_stmt|;
name|rli
operator|->
name|bitpos
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rli
operator|->
name|bitpos
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|eoc
argument_list|,
name|rli_size
argument_list|)
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate    BINFO_OFFSETs for all of the base-classes.  Position the vtable    pointer.  Accumulate declared virtual functions on VIRTUALS_P.  */
end_comment

begin_function
specifier|static
name|void
name|layout_class_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|virtuals_p
parameter_list|)
block|{
name|tree
name|non_static_data_members
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|vptr
decl_stmt|;
name|record_layout_info
name|rli
decl_stmt|;
comment|/* Maps offsets (represented as INTEGER_CSTs) to a TREE_LIST of      types that appear at that offset.  */
name|splay_tree
name|empty_base_offsets
decl_stmt|;
comment|/* True if the last field layed out was a bit-field.  */
name|bool
name|last_field_was_bitfield
init|=
name|false
decl_stmt|;
comment|/* The location at which the next field should be inserted.  */
name|tree
modifier|*
name|next_field
decl_stmt|;
comment|/* T, as a base class.  */
name|tree
name|base_t
decl_stmt|;
comment|/* Keep track of the first non-static data member.  */
name|non_static_data_members
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Start laying out the record.  */
name|rli
operator|=
name|start_record_layout
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If possible, we reuse the virtual function table pointer from one      of our base classes.  */
name|determine_primary_base
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Create a pointer to our virtual function table.  */
name|vptr
operator|=
name|create_vtable_ptr
argument_list|(
name|t
argument_list|,
name|virtuals_p
argument_list|)
expr_stmt|;
comment|/* The vptr is always the first thing in the class.  */
if|if
condition|(
name|vptr
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|vptr
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vptr
expr_stmt|;
name|next_field
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
name|place_field
argument_list|(
name|rli
argument_list|,
name|vptr
argument_list|)
expr_stmt|;
block|}
else|else
name|next_field
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Build FIELD_DECLs for all of the non-virtual base-types.  */
name|empty_base_offsets
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_integer_csts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|build_base_fields
argument_list|(
name|rli
argument_list|,
name|empty_base_offsets
argument_list|,
name|next_field
argument_list|)
expr_stmt|;
comment|/* Layout the non-static data members.  */
for|for
control|(
name|field
operator|=
name|non_static_data_members
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|padding
decl_stmt|;
comment|/* We still pass things that aren't non-static data members to 	 the back-end, in case it wants to do something with them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|place_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* If the static data member has incomplete type, keep track 	     of it so that it can be completed later.  (The handling  	     of pending statics in finish_record_layout is 	     insufficient; consider:  	       struct S1; 	       struct S2 { static S1 s1; }; 	                     At this point, finish_record_layout will be called, but 	     S1 is still incomplete.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|maybe_register_incomplete_var
argument_list|(
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|padding
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If this field is a bit-field whose width is greater than its 	 type, then there are some special rules for allocating 	 it.  */
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
name|INT_CST_LT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|integer_type_kind
name|itk
decl_stmt|;
name|tree
name|integer_type
decl_stmt|;
name|bool
name|was_unnamed_p
init|=
name|false
decl_stmt|;
comment|/* We must allocate the bits as if suitably aligned for the 	     longest integer type that fits in this many bits.  type 	     of the field.  Then, we are supposed to use the left over 	     bits as additional padding.  */
for|for
control|(
name|itk
operator|=
name|itk_char
init|;
name|itk
operator|!=
name|itk_none
condition|;
operator|++
name|itk
control|)
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|integer_types
index|[
name|itk
index|]
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* ITK now indicates a type that is too large for the 	     field.  We have to back up by one to find the largest 	     type that fits.  */
name|integer_type
operator|=
name|integer_types
index|[
name|itk
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Figure out how much additional padding is required.  GCC 	     3.2 always created a padding field, even if it had zero 	     width.  */
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|||
name|INT_CST_LT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|integer_type
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* In a union, the padding field must have the full width 		   of the bit-field; all fields start at offset zero.  */
name|padding
operator|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|warn_abi
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|warning
argument_list|(
literal|"size assigned to `%T' may not be "
literal|"ABI-compliant and may change in a future "
literal|"version of GCC"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|padding
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|integer_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
comment|/* An unnamed bitfield does not normally affect the 	     alignment of the containing class on a target where 	     PCC_BITFIELD_TYPE_MATTERS.  But, the C++ ABI does not 	     make any exceptions for unnamed bitfields when the 	     bitfields are longer than their types.  Therefore, we 	     temporarily give the field a name.  */
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|was_unnamed_p
operator|=
name|true
expr_stmt|;
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|integer_type
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|integer_type
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|integer_type
argument_list|)
expr_stmt|;
name|layout_nonempty_base_or_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
name|empty_base_offsets
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_unnamed_p
condition|)
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now that layout has been performed, set the size of the 	     field to the size of its declared type; the rest of the 	     field is effectively invisible.  */
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We must also reset the DECL_MODE of the field.  */
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|DECL_MODE
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_abi
operator|&&
name|DECL_MODE
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Versions of G++ before G++ 3.4 did not reset the 	       DECL_MODE.  */
name|warning
argument_list|(
literal|"the offset of `%D' may not be ABI-compliant and may "
literal|"change in a future version of GCC"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
name|layout_nonempty_base_or_field
argument_list|(
name|rli
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
name|empty_base_offsets
argument_list|)
expr_stmt|;
comment|/* Remember the location of any empty classes in FIELD.  */
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|record_subobject_offsets
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|byte_position
argument_list|(
name|field
argument_list|)
argument_list|,
name|empty_base_offsets
argument_list|,
comment|/*vbases_p=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* If a bit-field does not immediately follow another bit-field, 	 and yet it starts in the middle of a byte, we have failed to 	 comply with the ABI.  */
if|if
condition|(
name|warn_abi
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|last_field_was_bitfield
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|size_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"offset of `%D' is not ABI-compliant and may change in a future version of GCC"
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* G++ used to use DECL_FIELD_OFFSET as if it were the byte 	 offset of the field.  */
if|if
condition|(
name|warn_abi
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|byte_position
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|contains_empty_class_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"`%D' contains empty classes which may cause base "
literal|"classes to be placed at different locations in a "
literal|"future version of GCC"
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* If we needed additional padding after this field, add it 	 now.  */
if|if
condition|(
name|padding
condition|)
block|{
name|tree
name|padding_field
decl_stmt|;
name|padding_field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|padding_field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|padding_field
argument_list|)
operator|=
name|padding
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|padding_field
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|padding_field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_nonempty_base_or_field
argument_list|(
name|rli
argument_list|,
name|padding_field
argument_list|,
name|NULL_TREE
argument_list|,
name|empty_base_offsets
argument_list|)
expr_stmt|;
block|}
name|last_field_was_bitfield
operator|=
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|)
condition|)
block|{
comment|/* Make sure that we are on a byte boundary so that the size of 	 the class without virtual bases will always be a round number 	 of bytes.  */
name|rli
operator|->
name|bitpos
operator|=
name|round_up
argument_list|(
name|rli
operator|->
name|bitpos
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|normalize_rli
argument_list|(
name|rli
argument_list|)
expr_stmt|;
block|}
comment|/* G++ 3.2 does not allow virtual bases to be overlaid with tail      padding.  */
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|include_empty_classes
argument_list|(
name|rli
argument_list|)
expr_stmt|;
comment|/* Delete all zero-width bit-fields from the list of fields.  Now      that the type is laid out they are no longer important.  */
name|remove_zero_width_bit_fields
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Create the version of T used for virtual bases.  We do not use      make_aggr_type for this version; this is an artificial type.  For      a POD type, we just reuse T.  */
if|if
condition|(
name|CLASSTYPE_NON_POD_P
argument_list|(
name|t
argument_list|)
operator|||
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|base_t
operator|=
name|make_node
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the size and alignment for the new type.  In G++ 3.2, all 	 empty classes were considered to have size zero when used as 	 base classes.  */
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TYPE_SIZE
argument_list|(
name|base_t
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|base_t
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
if|if
condition|(
name|warn_abi
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"layout of classes derived from empty class `%T' "
literal|"may change in a future version of GCC"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|eoc
decl_stmt|;
comment|/* If the ABI version is not at least two, and the last 	     field was a bit-field, RLI may not be on a byte 	     boundary.  In particular, rli_size_unit_so_far might 	     indicate the last complete byte, while rli_size_so_far 	     indicates the total number of bits used.  Therefore, 	     rli_size_so_far, rather than rli_size_unit_so_far, is 	     used to compute TYPE_SIZE_UNIT.  */
name|eoc
operator|=
name|end_of_class
argument_list|(
name|t
argument_list|,
comment|/*include_virtuals_p=*/
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|base_t
argument_list|)
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|rli_size_so_far
argument_list|(
name|rli
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|eoc
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|base_t
argument_list|)
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|rli_size_so_far
argument_list|(
name|rli
argument_list|)
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|eoc
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_ALIGN
argument_list|(
name|base_t
argument_list|)
operator|=
name|rli
operator|->
name|record_align
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|base_t
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Copy the fields from T.  */
name|next_field
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|base_t
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
operator|*
name|next_field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
operator|*
name|next_field
argument_list|)
operator|=
name|base_t
expr_stmt|;
name|DECL_FIELD_OFFSET
argument_list|(
operator|*
name|next_field
argument_list|)
operator|=
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_FIELD_BIT_OFFSET
argument_list|(
operator|*
name|next_field
argument_list|)
operator|=
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
operator|*
name|next_field
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
operator|*
name|next_field
argument_list|)
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|next_field
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|next_field
argument_list|)
expr_stmt|;
block|}
comment|/* Record the base version of the type.  */
name|CLASSTYPE_AS_BASE
argument_list|(
name|t
argument_list|)
operator|=
name|base_t
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|base_t
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
else|else
name|CLASSTYPE_AS_BASE
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Every empty class contains an empty class.  */
if|if
condition|(
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Set the TYPE_DECL for this type to contain the right      value for DECL_OFFSET, so that we can use it as part      of a COMPONENT_REF for multiple inheritance.  */
name|layout_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now fix up any virtual base class types that we left lying      around.  We must get these done before we try to lay out the      virtual function table.  As a side-effect, this will remove the      base subobject fields.  */
name|layout_virtual_bases
argument_list|(
name|rli
argument_list|,
name|empty_base_offsets
argument_list|)
expr_stmt|;
comment|/* Make sure that empty classes are reflected in RLI at this       point.  */
name|include_empty_classes
argument_list|(
name|rli
argument_list|)
expr_stmt|;
comment|/* Make sure not to create any structures with zero size.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|rli_size_unit_so_far
argument_list|(
name|rli
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
condition|)
name|place_field
argument_list|(
name|rli
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let the back-end lay out the type.  */
name|finish_record_layout
argument_list|(
name|rli
argument_list|,
comment|/*free_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Warn about bases that can't be talked about due to ambiguity.  */
name|warn_about_ambiguous_bases
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|empty_base_offsets
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the virtual function with which the vtable for TYPE is    emitted, or NULL_TREE if that heuristic is not applicable to TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|key_method
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|method
decl_stmt|;
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|||
name|processing_template_decl
operator|||
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
operator|||
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|method
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|method
operator|!=
name|NULL_TREE
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|method
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|method
argument_list|)
condition|)
return|return
name|method
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Perform processing required when the definition of T (a class type)    is complete.  */
end_comment

begin_function
name|void
name|finish_struct_1
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
comment|/* A TREE_LIST.  The TREE_VALUE of each node is a FUNCTION_DECL.  */
name|tree
name|virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|n_fields
init|=
literal|0
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|popclass
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|fixup_inline_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Make assumptions about the class; we'll reset the flags if      necessary.  */
name|CLASSTYPE_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_CONTAINS_EMPTY_CLASS_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do end-of-class semantic processing: checking the validity of the      bases and members and add implicitly generated methods.  */
name|check_bases_and_members
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Find the key method.  */
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|t
argument_list|)
operator|=
name|key_method
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If a polymorphic class has no key method, we may emit the vtable 	 in every translation unit where the class definition appears.  */
if|if
condition|(
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|keyed_classes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|keyed_classes
argument_list|)
expr_stmt|;
block|}
comment|/* Layout the class itself.  */
name|layout_class_type
argument_list|(
name|t
argument_list|,
operator|&
name|virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_AS_BASE
argument_list|(
name|t
argument_list|)
operator|!=
name|t
condition|)
comment|/* We use the base type for trivial assignments, and hence it        needs a mode.  */
name|compute_record_mode
argument_list|(
name|CLASSTYPE_AS_BASE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that we get our own copy of the vfield FIELD_DECL.  */
name|vfield
operator|=
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfield
operator|&&
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|primary
init|=
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|primary
argument_list|)
argument_list|)
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
comment|/* The vtable better be at the start.  */
name|my_friendly_assert
argument_list|(
name|integer_zerop
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|integer_zerop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|primary
argument_list|)
argument_list|)
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
name|vfield
operator|=
name|copy_decl
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
block|}
else|else
name|my_friendly_assert
argument_list|(
operator|!
name|vfield
operator|||
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|==
name|t
argument_list|,
literal|20010726
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
name|nreverse
argument_list|(
name|virtuals
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we created a new vtbl pointer for this class, add it to the      list.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If necessary, create the primary vtable for this class.  */
if|if
condition|(
name|virtuals
operator|||
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* We must enter these virtuals into the table.  */
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|build_primary_vtable
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
comment|/* Here we know enough to change the type of our virtual 	   function table, but we will wait until later this function.  */
name|build_primary_vtable
argument_list|(
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|vindex
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|DECL_VIRTUAL_P
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|20000116
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|t
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|20000116
argument_list|)
expr_stmt|;
comment|/* Add entries for virtual functions introduced by this class.  */
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|virtuals
argument_list|)
expr_stmt|;
comment|/* Set DECL_VINDEX for all functions declared in this class.  */
for|for
control|(
name|vindex
operator|=
literal|0
operator|,
name|fn
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
operator|,
name|vindex
operator|+=
operator|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|?
name|TARGET_VTABLE_USES_DESCRIPTORS
else|:
literal|1
operator|)
control|)
block|{
name|tree
name|fndecl
init|=
name|BV_FN
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|fndecl
argument_list|)
condition|)
comment|/* A thunk. We should never be calling this entry directly 	       from this vtable -- we'd use the entry for the non 	       thunk base function.  */
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_shared_int_cst
argument_list|(
name|vindex
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_struct_bits
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Complete the rtl for any static member objects of the type we're      working on.  */
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
name|DECL_MODE
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Done with FIELDS...now decide whether to sort these for      faster lookups later.       We use a small number because most searches fail (succeeding      ultimately as the search bores through the inheritance      hierarchy), and we want this failure to occur quickly.  */
name|n_fields
operator|=
name|count_fields
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_fields
operator|>
literal|7
condition|)
block|{
name|struct
name|sorted_fields_type
modifier|*
name|field_vec
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sorted_fields_type
argument_list|)
operator|+
name|n_fields
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|field_vec
operator|->
name|len
operator|=
name|n_fields
expr_stmt|;
name|add_fields_to_record_type
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|field_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|field_vec
operator|->
name|elts
argument_list|,
name|n_fields
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|field_decl_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|retrofit_lang_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|field_vec
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
comment|/* Mark the fact that constructor for T could affect anybody 	   inheriting from T who wants to initialize vtables for 	   VFIELDS's type.  */
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Make the rtl for any new vtables we have created, and unmark      the base types we marked.  */
name|finish_vtbls
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Build the VTT for T.  */
name|build_vtt
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_nonvdtor
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|warning
argument_list|(
literal|"`%#T' has virtual functions but non-virtual destructor"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|complete_vars
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_overloaded_virtual
condition|)
name|warn_hidden
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|maybe_suppress_debug_info
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_class_hierarchy
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
operator|!
name|LOCAL_CLASS_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When T was built up, the member declarations were added in reverse    order.  Rearrange them to declaration order.  */
end_comment

begin_function
name|void
name|unreverse_member_declarations
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|next
decl_stmt|;
name|tree
name|prev
decl_stmt|;
name|tree
name|x
decl_stmt|;
comment|/* The following lists are all in reverse order.  Put them in      declaration order now.  */
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_DECL_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|CLASSTYPE_DECL_LIST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in      reverse order, so we can't just use nreverse.  */
name|prev
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
condition|;
name|x
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|finish_struct
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|location_t
name|saved_loc
init|=
name|input_location
decl_stmt|;
comment|/* Now that we've got all the field declarations, reverse everything      as necessary.  */
name|unreverse_member_declarations
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
operator|&
name|t
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
comment|/* Nadger the current location so that diagnostics point to the start of      the struct, not the end.  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|finish_struct_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
block|}
else|else
name|finish_struct_1
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|saved_loc
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
name|popclass
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to finish struct, but kicked out due to previous parse errors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|at_function_scope_p
argument_list|()
condition|)
name|add_stmt
argument_list|(
name|build_min
argument_list|(
name|TAG_DEFN
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the dynamic type of INSTANCE, if known.    Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  *NONNULL should be initialized    before this function is called.  */
end_comment

begin_function
specifier|static
name|tree
name|fixed_type_or_null
parameter_list|(
name|tree
name|instance
parameter_list|,
name|int
modifier|*
name|nonnull
parameter_list|,
name|int
modifier|*
name|cdtorp
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|SAVE_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
return|return
name|NULL_TREE
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Propagate nonnull.  */
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
return|;
block|}
comment|/* fall through...  */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|==
name|current_class_ptr
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
comment|/* if we're in a ctor or dtor, we know our type.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cdtorp
condition|)
operator|*
name|cdtorp
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Reference variables should be references to objects.  */
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
comment|/* DECL_VAR_MARKED_P is used to prevent recursion; a 	     variable's initializer may refer to the variable 	     itself.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|instance
argument_list|)
operator|&&
operator|!
name|DECL_VAR_MARKED_P
argument_list|(
name|instance
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|DECL_VAR_MARKED_P
argument_list|(
name|instance
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|fixed_type_or_null
argument_list|(
name|DECL_INITIAL
argument_list|(
name|instance
argument_list|)
argument_list|,
name|nonnull
argument_list|,
name|cdtorp
argument_list|)
expr_stmt|;
name|DECL_VAR_MARKED_P
argument_list|(
name|instance
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the dynamic type of INSTANCE is known, and    equivalent to the static type.  We also handle the case where    INSTANCE is really a pointer. Return negative if this is a    ctor/dtor. There the dynamic type is known, but this might not be    the most derived base of the original object, and hence virtual    bases may not be layed out according to this type.     Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  *NONNULL should be initialized    before this function is called.  */
end_comment

begin_function
name|int
name|resolves_to_fixed_type_p
parameter_list|(
name|tree
name|instance
parameter_list|,
name|int
modifier|*
name|nonnull
parameter_list|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
name|int
name|cdtorp
init|=
literal|0
decl_stmt|;
name|tree
name|fixed
init|=
name|fixed_type_or_null
argument_list|(
name|instance
argument_list|,
name|nonnull
argument_list|,
operator|&
name|cdtorp
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixed
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|t
argument_list|,
name|fixed
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|cdtorp
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_class_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|current_class_depth
operator|=
literal|0
expr_stmt|;
name|current_class_stack_size
operator|=
literal|10
expr_stmt|;
name|current_class_stack
operator|=
name|xmalloc
argument_list|(
name|current_class_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|class_stack_node
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|local_classes
argument_list|,
literal|8
argument_list|,
literal|"local_classes"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PUBLIC
index|]
operator|=
name|access_public_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PRIVATE
index|]
operator|=
name|access_private_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PROTECTED
index|]
operator|=
name|access_protected_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE as    appropriate for TYPE.     So that we may avoid calls to lookup_name, we cache the _TYPE    nodes of local TYPE_DECLs in the TREE_TYPE field of the name.     For multiple inheritance, we perform a two-pass depth-first search    of the type lattice.  The first pass performs a pre-order search,    marking types after the type has had its fields installed in    the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely    unmarks the marked types.  If a field or member function name    appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of    that name becomes `error_mark_node'.  */
end_comment

begin_function
name|void
name|pushclass
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure there is enough room for the new entry on the stack.  */
if|if
condition|(
name|current_class_depth
operator|+
literal|1
operator|>=
name|current_class_stack_size
condition|)
block|{
name|current_class_stack_size
operator|*=
literal|2
expr_stmt|;
name|current_class_stack
operator|=
name|xrealloc
argument_list|(
name|current_class_stack
argument_list|,
name|current_class_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|class_stack_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert a new entry on the class stack.  */
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|name
operator|=
name|current_class_name
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|type
operator|=
name|current_class_type
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|access
operator|=
name|current_access_specifier
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
operator|=
literal|0
expr_stmt|;
name|current_class_depth
operator|++
expr_stmt|;
comment|/* Now set up the new type.  */
name|current_class_name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|current_class_name
operator|=
name|DECL_NAME
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
name|current_class_type
operator|=
name|type
expr_stmt|;
comment|/* By default, things in classes are private, while things in      structures or unions are public.  */
name|current_access_specifier
operator|=
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|type
argument_list|)
condition|?
name|access_private_node
else|:
name|access_public_node
operator|)
expr_stmt|;
if|if
condition|(
name|previous_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|type
operator|!=
name|previous_class_type
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|previous_class_type
argument_list|)
operator|)
operator|&&
name|current_class_depth
operator|==
literal|1
condition|)
block|{
comment|/* Forcibly remove any old class remnants.  */
name|invalidate_class_lookup_cache
argument_list|()
expr_stmt|;
block|}
comment|/* If we're about to enter a nested class, clear      IDENTIFIER_CLASS_VALUE for the enclosing classes.  */
if|if
condition|(
name|current_class_depth
operator|>
literal|1
condition|)
name|clear_identifier_class_values
argument_list|()
expr_stmt|;
name|pushlevel_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|previous_class_type
operator|||
name|current_class_depth
operator|>
literal|1
condition|)
block|{
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* If we are entering the scope of a template declaration (not a 	     specialization), we need to push all the using decls with 	     dependent scope too.  */
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|USING_DECL
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
condition|)
name|pushdecl_class_level
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|item
decl_stmt|;
comment|/* We are re-entering the same class we just left, so we don't 	 have to search the whole inheritance matrix to find all the 	 decls to bind again.  Instead, we install the cached 	 class_shadowed list, and walk through it binding names and 	 setting up IDENTIFIER_TYPE_VALUEs.  */
name|set_class_shadows
argument_list|(
name|previous_class_values
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|previous_class_values
init|;
name|item
condition|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_PURPOSE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|push_class_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|unuse_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|cxx_remember_type_decls
argument_list|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When we exit a toplevel class scope, we save the    IDENTIFIER_CLASS_VALUEs so that we can restore them quickly if we    reenter the class.  Here, we've entered some other class, so we    must invalidate our cache.  */
end_comment

begin_function
name|void
name|invalidate_class_lookup_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* The IDENTIFIER_CLASS_VALUEs are no longer valid.  */
for|for
control|(
name|t
operator|=
name|previous_class_values
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|previous_class_values
operator|=
name|NULL_TREE
expr_stmt|;
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current class scope. If we were in a class scope    previously, that is the one popped to.  */
end_comment

begin_function
name|void
name|popclass
parameter_list|(
name|void
parameter_list|)
block|{
name|poplevel_class
argument_list|()
expr_stmt|;
name|pop_class_decls
argument_list|()
expr_stmt|;
name|current_class_depth
operator|--
expr_stmt|;
name|current_class_name
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|name
expr_stmt|;
name|current_class_type
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|type
expr_stmt|;
name|current_access_specifier
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|access
expr_stmt|;
if|if
condition|(
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
condition|)
name|splay_tree_delete
argument_list|(
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if current_class_type is either T or a nested type of T.    We start looking from 1 because entry 0 is from global scope, and has    no type.  */
end_comment

begin_function
name|int
name|currently_open_class
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|same_type_p
argument_list|(
name|t
argument_list|,
name|current_class_type
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|current_class_depth
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
operator|&&
name|same_type_p
argument_list|(
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If either current_class_type or one of its enclosing classes are derived    from T, return the appropriate type.  Used to determine how we found    something via unqualified lookup.  */
end_comment

begin_function
name|tree
name|currently_open_derived_class
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* The bases of a dependent type are unknown.  */
if|if
condition|(
name|dependent_type_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|current_class_type
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|current_class_type
argument_list|)
condition|)
return|return
name|current_class_type
return|;
for|for
control|(
name|i
operator|=
name|current_class_depth
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
argument_list|)
condition|)
return|return
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* When entering a class scope, all enclosing class scopes' names with    static meaning (static variables, static functions, types and    enumerators) have to be visible.  This recursive function calls    pushclass for all enclosing class contexts until global or a local    scope is reached.  TYPE is the enclosed class.  */
end_comment

begin_function
name|void
name|push_nested_class
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|context
decl_stmt|;
comment|/* A namespace might be passed in error cases, like A::B:C.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
return|return;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undoes a push_nested_class call.  */
end_comment

begin_function
name|void
name|pop_nested_class
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|popclass
argument_list|()
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the number of extern "LANG" blocks we are nested within.  */
end_comment

begin_function
name|int
name|current_lang_depth
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|current_lang_base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_LANG_NAME to appropriate value    so that behavior of name-mangling machinery is correct.  */
end_comment

begin_function
name|void
name|push_lang_context
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|VARRAY_PUSH_TREE
argument_list|(
name|current_lang_base
argument_list|,
name|current_lang_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_java
condition|)
block|{
name|current_lang_name
operator|=
name|name
expr_stmt|;
comment|/* DECL_IGNORED_P is initially set for these types, to avoid clutter. 	 (See record_builtin_java_type in decl.c.)  However, that causes 	 incorrect debug entries if these types are actually used. 	 So we re-enable debug output after extern "Java".  */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_byte_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_short_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_int_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_long_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_float_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_double_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_char_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_boolean_type_node
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
block|{
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"language string `\"%s\"' not recognized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current language scope.  */
end_comment

begin_function
name|void
name|pop_lang_context
parameter_list|(
name|void
parameter_list|)
block|{
name|current_lang_name
operator|=
name|VARRAY_TOP_TREE
argument_list|(
name|current_lang_base
argument_list|)
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|current_lang_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Type instantiation routines.  */
end_comment

begin_comment
comment|/* Given an OVERLOAD and a TARGET_TYPE, return the function that    matches the TARGET_TYPE.  If there is no satisfactory match, return    error_mark_node, and issue a error& warning messages under control    of FLAGS.  Permit pointers to member function if FLAGS permits.  If    TEMPLATE_ONLY, the name of the overloaded function was a    template-id, and EXPLICIT_TARGS are the explicitly provided    template arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_address_of_overloaded_function
parameter_list|(
name|tree
name|target_type
parameter_list|,
name|tree
name|overload
parameter_list|,
name|tsubst_flags_t
name|flags
parameter_list|,
name|bool
name|template_only
parameter_list|,
name|tree
name|explicit_targs
parameter_list|)
block|{
comment|/* Here's what the standard says:              [over.over]         If the name is a function template, template argument deduction        is done, and if the argument deduction succeeds, the deduced        arguments are used to generate a single template function, which        is added to the set of overloaded functions considered.         Non-member functions and static member functions match targets of        type "pointer-to-function" or "reference-to-function."  Nonstatic        member functions match targets of type "pointer-to-member        function;" the function type of the pointer to member is used to        select the member function from the set of overloaded member        functions.  If a nonstatic member function is selected, the        reference to the overloaded function name is required to have the        form of a pointer to member as described in 5.3.1.         If more than one function is selected, any template functions in        the set are eliminated if the set also contains a non-template        function, and any given template function is eliminated if the        set contains a second template function that is more specialized        than the first according to the partial ordering rules 14.5.5.2.        After such eliminations, if any, there shall remain exactly one        selected function.  */
name|int
name|is_ptrmem
init|=
literal|0
decl_stmt|;
name|int
name|is_reference
init|=
literal|0
decl_stmt|;
comment|/* We store the matches in a TREE_LIST rooted here.  The functions      are the TREE_PURPOSE, not the TREE_VALUE, in this list, for easy      interoperability with most_specialized_instantiation.  */
name|tree
name|matches
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* By the time we get here, we should be seeing only real      pointer-to-member types, not the internal POINTER_TYPE to      METHOD_TYPE representation.  */
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|overload
argument_list|)
argument_list|,
literal|20030910
argument_list|)
expr_stmt|;
comment|/* Check that the TARGET_TYPE is reasonable.  */
if|if
condition|(
name|TYPE_PTRFN_P
argument_list|(
name|target_type
argument_list|)
condition|)
comment|/* This is OK.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|target_type
argument_list|)
condition|)
comment|/* This is OK, too.  */
name|is_ptrmem
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* This is OK, too.  This comes from a conversion to reference 	 type.  */
name|target_type
operator|=
name|build_reference_type
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|is_reference
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"\ cannot resolve overloaded function `%D' based on conversion to type `%T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If we can find a non-template function that matches, we can just      use it.  There's no point in generating template instantiations      if we're just going to throw them out anyhow.  But, of course, we      can only do this when we don't *need* a template function.  */
if|if
condition|(
operator|!
name|template_only
condition|)
block|{
name|tree
name|fns
decl_stmt|;
for|for
control|(
name|fns
operator|=
name|overload
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* We're not looking for templates just yet.  */
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|!=
name|is_ptrmem
condition|)
comment|/* We're looking for a non-static member, and this isn't 	       one, or vice versa.  */
continue|continue;
comment|/* Ignore anticipated decls of undeclared builtins.  */
if|if
condition|(
name|DECL_ANTICIPATED
argument_list|(
name|fn
argument_list|)
condition|)
continue|continue;
comment|/* See if there's a match.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|fntype
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_reference
condition|)
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_convert_arg
argument_list|(
name|target_type
argument_list|,
name|fntype
argument_list|,
name|fn
argument_list|)
condition|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|matches
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, if we've already got a match (or matches), there's no need      to proceed to the template functions.  But, if we don't have a      match we need to look at them, too.  */
if|if
condition|(
operator|!
name|matches
condition|)
block|{
name|tree
name|target_fn_type
decl_stmt|;
name|tree
name|target_arg_types
decl_stmt|;
name|tree
name|target_ret_type
decl_stmt|;
name|tree
name|fns
decl_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|target_fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|target_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|target_fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|target_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|target_fn_type
argument_list|)
expr_stmt|;
name|target_ret_type
operator|=
name|TREE_TYPE
argument_list|(
name|target_fn_type
argument_list|)
expr_stmt|;
comment|/* Never do unification on the 'this' parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_fn_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|target_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|target_arg_types
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|overload
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|instantiation
decl_stmt|;
name|tree
name|instantiation_type
decl_stmt|;
name|tree
name|targs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* We're only looking for templates.  */
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|!=
name|is_ptrmem
condition|)
comment|/* We're not looking for a non-static member, and this is 	       one, or vice versa.  */
continue|continue;
comment|/* Try to do argument deduction.  */
name|targs
operator|=
name|make_tree_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_type_unification
argument_list|(
name|fn
argument_list|,
name|explicit_targs
argument_list|,
name|targs
argument_list|,
name|target_arg_types
argument_list|,
name|target_ret_type
argument_list|,
name|DEDUCE_EXACT
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Argument deduction failed.  */
continue|continue;
comment|/* Instantiate the template.  */
name|instantiation
operator|=
name|instantiate_template
argument_list|(
name|fn
argument_list|,
name|targs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|instantiation
operator|==
name|error_mark_node
condition|)
comment|/* Instantiation failed.  */
continue|continue;
comment|/* See if there's a match.  */
name|instantiation_type
operator|=
name|TREE_TYPE
argument_list|(
name|instantiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|instantiation_type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|instantiation_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_reference
condition|)
name|instantiation_type
operator|=
name|build_pointer_type
argument_list|(
name|instantiation_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_convert_arg
argument_list|(
name|target_type
argument_list|,
name|instantiation_type
argument_list|,
name|instantiation
argument_list|)
condition|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|instantiation
argument_list|,
name|fn
argument_list|,
name|matches
argument_list|)
expr_stmt|;
block|}
comment|/* Now, remove all but the most specialized of the matches.  */
if|if
condition|(
name|matches
condition|)
block|{
name|tree
name|match
init|=
name|most_specialized_instantiation
argument_list|(
name|matches
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|!=
name|error_mark_node
condition|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|match
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we should have exactly one function in MATCHES.  */
if|if
condition|(
name|matches
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* There were *no* matches.  */
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
block|{
name|error
argument_list|(
literal|"no matches converting function `%D' to type `%#T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* print_candidates expects a chain with the functions in              TREE_VALUE slots, so we cons one up here (we're losing anyway,              so why be clever?).  */
for|for
control|(
init|;
name|overload
condition|;
name|overload
operator|=
name|OVL_NEXT
argument_list|(
name|overload
argument_list|)
control|)
name|matches
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|OVL_CURRENT
argument_list|(
name|overload
argument_list|)
argument_list|,
name|matches
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|matches
argument_list|)
condition|)
block|{
comment|/* There were too many matches.  */
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
block|{
name|tree
name|match
decl_stmt|;
name|error
argument_list|(
literal|"converting overloaded function `%D' to type `%#T' is ambiguous"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* Since print_candidates expects the functions in the 	     TREE_VALUE slot, we flip them here.  */
for|for
control|(
name|match
operator|=
name|matches
init|;
name|match
condition|;
name|match
operator|=
name|TREE_CHAIN
argument_list|(
name|match
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|match
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* Good, exactly one match.  Now, convert it to the correct type.  */
name|fn
operator|=
name|TREE_PURPOSE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|tf_ptrmem_ok
operator|)
operator|&&
operator|!
name|flag_ms_extensions
condition|)
block|{
specifier|static
name|int
name|explained
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|tf_error
operator|)
condition|)
return|return
name|error_mark_node
return|;
name|pedwarn
argument_list|(
literal|"assuming pointer to member `%D'"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|pedwarn
argument_list|(
literal|"(a pointer to member can only be formed with `&%E')"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we're doing overload resolution purely for the purpose of      determining conversion sequences, we should not consider the      function used.  If this conversion sequence is selected, the      function will be marked as used at this point.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|tf_conv
operator|)
condition|)
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRFN_P
argument_list|(
name|target_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|target_type
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
comment|/* The target must be a REFERENCE_TYPE.  Above, build_unary_op 	 will mark the function as addressed, but here we must do it 	 explicitly.  */
name|cxx_mark_addressable
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function will instantiate the type of the expression given in    RHS to match the type of LHSTYPE.  If errors exist, then return    error_mark_node. FLAGS is a bit mask.  If TF_ERROR is set, then    we complain on errors.  If we are not complaining, never modify rhs,    as overload resolution wants to try many possible instantiations, in    the hope that at least one will work.        For non-recursive calls, LHSTYPE should be a function, pointer to    function, or a pointer to member function.  */
end_comment

begin_function
name|tree
name|instantiate_type
parameter_list|(
name|tree
name|lhstype
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|tsubst_flags_t
name|flags
parameter_list|)
block|{
name|tsubst_flags_t
name|flags_in
init|=
name|flags
decl_stmt|;
name|flags
operator|&=
operator|~
name|tf_ptrmem_ok
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
operator|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
return|return
name|rhs
return|;
if|if
condition|(
name|flag_ms_extensions
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|lhstype
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
comment|/* Microsoft allows `A::f' to be resolved to a 	   pointer-to-member.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"argument of type `%T' does not match `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BASELINK
condition|)
name|rhs
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* We don't overwrite rhs if it is an overloaded function.      Copying it would destroy the tree link.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|rhs
operator|=
name|copy_node
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* This should really only be used when attempting to distinguish      what sort of a pointer to function we have.  For now, any      arithmetic operation which is not supported on pointers      is rejected as an error.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TYPE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|BUFFER_REF
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|new_rhs
decl_stmt|;
name|new_rhs
operator|=
name|instantiate_type
argument_list|(
name|build_pointer_type
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|new_rhs
expr_stmt|;
return|return
name|rhs
return|;
block|}
case|case
name|NOP_EXPR
case|:
name|rhs
operator|=
name|copy_node
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|addr
init|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
name|error_mark_node
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* Do not lose object's side effects.  */
name|addr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
case|case
name|OFFSET_REF
case|:
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|BASELINK_FUNCTIONS
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|flags_in
argument_list|)
return|;
comment|/* This can happen if we are forming a pointer-to-member for a 	 member template.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|fns
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|resolve_address_of_overloaded_function
argument_list|(
name|lhstype
argument_list|,
name|fns
argument_list|,
name|flags_in
argument_list|,
comment|/*template_only=*/
name|true
argument_list|,
name|args
argument_list|)
return|;
block|}
case|case
name|OVERLOAD
case|:
case|case
name|FUNCTION_DECL
case|:
return|return
name|resolve_address_of_overloaded_function
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|flags_in
argument_list|,
comment|/*template_only=*/
name|false
argument_list|,
comment|/*explicit_targs=*/
name|NULL_TREE
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
comment|/* Now we should have a baselink.  */
name|my_friendly_assert
argument_list|(
name|BASELINK_P
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|990412
argument_list|)
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|BASELINK_FUNCTIONS
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* This is too hard for now.  */
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"invalid operation on uninstantiated type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MODIFY_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ADDR_EXPR
case|:
block|{
if|if
condition|(
name|PTRMEM_OK_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|flags
operator||=
name|tf_ptrmem_ok
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
case|case
name|ENTRY_VALUE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the virtual function pointer field    (as an IDENTIFIER_NODE) for the given TYPE.  Note that    this may have to look back through base types to find the    ultimate field name.  (For single inheritance, these could    all be the same name.  Who knows for multiple inheritance).  */
end_comment

begin_function
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VFIELD_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VFIELD_NAME_FORMAT
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_class_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert_harshness = %d\n"
argument_list|,
name|n_convert_harshness
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compute_conversion_costs = %d\n"
argument_list|,
name|n_compute_conversion_costs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_vtables
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtables = %d; vtable searches = %d\n"
argument_list|,
name|n_vtables
argument_list|,
name|n_vtable_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable entries = %d; vtable elems = %d\n"
argument_list|,
name|n_vtable_entries
argument_list|,
name|n_vtable_elems
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Build a dummy reference to ourselves so Derived::Base (and A::A) works,    according to [class]:                                           The class-name is also inserted    into  the scope of the class itself.  For purposes of access checking,    the inserted class name is treated as if it were a public member name.  */
end_comment

begin_function
name|void
name|build_self_reference
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|saved_cas
decl_stmt|;
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_SELF_REFERENCE_P
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|value
operator|=
name|push_template_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|saved_cas
operator|=
name|current_access_specifier
expr_stmt|;
name|current_access_specifier
operator|=
name|access_public_node
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|current_access_specifier
operator|=
name|saved_cas
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE contains only padding bytes.  */
end_comment

begin_function
name|int
name|is_empty_class
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* In G++ 3.2, whether or not a class was empty was determined by      looking at its size.  */
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
return|return
name|CLASSTYPE_EMPTY_P
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
name|integer_zerop
argument_list|(
name|CLASSTYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if TYPE contains an empty class.  */
end_comment

begin_function
specifier|static
name|bool
name|contains_empty_class_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|is_empty_class
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|field
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|contains_empty_class_p
argument_list|(
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|contains_empty_class_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Find the enclosing class of the given NODE.  NODE can be a *_DECL or    a *_TYPE node.  NODE can also be a local class.  */
end_comment

begin_function
name|tree
name|get_enclosing_class
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|node
init|=
name|type
decl_stmt|;
while|while
condition|(
name|node
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|node
operator|=
name|DECL_CONTEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|node
operator|!=
name|type
condition|)
return|return
name|node
return|;
name|node
operator|=
name|TYPE_CONTEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Note that NAME was looked up while the current class was being    defined and that the result of that lookup was DECL.  */
end_comment

begin_function
name|void
name|maybe_note_name_used_in_class
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|splay_tree
name|names_used
decl_stmt|;
comment|/* If we're not defining a class, there's nothing to do.  */
if|if
condition|(
name|innermost_scope_kind
argument_list|()
operator|!=
name|sk_class
condition|)
return|return;
comment|/* If there's already a binding for this NAME, then we don't have      anything to worry about.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
condition|)
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|names_used
operator|=
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|names_used
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that NAME was declared (as DECL) in the current class.  Check    to see that the declaration is valid.  */
end_comment

begin_function
name|void
name|note_name_declared_in_class
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|splay_tree
name|names_used
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Look to see if we ever used this name.  */
name|names_used
operator|=
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
expr_stmt|;
if|if
condition|(
operator|!
name|names_used
condition|)
return|return;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|names_used
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* [basic.scope.class] 	  	 A name N used in a class S shall refer to the same declaration 	 in its context and when re-evaluated in the completed scope of 	 S.  */
name|error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"changes meaning of `%D' from `%+#D'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the VAR_DECL for the complete vtable associated with BINFO.    Secondary vtables are merged with primary vtables; this function    will return the VAR_DECL for the primary vtable.  */
end_comment

begin_function
name|tree
name|get_vtbl_decl_for_binfo
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|,
literal|2000403
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|20000403
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns the binfo for the primary base of BINFO.  If the resulting    BINFO is a virtual base, and it is inherited elsewhere in the    hierarchy, then the returned binfo might not be the primary base of    BINFO in the complete object.  Check BINFO_PRIMARY_P or    BINFO_LOST_PRIMARY_P to be sure.  */
end_comment

begin_function
name|tree
name|get_primary_binfo
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|primary_base
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|primary_base
operator|=
name|CLASSTYPE_PRIMARY_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|primary_base
condition|)
return|return
name|NULL_TREE
return|;
name|result
operator|=
name|copied_binfo
argument_list|(
name|primary_base
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* If INDENTED_P is zero, indent to INDENT. Return nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_indent_hierarchy
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|indented_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|indented_p
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%*s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dump the offsets of all the bases rooted at BINFO to STREAM.    INDENT should be zero when called from the top level; it is    incremented recursively.  IGO indicates the next expected BINFO in    inheritance graph ordering.  */
end_comment

begin_function
specifier|static
name|tree
name|dump_class_hierarchy_r
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|tree
name|igo
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|indented
init|=
literal|0
decl_stmt|;
name|tree
name|base_binfos
decl_stmt|;
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s (0x%lx) "
argument_list|,
name|type_as_string
argument_list|(
name|binfo
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|!=
name|igo
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"alternative-path\n"
argument_list|)
expr_stmt|;
return|return
name|igo
return|;
block|}
name|igo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_empty_class
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" empty"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_NEARLY_EMPTY_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" nearly-empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" virtual"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|indented
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" primary-for %s (0x%lx)"
argument_list|,
name|type_as_string
argument_list|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" lost-primary"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indented
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|int
name|indented
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" subvttidx=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vptridx=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_VPTR_FIELD
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vbaseoffset=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_VPTR_FIELD
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|indented
operator|=
name|maybe_indent_hierarchy
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vptr=%s"
argument_list|,
name|expr_as_string
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indented
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|base_binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfos
condition|)
block|{
name|int
name|ix
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|n
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|igo
operator|=
name|dump_class_hierarchy_r
argument_list|(
name|stream
argument_list|,
name|flags
argument_list|,
name|base_binfo
argument_list|,
name|igo
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|igo
return|;
block|}
end_function

begin_comment
comment|/* Dump the BINFO hierarchy for T.  */
end_comment

begin_function
specifier|static
name|void
name|dump_class_hierarchy_1
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Class %s\n"
argument_list|,
name|type_as_string
argument_list|(
name|t
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"   size=%lu align=%lu\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"   base size=%lu base align=%lu\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|CLASSTYPE_AS_BASE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|CLASSTYPE_AS_BASE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|dump_class_hierarchy_r
argument_list|(
name|stream
argument_list|,
name|flags
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debug interface to hierarchy dumping.  */
end_comment

begin_function
specifier|extern
name|void
name|debug_class
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|dump_class_hierarchy_1
argument_list|(
name|stderr
argument_list|,
name|TDF_SLIM
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_class_hierarchy
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_class
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|dump_class_hierarchy_1
argument_list|(
name|stream
argument_list|,
name|flags
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_array
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|inits
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|HOST_WIDE_INT
name|elt
decl_stmt|;
name|tree
name|size
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|elt
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s:"
argument_list|,
name|decl_as_string
argument_list|(
name|decl
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s entries"
argument_list|,
name|expr_as_string
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|size_one_node
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
operator|,
name|inits
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|inits
condition|;
name|ix
operator|++
operator|,
name|inits
operator|=
name|TREE_CHAIN
argument_list|(
name|inits
argument_list|)
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-4ld  %s\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ix
operator|*
name|elt
argument_list|)
argument_list|,
name|expr_as_string
argument_list|(
name|TREE_VALUE
argument_list|(
name|inits
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_vtable
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|tree
name|vtable
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_class
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|int
name|ctor_vtbl_p
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|!=
name|binfo
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s for %s"
argument_list|,
name|ctor_vtbl_p
condition|?
literal|"Construction vtable"
else|:
literal|"Vtable"
argument_list|,
name|type_as_string
argument_list|(
name|binfo
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctor_vtbl_p
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" (0x%lx instance)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|binfo
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" in %s"
argument_list|,
name|type_as_string
argument_list|(
name|t
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_array
argument_list|(
name|stream
argument_list|,
name|vtable
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dump_end
argument_list|(
name|TDI_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_vtt
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|vtt
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_class
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"VTT for %s\n"
argument_list|,
name|type_as_string
argument_list|(
name|t
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|dump_array
argument_list|(
name|stream
argument_list|,
name|vtt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dump_end
argument_list|(
name|TDI_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a function or thunk and its thunkees.  */
end_comment

begin_function
specifier|static
name|void
name|dump_thunk
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|tree
name|thunk
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|spaces
index|[]
init|=
literal|"        "
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|thunk
argument_list|)
decl_stmt|;
name|tree
name|thunks
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%.*s%p %s %s"
argument_list|,
name|indent
argument_list|,
name|spaces
argument_list|,
operator|(
name|void
operator|*
operator|)
name|thunk
argument_list|,
operator|!
name|DECL_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|?
literal|"function"
else|:
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|?
literal|"this-thunk"
else|:
literal|"covariant-thunk"
argument_list|,
name|name
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
else|:
literal|"<unset>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|fixed_adjust
init|=
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk
argument_list|)
decl_stmt|;
name|tree
name|virtual_adjust
init|=
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" fixed="
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|fixed_adjust
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|virtual_adjust
condition|)
comment|/*NOP*/
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vcall="
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|tree_low_cst
argument_list|(
name|virtual_adjust
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" vbase="
name|HOST_WIDE_INT_PRINT_DEC
literal|"(%s)"
argument_list|,
name|tree_low_cst
argument_list|(
name|BINFO_VPTR_FIELD
argument_list|(
name|virtual_adjust
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type_as_string
argument_list|(
name|BINFO_TYPE
argument_list|(
name|virtual_adjust
argument_list|)
argument_list|,
name|TFF_SCOPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" alias to %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|thunks
operator|=
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
init|;
name|thunks
condition|;
name|thunks
operator|=
name|TREE_CHAIN
argument_list|(
name|thunks
argument_list|)
control|)
name|dump_thunk
argument_list|(
name|stream
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|thunks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the thunks for FN.  */
end_comment

begin_function
specifier|extern
name|void
name|debug_thunks
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|dump_thunk
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Virtual function table initialization.  */
end_comment

begin_comment
comment|/* Create all the necessary vtables for T and its base classes.  */
end_comment

begin_function
specifier|static
name|void
name|finish_vtbls
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
comment|/* We lay out the primary and secondary vtables in one contiguous      vtable.  The primary vtable is first, followed by the non-virtual      secondary vtables in inheritance graph order.  */
name|list
operator|=
name|build_tree_list
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|accumulate_vtbl_inits
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Then come the virtual bases, also in inheritance graph order.  */
for|for
control|(
name|vbase
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|)
continue|continue;
name|accumulate_vtbl_inits
argument_list|(
name|vbase
argument_list|,
name|vbase
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
condition|)
name|initialize_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the vtable for BINFO with the INITS.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_vtable
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|inits
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|layout_vtable_decl
argument_list|(
name|binfo
argument_list|,
name|list_length
argument_list|(
name|inits
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|initialize_array
argument_list|(
name|decl
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|dump_vtable
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|binfo
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize DECL (a declaration for a namespace-scope array) with    the INITS.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_array
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|inits
parameter_list|)
block|{
name|tree
name|context
decl_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the VTT (virtual table table) for T.    A class requires a VTT if it has virtual bases.        This holds    1 - primary virtual pointer for complete object T    2 - secondary VTTs for each direct non-virtual base of T which requires a        VTT    3 - secondary virtual pointers for each direct or indirect base of T which        has virtual bases or is reachable via a virtual path from T.    4 - secondary VTTs for each direct or indirect virtual base of T.        Secondary VTTs look like complete object VTTs without part 4.  */
end_comment

begin_function
specifier|static
name|void
name|build_vtt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|inits
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|vtt
decl_stmt|;
name|tree
name|index
decl_stmt|;
comment|/* Build up the initializers for the VTT.  */
name|inits
operator|=
name|NULL_TREE
expr_stmt|;
name|index
operator|=
name|size_zero_node
expr_stmt|;
name|build_vtt_inits
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
operator|&
name|inits
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
comment|/* If we didn't need a VTT, we're done.  */
if|if
condition|(
operator|!
name|inits
condition|)
return|return;
comment|/* Figure out the type of the VTT.  */
name|type
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|list_length
argument_list|(
name|inits
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|const_ptr_type_node
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Now, build the VTT object itself.  */
name|vtt
operator|=
name|build_vtable
argument_list|(
name|t
argument_list|,
name|get_vtt_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|initialize_array
argument_list|(
name|vtt
argument_list|,
name|inits
argument_list|)
expr_stmt|;
comment|/* Add the VTT to the vtables list.  */
name|TREE_CHAIN
argument_list|(
name|vtt
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|CLASSTYPE_VTABLES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|CLASSTYPE_VTABLES
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|vtt
expr_stmt|;
name|dump_vtt
argument_list|(
name|t
argument_list|,
name|vtt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When building a secondary VTT, BINFO_VTABLE is set to a TREE_LIST with    PURPOSE the RTTI_BINFO, VALUE the real vtable pointer for this binfo,    and CHAIN the vtable pointer for this binfo after construction is    complete.  VALUE can also be another BINFO, in which case we recurse.  */
end_comment

begin_function
specifier|static
name|tree
name|binfo_ctor_vtable
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|vt
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|vt
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vt
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|vt
operator|=
name|TREE_VALUE
argument_list|(
name|vt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vt
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|binfo
operator|=
name|vt
expr_stmt|;
else|else
break|break;
block|}
return|return
name|vt
return|;
block|}
end_function

begin_comment
comment|/* Recursively build the VTT-initializer for BINFO (which is in the    hierarchy dominated by T).  INITS points to the end of the initializer    list to date.  INDEX is the VTT index where the next element will be    replaced.  Iff BINFO is the binfo for T, this is the top level VTT (i.e.    not a subvtt for some base of T).  When that is so, we emit the sub-VTTs    for virtual bases of T. When it is not so, we build the constructor    vtables for the BINFO-in-T variant.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|build_vtt_inits
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|inits
parameter_list|,
name|tree
modifier|*
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|b
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|secondary_vptrs
decl_stmt|;
name|int
name|top_level_p
init|=
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
comment|/* We only need VTTs for subobjects with virtual bases.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|inits
return|;
comment|/* We need to use a construction vtable if this is not the primary      VTT.  */
if|if
condition|(
operator|!
name|top_level_p
condition|)
block|{
name|build_ctor_vtbl_group
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Record the offset in the VTT where this sub-VTT can be found.  */
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
operator|=
operator|*
name|index
expr_stmt|;
block|}
comment|/* Add the address of the primary vtable for the complete object.  */
name|init
operator|=
name|binfo_ctor_vtable
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
operator|*
name|inits
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|inits
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|inits
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_level_p
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|20010129
argument_list|)
expr_stmt|;
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
operator|=
operator|*
name|index
expr_stmt|;
block|}
operator|*
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|index
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recursively add the secondary VTTs for non-virtual bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|b
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
condition|)
name|inits
operator|=
name|build_vtt_inits
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|,
name|t
argument_list|,
name|inits
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Add secondary virtual pointers for all subobjects of BINFO with      either virtual bases or reachable along a virtual path, except      subobjects that are non-virtual primary bases.  */
name|secondary_vptrs
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
operator|*
name|index
expr_stmt|;
name|VTT_TOP_LEVEL_P
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
name|top_level_p
expr_stmt|;
name|VTT_MARKED_BINFO_P
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
name|dfs_build_secondary_vptr_vtt_inits
argument_list|,
name|NULL
argument_list|,
name|dfs_ctor_vtable_bases_queue_p
argument_list|,
name|secondary_vptrs
argument_list|)
expr_stmt|;
name|VTT_MARKED_BINFO_P
argument_list|(
name|secondary_vptrs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|dfs_ctor_vtable_bases_queue_p
argument_list|,
name|secondary_vptrs
argument_list|)
expr_stmt|;
operator|*
name|index
operator|=
name|TREE_TYPE
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
comment|/* The secondary vptrs come back in reverse order.  After we reverse      them, and add the INITS, the last init will be the first element      of the chain.  */
name|secondary_vptrs
operator|=
name|TREE_VALUE
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|secondary_vptrs
condition|)
block|{
operator|*
name|inits
operator|=
name|nreverse
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
name|inits
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|secondary_vptrs
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|*
name|inits
operator|==
name|NULL_TREE
argument_list|,
literal|20000517
argument_list|)
expr_stmt|;
block|}
comment|/* Add the secondary VTTs for virtual bases.  */
if|if
condition|(
name|top_level_p
condition|)
for|for
control|(
name|b
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|TREE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
name|inits
operator|=
name|build_vtt_inits
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|inits
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|top_level_p
condition|)
block|{
name|tree
name|data
init|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|VTT_TOP_LEVEL_P
argument_list|(
name|data
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VTT_MARKED_BINFO_P
argument_list|(
name|data
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_fixup_binfo_vtbls
argument_list|,
name|dfs_ctor_vtable_bases_queue_p
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|inits
return|;
block|}
end_function

begin_comment
comment|/* Called from build_vtt_inits via dfs_walk.  BINFO is the binfo    for the base in most derived. DATA is a TREE_LIST who's    TREE_CHAIN is the type of the base being    constructed whilst this secondary vptr is live.  The TREE_UNSIGNED    flag of DATA indicates that this is a constructor vtable.  The    TREE_TOP_LEVEL flag indicates that this is the primary VTT.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_build_secondary_vptr_vtt_inits
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|l
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|int
name|top_level_p
decl_stmt|;
name|l
operator|=
operator|(
name|tree
operator|)
name|data
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|top_level_p
operator|=
name|VTT_TOP_LEVEL_P
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We don't care about bases that don't have vtables.  */
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We're only interested in proper subobjects of T.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We're not interested in non-virtual primary bases.  */
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If BINFO has virtual bases or is reachable via a virtual path      from T, it'll have a secondary vptr.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|!
name|binfo_via_virtual
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Record the index where this secondary vptr can be found.  */
name|index
operator|=
name|TREE_TYPE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_level_p
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|20010129
argument_list|)
expr_stmt|;
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
operator|=
name|index
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|l
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|index
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the initializer for the secondary vptr itself.  */
if|if
condition|(
name|top_level_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
comment|/* It's a primary virtual base, and this is not the construction          vtable. Find the base this is primary of in the inheritance graph,          and use that base's vtable now.  */
while|while
condition|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|binfo_ctor_vtable
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* dfs_walk_real predicate for building vtables. DATA is a TREE_LIST,    VTT_MARKED_BINFO_P indicates whether marked or unmarked bases    should be walked.  TREE_PURPOSE is the TREE_TYPE that dominates the    hierarchy.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_ctor_vtable_bases_queue_p
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
name|VTT_MARKED_BINFO_P
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Called from build_vtt_inits via dfs_walk. After building constructor    vtables and generating the sub-vtt from them, we need to restore the    BINFO_VTABLES that were scribbled on.  DATA is a TREE_LIST whose    TREE_VALUE is the TREE_TYPE of the base whose sub vtt was generated.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_fixup_binfo_vtbls
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We don't care about bases that don't have vtables.  */
if|if
condition|(
operator|!
name|TYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we scribbled the construction vtable vptr into BINFO, clear it      out now.  */
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|TREE_PURPOSE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
operator|)
condition|)
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build the construction vtable group for BINFO which is in the    hierarchy dominated by T.  */
end_comment

begin_function
specifier|static
name|void
name|build_ctor_vtbl_group
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|vtbl
decl_stmt|;
name|tree
name|inits
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
comment|/* See if we've already created this construction vtable group.  */
name|id
operator|=
name|mangle_ctor_vtbl_for_type
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
condition|)
return|return;
name|my_friendly_assert
argument_list|(
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|,
literal|20010124
argument_list|)
expr_stmt|;
comment|/* Build a version of VTBL (with the wrong type) for use in      constructing the addresses of secondary vtables in the      construction vtable group.  */
name|vtbl
operator|=
name|build_vtable
argument_list|(
name|t
argument_list|,
name|id
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|list
operator|=
name|build_tree_list
argument_list|(
name|vtbl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|accumulate_vtbl_inits
argument_list|(
name|binfo
argument_list|,
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|binfo
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Add the vtables for each of our virtual bases using the vbase in T      binfo.  */
for|for
control|(
name|vbase
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
name|tree
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|)
continue|continue;
name|b
operator|=
name|copied_binfo
argument_list|(
name|vbase
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
name|accumulate_vtbl_inits
argument_list|(
name|b
argument_list|,
name|vbase
argument_list|,
name|binfo
argument_list|,
name|t
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|inits
operator|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* Figure out the type of the construction vtable.  */
name|type
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|list_length
argument_list|(
name|inits
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Initialize the construction vtable.  */
name|CLASSTYPE_VTABLES
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASSTYPE_VTABLES
argument_list|(
name|t
argument_list|)
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|initialize_array
argument_list|(
name|vtbl
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|dump_vtable
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the vtbl initializers for BINFO (and its bases other than    non-virtual primaries) to the list of INITS.  BINFO is in the    hierarchy dominated by T.  RTTI_BINFO is the binfo within T of    the constructor the vtbl inits should be accumulated for. (If this    is the complete object vtbl then RTTI_BINFO will be TYPE_BINFO (T).)    ORIG_BINFO is the binfo for this object within BINFO_TYPE (RTTI_BINFO).    BINFO is the active base equivalent of ORIG_BINFO in the inheritance    graph of T. Both BINFO and ORIG_BINFO will have the same BINFO_TYPE,    but are not necessarily the same in terms of layout.  */
end_comment

begin_function
specifier|static
name|void
name|accumulate_vtbl_inits
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|orig_binfo
parameter_list|,
name|tree
name|rtti_binfo
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
name|inits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ctor_vtbl_p
init|=
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|orig_binfo
argument_list|)
argument_list|)
argument_list|,
literal|20000517
argument_list|)
expr_stmt|;
comment|/* If it doesn't have a vptr, we don't do anything.  */
if|if
condition|(
operator|!
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If we're building a construction vtable, we're not interested in      subobjects that don't require construction vtables.  */
if|if
condition|(
name|ctor_vtbl_p
operator|&&
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|!
name|binfo_via_virtual
argument_list|(
name|orig_binfo
argument_list|,
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Build the initializers for the BINFO-in-T vtable.  */
name|TREE_VALUE
argument_list|(
name|inits
argument_list|)
operator|=
name|chainon
argument_list|(
name|TREE_VALUE
argument_list|(
name|inits
argument_list|)
argument_list|,
name|dfs_accumulate_vtbl_inits
argument_list|(
name|binfo
argument_list|,
name|orig_binfo
argument_list|,
name|rtti_binfo
argument_list|,
name|t
argument_list|,
name|inits
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk the BINFO and its bases.  We walk in preorder so that as we      initialize each vtable we can figure out at what offset the      secondary vtable lies from the primary vtable.  We can't use      dfs_walk here because we need to iterate through bases of BINFO      and RTTI_BINFO simultaneously.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Skip virtual bases.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|accumulate_vtbl_inits
argument_list|(
name|base_binfo
argument_list|,
name|BINFO_BASETYPE
argument_list|(
name|orig_binfo
argument_list|,
name|i
argument_list|)
argument_list|,
name|rtti_binfo
argument_list|,
name|t
argument_list|,
name|inits
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from accumulate_vtbl_inits.  Returns the initializers for    the BINFO vtable.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accumulate_vtbl_inits
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|orig_binfo
parameter_list|,
name|tree
name|rtti_binfo
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
name|l
parameter_list|)
block|{
name|tree
name|inits
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vtbl
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|ctor_vtbl_p
init|=
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctor_vtbl_p
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|orig_binfo
argument_list|)
operator|&&
name|BINFO_PRIMARY_P
argument_list|(
name|orig_binfo
argument_list|)
condition|)
block|{
comment|/* In the hierarchy of BINFO_TYPE (RTTI_BINFO), this is a 	 primary virtual base.  If it is not the same primary in 	 the hierarchy of T, we'll need to generate a ctor vtable 	 for it, to place at its location in T.  If it is the same 	 primary, we still need a VTT entry for the vtable, but it 	 should point to the ctor vtable for the base it is a 	 primary for within the sub-hierarchy of RTTI_BINFO. 	       	 There are three possible cases: 	       	 1) We are in the same place. 	 2) We are a primary base within a lost primary virtual base of 	 RTTI_BINFO. 	 3) We are primary to something not a base of RTTI_BINFO.  */
name|tree
name|b
init|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|;
comment|/* First, look through the bases we are primary to for RTTI_BINFO 	 or a virtual base.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|b
argument_list|)
control|)
block|{
name|last
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
operator|||
name|b
operator|==
name|rtti_binfo
condition|)
break|break;
block|}
comment|/* If we run out of primary links, keep looking down our 	 inheritance chain; we might be an indirect primary.  */
if|if
condition|(
name|b
operator|==
name|NULL_TREE
condition|)
for|for
control|(
name|b
operator|=
name|last
init|;
name|b
condition|;
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|b
argument_list|)
operator|||
name|b
operator|==
name|rtti_binfo
condition|)
break|break;
comment|/* If we found RTTI_BINFO, this is case 1.  If we found a virtual 	 base B and it is a base of RTTI_BINFO, this is case 2.  In 	 either case, we share our vtable with LAST, i.e. the 	 derived-most base within B of which we are a primary.  */
if|if
condition|(
name|b
operator|==
name|rtti_binfo
operator|||
operator|(
name|b
operator|&&
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* Just set our BINFO_VTABLE to point to LAST, as we may not have 	   set LAST's BINFO_VTABLE yet.  We'll extract the actual vptr in 	   binfo_ctor_vtable after everything's been set up.  */
name|vtbl
operator|=
name|last
expr_stmt|;
comment|/* Otherwise, this is case 3 and we get our own.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|orig_binfo
argument_list|)
condition|)
return|return
name|inits
return|;
if|if
condition|(
operator|!
name|vtbl
condition|)
block|{
name|tree
name|index
decl_stmt|;
name|int
name|non_fn_entries
decl_stmt|;
comment|/* Compute the initializer for this vtable.  */
name|inits
operator|=
name|build_vtbl_initializer
argument_list|(
name|binfo
argument_list|,
name|orig_binfo
argument_list|,
name|t
argument_list|,
name|rtti_binfo
argument_list|,
operator|&
name|non_fn_entries
argument_list|)
expr_stmt|;
comment|/* Figure out the position to which the VPTR should point.  */
name|vtbl
operator|=
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtbl_ptr_type_node
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_int
argument_list|(
name|non_fn_entries
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|list_length
argument_list|(
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|vtbl
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ctor_vtbl_p
condition|)
comment|/* For a construction vtable, we can't overwrite BINFO_VTABLE.        So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will        straighten this out.  */
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|rtti_binfo
argument_list|,
name|vtbl
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|inits
operator|=
name|NULL_TREE
expr_stmt|;
else|else
comment|/* For an ordinary vtable, set BINFO_VTABLE.  */
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|vtbl
expr_stmt|;
return|return
name|inits
return|;
block|}
end_function

begin_comment
comment|/* Construct the initializer for BINFO's virtual function table.  BINFO    is part of the hierarchy dominated by T.  If we're building a    construction vtable, the ORIG_BINFO is the binfo we should use to    find the actual function pointers to put in the vtable - but they    can be overridden on the path to most-derived in the graph that    ORIG_BINFO belongs.  Otherwise,    ORIG_BINFO should be the same as BINFO.  The RTTI_BINFO is the    BINFO that should be indicated by the RTTI information in the    vtable; it will be a base class of T, rather than T itself, if we    are building a construction vtable.     The value returned is a TREE_LIST suitable for wrapping in a    CONSTRUCTOR to use as the DECL_INITIAL for a vtable.  If    NON_FN_ENTRIES_P is not NULL, *NON_FN_ENTRIES_P is set to the    number of non-function entries in the vtable.       It might seem that this function should never be called with a    BINFO for which BINFO_PRIMARY_P holds, the vtable for such a    base is always subsumed by a derived class vtable.  However, when    we are building construction vtables, we do build vtables for    primary bases; we need these while the primary base is being    constructed.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtbl_initializer
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|orig_binfo
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
name|rtti_binfo
parameter_list|,
name|int
modifier|*
name|non_fn_entries_p
parameter_list|)
block|{
name|tree
name|v
decl_stmt|,
name|b
decl_stmt|;
name|tree
name|vfun_inits
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
name|vtbl_init_data
name|vid
decl_stmt|;
comment|/* Initialize VID.  */
name|memset
argument_list|(
operator|&
name|vid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vid
argument_list|)
argument_list|)
expr_stmt|;
name|vid
operator|.
name|binfo
operator|=
name|binfo
expr_stmt|;
name|vid
operator|.
name|derived
operator|=
name|t
expr_stmt|;
name|vid
operator|.
name|rtti_binfo
operator|=
name|rtti_binfo
expr_stmt|;
name|vid
operator|.
name|last_init
operator|=
operator|&
name|vid
operator|.
name|inits
expr_stmt|;
name|vid
operator|.
name|primary_vtbl_p
operator|=
operator|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|vid
operator|.
name|ctor_vtbl_p
operator|=
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rtti_binfo
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vid
operator|.
name|generate_vcall_entries
operator|=
name|true
expr_stmt|;
comment|/* The first vbase or vcall offset is at index -3 in the vtable.  */
name|vid
operator|.
name|index
operator|=
name|ssize_int
argument_list|(
operator|-
literal|3
operator|*
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
argument_list|)
expr_stmt|;
comment|/* Add entries to the vtable for RTTI.  */
name|build_rtti_vtbl_entries
argument_list|(
name|binfo
argument_list|,
operator|&
name|vid
argument_list|)
expr_stmt|;
comment|/* Create an array for keeping track of the functions we've      processed.  When we see multiple functions with the same      signature, we share the vcall offsets.  */
name|VARRAY_TREE_INIT
argument_list|(
name|vid
operator|.
name|fns
argument_list|,
literal|32
argument_list|,
literal|"fns"
argument_list|)
expr_stmt|;
comment|/* Add the vcall and vbase offset entries.  */
name|build_vcall_and_vbase_vtbl_entries
argument_list|(
name|binfo
argument_list|,
operator|&
name|vid
argument_list|)
expr_stmt|;
comment|/* Clear BINFO_VTABLE_PATH_MARKED; it's set by      build_vbase_offset_vtbl_entries.  */
for|for
control|(
name|vbase
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbase
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If the target requires padding between data entries, add that now.  */
if|if
condition|(
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
operator|>
literal|1
condition|)
block|{
name|tree
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
operator|&
name|vid
operator|.
name|inits
init|;
operator|(
name|cur
operator|=
operator|*
name|prev
operator|)
condition|;
name|prev
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|cur
argument_list|)
control|)
block|{
name|tree
name|add
init|=
name|cur
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
condition|;
operator|++
name|i
control|)
name|add
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|null_pointer_node
argument_list|)
argument_list|,
name|add
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|add
expr_stmt|;
block|}
block|}
if|if
condition|(
name|non_fn_entries_p
condition|)
operator|*
name|non_fn_entries_p
operator|=
name|list_length
argument_list|(
name|vid
operator|.
name|inits
argument_list|)
expr_stmt|;
comment|/* Go through all the ordinary virtual functions, building up      initializers.  */
name|vfun_inits
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|v
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|orig_binfo
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|vcall_index
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|fn_original
decl_stmt|;
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
name|fn
operator|=
name|BV_FN
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|fn_original
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
condition|)
name|finish_thunk
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|THUNK_ALIAS
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|fn
operator|=
name|THUNK_ALIAS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|BV_FN
argument_list|(
name|v
argument_list|)
operator|=
name|fn
expr_stmt|;
block|}
name|fn_original
operator|=
name|THUNK_TARGET
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* If the only definition of this function signature along our 	 primary base chain is from a lost primary, this vtable slot will 	 never be used, so just zero it out.  This is important to avoid 	 requiring extra thunks which cannot be generated with the function.  	 We first check this in update_vtable_entry_for_fn, so we handle 	 restored primary bases properly; we also need to do it here so we 	 zero out unused slots in ctor vtables, rather than filling themff 	 with erroneous values (though harmless, apart from relocation 	 costs).  */
for|for
control|(
name|b
operator|=
name|binfo
init|;
condition|;
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
control|)
block|{
comment|/* We found a defn before a lost primary; go ahead as normal.  */
if|if
condition|(
name|look_for_overrides_here
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|fn_original
argument_list|)
condition|)
break|break;
comment|/* The nearest definition is from a lost primary; clear the 	     slot.  */
if|if
condition|(
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|init
operator|=
name|size_zero_node
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|init
condition|)
block|{
comment|/* Pull the offset for `this', and the function to call, out of 	     the list.  */
name|delta
operator|=
name|BV_DELTA
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|vcall_index
operator|=
name|BV_VCALL_INDEX
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|delta
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
literal|19990727
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|19990727
argument_list|)
expr_stmt|;
comment|/* You can't call an abstract virtual function; it's abstract. 	     So, we replace these functions with __pure_virtual.  */
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|fn_original
argument_list|)
condition|)
name|fn
operator|=
name|abort_fndecl
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|delta
argument_list|)
operator|||
name|vcall_index
condition|)
block|{
name|fn
operator|=
name|make_thunk
argument_list|(
name|fn
argument_list|,
comment|/*this_adjusting=*/
literal|1
argument_list|,
name|delta
argument_list|,
name|vcall_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
condition|)
name|finish_thunk
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* Take the address of the function, considering it to be of an 	     appropriate generic type.  */
name|init
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* The address of a function can't change.  */
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* And add it to the chain of initializers.  */
if|if
condition|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|size_zero_node
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|;
operator|++
name|i
control|)
name|vfun_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|vfun_inits
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|fdesc
init|=
name|build
argument_list|(
name|FDESC_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|fdesc
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfun_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fdesc
argument_list|,
name|vfun_inits
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|vfun_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|vfun_inits
argument_list|)
expr_stmt|;
block|}
comment|/* The initializers for virtual functions were built up in reverse      order; straighten them out now.  */
name|vfun_inits
operator|=
name|nreverse
argument_list|(
name|vfun_inits
argument_list|)
expr_stmt|;
comment|/* The negative offset initializers are also in reverse order.  */
name|vid
operator|.
name|inits
operator|=
name|nreverse
argument_list|(
name|vid
operator|.
name|inits
argument_list|)
expr_stmt|;
comment|/* Chain the two together.  */
return|return
name|chainon
argument_list|(
name|vid
operator|.
name|inits
argument_list|,
name|vfun_inits
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Adds to vid->inits the initializers for the vbase and vcall    offsets in BINFO, which is in the hierarchy dominated by T.  */
end_comment

begin_function
specifier|static
name|void
name|build_vcall_and_vbase_vtbl_entries
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|vtbl_init_data
modifier|*
name|vid
parameter_list|)
block|{
name|tree
name|b
decl_stmt|;
comment|/* If this is a derived class, we must first create entries      corresponding to the primary base class.  */
name|b
operator|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|build_vcall_and_vbase_vtbl_entries
argument_list|(
name|b
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Add the vbase entries for this base.  */
name|build_vbase_offset_vtbl_entries
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Add the vcall entries for this base.  */
name|build_vcall_offset_vtbl_entries
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the initializers for the vbase offset entries in the vtable    for BINFO (which is part of the class hierarchy dominated by T), in    reverse order.  VBASE_OFFSET_INDEX gives the vtable index    where the next vbase offset will go.  */
end_comment

begin_function
specifier|static
name|void
name|build_vbase_offset_vtbl_entries
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|vtbl_init_data
modifier|*
name|vid
parameter_list|)
block|{
name|tree
name|vbase
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|non_primary_binfo
decl_stmt|;
comment|/* If there are no virtual baseclasses, then there is nothing to      do.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return;
name|t
operator|=
name|vid
operator|->
name|derived
expr_stmt|;
comment|/* We might be a primary base class.  Go up the inheritance hierarchy      until we find the most derived class of which we are a primary base:      it is the offset of that which we need to use.  */
name|non_primary_binfo
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
name|tree
name|b
decl_stmt|;
comment|/* If we have reached a virtual base, then it must be a primary 	 base (possibly multi-level) of vid->binfo, or we wouldn't 	 have called build_vcall_and_vbase_vtbl_entries for it.  But it 	 might be a lost primary, so just skip down to vid->binfo.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
name|non_primary_binfo
operator|=
name|vid
operator|->
name|binfo
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
operator|!=
name|non_primary_binfo
condition|)
break|break;
name|non_primary_binfo
operator|=
name|b
expr_stmt|;
block|}
comment|/* Go through the virtual bases, adding the offsets.  */
for|for
control|(
name|vbase
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
init|;
name|vbase
condition|;
name|vbase
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase
argument_list|)
control|)
block|{
name|tree
name|b
decl_stmt|;
name|tree
name|delta
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase
argument_list|)
condition|)
continue|continue;
comment|/* Find the instance of this virtual base in the complete 	 object.  */
name|b
operator|=
name|copied_binfo
argument_list|(
name|vbase
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* If we've already got an offset for this virtual base, we 	 don't need another one.  */
if|if
condition|(
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Figure out where we can find this vbase offset.  */
name|delta
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|vid
operator|->
name|index
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vid
operator|->
name|primary_vtbl_p
condition|)
name|BINFO_VPTR_FIELD
argument_list|(
name|b
argument_list|)
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|binfo
operator|!=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* The vbase offset had better be the same.  */
name|my_friendly_assert
argument_list|(
name|tree_int_cst_equal
argument_list|(
name|delta
argument_list|,
name|BINFO_VPTR_FIELD
argument_list|(
name|vbase
argument_list|)
argument_list|)
argument_list|,
literal|20030202
argument_list|)
expr_stmt|;
block|}
comment|/* The next vbase will come at a more negative offset.  */
name|vid
operator|->
name|index
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|vid
operator|->
name|index
argument_list|,
name|ssize_int
argument_list|(
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The initializer is the delta from BINFO to this virtual base. 	 The vbase offsets go in reverse inheritance-graph order, and 	 we are walking in inheritance graph order so these end up in 	 the right order.  */
name|delta
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|b
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|non_primary_binfo
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|delta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adds the initializers for the vcall offset entries in the vtable    for BINFO (which is part of the class hierarchy dominated by VID->DERIVED)    to VID->INITS.  */
end_comment

begin_function
specifier|static
name|void
name|build_vcall_offset_vtbl_entries
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|vtbl_init_data
modifier|*
name|vid
parameter_list|)
block|{
comment|/* We only need these entries if this base is a virtual base.  We      compute the indices -- but do not add to the vtable -- when      building the main vtable for a class.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|||
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|vid
operator|->
name|derived
argument_list|)
condition|)
block|{
comment|/* We need a vcall offset for each of the virtual functions in this 	 vtable.  For example:  	   class A { virtual void f (); }; 	   class B1 : virtual public A { virtual void f (); }; 	   class B2 : virtual public A { virtual void f (); }; 	   class C: public B1, public B2 { virtual void f (); };  	 A C object has a primary base of B1, which has a primary base of A.  A 	 C also has a secondary base of B2, which no longer has a primary base 	 of A.  So the B2-in-C construction vtable needs a secondary vtable for 	 A, which will adjust the A* to a B2* to call f.  We have no way of 	 knowing what (or even whether) this offset will be when we define B2, 	 so we store this "vcall offset" in the A sub-vtable and look it up in 	 a "virtual thunk" for B2::f.  	 We need entries for all the functions in our primary vtable and 	 in our non-virtual bases' secondary vtables.  */
name|vid
operator|->
name|vbase
operator|=
name|binfo
expr_stmt|;
comment|/* If we are just computing the vcall indices -- but do not need 	 the actual entries -- not that.  */
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|vid
operator|->
name|generate_vcall_entries
operator|=
name|false
expr_stmt|;
comment|/* Now, walk through the non-virtual bases, adding vcall offsets.  */
name|add_vcall_offset_vtbl_entries_r
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build vcall offsets, starting with those for BINFO.  */
end_comment

begin_function
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_r
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|vtbl_init_data
modifier|*
name|vid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|primary_binfo
decl_stmt|;
comment|/* Don't walk into virtual bases -- except, of course, for the      virtual base for which we are building vcall offsets.  Any      primary virtual base will have already had its offsets generated      through the recursion in build_vcall_and_vbase_vtbl_entries.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|vid
operator|->
name|vbase
operator|!=
name|binfo
condition|)
return|return;
comment|/* If BINFO has a primary base, process it first.  */
name|primary_binfo
operator|=
name|get_primary_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary_binfo
condition|)
name|add_vcall_offset_vtbl_entries_r
argument_list|(
name|primary_binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Add BINFO itself to the list.  */
name|add_vcall_offset_vtbl_entries_1
argument_list|(
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
comment|/* Scan the non-primary bases of BINFO.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
operator|!=
name|primary_binfo
condition|)
name|add_vcall_offset_vtbl_entries_r
argument_list|(
name|base_binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from build_vcall_offset_vtbl_entries_r.  */
end_comment

begin_function
specifier|static
name|void
name|add_vcall_offset_vtbl_entries_1
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|vtbl_init_data
modifier|*
name|vid
parameter_list|)
block|{
comment|/* Make entries for the rest of the virtuals.  */
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|tree
name|orig_fn
decl_stmt|;
comment|/* The ABI requires that the methods be processed in declaration 	 order.  G++ 3.2 used the order in the vtable.  */
for|for
control|(
name|orig_fn
operator|=
name|TYPE_METHODS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
init|;
name|orig_fn
condition|;
name|orig_fn
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_fn
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|orig_fn
argument_list|)
condition|)
name|add_vcall_offset
argument_list|(
name|orig_fn
argument_list|,
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|derived_virtuals
decl_stmt|;
name|tree
name|base_virtuals
decl_stmt|;
name|tree
name|orig_virtuals
decl_stmt|;
comment|/* If BINFO is a primary base, the most derived class which has 	 BINFO as a primary base; otherwise, just BINFO.  */
name|tree
name|non_primary_binfo
decl_stmt|;
comment|/* We might be a primary base class.  Go up the inheritance hierarchy 	 until we find the most derived class of which we are a primary base: 	 it is the BINFO_VIRTUALS there that we need to consider.  */
name|non_primary_binfo
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
name|tree
name|b
decl_stmt|;
comment|/* If we have reached a virtual base, then it must be vid->vbase, 	     because we ignore other virtual bases in 	     add_vcall_offset_vtbl_entries_r.  In turn, it must be a primary 	     base (possibly multi-level) of vid->binfo, or we wouldn't 	     have called build_vcall_and_vbase_vtbl_entries for it.  But it 	     might be a lost primary, so just skip down to vid->binfo.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|non_primary_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|non_primary_binfo
operator|!=
name|vid
operator|->
name|vbase
condition|)
name|abort
argument_list|()
expr_stmt|;
name|non_primary_binfo
operator|=
name|vid
operator|->
name|binfo
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|non_primary_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
operator|!=
name|non_primary_binfo
condition|)
break|break;
name|non_primary_binfo
operator|=
name|b
expr_stmt|;
block|}
if|if
condition|(
name|vid
operator|->
name|ctor_vtbl_p
condition|)
comment|/* For a ctor vtable we need the equivalent binfo within the hierarchy 	   where rtti_binfo is the most derived type.  */
name|non_primary_binfo
operator|=
name|original_binfo
argument_list|(
name|non_primary_binfo
argument_list|,
name|vid
operator|->
name|rtti_binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|base_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|,
name|derived_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|non_primary_binfo
argument_list|)
operator|,
name|orig_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
init|;
name|base_virtuals
condition|;
name|base_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|base_virtuals
argument_list|)
operator|,
name|derived_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|derived_virtuals
argument_list|)
operator|,
name|orig_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|orig_virtuals
argument_list|)
control|)
block|{
name|tree
name|orig_fn
decl_stmt|;
comment|/* Find the declaration that originally caused this function to 	     be present in BINFO_TYPE (binfo).  */
name|orig_fn
operator|=
name|BV_FN
argument_list|(
name|orig_virtuals
argument_list|)
expr_stmt|;
comment|/* When processing BINFO, we only want to generate vcall slots for 	     function slots introduced in BINFO.  So don't try to generate 	     one if the function isn't even defined in BINFO.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|orig_fn
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
continue|continue;
name|add_vcall_offset
argument_list|(
name|orig_fn
argument_list|,
name|binfo
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a vcall offset entry for ORIG_FN to the vtable.  */
end_comment

begin_function
specifier|static
name|void
name|add_vcall_offset
parameter_list|(
name|tree
name|orig_fn
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|vtbl_init_data
modifier|*
name|vid
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|vcall_offset
decl_stmt|;
comment|/* If there is already an entry for a function with the same      signature as FN, then we do not need a second vcall offset.      Check the list of functions already present in the derived      class vtable.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|vid
operator|->
name|fns
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|derived_entry
decl_stmt|;
name|derived_entry
operator|=
name|VARRAY_TREE
argument_list|(
name|vid
operator|->
name|fns
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_signature_p
argument_list|(
name|derived_entry
argument_list|,
name|orig_fn
argument_list|)
comment|/* We only use one vcall offset for virtual destructors, 	     even though there are two virtual table entries.  */
operator|||
operator|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|derived_entry
argument_list|)
operator|&&
name|DECL_DESTRUCTOR_P
argument_list|(
name|orig_fn
argument_list|)
operator|)
condition|)
return|return;
block|}
comment|/* If we are building these vcall offsets as part of building      the vtable for the most derived class, remember the vcall      offset.  */
if|if
condition|(
name|vid
operator|->
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|vid
operator|->
name|derived
argument_list|)
condition|)
name|CLASSTYPE_VCALL_INDICES
argument_list|(
name|vid
operator|->
name|derived
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|orig_fn
argument_list|,
name|vid
operator|->
name|index
argument_list|,
name|CLASSTYPE_VCALL_INDICES
argument_list|(
name|vid
operator|->
name|derived
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The next vcall offset will be found at a more negative      offset.  */
name|vid
operator|->
name|index
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|vid
operator|->
name|index
argument_list|,
name|ssize_int
argument_list|(
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep track of this function.  */
name|VARRAY_PUSH_TREE
argument_list|(
name|vid
operator|->
name|fns
argument_list|,
name|orig_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|vid
operator|->
name|generate_vcall_entries
condition|)
block|{
name|tree
name|base
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* Find the overriding function.  */
name|fn
operator|=
name|find_final_overrider
argument_list|(
name|vid
operator|->
name|rtti_binfo
argument_list|,
name|binfo
argument_list|,
name|orig_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
name|vcall_offset
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
block|{
name|base
operator|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* The vbase we're working on is a primary base of 	     vid->binfo.  But it might be a lost primary, so its 	     BINFO_OFFSET might be wrong, so we just use the 	     BINFO_OFFSET from vid->binfo.  */
name|vcall_offset
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vid
operator|->
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|vcall_offset
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|vcall_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the initializer to the vtable.  */
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|vcall_offset
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return vtbl initializers for the RTTI entries corresponding to the    BINFO's vtable.  The RTTI entries should indicate the object given    by VID->rtti_binfo.  */
end_comment

begin_function
specifier|static
name|void
name|build_rtti_vtbl_entries
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|vtbl_init_data
modifier|*
name|vid
parameter_list|)
block|{
name|tree
name|b
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|t
operator|=
name|BINFO_TYPE
argument_list|(
name|vid
operator|->
name|rtti_binfo
argument_list|)
expr_stmt|;
comment|/* To find the complete object, we will first convert to our most      primary base, and then add the offset in the vtbl to that value.  */
name|b
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|)
operator|&&
operator|!
name|BINFO_LOST_PRIMARY_P
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|tree
name|primary_base
decl_stmt|;
name|primary_base
operator|=
name|get_primary_binfo
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|primary_base
argument_list|)
operator|==
name|b
argument_list|,
literal|20010127
argument_list|)
expr_stmt|;
name|b
operator|=
name|primary_base
expr_stmt|;
block|}
name|offset
operator|=
name|size_diffop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|vid
operator|->
name|rtti_binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The second entry is the address of the typeinfo object.  */
if|if
condition|(
name|flag_rtti
condition|)
name|decl
operator|=
name|build_address
argument_list|(
name|get_tinfo_decl
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Convert the declaration to a type that can be stored in the      vtable.  */
name|init
operator|=
name|build_nop
argument_list|(
name|vfunc_ptr_type_node
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
comment|/* Add the offset-to-top entry.  It comes earlier in the vtable that      the the typeinfo entry.  Convert the offset to look like a      function pointer, so that we can put it in the vtable.  */
name|init
operator|=
name|build_nop
argument_list|(
name|vfunc_ptr_type_node
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|vid
operator|->
name|last_init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|vid
operator|->
name|last_init
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|vid
operator|->
name|last_init
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

