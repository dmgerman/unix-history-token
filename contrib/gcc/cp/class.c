begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to building classes and their related objects.    Copyright (C) 1987, 92-97, 1998, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* This is how we tell when two virtual member functions are really the    same.  */
end_comment

begin_define
define|#
directive|define
name|SAME_FN
parameter_list|(
name|FN1DECL
parameter_list|,
name|FN2DECL
parameter_list|)
value|(DECL_ASSEMBLER_NAME (FN1DECL) == DECL_ASSEMBLER_NAME (FN2DECL))
end_define

begin_decl_stmt
specifier|extern
name|void
name|set_class_shadows
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of nested classes being processed.  If we are not in the    scope of any class, this is zero.  */
end_comment

begin_decl_stmt
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In order to deal with nested classes, we keep a stack of classes.    The topmost entry is the innermost class, and is the entry at index    CURRENT_CLASS_DEPTH  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|class_stack_node
block|{
comment|/* The name of the class.  */
name|tree
name|name
decl_stmt|;
comment|/* The _TYPE node for the class.  */
name|tree
name|type
decl_stmt|;
comment|/* The access specifier pending for new declarations in the scope of      this class.  */
name|tree
name|access
decl_stmt|;
comment|/* If were defining TYPE, the names used in this class.  */
name|splay_tree
name|names_used
decl_stmt|;
block|}
typedef|*
name|class_stack_node_t
typedef|;
end_typedef

begin_comment
comment|/* The stack itself.  This is an dynamically resized array.  The    number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_class_stack_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|class_stack_node_t
name|current_class_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we're processing a member function, current_class_ptr is the    PARM_DECL for the `this' pointer.  The current_class_ref is an    expression for `*this'.  */
end_comment

begin_decl_stmt
name|tree
name|current_class_ptr
decl_stmt|,
name|current_class_ref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following two can be derived from the previous one */
end_comment

begin_decl_stmt
name|tree
name|current_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IDENTIFIER_NODE: name of current class */
end_comment

begin_decl_stmt
name|tree
name|current_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the type of the current class */
end_comment

begin_decl_stmt
name|tree
name|current_access_specifier
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|previous_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the previous type that was a class */
end_comment

begin_decl_stmt
name|tree
name|previous_class_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TREE_LIST: copy of the class_shadowed list 				   when leaving an outermost class scope.  */
end_comment

begin_comment
comment|/* The obstack on which the cached class declarations are kept.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|class_cache_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first object allocated on that obstack.  We can use    obstack_free with tis value to free the entire obstack.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|class_cache_firstobj
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|base_info
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|tree
name|get_vfield_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_anon
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vbase_pointer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtable_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vtable_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_derived_offset
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_basefndecls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_rtti_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prepare_fresh_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_vtable_deltas1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_vtable_deltas
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_vtbls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_vtable_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vtable_entry_n
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_virtual_function
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|delete_duplicate_fields_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_duplicate_fields
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_bits
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alter_access
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_using_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|overrides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strictly_overrides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_overrides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|override_one_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_overriders
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_for_override
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_class_offset_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_class_offset
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_one_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_all_vtables
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_all_direct_vtables
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_all_indirect_vtables
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finish_base_struct
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|base_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_methods
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_warn_about_overly_private_class
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|make_method_vec
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_method_vec
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_implicitly_declared_members
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fixed_type_or_null
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|resolve_address_of_overloaded_function
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_vtable_entry_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking language names.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_lang_stacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of languages we recognize.  */
end_comment

begin_decl_stmt
name|tree
name|lang_name_c
decl_stmt|,
name|lang_name_cplusplus
decl_stmt|,
name|lang_name_java
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_lang_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When layout out an aggregate type, the size of the    basetypes (virtual and non-virtual) is passed to layout_record    via this node.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|base_layout_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants used for access control.  */
end_comment

begin_decl_stmt
name|tree
name|access_default_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 */
end_comment

begin_decl_stmt
name|tree
name|access_public_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 */
end_comment

begin_decl_stmt
name|tree
name|access_protected_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2 */
end_comment

begin_decl_stmt
name|tree
name|access_private_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3 */
end_comment

begin_decl_stmt
name|tree
name|access_default_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 4 */
end_comment

begin_decl_stmt
name|tree
name|access_public_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5 */
end_comment

begin_decl_stmt
name|tree
name|access_protected_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6 */
end_comment

begin_decl_stmt
name|tree
name|access_private_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 7 */
end_comment

begin_comment
comment|/* Variables shared between class.c and call.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|n_vtables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_searches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_elems
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_convert_harshness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_compute_conversion_costs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_build_method_call
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_inner_fields_searched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Virtual baseclass things.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vbase_pointer
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|FORMAT_VBASE_NAME
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Is the type of the EXPR, the complete type of the object?    If we are going to be wrong, we must be conservative, and return 0.  */
end_comment

begin_comment
unit|static int complete_type_p (expr)      tree expr; {   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (expr));   while (1)     {       switch (TREE_CODE (expr)) 	{ 	case SAVE_EXPR: 	case INDIRECT_REF: 	case ADDR_EXPR: 	case NOP_EXPR: 	case CONVERT_EXPR: 	  expr = TREE_OPERAND (expr, 0); 	  continue;  	case CALL_EXPR:  	  if (! TREE_HAS_CONSTRUCTOR (expr)) 	    break;
comment|/* fall through...  */
end_comment

begin_comment
unit|case VAR_DECL: 	case FIELD_DECL: 	  if (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE&& IS_AGGR_TYPE (TREE_TYPE (TREE_TYPE (expr)))&& TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type) 	    return 1;
comment|/* fall through...  */
end_comment

begin_comment
unit|case TARGET_EXPR: 	case PARM_DECL: 	  if (IS_AGGR_TYPE (TREE_TYPE (expr))&& TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type) 	    return 1;
comment|/* fall through...  */
end_comment

begin_endif
unit|case PLUS_EXPR: 	default: 	  break; 	}       break;     }   return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build multi-level access to EXPR using hierarchy path PATH.    CODE is PLUS_EXPR if we are going with the grain,    and MINUS_EXPR if we are not (in which case, we cannot traverse    virtual baseclass links).     TYPE is the type we want this path to have on exit.     NONNULL is non-zero if  we know (for any reason) that EXPR is    not, in fact, zero.  */
end_comment

begin_function
name|tree
name|build_vbase_path
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|expr
parameter_list|,
name|path
parameter_list|,
name|nonnull
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|,
name|path
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
block|{
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|,
name|last_virtual
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|fixed_type_p
decl_stmt|;
name|tree
name|null_expr
init|=
literal|0
decl_stmt|,
name|nonnull_expr
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|offset
init|=
name|integer_zero_node
decl_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* If -fthis-is-variable, we might have set nonnull incorrectly.  We      don't care enough to get this right, so just clear it.  */
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
name|nonnull
operator|=
literal|0
expr_stmt|;
comment|/* We could do better if we had additional logic to convert back to the      unconverted type (the static type of the complete object), and then      convert back to the type we want.  Until that is done, we only optimize      if the complete type is the same type as expr has.  */
name|fixed_type_p
operator|=
name|resolves_to_fixed_type_p
argument_list|(
name|expr
argument_list|,
operator|&
name|nonnull
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_type_p
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
condition|)
name|path
operator|=
name|reverse_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|last_virtual
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
name|changed
operator|=
operator|!
name|fixed_type_p
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|tree
name|ind
decl_stmt|;
comment|/* We already check for ambiguous things in the caller, just 		     find a path.  */
if|if
condition|(
name|last
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|nonnull_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nonnull_expr
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
name|ind
operator|=
name|build_indirect_ref
argument_list|(
name|nonnull_expr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|build_vbase_pointer
argument_list|(
name|ind
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonnull
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|null_expr
operator|==
name|NULL_TREE
condition|)
block|{
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else we'll figure out the offset below.  */
comment|/* Happens in the case of parse errors.  */
if|if
condition|(
name|nonnull_expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"cannot cast up from virtual baseclass `%T'"
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|last
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* LAST is now the last basetype assoc on the path.  */
comment|/* A pointer to a virtual base member of a non-null object      is non-null.  Therefore, we only need to test for zeroness once.      Make EXPR the canonical expression to deal with here.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|nonnull_expr
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|nonnull_expr
expr_stmt|;
comment|/* If we go through any virtual base pointers, make sure that      casts to BASETYPE from the last virtual base class use      the right value for BASETYPE.  */
if|if
condition|(
name|changed
condition|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
operator|!=
name|BINFO_TYPE
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_virtual
condition|)
block|{
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo_member
argument_list|(
name|last_virtual
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
condition|)
block|{
comment|/* Bash types to make the backend happy.  */
name|offset
operator|=
name|cp_convert
argument_list|(
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This shouldn't be necessary.  (mrs) */
block|expr = build1 (NOP_EXPR, type, expr);
endif|#
directive|endif
comment|/* If expr might be 0, we need to preserve that zeroness.  */
if|if
condition|(
name|nonnull
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|null_expr
condition|)
name|TREE_TYPE
argument_list|(
name|null_expr
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* Cannot change the TREE_TYPE of a NOP_EXPR here, since it may      be used multiple times in initialization of multiple inheritance.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Virtual function things.  */
end_comment

begin_comment
comment|/* Build an entry in the virtual function table.    DELTA is the offset for the `this' pointer.    PFN is an ADDR_EXPR containing a pointer to the virtual function.    Note that the index (DELTA2) in the virtual function table    is always 0.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable_entry
parameter_list|(
name|delta
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|delta
decl_stmt|,
name|pfn
decl_stmt|;
block|{
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
name|HOST_WIDE_INT
name|idelta
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
name|idelta
operator|&&
operator|!
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|pfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|make_thunk
argument_list|(
name|pfn
argument_list|,
name|idelta
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|pfn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|pfn
return|;
block|}
else|else
block|{
specifier|extern
name|int
name|flag_huge_objects
decl_stmt|;
name|tree
name|elems
init|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|pfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|entry
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
decl_stmt|;
comment|/* DELTA used to be constructed by `size_int' and/or size_binop, 	 which caused overflow problems when it was negative.  That should 	 be fixed now.  */
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|delta
argument_list|,
name|delta_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_huge_objects
condition|)
name|sorry
argument_list|(
literal|"object size exceeds built-in limit for virtual function table implementation"
argument_list|)
expr_stmt|;
else|else
name|sorry
argument_list|(
literal|"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects"
argument_list|)
expr_stmt|;
block|}
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|entry
return|;
block|}
block|}
end_function

begin_comment
comment|/* We want to give the assembler the vtable identifier as well as    the offset to the function pointer.  So we generate     __asm__ __volatile__ (".vtable_entry %c0, %c1"       : : "s"(&class_vtable),           "i"((long)&vtbl[idx].pfn - (long)&vtbl[0])); */
end_comment

begin_function
specifier|static
name|void
name|build_vtable_entry_ref
parameter_list|(
name|basetype
parameter_list|,
name|vtbl
parameter_list|,
name|idx
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|vtbl
decl_stmt|,
name|idx
decl_stmt|;
block|{
specifier|static
name|char
name|asm_stmt
index|[]
init|=
literal|".vtable_entry %c0, %c1"
decl_stmt|;
name|tree
name|s
decl_stmt|,
name|i
decl_stmt|,
name|i2
decl_stmt|;
name|s
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|build_tree_list
argument_list|(
name|build_string
argument_list|(
literal|1
argument_list|,
literal|"s"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_vtable_thunks
condition|)
name|i
operator|=
name|build_component_ref
argument_list|(
name|i
argument_list|,
name|pfn_identifier
argument_list|,
name|vtable_entry_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|build_c_cast
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|i2
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|i2
operator|=
name|build_c_cast
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|i2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|i
argument_list|,
name|i2
argument_list|)
expr_stmt|;
name|i
operator|=
name|build_tree_list
argument_list|(
name|build_string
argument_list|(
literal|1
argument_list|,
literal|"i"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|expand_asm_operands
argument_list|(
name|build_string
argument_list|(
sizeof|sizeof
argument_list|(
name|asm_stmt
argument_list|)
operator|-
literal|1
argument_list|,
name|asm_stmt
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|chainon
argument_list|(
name|s
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields the    virtual function vtable element corresponding to INDEX.  There are    many special cases for INSTANCE which we take care of here, mainly    to avoid creating extra tree nodes when we don't have to.  */
end_comment

begin_function
name|tree
name|build_vtbl_ref
parameter_list|(
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|tree
name|vtbl
decl_stmt|,
name|aref
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|current_class_ref
condition|)
name|vtbl
operator|=
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Try to figure out what a reference refers to, and 	     access its virtual function table directly.  */
name|tree
name|ref
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|instance
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|instance
operator|=
name|init
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|vtbl
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|vtbl
operator|=
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_gc
condition|)
name|build_vtable_entry_ref
argument_list|(
name|basetype
argument_list|,
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields the    virtual function corresponding to INDEX.  There are many special    cases for INSTANCE which we take care of here, mainly to avoid    creating extra tree nodes when we don't have to.  */
end_comment

begin_function
name|tree
name|build_vfn_ref
parameter_list|(
name|ptr_to_instptr
parameter_list|,
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
modifier|*
name|ptr_to_instptr
decl_stmt|,
name|instance
decl_stmt|;
name|tree
name|idx
decl_stmt|;
block|{
name|tree
name|aref
init|=
name|build_vtbl_ref
argument_list|(
name|instance
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|/* When using thunks, there is no extra delta, and we get the pfn      directly.  */
if|if
condition|(
name|flag_vtable_thunks
condition|)
return|return
name|aref
return|;
if|if
condition|(
name|ptr_to_instptr
condition|)
block|{
comment|/* Save the intermediate result in a SAVE_EXPR so we don't have to 	 compute each component of the virtual function pointer twice.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ptr_to_instptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|ptr_to_instptr
argument_list|)
argument_list|,
operator|*
name|ptr_to_instptr
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the virtual function table (as an IDENTIFIER_NODE)    for the given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type_id
init|=
name|build_typename_overload
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|type_id
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|type_id
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
index|[
name|i
index|]
operator|==
name|OPERATOR_TYPENAME_FORMAT
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|#
directive|if
literal|0
comment|/* We don't take off the numbers; prepare_fresh_vtable uses the      DECL_ASSEMBLER_NAME for the type, which includes the number      in `3foo'.  If we were to pull them off here, we'd end up with      something like `_vt.foo.3bar', instead of a uniform definition.  */
block|while (ptr[i]>= '0'&& ptr[i]<= '9')     i += 1;
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|ptr
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the offset to the main vtable for a given base BINFO.  */
end_comment

begin_function
name|tree
name|get_vfield_offset
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|tmp
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the offset to the start of the original binfo that we derived    this binfo from.  If we find TYPE first, return the offset only    that far.  The shortened search is useful because the this pointer    on method calling is expected to point to a DECL_CONTEXT (fndecl)    object, and not a baseclass of it.  */
end_comment

begin_function
specifier|static
name|tree
name|get_derived_offset
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|offset1
init|=
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|offset2
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|type
condition|)
break|break;
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|offset2
operator|=
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset1
argument_list|,
name|offset2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update the rtti info for this class.  */
end_comment

begin_function
specifier|static
name|void
name|set_rtti_entry
parameter_list|(
name|virtuals
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|tree
name|virtuals
decl_stmt|,
name|offset
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|vfn
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|flag_rtti
condition|)
name|vfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|get_tinfo_fn
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vfn
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|size_zero_node
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_vtable_thunks
condition|)
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|offset
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|voff
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|voff
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|voff
argument_list|)
expr_stmt|;
comment|/* The second slot is for the tdesc pointer when thunks are used.  */
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a virtual function for type TYPE.    If BINFO is non-NULL, build the vtable starting with the initial    approximation that it is the same as the one which is the head of    the association list.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|name
init|=
name|get_vtable_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|virtuals
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|tree
name|offset
decl_stmt|;
name|virtuals
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now do rtti stuff.  */
name|offset
operator|=
name|get_derived_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|virtuals
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|virtuals
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Initialize the association list for this type, based      on our first approximation.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|WRITABLE_VTABLES
comment|/* Make them READONLY by default. (mrs) */
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* At one time the vtable info was grabbed 2 words at a time.  This      fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|tree
name|signed_size_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Give TYPE a new virtual function table which is initialized    with a skeleton-copy of its original initialization.  The only    entry that changes is the `delta' entry, so we can really    share a lot of structure.     FOR_TYPE is the derived type which caused this table to    be needed.     BINFO is the type association which provided TYPE for FOR_TYPE.     The order in which vtables are built (by calling this function) for    an object must remain the same, otherwise a binary incompatibility    can result.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_fresh_vtable
parameter_list|(
name|binfo
parameter_list|,
name|for_type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|for_type
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|orig_decl
init|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|new_decl
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|path
init|=
name|binfo
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|char
name|joiner
init|=
literal|'_'
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|JOINER
name|joiner
operator|=
name|JOINER
expr_stmt|;
endif|#
directive|endif
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|i
operator|=
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* We know that the vtable that we are going to create doesn't exist      yet in the global namespace, and when we finish, it will be      pushed into the global namespace.  In complex MI hierarchies, we      have to loop while the name we are thinking of adding is globally      defined, adding more name components to the vtable name as we      loop, until the name is unique.  This is because in complex MI      cases, we might have the same base more than once.  This means      that the order in which this function is called for vtables must      remain the same, otherwise binary compatibility can be      compromised.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|buf1
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|for_type
argument_list|)
operator|+
literal|1
operator|+
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_buf2
decl_stmt|;
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%s%c%s"
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|for_type
argument_list|)
argument_list|,
name|joiner
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* If this name doesn't clash, then we can use it, otherwise 	 we add more to the name until it is unique.  */
if|if
condition|(
operator|!
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
break|break;
comment|/* Set values for next loop through, if the name isn't unique.  */
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* We better not run out of stuff to make it unique.  */
name|my_friendly_assert
argument_list|(
name|path
operator|!=
name|NULL_TREE
argument_list|,
literal|368
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_type
operator|==
name|basetype
condition|)
block|{
comment|/* If we run out of basetypes in the path, we have already 	     found created a vtable with that name before, we now 	     resort to tacking on _%d to distinguish them.  */
name|int
name|j
init|=
literal|2
decl_stmt|;
name|i
operator|=
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
operator|+
name|i
operator|+
literal|1
operator|+
literal|3
expr_stmt|;
name|buf1
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%s%c%s%c%d"
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|joiner
argument_list|,
name|buf2
argument_list|,
name|joiner
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* If this name doesn't clash, then we can use it, 	       otherwise we add something different to the name until 	       it is unique.  */
block|}
do|while
condition|(
operator|++
name|j
operator|<=
literal|999
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
do|;
comment|/* Hey, they really like MI don't they?  Increase the 3              above to 6, and the 999 to 999999.  :-)  */
name|my_friendly_assert
argument_list|(
name|j
operator|<=
literal|999
argument_list|,
literal|369
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
operator|+
name|i
expr_stmt|;
name|new_buf2
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_buf2
argument_list|,
literal|"%s%c%s"
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|joiner
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|new_buf2
expr_stmt|;
block|}
name|new_decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember which class this vtable is really for.  */
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|for_type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|pushdecl_top_level
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|WRITABLE_VTABLES
comment|/* Make them READONLY by default. (mrs) */
name|TREE_READONLY
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|DECL_ALIGN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
comment|/* Make fresh virtual list, so we can smash it later.  */
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|binfo1
init|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|for_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* XXX - This should never happen, if it does, the caller should 	 ensure that the binfo is from for_type's binfos, not from any 	 base type's.  We can remove all this code after a while.  */
if|if
condition|(
name|binfo1
operator|!=
name|binfo
condition|)
name|warning
argument_list|(
literal|"internal inconsistency: binfo offset error for rtti"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo1
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|offset
argument_list|)
argument_list|,
name|for_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|new_decl
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|binfo
operator|==
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
literal|170
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Access the virtual function table entry that logically    contains BASE_FNDECL.  VIRTUALS is the virtual function table's    initializer.  We can run off the end, when dealing with virtual    destructors in MI situations, return NULL_TREE in that case.  */
end_comment

begin_ifdef
unit|static tree get_vtable_entry (virtuals, base_fndecl)      tree virtuals, base_fndecl; {   unsigned HOST_WIDE_INT n = (HOST_BITS_PER_WIDE_INT>= BITS_PER_WORD 	   ? (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))& (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1)) 	   : TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl)));
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_endif
unit|n_vtable_searches += n;
endif|#
directive|endif
end_endif

begin_endif
unit|while (n> 0&& virtuals)     {       --n;       virtuals = TREE_CHAIN (virtuals);     }   return virtuals; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put new entry ENTRY into virtual function table initializer    VIRTUALS.     Also update DECL_VINDEX (FNDECL).  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|old_entry_in_list
parameter_list|,
name|new_entry
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|old_entry_in_list
decl_stmt|,
name|new_entry
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"replaced %D with %D"
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
operator|=
name|new_entry
expr_stmt|;
comment|/* Now assign virtual dispatch information, if unset.  */
comment|/* We can dispatch this, through any overridden base function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Access the virtual function table entry N.  VIRTUALS is the virtual    function table's initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_entry_n
parameter_list|(
name|virtuals
parameter_list|,
name|n
parameter_list|)
name|tree
name|virtuals
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|virtuals
return|;
block|}
end_function

begin_comment
comment|/* Add a virtual function to all the appropriate vtables for the class    T.  DECL_VINDEX(X) should be error_mark_node, if we want to    allocate a new slot in our table.  If it is error_mark_node, we    know that no other function from another vtable is overridden by X.    HAS_VIRTUAL keeps track of how many virtuals there are in our main    vtable for the type, and we build upon the PENDING_VIRTUALS list    and return it.  */
end_comment

begin_function
specifier|static
name|void
name|add_virtual_function
parameter_list|(
name|pv
parameter_list|,
name|phv
parameter_list|,
name|has_virtual
parameter_list|,
name|fndecl
parameter_list|,
name|t
parameter_list|)
name|tree
modifier|*
name|pv
decl_stmt|,
decl|*
name|phv
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|has_virtual
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure type.  */
end_comment

begin_block
block|{
name|tree
name|pending_virtuals
init|=
operator|*
name|pv
decl_stmt|;
name|tree
name|pending_hard_virtuals
init|=
operator|*
name|phv
decl_stmt|;
comment|/* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely      convert to void *.  Make such a conversion here.  */
name|tree
name|vfn
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fndecl
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|DUMB_USER
if|if
condition|(
name|current_class_type
operator|==
literal|0
condition|)
name|cp_warning
argument_list|(
literal|"internal problem, current_class_type is zero when adding `%D', please report"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|t
operator|!=
name|current_class_type
condition|)
name|cp_warning
argument_list|(
literal|"internal problem, current_class_type differs when adding `%D', please report"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the virtual function is a redefinition of a prior one,      figure out in which base class the new definition goes,      and if necessary, make a fresh virtual function table      to hold that entry.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|tree
name|entry
decl_stmt|;
comment|/* We remember that this was the base sub-object for rtti.  */
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* If we are using thunks, use two slots at the front, one 	 for the offset pointer, one for the tdesc pointer.          For ARM-style vtables, use the same slot for both.  */
if|if
condition|(
operator|*
name|has_virtual
operator|==
literal|0
operator|&&
operator|!
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_vtable_thunks
condition|)
operator|*
name|has_virtual
operator|=
literal|2
expr_stmt|;
else|else
operator|*
name|has_virtual
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Build a new INT_CST for this DECL_VINDEX.  */
block|{
specifier|static
name|tree
name|index_table
index|[
literal|256
index|]
decl_stmt|;
name|tree
name|idx
decl_stmt|;
comment|/* We skip a slot for the offset/tdesc entry.  */
name|int
name|i
init|=
operator|(
operator|*
name|has_virtual
operator|)
operator|++
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|256
operator|||
name|index_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|idx
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|256
condition|)
name|index_table
index|[
name|i
index|]
operator|=
name|idx
expr_stmt|;
block|}
else|else
name|idx
operator|=
name|index_table
index|[
name|i
index|]
expr_stmt|;
comment|/* Now assign virtual dispatch information.  */
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|idx
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
name|entry
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Might already be INTEGER_CST if declared twice in class.  We will      give error later or we've already given it.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* Need an entry in some other virtual function table.          Deal with this after we have laid out our virtual base classes.  */
name|pending_hard_virtuals
operator|=
name|temp_tree_cons
argument_list|(
name|fndecl
argument_list|,
name|vfn
argument_list|,
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
operator|*
name|pv
operator|=
name|pending_virtuals
expr_stmt|;
operator|*
name|phv
operator|=
name|pending_hard_virtuals
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Obstack on which to build the vector of class methods.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are method vectors that were too small for the number of    methods in some class, and so were abandoned.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|free_method_vecs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns a method vector with enough room for N methods.  N should    be a power of two.  */
end_comment

begin_function
specifier|static
name|tree
name|make_method_vec
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|tree
name|new_vec
decl_stmt|;
name|tree
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|free_method_vecs
init|;
operator|*
name|t
condition|;
name|t
operator|=
operator|&
operator|(
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
operator|)
control|)
comment|/* Note that we don't use>= n here because we don't want to        allocate a very large vector where it isn't needed.  */
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
operator|*
name|t
argument_list|)
operator|==
name|n
condition|)
block|{
name|new_vec
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|new_vec
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new_vec
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_vec
return|;
block|}
name|new_vec
operator|=
name|make_tree_vec
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|new_vec
return|;
block|}
end_function

begin_comment
comment|/* Free the method vector VEC.  */
end_comment

begin_function
specifier|static
name|void
name|free_method_vec
parameter_list|(
name|vec
parameter_list|)
name|tree
name|vec
decl_stmt|;
block|{
name|TREE_CHAIN
argument_list|(
name|vec
argument_list|)
operator|=
name|free_method_vecs
expr_stmt|;
name|free_method_vecs
operator|=
name|vec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add method METHOD to class TYPE.     If non-NULL, FIELDS is the entry in the METHOD_VEC vector entry of    the class type where the method should be added.  */
end_comment

begin_function
name|void
name|add_method
parameter_list|(
name|type
parameter_list|,
name|fields
parameter_list|,
name|method
parameter_list|)
name|tree
name|type
decl_stmt|,
decl|*
name|fields
decl_stmt|,
name|method
decl_stmt|;
end_function

begin_block
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Setting the DECL_CONTEXT and DECL_CLASS_CONTEXT here is probably      redundant.  */
name|DECL_CONTEXT
argument_list|(
name|method
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|method
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|fields
operator|&&
operator|*
name|fields
condition|)
operator|*
name|fields
operator|=
name|build_overload
argument_list|(
name|method
argument_list|,
operator|*
name|fields
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|len
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Make a new method vector.  We start with 8 entries.  We must 	   allocate at least two (for constructors and destructors), and 	   we're going to end up with an assignment operator at some 	   point as well.    	   We could use a TREE_LIST for now, and convert it to a 	   TREE_VEC in finish_struct, but we would probably waste more 	   memory making the links in the list than we would by 	   over-allocating the size of the vector here.  Furthermore, 	   we would complicate all the code that expects this to be a 	   vector.  We keep a free list of vectors that we outgrew so 	   that we don't really waste any memory.  */
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|make_method_vec
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|method
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
condition|)
comment|/* A new constructor or destructor.  Constructors go in  	   slot 0; destructors go in slot 1.  */
name|slot
operator|=
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
block|{
comment|/* See if we already have an entry with this name.  */
for|for
control|(
name|slot
operator|=
literal|2
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|method
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|slot
operator|==
name|len
condition|)
block|{
comment|/* We need a bigger method vector.  */
name|tree
name|new_vec
init|=
name|make_method_vec
argument_list|(
literal|2
operator|*
name|len
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|free_method_vec
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
name|len
expr_stmt|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|new_vec
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
condition|)
block|{
comment|/* Type conversion operators have to come before 		 ordinary methods; add_conversions depends on this to 		 speed up looking for conversion operators.  So, if 		 necessary, we slide some of the vector elements up. 		 In theory, this makes this algorithm O(N^2) but we 		 don't expect many conversion operators.  */
for|for
control|(
name|slot
operator|=
literal|2
init|;
name|slot
operator|<
name|len
condition|;
operator|++
name|slot
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
comment|/* There are no more entries in the vector, so we 		       can insert the new conversion operator here.  */
break|break;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
comment|/* We can insert the new function right at the 		       SLOTth position.  */
break|break;
block|}
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
condition|)
comment|/* There is nothing in the Ith slot, so we can avoid 		   moving anything.  */
empty_stmt|;
else|else
block|{
comment|/* We know the last slot in the vector is empty 		     because we know that at this point there's room 		     for a new function.  */
name|bcopy
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
name|len
operator|-
name|slot
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|template_class_depth
argument_list|(
name|type
argument_list|)
condition|)
comment|/* TYPE is a template class.  Don't issue any errors now; wait 	   until instantiation time to complain.  */
empty_stmt|;
else|else
block|{
name|tree
name|fns
decl_stmt|;
comment|/* Check to see if we've already got this method.  */
for|for
control|(
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|method
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
comment|/* [over.load] Member function declarations with the 		     same name and the same parameter types cannot be 		     overloaded if any of them is a static member 		     function declaration.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|!=
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|tree
name|parms1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parms2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parms1
operator|=
name|TREE_CHAIN
argument_list|(
name|parms1
argument_list|)
expr_stmt|;
else|else
name|parms2
operator|=
name|TREE_CHAIN
argument_list|(
name|parms2
argument_list|)
expr_stmt|;
if|if
condition|(
name|compparms
argument_list|(
name|parms1
argument_list|,
name|parms2
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"`%#D' and `%#D' cannot be overloaded"
argument_list|,
name|fn
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
comment|/* Since this is an ordinary function in a 		     non-template class, it's mangled name can be used 		     as a unique identifier.  This technique is only 		     an optimization; we would get the same results if 		     we just used decls_match here.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn
argument_list|)
operator|!=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|method
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|decls_match
argument_list|(
name|fn
argument_list|,
name|method
argument_list|)
condition|)
continue|continue;
comment|/* There has already been a declaration of this method 		 or member template.  */
name|cp_error_at
argument_list|(
literal|"`%D' has already been declared in `%T'"
argument_list|,
name|method
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* We don't call duplicate_decls here to merge the 		 declarations because that will confuse things if the 		 methods have inline definitions.  In particular, we 		 will crash while processing the definitions.  */
return|return;
block|}
block|}
comment|/* Actually insert the new method.  */
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
operator|=
name|build_overload
argument_list|(
name|method
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the new binding.  */
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|method
argument_list|)
condition|)
name|push_class_level_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|method
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Subroutines of finish_struct.  */
end_comment

begin_comment
comment|/* Look through the list of fields for this struct, deleting    duplicates as we go.  This must be recursive to handle    anonymous unions.     FIELD is the field which may not appear anywhere in FIELDS.    FIELD_PTR, if non-null, is the starting point at which    chained deletions may take place.    The value returned is the first acceptable entry found    in FIELDS.     Note that anonymous fields which are not of UNION_TYPE are    not duplicates, they are just anonymous fields.  This happens    when we have unnamed bitfields, for example.  */
end_comment

begin_function
specifier|static
name|tree
name|delete_duplicate_fields_1
parameter_list|(
name|field
parameter_list|,
name|fields
parameter_list|)
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|tree
name|prev
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
return|return
name|fields
return|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|fields
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|fields
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|prev
operator|=
name|x
operator|,
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
continue|continue;
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|field
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate enum value `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as enum and non-enum)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARES_TYPE_P
argument_list|(
name|field
argument_list|)
operator|&&
name|DECL_DECLARES_TYPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|cp_error_at
argument_list|(
literal|"duplicate nested type `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARES_TYPE_P
argument_list|(
name|field
argument_list|)
operator|||
name|DECL_DECLARES_TYPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Hide tag decls.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
continue|continue;
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as type and non-type)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error_at
argument_list|(
literal|"duplicate member `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|fields
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_duplicate_fields
parameter_list|(
name|fields
parameter_list|)
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the access of FDECL to ACCESS in T.  The access to FDECL is    along the path given by BINFO.  Return 1 if change was legit,    otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|alter_access
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fdecl
parameter_list|,
name|access
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|fdecl
decl_stmt|;
name|tree
name|access
decl_stmt|;
block|{
name|tree
name|elem
init|=
name|purpose_member
argument_list|(
name|t
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
operator|!=
name|access
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"conflicting access specifications for method `%D', ignored"
argument_list|,
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"conflicting access specifications for field `%s', ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* They're changing the access to the same thing they changed 	     it to before.  That's OK.  */
empty_stmt|;
block|}
block|}
else|else
block|{
name|enforce_access
argument_list|(
name|binfo
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|access
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the USING_DECL, which is a member of T.  The METHOD_VEC, if    non-NULL, is the methods of T.  The FIELDS are the fields of T.  */
end_comment

begin_function
specifier|static
name|void
name|handle_using_decl
parameter_list|(
name|using_decl
parameter_list|,
name|t
parameter_list|,
name|method_vec
parameter_list|,
name|fields
parameter_list|)
name|tree
name|using_decl
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|ctype
init|=
name|DECL_INITIAL
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|access
init|=
name|TREE_PRIVATE
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_private_node
else|:
name|TREE_PROTECTED
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_protected_node
else|:
name|access_public_node
decl_stmt|;
name|tree
name|fdecl
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|flist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n_methods
decl_stmt|;
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|ctype
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
return|return;
if|if
condition|(
name|name
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|||
name|name
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"using-declaration for constructor"
argument_list|,
name|using_decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|fdecl
operator|=
name|lookup_member
argument_list|(
name|binfo
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"no members matching `%D' in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Functions are represented as TREE_LIST, with the purpose      being the type and the value the functions. Other members      come as themselves. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* Ignore base type this came from. */
name|fdecl
operator|=
name|TREE_VALUE
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
comment|/* We later iterate over all functions. */
name|flist
operator|=
name|fdecl
expr_stmt|;
name|fdecl
operator|=
name|OVL_FUNCTION
argument_list|(
name|flist
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
name|n_methods
operator|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|n_methods
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot adjust access to `%#D' in `%#T'"
argument_list|,
name|fdecl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local method `%#D' with same name"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|fdecl
argument_list|)
condition|)
comment|/* We don't currently handle DECL_ACCESS for TYPE_DECLs; just return.  */
return|return;
for|for
control|(
name|tmp
operator|=
name|fields
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tmp
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot adjust access to `%#D' in `%#T'"
argument_list|,
name|fdecl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local field `%#D' with same name"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make type T see field decl FDECL with access ACCESS.*/
if|if
condition|(
name|flist
condition|)
block|{
while|while
condition|(
name|flist
condition|)
block|{
if|if
condition|(
name|alter_access
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|OVL_FUNCTION
argument_list|(
name|flist
argument_list|)
argument_list|,
name|access
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|flist
operator|=
name|OVL_CHAIN
argument_list|(
name|flist
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|alter_access
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|fdecl
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|base_info
block|{
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|tree
name|rtti
decl_stmt|;
name|char
name|cant_have_default_ctor
decl_stmt|;
name|char
name|cant_have_const_ctor
decl_stmt|;
name|char
name|no_const_asn_ref
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about type T derived from its base classes.    Store most of that information in T itself, and place the    remaining information in the struct BASE_INFO.     Propagate basetype offsets throughout the lattice.  Note that the    lattice topped by T is really a pair: it's a DAG that gives the    structure of the derivation hierarchy, and it's a list of the    virtual baseclasses that appear anywhere in the DAG.  When a vbase    type appears in the DAG, it's offset is 0, and it's children start    their offsets from that point.  When a vbase type appears in the list,    its offset is the offset it has in the hierarchy, and its children's    offsets include that offset in theirs.     Returns the index of the first base class to have virtual functions,    or -1 if no such base class.  */
end_comment

begin_function
specifier|static
name|int
name|finish_base_struct
parameter_list|(
name|t
parameter_list|,
name|b
parameter_list|)
name|tree
name|t
decl_stmt|;
name|struct
name|base_info
modifier|*
name|b
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|first_vfn_base_index
init|=
operator|-
literal|1
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|base_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
comment|/* Effective C++ rule 14.  We only need to check TYPE_VIRTUAL_P 	 here because the case of virtual functions but non-virtual 	 dtor is handled in finish_struct_1.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|!
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"base class `%#T' has a non-virtual destructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
comment|/* If the type of basetype is incomplete, then 	 we already complained about that fact 	 (and we should have fixed it up as well).  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* The base type is of incomplete type.  It is 	     probably best to pretend that it does not 	     exist.  */
if|if
condition|(
name|i
operator|==
name|n_baseclasses
operator|-
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|n_baseclasses
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|+
literal|1
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|b
operator|->
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"base `%T' with only non-default constructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"in class without a constructor"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|cp_error
argument_list|(
literal|"COM interface type `%T' must be the leftmost base class"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"COM interface type `%T' with non-COM base class `%T'"
argument_list|,
name|t
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* Ensure that this is set from at least a virtual base              class.  */
if|if
condition|(
name|b
operator|->
name|rtti
operator|==
name|NULL_TREE
condition|)
name|b
operator|->
name|rtti
operator|=
name|CLASSTYPE_RTTI
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* Don't borrow virtuals from virtual baseclasses.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
name|tree
name|vfields
decl_stmt|;
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
comment|/* Update these two, now that we know what vtable we are 		 going to extend.  This is so that we can add virtual 		 functions, and override them properly.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfields
operator|=
name|copy_list
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|vfields
operator|=
name|b
operator|->
name|vfields
expr_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
else|else
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
block|}
else|else
block|{
comment|/* Only add unique vfields, and flatten them out as we go.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
name|b
operator|->
name|vfields
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|value
argument_list|,
name|b
operator|->
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
else|else
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|has_virtual
operator|==
literal|0
condition|)
block|{
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
comment|/* Update these two, now that we know what vtable we are 		     going to extend.  This is so that we can add virtual 		     functions, and override them properly.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
comment|/* When we install the first one, set the VF_NORMAL_VALUE 		     to be the current class, as this it is the most derived 		     class.  Hopefully, this is not set to something else 		     later.  (mrs) */
name|vfields
operator|=
name|b
operator|->
name|vfields
expr_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
block|{
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* There should only be one of them!  And it should 			     always be found, if we get into here.  (mrs)  */
break|break;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|{
name|tree
name|vfields
decl_stmt|;
comment|/* Find the base class with the largest number of virtual functions.  */
for|for
control|(
name|vfields
operator|=
name|b
operator|->
name|vfields
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
operator|&&
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|->
name|vfield
operator|==
literal|0
condition|)
comment|/* If all virtual functions come only from virtual baseclasses.  */
return|return
operator|-
literal|1
return|;
comment|/* Update the rtti base if we have a non-virtual base class version      of it.  */
name|b
operator|->
name|rtti
operator|=
name|CLASSTYPE_RTTI
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|first_vfn_base_index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|first_vfn_base_index
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set memoizing fields and bits of T (and its variants) for later use.    MAX_HAS_VIRTUAL is the largest size of any T's virtual function tables.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|t
parameter_list|,
name|max_has_virtual
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Fix up variants (if any).  */
name|tree
name|variants
init|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
comment|/* These fields are in the _TYPE part of the node, not in 	 the TYPE_LANG_SPECIFIC component, so they are not shared.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_VIRTUAL_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Copy whatever these are holding today.  */
name|TYPE_MIN_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
operator|&&
name|max_has_virtual
condition|)
block|{
comment|/* For a class w/o baseclasses, `finish_struct' has set          CLASS_TYPE_ABSTRACT_VIRTUALS correctly (by definition). Similarly          for a class who's base classes do not have vtables. When neither          of these is true, we might have removed abstract virtuals (by          providing a definition), added some (by declaring new ones), or          redeclared ones from a base class. We need to recalculate what's          really an abstract virtual at this point (by looking in the          vtables).  */
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|get_abstract_virtuals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
condition|)
block|{
comment|/* Notice whether this class has type conversion functions defined.  */
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this type has a copy constructor, force its mode to be BLKmode, and      force its TREE_ADDRESSABLE bit to be nonzero.  This will cause it to      be passed by invisible reference and prevent it from being returned in      a register.       Also do this if the class has BLKmode but can still be returned in      registers, since function_cannot_inline_p won't let us inline      functions returning such a type.  This affects the HP-PA.  */
if|if
condition|(
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|tree
name|variants
decl_stmt|;
name|DECL_MODE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
for|for
control|(
name|variants
operator|=
name|t
init|;
name|variants
condition|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
control|)
block|{
name|TYPE_MODE
argument_list|(
name|variants
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|variants
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Issue warnings about T having private constructors, but no friends,    and so forth.       HAS_NONPRIVATE_METHOD is nonzero if T has any non-private methods or    static members.  HAS_NONPRIVATE_STATIC_FN is nonzero if T has any    non-private static member functions.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_warn_about_overly_private_class
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|has_member_fn
init|=
literal|0
decl_stmt|;
name|int
name|has_nonprivate_method
init|=
literal|0
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|warn_ctor_dtor_privacy
comment|/* If the class has friends, those entities might create and 	 access instances, so we should not warn.  */
operator|||
operator|(
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
comment|/* We will have warned when the template was declared; there's 	 no need to warn on every instantiation.  */
operator|||
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
comment|/* There's no reason to even consider warning about this         class.  */
return|return;
comment|/* We only issue one warning, if more than one applies, because      otherwise, on code like:       class A {        // Oops - forgot `public:'        A();        A(const A&);        ~A();      };       we warn several times about essentially the same problem.  */
comment|/* Check to see if all (non-constructor, non-destructor) member      functions are private.  (Since there are no friends or      non-private statics, we can't ever call any of the private member      functions.)  */
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
comment|/* We're not interested in compiler-generated methods; they don't        provide any way to call private members.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* A non-private static member function is just like a 		 friend; it can create and invoke private member 		 functions, and be accessed without a class 		 instance.  */
return|return;
name|has_nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|has_member_fn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_nonprivate_method
operator|&&
name|has_member_fn
condition|)
block|{
comment|/* There are no non-private methods, and there's at least one 	 private member function that isn't a constructor or 	 destructor.  (If all the private members are 	 constructors/destructors we want to use the code below that 	 issues error messages specifically referring to 	 constructors/destructors.)  */
name|int
name|i
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_PROTECTED
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|has_nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|has_nonprivate_method
condition|)
block|{
name|cp_warning
argument_list|(
literal|"all member functions in class `%T' are private"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Even if some of the member functions are non-private, the class      won't be useful for much if all the constructors or destructors      are private: such an object can never be created or destroyed.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|dtor
init|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|dtor
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`%#T' only defines a private destructor and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|nonprivate_ctor
init|=
literal|0
decl_stmt|;
comment|/* If a non-template class does not define a copy 	 constructor, one is defined for it, enabling it to avoid 	 this warning.  For a template class, this does not 	 happen, and so we would normally get a warning on:  	   template<class T> class C { private: C(); };   	   	 To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  All 	 complete non-template or fully instantiated classes have this 	 flag set.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|fn
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|ctor
init|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
comment|/* Ideally, we wouldn't count copy constructors (or, in 	       fact, any constructor that takes an argument of the 	       class type as a parameter) because such things cannot 	       be used to construct an instance of the class unless 	       you already have one.  But, for now at least, we're 	       more generous.  */
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|ctor
argument_list|)
condition|)
block|{
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nonprivate_ctor
operator|==
literal|0
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`%#T' only defines private constructors and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Warn about duplicate methods in fn_fields.  Also compact method    lists so that lookup can be made faster.     Data Structure: List of method lists.  The outer list is a    TREE_LIST, whose TREE_PURPOSE field is the field name and the    TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN    links the entire list of methods for TYPE_METHODS.  Friends are    chained in the same way as member functions (? TREE_CHAIN or    DECL_CHAIN), but they live in the TREE_TYPE field of the outer    list.  That allows them to be quickly deleted, and requires no    extra storage.     If there are any constructors/destructors, they are moved to the    front of the list.  This makes pushclass more efficient.     We also link each field which has shares a name with its baseclass    to the head of the list of fields for that base class.  This allows    us to reduce search time in places like `build_method_call' to    consider only reasonably likely functions.   */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_methods
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|fn_fields
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|ctor_name
init|=
name|constructor_name
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* First fill in entry 0 with the constructors, entry 1 with destructors,      and the next few with type conversion operators (if any).  */
for|for
control|(
name|fn_fields
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|fn_fields
condition|;
name|fn_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
control|)
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
comment|/* Clear out this flag.  	 @@ Doug may figure out how to break 	 @@ this with nested classes and friends.  */
name|DECL_IN_AGGR_P
argument_list|(
name|fn_fields
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Note here that a copy ctor is private, so we don't dare generate  	 a default copy constructor for a class that has a member  	 of this type without making sure they have access to it.  */
if|if
condition|(
name|fn_name
operator|==
name|ctor_name
condition|)
block|{
name|tree
name|parmtypes
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fn_name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy_assignment_arg_p
argument_list|(
name|parmtype
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* We thought there was a destructor, but there wasn't.  Some        parse errors cause this anomalous situation.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Issue warnings about private constructors and such.  If there are      no methods, then some public defaults are generated.  */
name|maybe_warn_about_overly_private_class
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit error when a duplicate definition of a type is seen.  Patch up.  */
end_comment

begin_function
name|void
name|duplicate_tag_error
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|cp_error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous definition here"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pretend we haven't defined this type.  */
comment|/* All of the component_decl's were TREE_CHAINed together in the parser.      finish_struct_methods walks these chains and assembles all methods with      the same base name into DECL_CHAINs. Now we don't need the parser chains      anymore, so we unravel them.  */
comment|/* This used to be in finish_struct, but it turns out that the      TREE_CHAIN is used by dbxout_type_methods and perhaps some other      things...  */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|unchain
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|unchain
operator|!=
name|NULL_TREE
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|OVL_CURRENT
argument_list|(
name|unchain
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|unchain
operator|=
name|OVL_NEXT
argument_list|(
name|unchain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_only
init|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_unknown
init|=
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|TYPE_REDEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* finish up all new vtables.  */
end_comment

begin_function
specifier|static
name|void
name|finish_vtbls
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|,
name|context
decl_stmt|;
name|decl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_vtbls
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True if we should override the given BASE_FNDECL with the given    FNDECL.  */
end_comment

begin_function
specifier|static
name|int
name|overrides
parameter_list|(
name|fndecl
parameter_list|,
name|base_fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|base_fndecl
decl_stmt|;
block|{
comment|/* Destructors have special names.  */
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|&&
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|base_fndecl
argument_list|)
condition|)
block|{
name|tree
name|types
decl_stmt|,
name|base_types
decl_stmt|;
if|#
directive|if
literal|0
block|retypes = TREE_TYPE (TREE_TYPE (fndecl));       base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));
endif|#
directive|endif
name|types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|base_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_types
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|base_types
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_class_offset_1
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|context
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|,
name|context
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|parent
condition|)
return|return
name|error_mark_node
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|nrval
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|nrval
operator|=
name|get_class_offset_1
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|,
name|context
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* See if we have a new value */
if|if
condition|(
name|nrval
operator|&&
operator|(
name|nrval
operator|!=
name|error_mark_node
operator|||
name|rval
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Only compare if we have two offsets */
if|if
condition|(
name|rval
operator|&&
name|rval
operator|!=
name|error_mark_node
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|nrval
argument_list|,
name|rval
argument_list|)
condition|)
block|{
comment|/* Only give error if the two offsets are different */
name|error
argument_list|(
literal|"every virtual function must have a unique final overrider"
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  found two (or more) `%T' class subobjects in `%T'"
argument_list|,
name|context
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  with virtual `%D' from virtual base class"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
name|rval
operator|=
name|nrval
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|&&
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|rval
operator|==
name|error_mark_node
operator|||
name|tree_int_cst_equal
argument_list|(
name|rval
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|rval
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Get the offset to the CONTEXT subobject that is related to the    given BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_offset
parameter_list|(
name|context
parameter_list|,
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|context
decl_stmt|,
name|t
decl_stmt|,
name|binfo
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|first_binfo
init|=
name|binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|context
operator|==
name|t
condition|)
return|return
name|integer_zero_node
return|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
comment|/* Check less derived binfos first.  */
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
block|}
comment|/* Ok, not found in the less derived binfos, now check the more      derived binfos.  */
name|offset
operator|=
name|get_class_offset_1
argument_list|(
name|first_binfo
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|context
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|my_friendly_abort
argument_list|(
literal|999
argument_list|)
expr_stmt|;
comment|/* we have to find it.  */
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Skip RTTI information at the front of the virtual list.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|skip_rtti_stuff
parameter_list|(
name|virtuals
parameter_list|,
name|t
parameter_list|)
name|tree
modifier|*
name|virtuals
decl_stmt|,
name|t
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|virtuals
condition|)
block|{
comment|/* We always reserve a slot for the offset/tdesc entry.  */
operator|++
name|n
expr_stmt|;
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_vtable_thunks
operator|&&
operator|*
name|virtuals
condition|)
block|{
comment|/* The second slot is reserved for the tdesc pointer when thunks          are used.  */
operator|++
name|n
expr_stmt|;
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|modify_one_vtable
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
comment|/* update rtti entry */
if|if
condition|(
name|flag_rtti
condition|)
block|{
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|current_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|current_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|current_fndecl
argument_list|)
expr_stmt|;
name|current_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|current_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_fndecl
operator|&&
name|overrides
argument_list|(
name|fndecl
argument_list|,
name|current_fndecl
argument_list|)
condition|)
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|this_offset
decl_stmt|;
name|offset
operator|=
name|get_class_offset
argument_list|(
name|context
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Find the right offset for the this pointer based on the 	     base class we just found.  We have to take into 	     consideration the virtual base class pointers that we 	     stick in before the virtual function table pointer.  	     Also, we want just the delta between the most base class 	     that we derived this vfield from and us.  */
name|base_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|get_derived_offset
argument_list|(
name|binfo
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|current_fndecl
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying. 		 We start with the approximation that it's vtable is that 		 of the immediate base class.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with. 		 Later, we will fill in all the virtual functions 		 that override the virtual functions in these base classes 		 which are not defined by the current type.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"in %D"
argument_list|,
name|DECL_NAME
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry_n
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|n
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are the ones that are not through virtual base classes.  */
end_comment

begin_function
specifier|static
name|void
name|modify_all_direct_vtables
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|modify_one_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|modify_all_direct_vtables
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fixup all the delta entries in this one vtable that need updating.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_vtable_deltas1
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|tree
name|pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|delta
init|=
name|DELTA_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|this_offset
decl_stmt|;
name|offset
operator|=
name|get_class_offset
argument_list|(
name|context
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Find the right offset for the this pointer based on the 	     base class we just found.  We have to take into 	     consideration the virtual base class pointers that we 	     stick in before the virtual function table pointer.  	     Also, we want just the delta between the most base class 	     that we derived this vfield from and us.  */
name|base_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|get_derived_offset
argument_list|(
name|binfo
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|this_offset
argument_list|,
name|delta
argument_list|)
condition|)
block|{
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying. 		     We start with the approximation that it's vtable is that 		     of the immediate base class.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with. 		     Later, we will fill in all the virtual functions 		     that override the virtual functions in these base classes 		     which are not defined by the current type.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry_n
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|n
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fixup all the delta entries in all the direct vtables that need updating.    This happens when we have non-overridden virtual functions from a    virtual base class, that are at a different offset, in the new    hierarchy, because the layout of the virtual bases has changed.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_vtable_deltas
parameter_list|(
name|binfo
parameter_list|,
name|init_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|init_self
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|fixup_vtable_deltas
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|init_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|fixup_vtable_deltas1
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are the ones that are through virtual base classes.  */
end_comment

begin_function
specifier|static
name|void
name|modify_all_indirect_vtables
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|via_virtual
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|,
name|via_virtual
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|via_virtual
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|modify_one_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|via_virtual
operator|=
literal|1
expr_stmt|;
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|modify_all_indirect_vtables
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|via_virtual
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|modify_all_vtables
parameter_list|(
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|vfn
parameter_list|)
name|tree
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|vfn
decl_stmt|;
block|{
comment|/* Do these first, so that we will make use of any non-virtual class's      vtable, over a virtual classes vtable.  */
name|modify_all_direct_vtables
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|modify_all_indirect_vtables
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here, we already know that they match in every respect.    All we have to check is where they had their declarations.  */
end_comment

begin_function
specifier|static
name|int
name|strictly_overrides
parameter_list|(
name|fndecl1
parameter_list|,
name|fndecl2
parameter_list|)
name|tree
name|fndecl1
decl_stmt|,
name|fndecl2
decl_stmt|;
block|{
name|int
name|distance
init|=
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl2
argument_list|)
argument_list|,
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|==
operator|-
literal|2
operator|||
name|distance
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Merge overrides for one vtable.    If we want to merge in same function, we are fine.    else      if one has a DECL_CLASS_CONTEXT that is a parent of the        other, than choose the more derived one      else        potentially ill-formed (see 10.3 [class.virtual])        we have to check later to see if there was an        override in this class.  If there was ok, if not        then it is ill-formed.  (mrs)     We take special care to reuse a vtable, if we can.  */
end_comment

begin_function
specifier|static
name|void
name|override_one_vtable
parameter_list|(
name|binfo
parameter_list|,
name|old
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|old
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|old_virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|old
argument_list|)
decl_stmt|;
enum|enum
block|{
name|REUSE_NEW
block|,
name|REUSE_OLD
block|,
name|UNDECIDED
block|,
name|NEITHER
block|}
name|choose
init|=
name|UNDECIDED
enum|;
comment|/* If we have already committed to modifying it, then don't try and      reuse another vtable.  */
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|choose
operator|=
name|NEITHER
expr_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|old_virtuals
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|tree
name|old_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
decl_stmt|;
name|fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|old_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|old_fndecl
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|old_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First check to see if they are the same.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|old_fndecl
argument_list|)
condition|)
block|{
comment|/* No need to do anything.  */
block|}
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|fndecl
argument_list|,
name|old_fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|choose
operator|==
name|UNDECIDED
condition|)
name|choose
operator|=
name|REUSE_NEW
expr_stmt|;
elseif|else
if|if
condition|(
name|choose
operator|==
name|REUSE_OLD
condition|)
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|old_fndecl
argument_list|,
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|choose
operator|==
name|UNDECIDED
condition|)
name|choose
operator|=
name|REUSE_OLD
expr_stmt|;
elseif|else
if|if
condition|(
name|choose
operator|==
name|REUSE_NEW
condition|)
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|choose
operator|==
name|NEITHER
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
comment|/* This MUST be overridden, or the class is ill-formed.  */
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|vfn
decl_stmt|;
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make sure we search for it later.  */
if|if
condition|(
operator|!
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|vfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can use integer_zero_node, as we will core dump 	       if this is used anyway.  */
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
block|}
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|old_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Let's reuse the old vtable.  */
if|if
condition|(
name|choose
operator|==
name|REUSE_OLD
condition|)
block|{
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|BINFO_VTABLE
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge in overrides for virtual bases.    BINFO is the hierarchy we want to modify, and OLD has the potential    overrides.  */
end_comment

begin_function
specifier|static
name|void
name|merge_overrides
parameter_list|(
name|binfo
parameter_list|,
name|old
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|old
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|old_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|old
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|old_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|old_binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|merge_overrides
argument_list|(
name|base_binfo
argument_list|,
name|old_base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the base virtual function declarations in T that are either    overridden or hidden by FNDECL as a list.  We set TREE_PURPOSE with    the overrider/hider.  */
end_comment

begin_function
specifier|static
name|tree
name|get_basefndecls
parameter_list|(
name|fndecl
parameter_list|,
name|t
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|methods
init|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|base_fndecls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|methods
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|methods
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|methods
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|methods
argument_list|)
condition|)
name|base_fndecls
operator|=
name|temp_tree_cons
argument_list|(
name|fndecl
argument_list|,
name|methods
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
name|methods
operator|=
name|TREE_CHAIN
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base_fndecls
condition|)
return|return
name|base_fndecls
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|fndecl
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
return|return
name|base_fndecls
return|;
block|}
end_function

begin_comment
comment|/* Mark the functions that have been hidden with their overriders.    Since we start out with all functions already marked with a hider,    no need to mark functions that are just hidden.     Subroutine of warn_hidden.  */
end_comment

begin_function
specifier|static
name|void
name|mark_overriders
parameter_list|(
name|fndecl
parameter_list|,
name|base_fndecls
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|base_fndecls
decl_stmt|;
block|{
for|for
control|(
init|;
name|base_fndecls
condition|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
control|)
block|{
if|if
condition|(
name|overrides
argument_list|(
name|fndecl
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|base_fndecls
argument_list|)
operator|=
name|fndecl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If this declaration supersedes the declaration of    a method declared virtual in the base class, then    mark this field as being virtual as well.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_override
parameter_list|(
name|decl
parameter_list|,
name|ctype
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|ctype
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|virtualp
init|=
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|found_overriden_fn
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|get_matching_virtual
argument_list|(
name|base_binfo
argument_list|,
name|decl
argument_list|,
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
operator|!
name|found_overriden_fn
condition|)
block|{
comment|/* If this function overrides some virtual in some base 		 class, then the function itself is also necessarily 		 virtual, even if the user didn't explicitly say so.  */
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The TMP we really want is the one from the deepest 		 baseclass on this path, taking care not to 		 duplicate if we have already found it (via another 		 path to its virtual baseclass.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"method `%D' may not be declared static"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"(since `%D' declared virtual in base class.)"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|virtualp
operator|=
literal|1
expr_stmt|;
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tmp
argument_list|,
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We now know that DECL overrides something, 		 which is all that is important.  But, we must 		 continue to iterate through all the base-classes 		 in order to allow get_matching_virtual to check for 		 various illegal overrides.  */
name|found_overriden_fn
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|virtualp
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn about hidden virtual functions that are not overridden in t.    We know that constructors and destructors don't apply.  */
end_comment

begin_function
name|void
name|warn_hidden
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|n_methods
init|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We go through each separately named virtual function.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|n_methods
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|base_fndecls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* First see if we have any virtual functions in this batch.  */
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
continue|continue;
comment|/* First we get a list of all possible functions that might be 	 hidden from each base class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|fndecl
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
comment|/* ...then mark up all the base functions with overriders, preferring 	 overriders to hiders.  */
if|if
condition|(
name|base_fndecls
condition|)
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
condition|)
name|mark_overriders
argument_list|(
name|fndecl
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
comment|/* Now give a warning for all base functions without overriders, 	 as they are hidden.  */
for|for
control|(
init|;
name|base_fndecls
condition|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|overrides
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Here we know it is a hider, and no overrider exists.  */
name|cp_warning_at
argument_list|(
literal|"`%D' was hidden"
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  by `%D'"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check for things that are invalid.  There are probably plenty of other    things we should check for also.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_anon
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
modifier|*
name|uelt
init|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|*
name|uelt
condition|;
name|uelt
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|uelt
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
operator|*
name|uelt
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|uelt
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|t
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"ANSI C++ forbids member `%D' with same name as enclosing class"
argument_list|,
operator|*
name|uelt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|uelt
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"`%#D' invalid; an anonymous union can only have non-static data members"
argument_list|,
operator|*
name|uelt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
operator|*
name|uelt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"private member `%#D' in anonymous union"
argument_list|,
operator|*
name|uelt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
operator|*
name|uelt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"protected member `%#D' in anonymous union"
argument_list|,
operator|*
name|uelt
argument_list|)
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
operator|*
name|uelt
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
operator|*
name|uelt
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|interface_only
decl_stmt|,
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create default constructors, assignment operators, and so forth for    the type indicated by T, if they are needed.    CANT_HAVE_DEFAULT_CTOR, CANT_HAVE_CONST_CTOR, and    CANT_HAVE_ASSIGNMENT are nonzero if, for whatever reason, the class    cannot have a default constructor, copy constructor taking a const    reference argument, or an assignment operator, respectively.  If a    virtual destructor is created, its DECL is returned; otherwise the    return value is NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|add_implicitly_declared_members
parameter_list|(
name|t
parameter_list|,
name|cant_have_default_ctor
parameter_list|,
name|cant_have_const_cctor
parameter_list|,
name|cant_have_assignment
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|cant_have_default_ctor
decl_stmt|;
name|int
name|cant_have_const_cctor
decl_stmt|;
name|int
name|cant_have_assignment
decl_stmt|;
block|{
name|tree
name|default_fn
decl_stmt|;
name|tree
name|implicit_fns
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|virtual_dtor
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|f
decl_stmt|;
comment|/* Destructor.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_fn
operator|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_for_override
argument_list|(
name|default_fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we couldn't make it work, then pretend we didn't need it.  */
if|if
condition|(
name|default_fn
operator|==
name|void_type_node
condition|)
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|default_fn
argument_list|)
condition|)
name|virtual_dtor
operator|=
name|default_fn
expr_stmt|;
block|}
block|}
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Default constructor.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|cant_have_default_ctor
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_fn
operator|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Copy constructor.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* ARM 12.18: You get either X(X&) or X(const X&), but 	 not both.  --Chip  */
name|default_fn
operator|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|3
operator|+
name|cant_have_const_cctor
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Assignment operator.  */
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_fn
operator|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|5
operator|+
name|cant_have_assignment
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
name|implicit_fns
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Now, hook all of the new functions on to TYPE_METHODS,      and add them to the CLASSTYPE_METHOD_VEC.  */
for|for
control|(
name|f
operator|=
operator|&
name|implicit_fns
init|;
operator|*
name|f
condition|;
name|f
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|f
argument_list|)
control|)
name|add_method
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
operator|*
name|f
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|implicit_fns
expr_stmt|;
return|return
name|virtual_dtor
return|;
block|}
end_function

begin_comment
comment|/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration    (or C++ class declaration).     For C++, we must handle the building of derived classes.    Also, C++ allows static class members.  The way that this is    handled is to keep the field name where it is (as the DECL_NAME    of the field), and place the overloaded decl in the DECL_FIELD_BITPOS    of the field.  layout_record and layout_union will know about this.     More C++ hair: inline functions have text in their    DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into    meaningful tree structure.  After the struct has been laid out, set    things up so that this can happen.     And still more: virtual functions.  In the case of single inheritance,    when a new virtual function is seen which redefines a virtual function    from the base class, the new virtual function is placed into    the virtual function table at exactly the same address that    it had in the base class.  When this is extended to multiple    inheritance, the same thing happens, except that multiple virtual    function tables must be maintained.  The first virtual function    table is treated in exactly the same way as in the case of single    inheritance.  Additional virtual function tables have different    DELTAs, which tell how to adjust `this' to point to the right thing.     ATTRIBUTES is the set of decl attributes to be applied, if any.  */
end_comment

begin_function
name|void
name|finish_struct_1
parameter_list|(
name|t
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
name|int
name|old
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|last_x
decl_stmt|,
name|method_vec
decl_stmt|;
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|tree
name|pending_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|pending_hard_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|tree
name|virtual_dtor
decl_stmt|;
name|int
name|cant_have_default_ctor
decl_stmt|;
name|int
name|cant_have_const_ctor
decl_stmt|;
name|int
name|no_const_asn_ref
decl_stmt|;
name|int
name|has_mutable
init|=
literal|0
decl_stmt|;
comment|/* The index of the first base class which has virtual      functions.  Only applied to non-virtual baseclasses.  */
name|int
name|first_vfn_base_index
decl_stmt|;
name|int
name|n_baseclasses
decl_stmt|;
name|int
name|any_default_members
init|=
literal|0
decl_stmt|;
name|int
name|const_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|ref_sans_init
init|=
literal|0
decl_stmt|;
name|tree
name|access_decls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|aggregate
init|=
literal|1
decl_stmt|;
name|int
name|empty
init|=
literal|1
decl_stmt|;
name|int
name|has_pointers
init|=
literal|0
decl_stmt|;
name|tree
name|inline_friends
decl_stmt|;
if|if
condition|(
name|warn_anon
operator|&&
name|code
operator|!=
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"anonymous class type not used to declare any objects"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|172
argument_list|)
expr_stmt|;
name|popclass
argument_list|()
expr_stmt|;
return|return;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is in general too late to do this.  I moved the main case up to      left_curly, what else needs to move?  */
block|if (! IS_SIGNATURE (t))     {       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);       my_friendly_assert (CLASSTYPE_INTERFACE_KNOWN (t) == ! interface_unknown, 999);     }
endif|#
directive|endif
name|old
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* Install struct as DECL_FIELD_CONTEXT of each field decl.      Also process specified field sizes.      Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.      The specified size is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
condition|)
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|n_baseclasses
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
name|struct
name|base_info
name|base_info
decl_stmt|;
name|first_vfn_base_index
operator|=
name|finish_base_struct
argument_list|(
name|t
argument_list|,
operator|&
name|base_info
argument_list|)
expr_stmt|;
comment|/* Remember where we got our vfield from.  */
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|t
argument_list|)
operator|=
name|first_vfn_base_index
expr_stmt|;
name|has_virtual
operator|=
name|base_info
operator|.
name|has_virtual
expr_stmt|;
name|max_has_virtual
operator|=
name|base_info
operator|.
name|max_has_virtual
expr_stmt|;
name|vfield
operator|=
name|base_info
operator|.
name|vfield
expr_stmt|;
name|vfields
operator|=
name|base_info
operator|.
name|vfields
expr_stmt|;
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|base_info
operator|.
name|rtti
expr_stmt|;
name|cant_have_default_ctor
operator|=
name|base_info
operator|.
name|cant_have_default_ctor
expr_stmt|;
name|cant_have_const_ctor
operator|=
name|base_info
operator|.
name|cant_have_const_ctor
expr_stmt|;
name|no_const_asn_ref
operator|=
name|base_info
operator|.
name|no_const_asn_ref
expr_stmt|;
name|aggregate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|first_vfn_base_index
operator|=
operator|-
literal|1
expr_stmt|;
name|has_virtual
operator|=
literal|0
expr_stmt|;
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
name|vfield
operator|=
name|NULL_TREE
expr_stmt|;
name|vfields
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|cant_have_default_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_const_ctor
operator|=
literal|0
expr_stmt|;
name|no_const_asn_ref
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Both of these should be done before now.  */
block|if (write_virtuals == 3&& CLASSTYPE_INTERFACE_KNOWN (t)&& ! IS_SIGNATURE (t))     {       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);       my_friendly_assert (CLASSTYPE_VTABLE_NEEDS_WRITING (t) == ! interface_only, 999);     }
endif|#
directive|endif
comment|/* The three of these are approximations which may later be      modified.  Needed at this point to make add_virtual_function      and modify_vtable_entries work.  */
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If this was an evil function, don't keep it in class.  */
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Do both of these, even though they're in the same union; 	 if the insn `r' member and the size `i' member are 	 different sizes, as on the alpha, the larger of the two 	 will end up with garbage in it.  */
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|check_for_override
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"initializer specified for non-virtual method `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* The name of the field is the original field name 	 Save this in auxiliary field for later overloading.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|add_virtual_function
argument_list|(
operator|&
name|pending_virtuals
argument_list|,
operator|&
name|pending_hard_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Why did I comment this out?  (jason) */
block|else 	    TREE_USED (x) = 1;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|n_baseclasses
condition|)
name|fields
operator|=
name|chainon
argument_list|(
name|build_vbase_pointer_fields
argument_list|(
name|t
argument_list|)
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
operator||=
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
comment|/* A zero-width bitfield doesn't do the trick.  */
empty_stmt|;
else|else
name|empty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
condition|)
block|{
comment|/* Save access declarations for later.  */
if|if
condition|(
name|last_x
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|access_decls
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|access_decls
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
continue|continue;
comment|/* If we've gotten this far, it's a data member, possibly static, 	 or an enumerator.  */
name|DECL_FIELD_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* ``A local class cannot have static data members.'' ARM 9.4 */
if|if
condition|(
name|current_function_decl
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"field `%D' in local class cannot be static"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Perform error checking that did not get done in 	 grokdeclarator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared function type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared method type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared offset type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (DECL_NAME (x) == constructor_name (t)) 	cant_have_default_ctor = 1;
endif|#
directive|endif
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* When this goes into scope, it will be a non-local reference.  */
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* Unions cannot have static members.  */
name|cp_error_at
argument_list|(
literal|"field `%D' declared static in union"
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now it can only be a FIELD_DECL.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
condition|)
name|aggregate
operator|=
literal|0
expr_stmt|;
comment|/* If this is of reference type, check if it needs an init. 	 Also do a little ANSI jig if necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|ref_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static reference `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|cp_warning_at
argument_list|(
literal|"non-static reference in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|has_pointers
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|x
argument_list|)
operator|||
name|TYPE_HAS_MUTABLE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|has_mutable
operator|=
literal|1
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static const member `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|cp_warning_at
argument_list|(
literal|"non-static const member in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A field that is pseudo-const makes the structure 	     likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t1
argument_list|)
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We set DECL_C_BIT_FIELD in grokbitfield. 	 If the type and width are valid, we'll also set DECL_BIT_FIELD.  */
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Invalid bit-field size done by grokfield.  */
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%#D' with non-integral type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tree
name|w
init|=
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|width
init|=
literal|0
decl_stmt|;
comment|/* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */
name|STRIP_NOPS
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* detect invalid field size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|w
operator|=
name|DECL_INITIAL
argument_list|(
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|w
argument_list|)
condition|)
name|w
operator|=
name|decl_constant_value
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%D' width not an integer constant"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|w
argument_list|)
operator|,
name|width
operator|<
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"negative width in bit-field `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"zero width for bit-field `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
condition|)
block|{
comment|/* The backend will dump if you try to use something 		     too big; avoid that.  */
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sorry
argument_list|(
literal|"bit-fields larger than %d bits"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  in declaration of `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"width of `%D' exceeds its type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
operator|(
name|min_precision
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|width
operator|)
operator|||
operator|(
name|min_precision
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|width
operator|)
operator|)
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"`%D' is too small to hold all values of `%#T'"
argument_list|,
name|x
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|width
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
condition|)
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|ANON_UNION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Never let anything with uninheritable virtuals 		 make it through without complaint.  */
if|if
condition|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Don't let signatures make it through either.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
name|signature_error
argument_list|(
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
specifier|const
name|char
modifier|*
name|fie
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"constructor"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"destructor"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"copy assignment operator"
expr_stmt|;
if|if
condition|(
name|fie
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with %s not allowed in union"
argument_list|,
name|x
argument_list|,
name|fie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is wrong for aggregates.  */
block|if (! TYPE_HAS_CONSTRUCTOR (t)) 		    { 		      if (DECL_NAME (x)) 			cp_pedwarn_at ("member `%#D' with only non-default constructor", x); 		      else 			cp_pedwarn_at ("member with only non-default constructor", x); 		      cp_pedwarn_at ("in class without a constructor", 				     x); 		    }
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* `build_class_init_list' does not recognize 		 non-FIELD_DECLs.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|any_default_members
operator|!=
literal|0
condition|)
name|cp_error_at
argument_list|(
literal|"multiple fields in union `%T' initialized"
argument_list|)
expr_stmt|;
name|any_default_members
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If this type has any constant members which did not come      with their own initialization, mark that fact here.  It is      not an error here, since such types can be saved either by their      constructors, or by fortuitous initialization.  */
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|const_sans_init
expr_stmt|;
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|ref_sans_init
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
name|CLASSTYPE_HAS_MUTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|has_mutable
expr_stmt|;
comment|/* Effective C++ rule 11.  */
if|if
condition|(
name|has_pointers
operator|&&
name|warn_ecpp
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`%#T' has pointer data members"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"  but does not override `%T(const %T&)'"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"  or `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"  but does not override `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Do some bookkeeping that will guide the generation of implicitly      declared member functions.  */
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|has_virtual
operator|||
name|any_default_members
operator|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|has_virtual
operator|||
name|any_default_members
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|aggregate
operator|||
name|has_virtual
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_REAL_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Synthesize any needed methods.  Note that methods will be synthesized      for anonymous unions; grok_x_components undoes that.  */
name|virtual_dtor
operator|=
name|add_implicitly_declared_members
argument_list|(
name|t
argument_list|,
name|cant_have_default_ctor
argument_list|,
name|cant_have_const_ctor
argument_list|,
name|no_const_asn_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_dtor
condition|)
name|add_virtual_function
argument_list|(
operator|&
name|pending_virtuals
argument_list|,
operator|&
name|pending_hard_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|virtual_dtor
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|finish_struct_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|method_vec
operator|=
literal|0
expr_stmt|;
comment|/* Just in case these got accidentally 	 filled in by syntax errors.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|access_decls
operator|=
name|nreverse
argument_list|(
name|access_decls
argument_list|)
init|;
name|access_decls
condition|;
name|access_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|access_decls
argument_list|)
control|)
name|handle_using_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|access_decls
argument_list|)
argument_list|,
name|t
argument_list|,
name|method_vec
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfield
operator|==
name|NULL_TREE
operator|&&
name|has_virtual
condition|)
block|{
comment|/* We build this decl with vtbl_ptr_type_node, which is a 	 `vtable_entry_type*'.  It might seem more precise to use 	 `vtable_entry_type (*)[N]' where N is the number of firtual 	 functions.  However, that would require the vtable pointer in 	 base classes to have a different type than the vtable pointer 	 in derived classes.  We could make that happen, but that 	 still wouldn't solve all the problems.  In particular, the 	 type-based alias analysis code would decide that assignments 	 to the base class vtable pointer can't alias assignments to 	 the derived class vtable pointer, since they have different 	 types.  Thus, in an derived class destructor, where the base 	 class constructor was inlined, we could generate bad code for 	 setting up the vtable pointer.             Therefore, we use one type for all vtable pointers.  We still 	 use a type-correct type; it's just doesn't indicate the array 	 bounds.  That's better than using `void*' or some such; it's 	 cleaner, and it let's the alias analysis code know that these 	 stores cannot alias stores to void*!  */
name|vfield
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|vtbl_ptr_type_node
argument_list|)
expr_stmt|;
comment|/* If you change any of the below, take a look at all the 	 other VFIELD_BASEs and VTABLE_BASEs in the code, and change 	 them too.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|vfield
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VFIELD_BASE
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|vfield
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|vfield
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|vfield
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is more efficient, but breaks binary compatibility, turn 	 it on sometime when we don't care.  If we turn it on, we also 	 have to enable the code in dfs_init_vbase_pointers.  */
comment|/* vfield is always first entry in structure.  */
block|TREE_CHAIN (vfield) = fields;       fields = vfield;
else|#
directive|else
if|if
condition|(
name|last_x
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|175
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|last_x
operator|=
name|vfield
expr_stmt|;
block|}
else|else
name|fields
operator|=
name|vfield
expr_stmt|;
endif|#
directive|endif
name|empty
operator|=
literal|0
expr_stmt|;
name|vfields
operator|=
name|chainon
argument_list|(
name|vfields
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now DECL_INITIAL is null on all members except for zero-width bit-fields.       C++: maybe we will support default field initialization some day...  */
comment|/* Delete all duplicate fields from the fields */
name|delete_duplicate_fields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Now we have the nearly final fieldlist for the data fields.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
block|{
name|last_x
operator|=
name|build_base_fields
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If all our bases are empty, we can be empty too.  */
for|for
control|(
name|x
operator|=
name|last_x
init|;
name|empty
operator|&&
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|x
argument_list|)
operator|!=
name|integer_zero_node
condition|)
name|empty
operator|=
literal|0
expr_stmt|;
block|}
comment|/* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,      we have to save this before we start modifying      TYPE_NONCOPIED_PARTS.  */
name|inline_friends
operator|=
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
comment|/* C++: do not let empty structures exist.  */
name|tree
name|decl
init|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|fields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|last_x
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Remember the size and alignment of the class before adding      the virtual bases.  */
if|if
condition|(
name|empty
operator|&&
name|flag_new_abi
condition|)
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_new_abi
operator|&&
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_struct_anon
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_DECL for this type to contain the right      value for DECL_OFFSET, so that we can use it as part      of a COMPONENT_REF for multiple inheritance.  */
name|layout_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now fix up any virtual base class types that we left lying      around.  We must get these done before we try to lay out the      virtual function table.  */
name|pending_hard_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
comment|/* layout_basetypes will remove the base subobject fields.  */
name|max_has_virtual
operator|=
name|layout_basetypes
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|==
name|fields
argument_list|,
literal|981117
argument_list|)
expr_stmt|;
comment|/* Delete all zero-width bit-fields from the front of the fieldlist */
while|while
condition|(
name|fields
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|fields
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fields
argument_list|)
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Delete all such fields from the rest of the fields.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|{
comment|/* Now fixup overrides of all functions in vtables from all 	   direct or indirect virtual base classes.  */
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|merge_overrides
argument_list|(
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|vbases
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we      might need to know it for setting up the offsets in the vtable      (or in thunks) below.  */
if|if
condition|(
name|vfield
operator|!=
name|NULL_TREE
operator|&&
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|!=
name|t
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|offset
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"Doing hard virtuals for %T..."
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|has_virtual
operator|>
name|max_has_virtual
condition|)
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|max_has_virtual
operator|>
literal|0
condition|)
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_rtti
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|pending_hard_virtuals
condition|)
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
while|while
condition|(
name|pending_hard_virtuals
condition|)
block|{
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
expr_stmt|;
name|pending_hard_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
comment|/* Now fixup any virtual function entries from virtual bases 	 that have different deltas.  This has to come after we do the 	 pending hard virtuals, as we might have a function that comes 	 from multiple virtual base instances that is only overridden 	 by a hard virtual above.  */
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
comment|/* We might be able to shorten the amount of work we do by 	     only doing this for vtables that come from virtual bases 	     that have differing offsets, but don't want to miss any 	     entries.  */
name|fixup_vtable_deltas
argument_list|(
name|vbases
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Under our model of GC, every C++ class gets its own virtual      function table, at least virtually.  */
if|if
condition|(
name|pending_virtuals
condition|)
block|{
name|pending_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* We must enter these virtuals into the table.  */
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|CLASSTYPE_COM_INTERFACE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* The second slot is for the tdesc pointer when thunks are used.  */
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* The first slot is for the rtti offset.  */
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|pending_virtuals
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|build_vtable
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we know enough to change the type of our virtual 	     function table, but we will wait until later this function.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|first_vfn_base_index
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this type has basetypes with constructors, then those 	 constructors might clobber the virtual function table.  But 	 they don't if the derived class shares the exact vtable of the base 	 class.  */
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|first_vfn_base_index
argument_list|)
decl_stmt|;
comment|/* This class contributes nothing new to the virtual function 	 table.  However, it may have declared functions which 	 went into the virtual function table "inherited" from the 	 base class.  If so, we grab a copy of those updated functions, 	 and pretend they are ours.  */
comment|/* See if we should steal the virtual info from base class.  */
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|!=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
condition|)
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|max_has_virtual
operator|||
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pending_virtuals
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_virtual
condition|)
block|{
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|pending_virtuals
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now lay out the virtual function table.  */
if|if
condition|(
name|has_virtual
condition|)
block|{
comment|/* Use size_int so values are memoized in common cases.  */
name|tree
name|itype
init|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|has_virtual
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|atype
init|=
name|build_cplus_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
decl_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
comment|/* We may have to grow the vtable.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|atype
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|atype
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* At one time the vtable info was grabbed 2 words at a time.  This 	     fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|finish_struct_bits
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
comment|/* Complete the rtl for any static member objects of the type we're      working on.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|t
condition|)
block|{
name|DECL_MODE
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
comment|/* Mark the fact that constructor for T 	     could affect anybody inheriting from T 	     who wants to initialize vtables for VFIELDS's type.  */
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write out inline function definitions.  */
name|do_inline_function_hair
argument_list|(
name|t
argument_list|,
name|inline_friends
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is now done above.  */
block|if (DECL_FIELD_CONTEXT (vfield) != t) 	{ 	  tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0); 	  tree offset = BINFO_OFFSET (binfo);  	  vfield = copy_node (vfield); 	  copy_lang_decl (vfield);  	  if (! integer_zerop (offset)) 	    offset = size_binop (MULT_EXPR, offset, size_int (BITS_PER_UNIT)); 	  DECL_FIELD_CONTEXT (vfield) = t; 	  DECL_CLASS_CONTEXT (vfield) = t; 	  DECL_FIELD_BITPOS (vfield) 	    = size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield)); 	  CLASSTYPE_VFIELD (t) = vfield; 	}
endif|#
directive|endif
comment|/* In addition to this one, all the other vfields should be listed.  */
comment|/* Before that can be done, we have to have FIELD_DECLs for them, and 	 a place to find them.  */
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|default_conversion
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|vfield
argument_list|,
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_nonvdtor
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|cp_warning
argument_list|(
literal|"`%#T' has virtual functions but non-virtual destructor"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Make the rtl for any new vtables we have created, and unmark      the base types we marked.  */
name|finish_vtbls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|hack_incomplete_structures
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TYPE_NAME (t)&& TYPE_IDENTIFIER (t))     undo_template_name_overload (TYPE_IDENTIFIER (t), 1);
endif|#
directive|endif
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_overloaded_virtual
condition|)
name|warn_hidden
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This has to be done after we have sorted out what to do with      the enclosing type.  */
block|if (write_symbols != DWARF_DEBUG)     {
comment|/* Be smarter about nested classes here.  If a type is nested, 	 only output it if we would output the enclosing type.  */
block|if (DECL_CLASS_SCOPE_P (TYPE_MAIN_DECL (t))) 	DECL_IGNORED_P (TYPE_MAIN_DECL (t)) = TREE_ASM_WRITTEN (TYPE_MAIN_DECL (t));     }
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|!=
name|DWARF_DEBUG
operator|&&
name|write_symbols
operator|!=
name|DWARF2_DEBUG
condition|)
block|{
comment|/* If the type has methods, we want to think about cutting down 	 the amount of symbol table stuff we output.  The value stored in 	 the TYPE_DECL's DECL_IGNORED_P slot is a first approximation. 	 For example, if a member function is seen and we decide to 	 write out that member function, then we can change the value 	 of the DECL_IGNORED_P slot, and the type will be output when 	 that member function's debug info is written out.  	 We can't do this with DWARF, which does not support name 	 references between translation units.  */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Don't output full info about any type 	     which does not have its implementation defined here.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX do something about this.  */
block|else if (CLASSTYPE_INTERFACE_UNKNOWN (t))
comment|/* Only a first approximation!  */
block|TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* When T was built up, the member declarations were added in reverse    order.  Rearrange them to declaration order.  */
end_comment

begin_function
name|void
name|unreverse_member_declarations
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|next
decl_stmt|;
name|tree
name|prev
decl_stmt|;
name|tree
name|x
decl_stmt|;
comment|/* The TYPE_FIELDS, TYPE_METHODS, and CLASSTYPE_TAGS are all in      reverse order.  Put them in declaration order now.  */
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in      reverse order, so we can't just use nreverse.  */
name|prev
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
condition|;
name|x
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|attributes
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|,
name|attributes
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|name
argument_list|)
operator|=
name|input_filename
expr_stmt|;
comment|/* For TYPE_DECL that are not typedefs (those marked with a line 	 number of zero, we don't want to mark them as real typedefs. 	 If this fails one needs to make sure real typedefs have a 	 previous line number, even if it is wrong, that way the below 	 will fill in the right line number.  (mrs) */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Append the fields we need for constructing signature tables.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|append_signature_fields
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Now that we've got all the field declarations, reverse everything      as necessary.  */
name|unreverse_member_declarations
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|d
init|=
name|getdecls
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|d
condition|;
name|d
operator|=
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
control|)
block|{
comment|/* If this is the decl for the class or one of the template              parms, we've seen all the injected decls.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
operator|==
name|t
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|CONST_DECL
condition|)
break|break;
comment|/* Don't inject cache decls.  */
elseif|else
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|DECL_NAME
argument_list|(
name|d
argument_list|)
argument_list|)
condition|)
continue|continue;
name|DECL_TEMPLATE_INJECT
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|d
argument_list|,
name|DECL_TEMPLATE_INJECT
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_struct_methods
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
name|finish_struct_1
argument_list|(
name|t
argument_list|,
name|warn_anon
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
name|popclass
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to finish struct, but kicked out due to previous parse errors."
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the dynamic type of INSTANCE, if known.    Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  */
end_comment

begin_function
specifier|static
name|tree
name|fixed_type_or_null
parameter_list|(
name|instance
parameter_list|,
name|nonnull
parameter_list|)
name|tree
name|instance
decl_stmt|;
name|int
modifier|*
name|nonnull
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
comment|/* Check that we are not going through a cast of some sort.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|instance
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fall through...  */
case|case
name|CALL_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|SAVE_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
return|return
name|NULL_TREE
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Propagate nonnull.  */
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
name|fixed_type_or_null
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
return|;
block|}
comment|/* fall through...  */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|nonnull
condition|)
block|{
if|if
condition|(
name|instance
operator|==
name|current_class_ptr
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
block|{
comment|/* Normally, 'this' must be non-null.  */
if|if
condition|(
name|flag_this_is_variable
operator|==
literal|0
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
comment|/*<0 means we're in a constructor and we know our type.  */
if|if
condition|(
name|flag_this_is_variable
operator|<
literal|0
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* Reference variables should be references to objects.  */
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the dynamic type of INSTANCE is known, and equivalent    to the static type.  We also handle the case where INSTANCE is really    a pointer.     Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  */
end_comment

begin_function
name|int
name|resolves_to_fixed_type_p
parameter_list|(
name|instance
parameter_list|,
name|nonnull
parameter_list|)
name|tree
name|instance
decl_stmt|;
name|int
modifier|*
name|nonnull
decl_stmt|;
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
name|tree
name|fixed
init|=
name|fixed_type_or_null
argument_list|(
name|instance
argument_list|,
name|nonnull
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixed
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|fixed
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_class_processing
parameter_list|()
block|{
name|current_class_depth
operator|=
literal|0
expr_stmt|;
name|current_class_stack_size
operator|=
literal|10
expr_stmt|;
name|current_class_stack
operator|=
operator|(
name|class_stack_node_t
operator|)
name|xmalloc
argument_list|(
name|current_class_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|class_stack_node
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_stacksize
operator|=
literal|10
expr_stmt|;
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_lang_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
expr_stmt|;
name|access_default_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_public_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_protected_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_private_node
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_default_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_public_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_protected_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_private_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep these values lying around.  */
name|base_layout_decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current scope to NAME. CODE tells us if this is a    STRUCT, UNION, or ENUM environment.     NAME may end up being NULL_TREE if this is an anonymous or    late-bound struct (as in "struct { ... } foo;")  */
end_comment

begin_comment
comment|/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE to    appropriate values, found by looking up the type definition of    NAME (as a CODE).     If MODIFY is 1, we set IDENTIFIER_CLASS_VALUE's of names    which can be seen locally to the class.  They are shadowed by    any subsequent local declaration (including parameter names).     If MODIFY is 2, we set IDENTIFIER_CLASS_VALUE's of names    which have static meaning (i.e., static members, static    member functions, enum declarations, etc).     If MODIFY is 3, we set IDENTIFIER_CLASS_VALUE of names    which can be seen locally to the class (as in 1), but    know that we are doing this for declaration purposes    (i.e. friend foo::bar (int)).     So that we may avoid calls to lookup_name, we cache the _TYPE    nodes of local TYPE_DECLs in the TREE_TYPE field of the name.     For multiple inheritance, we perform a two-pass depth-first search    of the type lattice.  The first pass performs a pre-order search,    marking types after the type has had its fields installed in    the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely    unmarks the marked types.  If a field or member function name    appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of    that name becomes `error_mark_node'.  */
end_comment

begin_function
name|void
name|pushclass
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure there is enough room for the new entry on the stack.  */
if|if
condition|(
name|current_class_depth
operator|+
literal|1
operator|>=
name|current_class_stack_size
condition|)
block|{
name|current_class_stack_size
operator|*=
literal|2
expr_stmt|;
name|current_class_stack
operator|=
operator|(
name|class_stack_node_t
operator|)
name|xrealloc
argument_list|(
name|current_class_stack
argument_list|,
name|current_class_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|class_stack_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert a new entry on the class stack.  */
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|name
operator|=
name|current_class_name
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|type
operator|=
name|current_class_type
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|access
operator|=
name|current_access_specifier
expr_stmt|;
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
operator|=
literal|0
expr_stmt|;
name|current_class_depth
operator|++
expr_stmt|;
comment|/* Now set up the new type.  */
name|current_class_name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|current_class_name
operator|=
name|DECL_NAME
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
name|current_class_type
operator|=
name|type
expr_stmt|;
comment|/* By default, things in classes are private, while things in      structures or unions are public.  */
name|current_access_specifier
operator|=
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|type
argument_list|)
condition|?
name|access_private_node
else|:
name|access_public_node
operator|)
expr_stmt|;
if|if
condition|(
name|previous_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|type
operator|!=
name|previous_class_type
operator|||
name|TYPE_SIZE
argument_list|(
name|previous_class_type
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|&&
name|current_class_depth
operator|==
literal|1
condition|)
block|{
comment|/* Forcibly remove any old class remnants.  */
name|invalidate_class_lookup_cache
argument_list|()
expr_stmt|;
comment|/* Now, free the obstack on which we cached all the values.  */
if|if
condition|(
name|class_cache_firstobj
condition|)
name|obstack_free
argument_list|(
operator|&
name|class_cache_obstack
argument_list|,
name|class_cache_firstobj
argument_list|)
expr_stmt|;
name|class_cache_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|class_cache_obstack
argument_list|)
expr_stmt|;
block|}
comment|/* If we're about to enter a nested class, clear      IDENTIFIER_CLASS_VALUE for the enclosing classes.  */
if|if
condition|(
name|modify
operator|&&
name|current_class_depth
operator|>
literal|1
condition|)
name|clear_identifier_class_values
argument_list|()
expr_stmt|;
name|pushlevel_class
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if (CLASSTYPE_TEMPLATE_INFO (type))     overload_template_name (type);
endif|#
directive|endif
if|if
condition|(
name|modify
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|previous_class_type
operator|||
name|current_class_depth
operator|>
literal|1
condition|)
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|item
decl_stmt|;
comment|/* We are re-entering the same class we just left, so we 	     don't have to search the whole inheritance matrix to find 	     all the decls to bind again.  Instead, we install the 	     cached class_shadowed list, and walk through it binding 	     names and setting up IDENTIFIER_TYPE_VALUEs.  */
name|set_class_shadows
argument_list|(
name|previous_class_values
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|previous_class_values
init|;
name|item
condition|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_PURPOSE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|push_class_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|id
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unuse_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|storetags
argument_list|(
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* When we exit a toplevel class scope, we save the    IDENTIFIER_CLASS_VALUEs so that we can restore them quickly if we    reenter the class.  Here, we've entered some other class, so we    must invalidate our cache.  */
end_comment

begin_function
name|void
name|invalidate_class_lookup_cache
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
comment|/* This code can be seen as a cache miss.  When we've cached a      class' scope's bindings and we can't use them, we need to reset      them.  This is it!  */
for|for
control|(
name|t
operator|=
name|previous_class_values
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current class scope. If we were in a class scope    previously, that is the one popped to.  */
end_comment

begin_function
name|void
name|popclass
parameter_list|()
block|{
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Since poplevel_class does the popping of class decls nowadays,      this really only frees the obstack used for these decls.  */
name|pop_class_decls
argument_list|()
expr_stmt|;
name|current_class_depth
operator|--
expr_stmt|;
name|current_class_name
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|name
expr_stmt|;
name|current_class_type
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|type
expr_stmt|;
name|current_access_specifier
operator|=
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|access
expr_stmt|;
if|if
condition|(
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
condition|)
name|splay_tree_delete
argument_list|(
name|current_class_stack
index|[
name|current_class_depth
index|]
operator|.
name|names_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if current_class_type is either T or a nested type of T.  */
end_comment

begin_function
name|int
name|currently_open_class
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|current_class_type
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_class_depth
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|current_class_stack
index|[
name|i
index|]
operator|.
name|type
operator|==
name|t
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When entering a class scope, all enclosing class scopes' names with    static meaning (static variables, static functions, types and enumerators)    have to be visible.  This recursive function calls pushclass for all    enclosing class contexts until global or a local scope is reached.    TYPE is the enclosed class and MODIFY is equivalent with the pushclass    formal of the same name.  */
end_comment

begin_function
name|void
name|push_nested_class
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
comment|/* A namespace might be passed in error cases, like A::B:C.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
return|return;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undoes a push_nested_class call.  MODIFY is passed on to popclass.  */
end_comment

begin_function
name|void
name|pop_nested_class
parameter_list|()
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|popclass
argument_list|()
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_LANG_NAME to appropriate value    so that behavior of name-mangling machinery is correct.  */
end_comment

begin_function
name|void
name|push_lang_context
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
operator|*
name|current_lang_stack
operator|++
operator|=
name|current_lang_name
expr_stmt|;
if|if
condition|(
name|current_lang_stack
operator|>=
name|current_lang_base
operator|+
name|current_lang_stacksize
condition|)
block|{
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_lang_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_lang_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
operator|+
name|current_lang_stacksize
expr_stmt|;
name|current_lang_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_java
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
comment|/* DECL_IGNORED_P is initially set for these types, to avoid clutter. 	 (See record_builtin_java_type in decl.c.)  However, that causes 	 incorrect debug entries if these types are actually used. 	 So we re-enable debug output after extern "Java". */
name|DECL_IGNORED_P
argument_list|(
name|java_byte_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|java_short_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|java_int_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|java_long_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|java_float_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|java_double_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|java_char_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|java_boolean_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"language string `\"%s\"' not recognized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current language scope.  */
end_comment

begin_function
name|void
name|pop_lang_context
parameter_list|()
block|{
name|current_lang_name
operator|=
operator|*
operator|--
name|current_lang_stack
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|||
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Type instantiation routines.  */
end_comment

begin_comment
comment|/* Given an OVERLOAD and a TARGET_TYPE, return the function that    matches the TARGET_TYPE.  If there is no satisfactory match, return    error_mark_node, and issue an error message if COMPLAIN is    non-zero.  If TEMPLATE_ONLY, the name of the overloaded function    was a template-id, and EXPLICIT_TARGS are the explicitly provided    template arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_address_of_overloaded_function
parameter_list|(
name|target_type
parameter_list|,
name|overload
parameter_list|,
name|complain
parameter_list|,
name|template_only
parameter_list|,
name|explicit_targs
parameter_list|)
name|tree
name|target_type
decl_stmt|;
name|tree
name|overload
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|int
name|template_only
decl_stmt|;
name|tree
name|explicit_targs
decl_stmt|;
block|{
comment|/* Here's what the standard says:              [over.over]         If the name is a function template, template argument deduction        is done, and if the argument deduction succeeds, the deduced        arguments are used to generate a single template function, which        is added to the set of overloaded functions considered.         Non-member functions and static member functions match targets of        type "pointer-to-function" or "reference-to-function."  Nonstatic        member functions match targets of type "pointer-to-member        function;" the function type of the pointer to member is used to        select the member function from the set of overloaded member        functions.  If a nonstatic member function is selected, the        reference to the overloaded function name is required to have the        form of a pointer to member as described in 5.3.1.         If more than one function is selected, any template functions in        the set are eliminated if the set also contains a non-template        function, and any given template function is eliminated if the        set contains a second template function that is more specialized        than the first according to the partial ordering rules 14.5.5.2.        After such eliminations, if any, there shall remain exactly one        selected function.  */
name|int
name|is_ptrmem
init|=
literal|0
decl_stmt|;
name|int
name|is_reference
init|=
literal|0
decl_stmt|;
comment|/* We store the matches in a TREE_LIST rooted here.  The functions      are the TREE_PURPOSE, not the TREE_VALUE, in this list, for easy      interoperability with most_specialized_instantiation.  */
name|tree
name|matches
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* By the time we get here, we should be seeing only real      pointer-to-member types, not the internal POINTER_TYPE to      METHOD_TYPE representation.  */
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check that the TARGET_TYPE is reasonable.  */
if|if
condition|(
name|TYPE_PTRFN_P
argument_list|(
name|target_type
argument_list|)
condition|)
comment|/* This is OK.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|target_type
argument_list|)
condition|)
comment|/* This is OK, too.  */
name|is_ptrmem
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* This is OK, too.  This comes from a conversion to reference 	 type.  */
name|target_type
operator|=
name|build_reference_type
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|is_reference
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"cannot resolve overloaded function `%D' based on conversion to type `%T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If we can find a non-template function that matches, we can just      use it.  There's no point in generating template instantiations      if we're just going to throw them out anyhow.  But, of course, we      can only do this when we don't *need* a template function.  */
if|if
condition|(
operator|!
name|template_only
condition|)
block|{
name|tree
name|fns
decl_stmt|;
for|for
control|(
name|fns
operator|=
name|overload
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_CHAIN
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_FUNCTION
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* We're not looking for templates just yet.  */
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|!=
name|is_ptrmem
condition|)
comment|/* We're looking for a non-static member, and this isn't 	       one, or vice versa.  */
continue|continue;
comment|/* See if there's a match.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|fntype
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_reference
condition|)
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_convert_arg
argument_list|(
name|target_type
argument_list|,
name|fntype
argument_list|,
name|fn
argument_list|)
condition|)
name|matches
operator|=
name|scratch_tree_cons
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|matches
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, if we've already got a match (or matches), there's no need      to proceed to the template functions.  But, if we don't have a      match we need to look at them, too.  */
if|if
condition|(
operator|!
name|matches
condition|)
block|{
name|tree
name|target_fn_type
decl_stmt|;
name|tree
name|target_arg_types
decl_stmt|;
name|tree
name|fns
decl_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|target_fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|target_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|target_fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|target_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|target_fn_type
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|overload
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_CHAIN
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_FUNCTION
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|instantiation
decl_stmt|;
name|tree
name|instantiation_type
decl_stmt|;
name|tree
name|targs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* We're only looking for templates.  */
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|!=
name|is_ptrmem
condition|)
comment|/* We're not looking for a non-static member, and this is 	       one, or vice versa.  */
continue|continue;
comment|/* Try to do argument deduction.  */
name|targs
operator|=
name|make_scratch_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_type_unification
argument_list|(
name|fn
argument_list|,
name|explicit_targs
argument_list|,
name|targs
argument_list|,
name|target_arg_types
argument_list|,
name|NULL_TREE
argument_list|,
name|DEDUCE_EXACT
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Argument deduction failed.  */
continue|continue;
comment|/* Instantiate the template.  */
name|instantiation
operator|=
name|instantiate_template
argument_list|(
name|fn
argument_list|,
name|targs
argument_list|)
expr_stmt|;
if|if
condition|(
name|instantiation
operator|==
name|error_mark_node
condition|)
comment|/* Instantiation failed.  */
continue|continue;
comment|/* See if there's a match.  */
name|instantiation_type
operator|=
name|TREE_TYPE
argument_list|(
name|instantiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptrmem
condition|)
name|instantiation_type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|instantiation_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_reference
condition|)
name|instantiation_type
operator|=
name|build_pointer_type
argument_list|(
name|instantiation_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_convert_arg
argument_list|(
name|target_type
argument_list|,
name|instantiation_type
argument_list|,
name|instantiation
argument_list|)
condition|)
name|matches
operator|=
name|scratch_tree_cons
argument_list|(
name|instantiation
argument_list|,
name|fn
argument_list|,
name|matches
argument_list|)
expr_stmt|;
block|}
comment|/* Now, remove all but the most specialized of the matches.  */
if|if
condition|(
name|matches
condition|)
block|{
name|tree
name|match
init|=
name|most_specialized_instantiation
argument_list|(
name|matches
argument_list|,
name|explicit_targs
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|!=
name|error_mark_node
condition|)
name|matches
operator|=
name|scratch_tree_cons
argument_list|(
name|match
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we should have exactly one function in MATCHES.  */
if|if
condition|(
name|matches
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* There were *no* matches.  */
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"no matches converting function `%D' to type `%#T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* print_candidates expects a chain with the functions in              TREE_VALUE slots, so we cons one up here (we're losing anyway,              so why be clever?).  */
for|for
control|(
init|;
name|overload
condition|;
name|overload
operator|=
name|OVL_NEXT
argument_list|(
name|overload
argument_list|)
control|)
name|matches
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|OVL_CURRENT
argument_list|(
name|overload
argument_list|)
argument_list|,
name|matches
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|matches
argument_list|)
condition|)
block|{
comment|/* There were too many matches.  */
if|if
condition|(
name|complain
condition|)
block|{
name|tree
name|match
decl_stmt|;
name|cp_error
argument_list|(
literal|"converting overloaded function `%D' to type `%#T' is ambiguous"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|overload
argument_list|)
argument_list|)
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* Since print_candidates expects the functions in the 	     TREE_VALUE slot, we flip them here.  */
for|for
control|(
name|match
operator|=
name|matches
init|;
name|match
condition|;
name|match
operator|=
name|TREE_CHAIN
argument_list|(
name|match
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|match
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* Good, exactly one match.  Now, convert it to the correct type.  */
name|fn
operator|=
name|TREE_PURPOSE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRFN_P
argument_list|(
name|target_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|target_type
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
comment|/* The target must be a REFERENCE_TYPE.  Above, build_unary_op 	 will mark the function as addressed, but here we must do it 	 explicitly.  */
name|mark_addressable
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function will instantiate the type of the expression given in    RHS to match the type of LHSTYPE.  If errors exist, then return    error_mark_node.  We only complain is COMPLAIN is set.  If we are    not complaining, never modify rhs, as overload resolution wants to    try many possible instantiations, in hopes that at least one will    work.     FLAGS is a bitmask, as we see at the top of the function.     For non-recursive calls, LHSTYPE should be a function, pointer to    function, or a pointer to member function.  */
end_comment

begin_function
name|tree
name|instantiate_type
parameter_list|(
name|lhstype
parameter_list|,
name|rhs
parameter_list|,
name|flags
parameter_list|)
name|tree
name|lhstype
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|complain
init|=
operator|(
name|flags
operator|&
literal|1
operator|)
decl_stmt|;
name|int
name|strict
init|=
operator|(
name|flags
operator|&
literal|2
operator|)
condition|?
name|COMPARE_NO_ATTRIBUTES
else|:
name|COMPARE_STRICT
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
operator|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
return|return
name|rhs
return|;
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"argument of type `%T' does not match `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We don't overwrite rhs if it is an overloaded function.      Copying it would destroy the tree link.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|rhs
operator|=
name|copy_node
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* This should really only be used when attempting to distinguish      what sort of a pointer to function we have.  For now, any      arithmetic operation which is not supported on pointers      is rejected as an error.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TYPE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|BUFFER_REF
case|:
name|my_friendly_abort
argument_list|(
literal|177
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|new_rhs
decl_stmt|;
name|new_rhs
operator|=
name|instantiate_type
argument_list|(
name|build_pointer_type
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|new_rhs
expr_stmt|;
return|return
name|rhs
return|;
block|}
case|case
name|NOP_EXPR
case|:
name|rhs
operator|=
name|copy_node
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|field
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|error_mark_node
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|tree
name|t
init|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|lhstype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|field
operator|=
name|OVL_FUNCTION
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"object-dependent reference `%E' can only be used in a call"
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"  to form a pointer to member function, say `&%T::%E'"
argument_list|,
name|t
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_pedwarn
argument_list|(
literal|"object-dependent reference can only be used in a call"
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
return|return
name|r
return|;
block|}
case|case
name|OFFSET_REF
case|:
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
comment|/* This can happen if we are forming a pointer-to-member for a 	 member template.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|TEMPLATE_ID_EXPR
case|:
return|return
name|resolve_address_of_overloaded_function
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|,
comment|/*template_only=*/
literal|1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|OVERLOAD
case|:
return|return
name|resolve_address_of_overloaded_function
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|,
comment|/*template_only=*/
literal|0
argument_list|,
comment|/*explicit_targs=*/
name|NULL_TREE
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
comment|/* Now we should have a baselink. */
name|my_friendly_assert
argument_list|(
name|BASELINK_P
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|990412
argument_list|)
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* This is too hard for now.  */
name|my_friendly_abort
argument_list|(
literal|183
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid operation on uninstantiated type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MODIFY_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|my_friendly_abort
argument_list|(
literal|184
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|185
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the virtual function pointer field    (as an IDENTIFIER_NODE) for the given TYPE.  Note that    this may have to look back through base types to find the    ultimate field name.  (For single inheritance, these could    all be the same name.  Who knows for multiple inheritance).  */
end_comment

begin_function
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VFIELD_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VFIELD_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_class_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert_harshness = %d\n"
argument_list|,
name|n_convert_harshness
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compute_conversion_costs = %d\n"
argument_list|,
name|n_compute_conversion_costs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"build_method_call = %d (inner = %d)\n"
argument_list|,
name|n_build_method_call
argument_list|,
name|n_inner_fields_searched
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_vtables
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtables = %d; vtable searches = %d\n"
argument_list|,
name|n_vtables
argument_list|,
name|n_vtable_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable entries = %d; vtable elems = %d\n"
argument_list|,
name|n_vtable_entries
argument_list|,
name|n_vtable_elems
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Push an obstack which is sufficiently long-lived to hold such class    decls that may be cached in the previous_class_values list. The    effect is undone by pop_obstacks.  */
end_comment

begin_function
name|void
name|push_cache_obstack
parameter_list|()
block|{
specifier|static
name|int
name|cache_obstack_initialized
decl_stmt|;
if|if
condition|(
operator|!
name|cache_obstack_initialized
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|class_cache_obstack
argument_list|)
expr_stmt|;
name|class_cache_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|class_cache_obstack
argument_list|)
expr_stmt|;
name|cache_obstack_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|current_obstack
operator|=
operator|&
name|class_cache_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a dummy reference to ourselves so Derived::Base (and A::A) works,    according to [class]:                                           The class-name is also inserted    into  the scope of the class itself.  For purposes of access checking,    the inserted class name is treated as if it were a public member name.  */
end_comment

begin_function
name|void
name|build_self_reference
parameter_list|()
block|{
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|saved_cas
decl_stmt|;
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_cas
operator|=
name|current_access_specifier
expr_stmt|;
name|current_access_specifier
operator|=
name|access_public_node
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|current_access_specifier
operator|=
name|saved_cas
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE contains only padding bytes.  */
end_comment

begin_function
name|int
name|is_empty_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_new_abi
condition|)
return|return
name|CLASSTYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|integer_zero_node
return|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|==
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the enclosing class of the given NODE.  NODE can be a *_DECL or    a *_TYPE node.  NODE can also be a local class.  */
end_comment

begin_function
name|tree
name|get_enclosing_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|node
init|=
name|type
decl_stmt|;
while|while
condition|(
name|node
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|node
operator|=
name|DECL_CONTEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|node
operator|!=
name|type
condition|)
return|return
name|node
return|;
name|node
operator|=
name|TYPE_CONTEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TYPE or one of its enclosing classes is derived from BASE.  */
end_comment

begin_function
name|int
name|is_base_of_enclosing_class
parameter_list|(
name|base
parameter_list|,
name|type
parameter_list|)
name|tree
name|base
decl_stmt|,
name|type
decl_stmt|;
block|{
while|while
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|get_binfo
argument_list|(
name|base
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
name|type
operator|=
name|get_enclosing_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Note that NAME was looked up while the current class was being    defined and that the result of that lookup was DECL.  */
end_comment

begin_function
name|void
name|maybe_note_name_used_in_class
parameter_list|(
name|name
parameter_list|,
name|decl
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|splay_tree
name|names_used
decl_stmt|;
comment|/* If we're not defining a class, there's nothing to do.  */
if|if
condition|(
operator|!
name|current_class_type
operator|||
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
return|return;
comment|/* If there's already a binding for this NAME, then we don't have      anything to worry about.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
condition|)
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|names_used
operator|=
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|names_used
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that NAME was declared (as DECL) in the current class.  Check    to see that the declaration is legal.  */
end_comment

begin_function
name|void
name|note_name_declared_in_class
parameter_list|(
name|name
parameter_list|,
name|decl
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|splay_tree
name|names_used
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Look to see if we ever used this name.  */
name|names_used
operator|=
name|current_class_stack
index|[
name|current_class_depth
operator|-
literal|1
index|]
operator|.
name|names_used
expr_stmt|;
if|if
condition|(
operator|!
name|names_used
condition|)
return|return;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|names_used
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* [basic.scope.class] 	  	 A name N used in a class S shall refer to the same declaration 	 in its context and when re-evaluated in the completed scope of 	 S.  */
name|cp_error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"changes meaning of `%s' from `%+#D'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

